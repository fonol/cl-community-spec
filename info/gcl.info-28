This is Info file gcl.info, produced by Makeinfo-1.55 from the input file
gcl.texi.

This is a Texinfo GNU Common Lisp Manual based on the draft ANSI standard
for Common Lisp.

Copyright 1994 William F. Schelter


File: gcl.info,  Node: gensym,  Next: *gensym-counter*,  Prev: copy-symbol,  Up: Symbols Dictionary

gensym                                                           [Function]
---------------------------------------------------------------------------

`gensym'  &optional x =>  new-symbol

Arguments and Values::
......................

x--a string or a non-negative integer.  Complicated defaulting behavior;
see below.

new-symbol--a fresh, uninterned symbol.

Description::
.............

Creates and returns a fresh, uninterned symbol, as if by calling
make-symbol.  (The only difference between gensym and make-symbol is in
how the new-symbol's name is determined.)

The name of the new-symbol is the concatenation of a prefix, which
defaults to "G", and

a suffix, which is the decimal representation of a number that defaults to
the value of *gensym-counter*.

If x is supplied, and is a string, then that string is used as a prefix
instead of "G" for this call to gensym only.

If x is supplied, and is an integer, then that integer, instead of the
value of *gensym-counter*, is used as the suffix for this call to gensym
only.

If and only if no explicit suffix is supplied, *gensym-counter* is
incremented after it is used.

Examples::
..........

      (setq sym1 (gensym)) =>  #:G3142
      (symbol-package sym1) =>  NIL
      (setq sym2 (gensym 100)) =>  #:G100
      (setq sym3 (gensym 100)) =>  #:G100
      (eq sym2 sym3) =>  false
      (find-symbol "G100") =>  NIL, NIL
      (gensym "T") =>  #:T3143
      (gensym) =>  #:G3144

Side Effects::
..............

Might increment *gensym-counter*.

Affected By::
.............

*gensym-counter*

Exceptional Situations::
........................

Should signal an error of type type-error if x is not a string or a
non-negative integer.

See Also::
..........

*Note gentemp:: , *gensym-counter*

Notes::
.......

The ability to pass a numeric argument to gensym has been deprecated;
explicitly binding *gensym-counter* is now stylistically preferred.  (The
somewhat baroque conventions for the optional argument are historical in
nature, and supported primarily for compatibility with older dialects of
Lisp.   In modern code, it is recommended that the only kind of argument
used be a string prefix.  In general, though, to obtain more flexible
control of the new-symbol's name, consider using make-symbol instead.)


File: gcl.info,  Node: *gensym-counter*,  Next: gentemp,  Prev: gensym,  Up: Symbols Dictionary

*gensym-counter*                                                 [Variable]
---------------------------------------------------------------------------

Value Type::
............

a non-negative integer.

Initial Value::
...............

implementation-dependent.

Description::
.............

A number which will be used in constructing the name of the next symbol
generated by the function gensym.

*gensym-counter* can be either assigned or bound at any time, but its
value must always be a non-negative integer.

Affected By::
.............

gensym.

See Also::
..........

*Note gensym::

Notes::
.......

The ability to pass a numeric argument to gensym has been deprecated;
explicitly binding *gensym-counter* is now stylistically preferred.


File: gcl.info,  Node: gentemp,  Next: symbol-function,  Prev: *gensym-counter*,  Up: Symbols Dictionary

gentemp                                                          [Function]
---------------------------------------------------------------------------

`gentemp'  &optional prefix package =>  new-symbol

Arguments and Values::
......................

prefix--a string.  The default is "T".

package--a package designator.  The default is the current package.

new-symbol--a fresh, interned symbol.

Description::
.............

gentemp creates and returns a fresh symbol, interned in the indicated
package.  The symbol is guaranteed to be one that was not previously
accessible in package.  It is neither bound nor fbound, and has a null
property list.

The name of the new-symbol is the concatenation of the prefix and a
suffix, which is taken from an internal counter used only by gentemp.  (If
a symbol by that name is already accessible in package, the counter is
incremented as many times as is necessary to produce a name that is not
already the name of a symbol accessible in package.)

Examples::
..........

      (gentemp) =>  T1298
      (gentemp "FOO") =>  FOO1299
      (find-symbol "FOO1300") =>  NIL, NIL
      (gentemp "FOO") =>  FOO1300
      (find-symbol "FOO1300") =>  FOO1300, :INTERNAL
      (intern "FOO1301") =>  FOO1301, :INTERNAL
      (gentemp "FOO") =>  FOO1302
      (gentemp) =>  T1303

Side Effects::
..............

Its internal counter is incremented one or more times.

Interns the new-symbol in package.

Affected By::
.............

The current state of its internal counter, and the current state of the
package.

Exceptional Situations::
........................

Should signal an error of type type-error if prefix is not a string.
Should signal an error of type type-error if package is not a package
designator.

See Also::
..........

*Note gensym::

Notes::
.......

The function gentemp is deprecated.

If package is the KEYWORD package, the result is an external symbol of
package.  Otherwise, the result is an internal symbol of package.

The gentemp internal counter is independent of *gensym-counter*, the
counter used by gensym.  There is no provision for accessing the gentemp
internal counter.

Just because gentemp creates a symbol which did not previously exist does
not mean that such a symbol might not be seen in the future (e.g., in a
data file--perhaps even created by the same program in another session).
As such, this symbol is not truly unique in the same sense as a gensym
would be.  In particular, programs which do automatic code generation
should be careful not to attach global attributes to such generated
symbols (e.g., special declarations) and then write them into a file
because such global attributes might, in a different session, end up
applying to other symbols that were automatically generated on another day
for some other purpose.


File: gcl.info,  Node: symbol-function,  Next: symbol-name,  Prev: gentemp,  Up: Symbols Dictionary

symbol-function                                                  [Accessor]
---------------------------------------------------------------------------

`symbol-function'  symbol =>  contents

(setf (`         symbol-function' symbol) new-contents)
Arguments and Values::
......................

symbol--a symbol.

contents--

If the symbol is globally defined as a macro or a special operator, an
object of implementation-dependent nature and identity is returned.  If
the symbol is not globally defined as either a macro or a special operator,
and if the symbol is fbound, a function object is returned.

new-contents--a function.

Description::
.............

Accesses the symbol's function cell.

Examples::
..........

      (symbol-function 'car) =>  #<FUNCTION CAR>
      (symbol-function 'twice) is an error   ;because TWICE isn't defined.
      (defun twice (n) (* n 2)) =>  TWICE
      (symbol-function 'twice) =>  #<FUNCTION TWICE>
      (list (twice 3)
            (funcall (function twice) 3)
            (funcall (symbol-function 'twice) 3))
     =>  (6 6 6)
      (flet ((twice (x) (list x x)))
        (list (twice 3)
              (funcall (function twice) 3)
              (funcall (symbol-function 'twice) 3)))
     =>  ((3 3) (3 3) 6)
      (setf (symbol-function 'twice) #'(lambda (x) (list x x)))
     =>  #<FUNCTION anonymous>
      (list (twice 3)
            (funcall (function twice) 3)
            (funcall (symbol-function 'twice) 3))
     =>  ((3 3) (3 3) (3 3))
      (fboundp 'defun) =>  true
      (symbol-function 'defun)
     =>  implementation-dependent
      (functionp (symbol-function 'defun))
     =>  implementation-dependent
      (defun symbol-function-or-nil (symbol)
        (if (and (fboundp symbol)
                 (not (macro-function symbol))
                 (not (special-operator-p symbol)))
            (symbol-function symbol)
            nil)) =>  SYMBOL-FUNCTION-OR-NIL
      (symbol-function-or-nil 'car) =>  #<FUNCTION CAR>
      (symbol-function-or-nil 'defun) =>  NIL

Affected By::
.............

defun

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

Should signal undefined-function if symbol is not fbound and an attempt is
made to read its definition.  (No such error is signaled on an attempt to
write its definition.)

See Also::
..........

*Note fboundp:: , *Note fmakunbound:: , *Note macro-function:: ,

*Note special-operator-p::

Notes::
.......

symbol-function cannot access the value of a lexical function name
produced by flet or labels; it can access only the global function value.

setf may be used with symbol-function to replace a global function
definition when the symbol's function definition does not represent a
special operator.

     (symbol-function symbol) == (fdefinition symbol)

However, fdefinition accepts arguments other than just symbols.


File: gcl.info,  Node: symbol-name,  Next: symbol-package,  Prev: symbol-function,  Up: Symbols Dictionary

symbol-name                                                      [Function]
---------------------------------------------------------------------------

`symbol-name'  symbol =>  name

Arguments and Values::
......................

symbol--a symbol.

name--a string.

Description::
.............

symbol-name returns the name of symbol.

The consequences are undefined if name is ever modified.

Examples::
..........

      (symbol-name 'temp) =>  "TEMP"
      (symbol-name :start) =>  "START"
      (symbol-name (gensym)) =>  "G1234" ;for example

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.


File: gcl.info,  Node: symbol-package,  Next: symbol-plist,  Prev: symbol-name,  Up: Symbols Dictionary

symbol-package                                                   [Function]
---------------------------------------------------------------------------

`symbol-package'  symbol =>  contents

Arguments and Values::
......................

symbol--a symbol.

contents--a package object or nil.

Description::
.............

Returns the home package of symbol.

Examples::
..........

      (in-package "CL-USER") =>  #<PACKAGE "COMMON-LISP-USER">
      (symbol-package 'car) =>  #<PACKAGE "COMMON-LISP">
      (symbol-package 'bus) =>  #<PACKAGE "COMMON-LISP-USER">
      (symbol-package :optional) =>  #<PACKAGE "KEYWORD">
      ;; Gensyms are uninterned, so have no home package.
      (symbol-package (gensym)) =>  NIL
      (make-package 'pk1) =>  #<PACKAGE "PK1">
      (intern "SAMPLE1" "PK1") =>  PK1::SAMPLE1, NIL
      (export (find-symbol "SAMPLE1" "PK1") "PK1") =>  T
      (make-package 'pk2 :use '(pk1)) =>  #<PACKAGE "PK2">
      (find-symbol "SAMPLE1" "PK2") =>  PK1:SAMPLE1, :INHERITED
      (symbol-package 'pk1::sample1) =>  #<PACKAGE "PK1">
      (symbol-package 'pk2::sample1) =>  #<PACKAGE "PK1">
      (symbol-package 'pk1::sample2) =>  #<PACKAGE "PK1">
      (symbol-package 'pk2::sample2) =>  #<PACKAGE "PK2">
      ;; The next several forms create a scenario in which a symbol
      ;; is not really uninterned, but is "apparently uninterned",
      ;; and so SYMBOL-PACKAGE still returns NIL.
      (setq s3 'pk1::sample3) =>  PK1::SAMPLE3
      (import s3 'pk2) =>  T
      (unintern s3 'pk1) =>  T
      (symbol-package s3) =>  NIL
      (eq s3 'pk2::sample3) =>  T

Affected By::
.............

import, intern, unintern

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

See Also::
..........

*Note intern::


File: gcl.info,  Node: symbol-plist,  Next: symbol-value,  Prev: symbol-package,  Up: Symbols Dictionary

symbol-plist                                                     [Accessor]
---------------------------------------------------------------------------

`symbol-plist'  symbol =>  plist

(setf (`         symbol-plist' symbol) new-plist)
Arguments and Values::
......................

symbol--a symbol.

plist, new-plist--a property list.

Description::
.............

Accesses the property list of symbol.

Examples::
..........

      (setq sym (gensym)) =>  #:G9723
      (symbol-plist sym) =>  ()
      (setf (get sym 'prop1) 'val1) =>  VAL1
      (symbol-plist sym) =>  (PROP1 VAL1)
      (setf (get sym 'prop2) 'val2) =>  VAL2
      (symbol-plist sym) =>  (PROP2 VAL2 PROP1 VAL1)
      (setf (symbol-plist sym) (list 'prop3 'val3)) =>  (PROP3 VAL3)
      (symbol-plist sym) =>  (PROP3 VAL3)

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

See Also::
..........

*Note get:: , *Note remprop::

Notes::
.......

The use of setf should be avoided, since a symbol's property list is a
global resource that can contain information established and depended upon
by unrelated programs in the same Lisp image.


File: gcl.info,  Node: symbol-value,  Next: get,  Prev: symbol-plist,  Up: Symbols Dictionary

symbol-value                                                     [Accessor]
---------------------------------------------------------------------------

`symbol-value'  symbol =>  value

(setf (`         symbol-value' symbol) new-value)
Arguments and Values::
......................

symbol--a symbol that must have a value.

value, new-value--an object.

Description::
.............

Accesses the symbol's value cell.

Examples::
..........

      (setf (symbol-value 'a) 1) =>  1
      (symbol-value 'a) =>  1
      ;; SYMBOL-VALUE cannot see lexical variables.
      (let ((a 2)) (symbol-value 'a)) =>  1
      (let ((a 2)) (setq a 3) (symbol-value 'a)) =>  1
      ;; SYMBOL-VALUE can see dynamic variables.
      (let ((a 2))
        (declare (special a))
        (symbol-value 'a)) =>  2
      (let ((a 2))
        (declare (special a))
        (setq a 3)
        (symbol-value 'a)) =>  3
      (let ((a 2))
        (setf (symbol-value 'a) 3)
        a) =>  2
      a =>  3
      (symbol-value 'a) =>  3
      (let ((a 4))
        (declare (special a))
        (let ((b (symbol-value 'a)))
          (setf (symbol-value 'a) 5)
          (values a b))) =>  5, 4
      a =>  3
      (symbol-value :any-keyword) =>  :ANY-KEYWORD
      (symbol-value 'nil) =>  NIL
      (symbol-value '()) =>  NIL
      ;; The precision of this next one is implementation-dependent.
      (symbol-value 'pi) =>  3.141592653589793d0

Affected By::
.............

makunbound, set, setq

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

Should signal unbound-variable if symbol is unbound and an attempt is made
to read its value.  (No such error is signaled on an attempt to write its
value.)

See Also::
..........

*Note boundp:: , *Note makunbound:: , *Note set:: , *Note setq::

Notes::
.......

symbol-value can be used to get the value of a constant variable.
symbol-value cannot access the value of a lexical variable.


File: gcl.info,  Node: get,  Next: remprop,  Prev: symbol-value,  Up: Symbols Dictionary

get                                                              [Accessor]
---------------------------------------------------------------------------

`get'  symbol indicator &optional default =>  value

(setf (`         get' symbol indicator &optional default) new-value)
Arguments and Values::
......................

symbol--a symbol.

indicator--an object.

default--an object.  The default is nil.

value--if the indicated property exists, the object that is its value;
otherwise, the specified default.

new-value--an object.

Description::
.............

get finds a property on the property list_2 of symbol whose property
indicator is identical to indicator, and returns its corresponding
property value.

If there are multiple properties_1 with that property indicator, get uses
the first such property.

If there is no property with that property indicator, default is returned.

setf of get may be used to associate a new object with an existing
indicator already on the symbol's property list, or to create a new
assocation if none exists.

If there are multiple properties_1 with that property indicator, setf of
get associates the new-value with the first such property.

When a get form is used as a setf place, any default which is supplied is
evaluated according to normal left-to-right evaluation rules, but its
value is ignored.

Examples::
..........

      (defun make-person (first-name last-name)
        (let ((person (gensym "PERSON")))
          (setf (get person 'first-name) first-name)
          (setf (get person 'last-name) last-name)
          person)) =>  MAKE-PERSON
      (defvar *john* (make-person "John" "Dow")) =>  *JOHN*
      *john* =>  #:PERSON4603
      (defvar *sally* (make-person "Sally" "Jones")) =>  *SALLY*
      (get *john* 'first-name) =>  "John"
      (get *sally* 'last-name) =>  "Jones"
      (defun marry (man woman married-name)
        (setf (get man 'wife) woman)
        (setf (get woman 'husband) man)
        (setf (get man 'last-name) married-name)
        (setf (get woman 'last-name) married-name)
        married-name) =>  MARRY
      (marry *john* *sally* "Dow-Jones") =>  "Dow-Jones"
      (get *john* 'last-name) =>  "Dow-Jones"
      (get (get *john* 'wife) 'first-name) =>  "Sally"
      (symbol-plist *john*)
     =>  (WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John")
      (defmacro age (person &optional (default ''thirty-something))
        `(get ,person 'age ,default)) =>  AGE
      (age *john*) =>  THIRTY-SOMETHING
      (age *john* 20) =>  20
      (setf (age *john*) 25) =>  25
      (age *john*) =>  25
      (age *john* 20) =>  25

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

See Also::
..........

*Note getf:: , *Note symbol-plist:: , *Note remprop::

Notes::
.......

      (get x y) == (getf (symbol-plist x) y)

Numbers and characters are not recommended for use as indicators in
portable code since get tests with eq rather than eql, and consequently
the effect of using such indicators is implementation-dependent.

There is no way using get to distinguish an absent property from one whose
value is default.  However, see get-properties.


File: gcl.info,  Node: remprop,  Next: boundp,  Prev: get,  Up: Symbols Dictionary

remprop                                                          [Function]
---------------------------------------------------------------------------

`remprop'  symbol indicator =>  generalized-boolean

Arguments and Values::
......................

symbol--a symbol.

indicator--an object.

generalized-boolean--a generalized boolean.

Description::
.............

remprop removes from the property list_2 of symbol a property_1 with a
property indicator identical to indicator.

If there are multiple properties_1 with the identical key, remprop only
removes the first such property.

remprop returns false if no such property was found, or true if a property
was found.

The property indicator and the corresponding property value are removed in
an undefined order by destructively splicing the property list.

The permissible side-effects correspond to those permitted for remf, such
that:

      (remprop x y) == (remf (symbol-plist x) y)

Examples::
..........

      (setq test (make-symbol "PSEUDO-PI")) =>  #:PSEUDO-PI
      (symbol-plist test) =>  ()
      (setf (get test 'constant) t) =>  T
      (setf (get test 'approximation) 3.14) =>  3.14
      (setf (get test 'error-range) 'noticeable) =>  NOTICEABLE
      (symbol-plist test)
     =>  (ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)
      (setf (get test 'approximation) nil) =>  NIL
      (symbol-plist test)
     =>  (ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)
      (get test 'approximation) =>  NIL
      (remprop test 'approximation) =>  true
      (get test 'approximation) =>  NIL
      (symbol-plist test)
     =>  (ERROR-RANGE NOTICEABLE CONSTANT T)
      (remprop test 'approximation) =>  NIL
      (symbol-plist test)
     =>  (ERROR-RANGE NOTICEABLE CONSTANT T)
      (remprop test 'error-range) =>  true
      (setf (get test 'approximation) 3) =>  3
      (symbol-plist test)
     =>  (APPROXIMATION 3 CONSTANT T)

Side Effects::
..............

The property list of symbol is modified.

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

See Also::
..........

*Note remf:: , *Note symbol-plist::

Notes::
.......

Numbers and characters are not recommended for use as indicators in
portable code since remprop tests with eq rather than eql, and
consequently the effect of using such indicators is
implementation-dependent.  Of course, if you've gotten as far as needing
to remove such a property, you don't have much choice--the time to have
been thinking about this was when you used setf of get to establish the
property.


File: gcl.info,  Node: boundp,  Next: makunbound,  Prev: remprop,  Up: Symbols Dictionary

boundp                                                           [Function]
---------------------------------------------------------------------------

`boundp'  symbol =>  generalized-boolean

Arguments and Values::
......................

symbol--a symbol.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if symbol is bound; otherwise, returns false.

Examples::
..........

      (setq x 1) =>  1
      (boundp 'x) =>  true
      (makunbound 'x) =>  X
      (boundp 'x) =>  false
      (let ((x 2)) (boundp 'x)) =>  false
      (let ((x 2)) (declare (special x)) (boundp 'x)) =>  true

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

See Also::
..........

*Note set:: , *Note setq:: , *Note symbol-value:: , *Note makunbound::

Notes::
.......

The function bound determines only whether a symbol has a value in the
global environment; any lexical bindings are ignored.


File: gcl.info,  Node: makunbound,  Next: set,  Prev: boundp,  Up: Symbols Dictionary

makunbound                                                       [Function]
---------------------------------------------------------------------------

`makunbound'  symbol =>  symbol

Arguments and Values::
......................

symbol--a symbol

Description::
.............

Makes the symbol be unbound, regardless of whether it was previously bound.

Examples::
..........

      (setf (symbol-value 'a) 1)
      (boundp 'a) =>  true
      a =>  1
      (makunbound 'a) =>  A
      (boundp 'a) =>  false

Side Effects::
..............

The value cell of symbol is modified.

Exceptional Situations::
........................

Should signal an error of type type-error if symbol is not a symbol.

See Also::
..........

*Note boundp:: , *Note fmakunbound::


File: gcl.info,  Node: set,  Next: unbound-variable,  Prev: makunbound,  Up: Symbols Dictionary

set                                                              [Function]
---------------------------------------------------------------------------

`set'  symbol value =>  value

Arguments and Values::
......................

symbol--a symbol.

value--an object.

Description::
.............

set changes the contents of the value cell of symbol to the given value.

     (set symbol value) == (setf (symbol-value symbol) value)

Examples::
..........

      (setf (symbol-value 'n) 1) =>  1
      (set 'n 2) =>  2
      (symbol-value 'n) =>  2
      (let ((n 3))
        (declare (special n))
        (setq n (+ n 1))
        (setf (symbol-value 'n) (* n 10))
        (set 'n (+ (symbol-value 'n) n))
        n) =>  80
      n =>  2
      (let ((n 3))
        (setq n (+ n 1))
        (setf (symbol-value 'n) (* n 10))
        (set 'n (+ (symbol-value 'n) n))
        n) =>  4
      n =>  44
      (defvar *n* 2)
      (let ((*n* 3))
        (setq *n* (+ *n* 1))
        (setf (symbol-value '*n*) (* *n* 10))
        (set '*n* (+ (symbol-value '*n*) *n*))
        *n*) =>  80
       *n* =>  2
      (defvar *even-count* 0) =>  *EVEN-COUNT*
      (defvar *odd-count* 0) =>  *ODD-COUNT*
      (defun tally-list (list)
        (dolist (element list)
          (set (if (evenp element) '*even-count* '*odd-count*)
               (+ element (if (evenp element) *even-count* *odd-count*)))))
      (tally-list '(1 9 4 3 2 7)) =>  NIL
      *even-count* =>  6
      *odd-count* =>  20

Side Effects::
..............

The value of symbol is changed.

See Also::
..........

*Note setq:: , *Note progv:: , *Note symbol-value::

Notes::
.......

The function set is deprecated.

set cannot change the value of a lexical variable.


File: gcl.info,  Node: unbound-variable,  Prev: set,  Up: Symbols Dictionary

unbound-variable                                           [Condition Type]
---------------------------------------------------------------------------

Class Precedence List::
.......................

unbound-variable, cell-error, error, serious-condition, condition, t

Description::
.............

The type unbound-variable consists of error conditions that represent
attempts to read the value of an unbound variable.

The name of the cell (see cell-error) is the name of the variable that was
unbound.

See Also::
..........

*Note cell-error-name::


File: gcl.info,  Node: Packages,  Next: Numbers (Numbers),  Prev: Symbols,  Up: Top

Packages
********

* Menu:

* Package Concepts::
* Packages Dictionary::


File: gcl.info,  Node: Package Concepts,  Next: Packages Dictionary,  Prev: Packages,  Up: Packages

Package Concepts
================

* Menu:

* Introduction to Packages::
* Standardized Packages::


File: gcl.info,  Node: Introduction to Packages,  Next: Standardized Packages,  Prev: Package Concepts,  Up: Package Concepts

Introduction to Packages
------------------------

A package establishes a mapping from names to symbols.  At any given time,
one package is current.  The current package is the one that is the value
of *package*.  When using the Lisp reader, it is possible to refer to
symbols in packages other than the current one through the use of package
prefixes in the printed representation of the symbol.

Figure 11-1 lists some defined names that are applicable to packages.
Where an operator takes an argument that is either a symbol or a list of
symbols, an argument of nil is treated as an empty list of symbols.  Any
package argument may be either a string, a symbol, or a package.  If a
symbol is supplied, its name will be used as the package name.

  *modules*            import                     provide           
  *package*            in-package                 rename-package    
  defpackage           intern                     require           
  do-all-symbols       list-all-packages          shadow            
  do-external-symbols  make-package               shadowing-import  
  do-symbols           package-name               unexport          
  export               package-nicknames          unintern          
  find-all-symbols     package-shadowing-symbols  unuse-package     
  find-package         package-use-list           use-package       
  find-symbol          package-used-by-list                         

         Figure 11-1: Some Defined Names related to Packages       


* Menu:

* Package Names and Nicknames::
* Symbols in a Package::
* Internal and External Symbols::
* Package Inheritance::
* Accessibility of Symbols in a Package::
* Locating a Symbol in a Package::
* Prevention of Name Conflicts in Packages::


File: gcl.info,  Node: Package Names and Nicknames,  Next: Symbols in a Package,  Prev: Introduction to Packages,  Up: Introduction to Packages

Package Names and Nicknames
...........................

Each package has a name (a string) and perhaps some nicknames (also
strings).  These are assigned when the package is created and can be
changed later.

There is a single namespace for packages.  The function find-package
translates a package name or nickname into the associated package.  The
function package-name returns the name of a package.  The function
package-nicknames returns a list of all nicknames for a package.
rename-package removes a package's current name and nicknames and replaces
them with new ones specified by the caller.


File: gcl.info,  Node: Symbols in a Package,  Next: Internal and External Symbols,  Prev: Package Names and Nicknames,  Up: Introduction to Packages

Symbols in a Package
....................


File: gcl.info,  Node: Internal and External Symbols,  Next: Package Inheritance,  Prev: Symbols in a Package,  Up: Introduction to Packages

Internal and External Symbols
.............................

The mappings in a package are divided into two classes, external and
internal.  The symbols targeted by these different mappings are called
external symbols and internal symbols of the package. Within a package, a
name refers to one symbol or to none; if it does refer to a symbol, then
it is either external or internal in that package, but not both.  External
symbols

are part of the package's public interface to other packages.  Symbols
become external symbols of a given package if they have been exported from
that package.

A symbol has the same name no matter what package it is present in, but it
might be an external symbol of some packages and an internal symbol of
others.


File: gcl.info,  Node: Package Inheritance,  Next: Accessibility of Symbols in a Package,  Prev: Internal and External Symbols,  Up: Introduction to Packages

Package Inheritance
...................

Packages can be built up in layers.  From one point of view, a package is
a single collection of mappings from strings into internal symbols and
external symbols.  However, some of these mappings might be established
within the package itself, while other mappings are inherited from other
packages via use-package.  A symbol is said to be present in a package if
the mapping is in the package itself and is not inherited from somewhere
else.

There is no way to inherit the internal symbols of another package; to
refer to an internal symbol using the Lisp reader, a package containing
the symbol must be made to be the current package, a package prefix must
be used, or the symbol must be imported into the current package.


File: gcl.info,  Node: Accessibility of Symbols in a Package,  Next: Locating a Symbol in a Package,  Prev: Package Inheritance,  Up: Introduction to Packages

Accessibility of Symbols in a Package
.....................................

A symbol becomes accessible in a package if that is its home package when
it is created, or if it is imported into that package, or by inheritance
via use-package.

If a symbol is accessible in a package, it can be referred to when using
the Lisp reader without a package prefix when that package is the current
package, regardless of whether it is present or inherited.

Symbols from one package can be made accessible in another package in two
ways.

-
     Any individual symbol can be added to a package by use of import.
     After the call to import the symbol is present in the importing
     package.  The status of the symbol in the package it came from (if
     any) is unchanged, and the home package for this symbol is unchanged.
     Once imported, a symbol is present in the importing package and can
     be removed only by calling unintern.

     A symbol is shadowed_3 by another symbol in some package if the first
     symbol would be accessible by inheritance if not for the presence of
     the second symbol.  See shadowing-import.

-
     The second mechanism for making symbols from one package accessible
     in another is provided by use-package.  All of the external symbols
     of the used package are inherited by the using package.  The function
     unuse-package undoes the effects of a previous use-package.


File: gcl.info,  Node: Locating a Symbol in a Package,  Next: Prevention of Name Conflicts in Packages,  Prev: Accessibility of Symbols in a Package,  Up: Introduction to Packages

Locating a Symbol in a Package
..............................

When a symbol is to be located in a given package the following occurs:
-
     The external symbols and internal symbols of the package are searched
     for the symbol.

-
     The external symbols of the used packages are searched in some
     unspecified order.  The order does not matter; see the rules for
     handling name conflicts listed below.


File: gcl.info,  Node: Prevention of Name Conflicts in Packages,  Prev: Locating a Symbol in a Package,  Up: Introduction to Packages

Prevention of Name Conflicts in Packages
........................................

Within one package, any particular name can refer to at most one symbol.
A name conflict is said to occur when there would be more than one
candidate symbol.  Any time a name conflict is about to occur, a
correctable error is signaled.

The following rules apply to name conflicts:
-
     Name conflicts are detected when they become possible, that is, when
     the package structure is altered.  Name conflicts are not checked
     during every name lookup.

-
     If the same symbol is accessible to a package through more than one
     path, there is no name conflict.  A symbol cannot conflict with
     itself.  Name conflicts occur only between distinct symbols with the
     same name (under string=).

-
     Every package has a list of shadowing symbols.  A shadowing symbol
     takes precedence over any other symbol of the same name that would
     otherwise be accessible in the package.  A name conflict involving a
     shadowing symbol is always resolved in favor of the shadowing symbol,
     without signaling an error (except for one exception involving
     import).  See shadow and shadowing-import.

-
     The functions use-package, import, and export check for name
     conflicts.

-
     shadow and shadowing-import never signal a name-conflict error.

-
     unuse-package and unexport do not need to do any name-conflict
     checking.  unintern does name-conflict checking only when a symbol
     being uninterned is a shadowing symbol .

-
     Giving a shadowing symbol to unintern can uncover a name conflict
     that had previously been resolved by the shadowing.

-
     Package functions signal name-conflict errors of type package-error
     before making any change to the package structure.  When multiple
     changes are to be made, it is permissible for the implementation to
     process each change separately.  For example, when export is given a
     list of symbols, aborting from a name conflict caused by the second
     symbol in the list might still export the first symbol in the list.
     However, a name-conflict error caused by export of a single symbol
     will be signaled before that symbol's accessibility in any package is
     changed.

-
     Continuing from a name-conflict error must offer the user a chance to
     resolve the name conflict in favor of either of the candidates.  The
     package structure should be altered to reflect the resolution of the
     name conflict, via shadowing-import, unintern, or unexport.

-
     A name conflict in use-package between a symbol present in the using
     package and an external symbol of the used package is resolved in
     favor of the first symbol by making it a shadowing symbol, or in
     favor of the second symbol by uninterning the first symbol from the
     using package.

-
     A name conflict in export or unintern due to a package's inheriting
     two distinct symbols with the same name (under string=) from two
     other packages can be resolved in favor of either symbol by importing
     it into the using package and making it a shadowing symbol , just as
     with use-package.


File: gcl.info,  Node: Standardized Packages,  Prev: Introduction to Packages,  Up: Package Concepts

Standardized Packages
---------------------

This section describes the packages that are available in every conforming
implementation.  A summary of the names and nicknames of those
standardized packages is given in Figure 11-2.

  Name              Nicknames     COMMON-LISP       CL         
  COMMON-LISP-USER  CL-USER       KEYWORD           none       

  Figure 11-2: Standardized Package Names


* Menu:

* The COMMON-LISP Package::
* Constraints on the COMMON-LISP Package for Conforming Implementations::
* Constraints on the COMMON-LISP Package for Conforming Programs::
* Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs::
* The COMMON-LISP-USER Package::
* The KEYWORD Package::
* Interning a Symbol in the KEYWORD Package::
* Notes about The KEYWORD Package::
* Implementation-Defined Packages::


File: gcl.info,  Node: The COMMON-LISP Package,  Next: Constraints on the COMMON-LISP Package for Conforming Implementations,  Prev: Standardized Packages,  Up: Standardized Packages

The COMMON-LISP Package
.......................

The COMMON-LISP package contains the primitives of the Common Lisp system
as defined by this specification.  Its external symbols include all of the
defined names (except for defined names in the KEYWORD package) that are
present in the Common Lisp system, such as car, cdr,  *package*, etc.  The
COMMON-LISP package has the nickname CL.

The COMMON-LISP package has as external symbols those symbols enumerated
in the figures in *Note Symbols in the COMMON-LISP Package::, and no
others.  These external symbols are present in the COMMON-LISP package but
their home package need not be the COMMON-LISP package.

For example, the symbol HELP cannot be an external symbol of the
COMMON-LISP package because it is not mentioned in *Note Symbols in the
COMMON-LISP Package::.  In contrast, the symbol variable must be an
external symbol of the COMMON-LISP package even though it has no definition
because it is listed in that section (to support its use as a valid second
argument to the function documentation).

The COMMON-LISP package can have additional internal symbols.


File: gcl.info,  Node: Constraints on the COMMON-LISP Package for Conforming Implementations,  Next: Constraints on the COMMON-LISP Package for Conforming Programs,  Prev: The COMMON-LISP Package,  Up: Standardized Packages

Constraints on the COMMON-LISP Package for Conforming Implementations
.....................................................................

In a conforming implementation, an external symbol of the COMMON-LISP
package can have a function, macro, or special operator definition, a
global variable definition (or other status as a dynamic variable due to a
special proclamation), or a type definition only if explicitly permitted
in this standard.  For example, fboundp yields false for any external
symbol of the COMMON-LISP package that is not the name of a standardized
function, macro or special operator, and boundp returns false for any
external symbol of the COMMON-LISP package that is not the name of a
standardized global variable.  It also follows that conforming programs
can use external symbols of the COMMON-LISP package as the names of local
lexical variables with confidence that those names have not been
proclaimed special by the implementation unless those symbols are names of
standardized global variables.

A conforming implementation must not place any property on an external
symbol of the COMMON-LISP package using a property indicator that is
either an external symbol of any standardized package or a symbol that is
otherwise accessible in the COMMON-LISP-USER package.


File: gcl.info,  Node: Constraints on the COMMON-LISP Package for Conforming Programs,  Next: Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs,  Prev: Constraints on the COMMON-LISP Package for Conforming Implementations,  Up: Standardized Packages

Constraints on the COMMON-LISP Package for Conforming Programs
..............................................................

Except where explicitly allowed, the consequences are undefined if any of
the following actions are performed on an external symbol of the
COMMON-LISP package:

1.
     Binding or altering its value (lexically or dynamically).  (Some
     exceptions are noted below.)

2.
     Defining,

     undefining,

     or binding it as a function.  (Some exceptions are noted below.)

3.
     Defining,

     undefining,

     or binding it as a macro

     or compiler macro.

     (Some exceptions are noted below.)

4.
     Defining it as a type specifier (via defstruct, defclass, deftype,
     define-condition).

5.
     Defining it as a structure (via defstruct).

6.
     Defining it as a declaration with a declaration proclamation.

7.
     Defining it as a symbol macro.

8.
     Altering its home package.

9.
     Tracing it  (via trace).

10.
     Declaring or proclaiming it special (via declare,

     declaim,

     or proclaim).

11.
     Declaring or proclaiming its type or ftype (via declare,

     declaim,

     or proclaim).  (Some exceptions are noted below.)

12.
     Removing it from the COMMON-LISP package.

13.
     Defining a setf expander for it (via defsetf or define-setf-method).

14.
     Defining, undefining, or binding its setf function name.

15.
     Defining it as a method combination type (via
     define-method-combination).

16.
     Using it as the class-name argument to setf of find-class.

17.
     Binding it as a catch tag.

18.
     Binding it as a restart name.

19.
     Defining a method for a standardized generic function which is
     applicable when all of the arguments are direct instances of
     standardized classes.


File: gcl.info,  Node: Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs,  Next: The COMMON-LISP-USER Package,  Prev: Constraints on the COMMON-LISP Package for Conforming Programs,  Up: Standardized Packages

Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs
.................................................................................

If an external symbol of the COMMON-LISP package is not globally defined
as a standardized dynamic variable or constant variable, it is allowed to
lexically bind it and to declare the type of that binding, and it is
allowed to locally establish it as a symbol macro (e.g., with
symbol-macrolet).

Unless explicitly specified otherwise, if an external symbol of the
COMMON-LISP package is globally defined as a standardized dynamic variable,
it is permitted to bind or assign that dynamic variable provided that the
"Value Type" constraints on the dynamic variable are maintained, and that
the new value of the variable is consistent with the stated purpose of the
variable.

If an external symbol of the COMMON-LISP package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a function (e.g., with flet), to declare the ftype of
that binding, and (in implementations which provide the ability to do so)
to trace that binding.

If an external symbol of the COMMON-LISP package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a macro (e.g., with macrolet).

If an external symbol of the COMMON-LISP package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind its setf function name as a function, and to declare the
ftype of that binding.


File: gcl.info,  Node: The COMMON-LISP-USER Package,  Next: The KEYWORD Package,  Prev: Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs,  Up: Standardized Packages

The COMMON-LISP-USER Package
............................

The COMMON-LISP-USER package is the current package when a Common Lisp
system starts up.  This package uses the COMMON-LISP package.  The
COMMON-LISP-USER package has the nickname CL-USER.

The COMMON-LISP-USER package can have additional symbols interned within
it; it can use other implementation-defined packages.


File: gcl.info,  Node: The KEYWORD Package,  Next: Interning a Symbol in the KEYWORD Package,  Prev: The COMMON-LISP-USER Package,  Up: Standardized Packages

The KEYWORD Package
...................

The KEYWORD package contains symbols, called keywords_1, that are
typically used as special markers in programs and their associated data
expressions_1.

Symbol tokens that start with a package marker are parsed by the Lisp
reader as symbols in the KEYWORD package; see *Note Symbols as Tokens::.
This makes it notationally convenient to use keywords when communicating
between programs in different packages.  For example, the mechanism for
passing keyword parameters in a call uses keywords_1 to name the
corresponding arguments; see *Note Ordinary Lambda Lists::.

Symbols in the KEYWORD package are, by definition, of type keyword.


File: gcl.info,  Node: Interning a Symbol in the KEYWORD Package,  Next: Notes about The KEYWORD Package,  Prev: The KEYWORD Package,  Up: Standardized Packages

Interning a Symbol in the KEYWORD Package
.........................................

The KEYWORD package is treated differently than other packages in that
special actions are taken when a symbol is interned in it.  In particular,
when a symbol is interned in the KEYWORD package, it is automatically made
to be an external symbol and is automatically made to be a constant
variable with itself as a value.


File: gcl.info,  Node: Notes about The KEYWORD Package,  Next: Implementation-Defined Packages,  Prev: Interning a Symbol in the KEYWORD Package,  Up: Standardized Packages

Notes about The KEYWORD Package
...............................

It is generally best to confine the use of keywords to situations in which
there are a finitely enumerable set of names to be selected between.  For
example, if there were two states of a light switch, they might be called
:on and :off.

In situations where the set of names is not finitely enumerable (i.e.,
where name conflicts might arise) it is frequently best to use symbols in
some package other than KEYWORD so that conflicts will be naturally
avoided.  For example, it is generally not wise for a program to use a
keyword_1 as a property indicator, since if there were ever another program
that did the same thing, each would clobber the other's data.


File: gcl.info,  Node: Implementation-Defined Packages,  Prev: Notes about The KEYWORD Package,  Up: Standardized Packages

Implementation-Defined Packages
...............................

Other, implementation-defined packages might be present in the initial
Common Lisp environment.

It is recommended, but not required, that the documentation for a
conforming implementation contain a full list of all package names
initially present in that implementation but not specified in this
specification.  (See also the function list-all-packages.)


File: gcl.info,  Node: Packages Dictionary,  Prev: Package Concepts,  Up: Packages

Packages Dictionary
===================

* Menu:

* package::
* export::
* find-symbol::
* find-package::
* find-all-symbols::
* import::
* list-all-packages::
* rename-package::
* shadow::
* shadowing-import::
* delete-package::
* make-package::
* with-package-iterator::
* unexport::
* unintern::
* in-package::
* unuse-package::
* use-package::
* defpackage::
* do-symbols::
* intern::
* package-name::
* package-nicknames::
* package-shadowing-symbols::
* package-use-list::
* package-used-by-list::
* packagep::
* *package*::
* package-error::
* package-error-package::


File: gcl.info,  Node: package,  Next: export,  Prev: Packages Dictionary,  Up: Packages Dictionary

package                                                      [System Class]
---------------------------------------------------------------------------

Class Precedence List::
.......................

package, t

Description::
.............

A package is a namespace that maps symbol names to symbols; see *Note
Package Concepts::.

See Also::
..........

*Note Package Concepts::, *Note Printing Other Objects::, *Note Symbols as
Tokens::

