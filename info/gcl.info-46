This is Info file gcl.info, produced by Makeinfo-1.55 from the input file
gcl.texi.

This is a Texinfo GNU Common Lisp Manual based on the draft ANSI standard
for Common Lisp.

Copyright 1994 William F. Schelter


File: gcl.info,  Node: Printing Other Arrays,  Next: Examples of Printing Arrays,  Prev: Printing Other Vectors,  Up: Default Print-Object Methods

Printing Other Arrays
.....................

If  *print-array* is true and *print-readably* is false, any

array other than a vector is printed using #nA format.  Let n be the rank
of the array.  Then # is printed, then n as a decimal integer, then A,
then n open parentheses.  Next the elements are scanned in row-major order,
using write on each element, and separating elements from each other with
whitespace_1.  The array's dimensions are numbered 0 to n-1 from left to
right, and are enumerated with the rightmost index changing fastest.
Every time the index for dimension j is incremented, the following actions
are taken:

*
     If j < n-1, then a close parenthesis is printed.

*
     If incrementing the index for dimension j caused it to equal
     dimension j, that index is reset to zero and the index for dimension
     j-1 is incremented (thereby performing these three steps recursively),
     unless j=0, in which case the entire algorithm is terminated.  If
     incrementing the index for dimension j did not cause it to equal
     dimension j, then a space is printed.

*
     If j < n-1, then an open parenthesis is printed.

This causes the contents to be printed in a format suitable for
:initial-contents to make-array.  The lists effectively printed by this
procedure are subject to truncation by *print-level* and *print-length*.

If the array is of a specialized type, containing bits or characters, then
the innermost lists generated by the algorithm given above can instead be
printed using bit-vector or string syntax, provided that these innermost
lists would not be subject to truncation by *print-length*.

If both *print-array* and *print-readably* are false,

then the array is printed in a format (using #<) that is concise but not
readable.

If *print-readably* is true, the array prints in an implementation-defined
manner; see the variable *print-readably*.

In particular, this may be important for arrays having some dimension 0.

For information on how the Lisp reader parses these "other arrays," see
*Note Sharpsign A::.


File: gcl.info,  Node: Examples of Printing Arrays,  Next: Printing Random States,  Prev: Printing Other Arrays,  Up: Default Print-Object Methods

Examples of Printing Arrays
...........................

      (let ((a (make-array '(3 3)))
            (*print-pretty* t)
            (*print-array* t))
        (dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j))))
        (print a)
        (print (make-array 9 :displaced-to a)))
      |>  #2A(("<0,0>" "<0,1>" "<0,2>")
      |>      ("<1,0>" "<1,1>" "<1,2>")
      |>      ("<2,0>" "<2,1>" "<2,2>"))
      |>  #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>")
     =>  #<ARRAY 9 indirect 36363476>


File: gcl.info,  Node: Printing Random States,  Next: Printing Pathnames,  Prev: Examples of Printing Arrays,  Up: Default Print-Object Methods

Printing Random States
......................

A specific syntax for printing objects of type random-state is not
specified. However, every implementation must arrange to print a random
state object in such a way that, within the same implementation, read can
construct from the printed representation a copy of the random state
object as if the copy had been made by make-random-state.

If the type random state is effectively implemented by using the machinery
for defstruct, the usual structure syntax can then be used for printing
random state objects; one might look something like

      #S(RANDOM-STATE :DATA #(14 49 98436589 786345 8734658324 ... ))

where the components are implementation-dependent.


File: gcl.info,  Node: Printing Pathnames,  Next: Printing Structures,  Prev: Printing Random States,  Up: Default Print-Object Methods

Printing Pathnames
..................

When printer escaping is enabled,

the syntax #P"..." is how a pathname is printed by write and the other
functions herein described.  The "..." is the namestring representation of
the pathname.

When printer escaping is disabled,

write writes a pathname P by writing (namestring P) instead.

For information on how the Lisp reader parses pathnames, see *Note
Sharpsign P::.


File: gcl.info,  Node: Printing Structures,  Next: Printing Other Objects,  Prev: Printing Pathnames,  Up: Default Print-Object Methods

Printing Structures
...................

By default, a structure of type S is printed using #S syntax.  This
behavior can be customized by specifying a :print-function or
:print-object option to the defstruct form that defines S, or by writing a
print-object method that is specialized for objects of type S.

Different structures might print out in different ways; the default
notation for structures is:

      #S(structure-name {slot-key slot-value}*)

where #S indicates structure syntax, structure-name is a structure name,
each slot-key is an initialization argument name for a slot in the
structure, and each corresponding slot-value is a representation of the
object in that slot.

For information on how the Lisp reader parses structures, see *Note
Sharpsign S::.


File: gcl.info,  Node: Printing Other Objects,  Prev: Printing Structures,  Up: Default Print-Object Methods

Printing Other Objects
......................

Other objects are printed in an implementation-dependent manner.  It is
not required that an implementation print those objects readably.

For example, hash tables, readtables, packages, streams, and functions
might not print readably.

A common notation to use in this circumstance is #<...>.  Since #< is not
readable by the Lisp reader, the precise format of the text which follows
is not important, but a common format to use is that provided by the
print-unreadable-object macro.

For information on how the Lisp reader treats this notation, see *Note
Sharpsign Less-Than-Sign::.  For information on how to notate objects that
cannot be printed readably, see *Note Sharpsign Dot::.


File: gcl.info,  Node: Examples of Printer Behavior,  Prev: Default Print-Object Methods,  Up: The Lisp Printer

Examples of Printer Behavior
----------------------------

      (let ((*print-escape* t)) (fresh-line) (write #\a))
      |>  #\a
     =>  #\a
      (let ((*print-escape* nil) (*print-readably* nil))
        (fresh-line)
        (write #\a))
      |>  a
     =>  #\a
      (progn (fresh-line) (prin1 #\a))
      |>  #\a
     =>  #\a
      (progn (fresh-line) (print #\a))
      |> 
      |>  #\a
     =>  #\a
      (progn (fresh-line) (princ #\a))
      |>  a
     =>  #\a
     
      (dolist (val '(t nil))
        (let ((*print-escape* val) (*print-readably* val))
          (print '#\a)
          (prin1 #\a) (write-char #\Space)
          (princ #\a) (write-char #\Space)
          (write #\a)))
      |>  #\a #\a a #\a
      |>  #\a #\a a a
     =>  NIL
     
      (progn (fresh-line) (write '(let ((a 1) (b 2)) (+ a b))))
      |>  (LET ((A 1) (B 2)) (+ A B))
     =>  (LET ((A 1) (B 2)) (+ A B))
     
      (progn (fresh-line) (pprint '(let ((a 1) (b 2)) (+ a b))))
      |>  (LET ((A 1)
      |>        (B 2))
      |>    (+ A B))
     =>  (LET ((A 1) (B 2)) (+ A B))
     
      (progn (fresh-line)
             (write '(let ((a 1) (b 2)) (+ a b)) :pretty t))
      |>  (LET ((A 1)
      |>        (B 2))
      |>    (+ A B))
     =>  (LET ((A 1) (B 2)) (+ A B))
     
      (with-output-to-string (s)
         (write 'write :stream s)
         (prin1 'prin1 s))
     =>  "WRITEPRIN1"


File: gcl.info,  Node: The Lisp Pretty Printer,  Next: Formatted Output,  Prev: The Lisp Printer,  Up: Printer

The Lisp Pretty Printer
=======================

* Menu:

* Pretty Printer Concepts::
* Examples of using the Pretty Printer::
* Notes about the Pretty Printer's Background::


File: gcl.info,  Node: Pretty Printer Concepts,  Next: Examples of using the Pretty Printer,  Prev: The Lisp Pretty Printer,  Up: The Lisp Pretty Printer

Pretty Printer Concepts
-----------------------

The facilities provided by the pretty printer permit programs to redefine
the way in which code is displayed, and allow the full power of pretty
printing to be applied to complex combinations of data structures.

Whether any given style of output is in fact "pretty" is inherently a
somewhat subjective issue.  However, since the effect of the pretty
printer can be customized by conforming programs, the necessary
flexibility is provided for individual programs to achieve an arbitrary
degree of aesthetic control.

By providing direct access to the mechanisms within the pretty printer
that make dynamic decisions about layout, the macros and functions
pprint-logical-block, pprint-newline, and pprint-indent make it possible
to specify pretty printing layout rules as a part of any function that
produces output.  They also make it very easy for the detection of
circularity and sharing, and abbreviation based on length and nesting
depth to be supported by the function.

The pretty printer is driven entirely by dispatch based on the value of
*print-pprint-dispatch*.  The function set-pprint-dispatch makes it
possible for conforming programs to associate new pretty printing
functions with a type.

* Menu:

* Dynamic Control of the Arrangement of Output::
* Format Directive Interface::
* Compiling Format Strings::
* Pretty Print Dispatch Tables::
* Pretty Printer Margins::


File: gcl.info,  Node: Dynamic Control of the Arrangement of Output,  Next: Format Directive Interface,  Prev: Pretty Printer Concepts,  Up: Pretty Printer Concepts

Dynamic Control of the Arrangement of Output
............................................

The actions of the pretty printer when a piece of output is too large to
fit in the space available can be precisely controlled.  Three concepts
underlie the way these operations work--logical blocks , conditional
newlines , and sections .  Before proceeding further, it is important to
define these terms.

The first line of Figure 22-3 shows a schematic piece of output.  Each of
the characters in the output is represented by "-".  The positions of
conditional newlines are indicated by digits.  The beginnings and ends of
logical blocks are indicated by "<" and ">" respectively.

The output as a whole is a logical block and the outermost section.  This
section is indicated by the 0's on the second line of Figure 1.  Logical
blocks nested within the output are specified by the macro
pprint-logical-block.  Conditional newline positions are specified by
calls to pprint-newline.  Each conditional newline defines two sections
(one before it and one after it) and is associated with a third (the
section immediately containing it).

The section after a conditional newline consists of: all the output up to,
but not including, (a) the next conditional newline immediately contained
in the same logical block; or if (a) is not applicable, (b) the next
newline that is at a lesser level of nesting in logical blocks; or if (b)
is not applicable, (c) the end of the output.

The section before a conditional newline consists of: all the output back
to, but not including, (a) the previous conditional newline that is
immediately contained in the same logical block; or if (a) is not
applicable, (b) the beginning of the immediately containing logical block.
The last four lines in Figure 1 indicate the sections before and after the
four conditional newlines.

The section immediately containing a conditional newline is the shortest
section that contains the conditional newline in question.  In Figure 22-3,
the first conditional newline is immediately contained in the section
marked with 0's, the second and third conditional newlines are immediately
contained in the section before the fourth conditional newline, and the
fourth conditional newline is immediately contained in the section after
the first conditional newline.

      <-1---<--<--2---3->--4-->->
      000000000000000000000000000
      11 111111111111111111111111
                22 222
                   333 3333
             44444444444444 44444

  Figure 22-2: Example of Logical Blocks, Conditional Newlines, and Sections

Whenever possible, the pretty printer displays the entire contents of a
section on a single line.  However, if the section is too long to fit in
the space available, line breaks are inserted at conditional newline
positions within the section.


File: gcl.info,  Node: Format Directive Interface,  Next: Compiling Format Strings,  Prev: Dynamic Control of the Arrangement of Output,  Up: Pretty Printer Concepts

Format Directive Interface
..........................

The primary interface to operations for dynamically determining the
arrangement of output is provided through the functions and macros of the
pretty printer.  Figure 22-3 shows the defined names related to pretty
printing.

  *print-lines*            pprint-dispatch                pprint-pop           
  *print-miser-width*      pprint-exit-if-list-exhausted  pprint-tab           
  *print-pprint-dispatch*  pprint-fill                    pprint-tabular       
  *print-right-margin*     pprint-indent                  set-pprint-dispatch  
  copy-pprint-dispatch     pprint-linear                  write                
  format                   pprint-logical-block                                
  formatter                pprint-newline                                      

             Figure 22-3: Defined names related to pretty printing.           


Figure 22-4 identifies a set of format directives which serve as an
alternate interface to the same pretty printing operations in a more
textually compact form.

  ~I   ~W      ~<...~:>     ~:T  ~/.../  ~_        

  Figure 22-4: Format directives related to Pretty Printing



File: gcl.info,  Node: Compiling Format Strings,  Next: Pretty Print Dispatch Tables,  Prev: Format Directive Interface,  Up: Pretty Printer Concepts

Compiling Format Strings
........................

A format string is essentially a program in a special-purpose language
that performs printing, and that is interpreted by the function format.
The formatter macro provides the efficiency of using a compiled function
to do that same printing but without losing the textual compactness of
format strings.

A format control is either a format string or a function that was returned
by the the formatter macro.


File: gcl.info,  Node: Pretty Print Dispatch Tables,  Next: Pretty Printer Margins,  Prev: Compiling Format Strings,  Up: Pretty Printer Concepts

Pretty Print Dispatch Tables
............................

A pprint dispatch table is a mapping from keys to pairs of values.  Each
key is a type specifier.  The values associated with a key are a
"function" (specifically, a function designator or nil) and a "numerical
priority" (specifically, a real).  Basic insertion and retrieval is done
based on the keys with the equality of keys being tested by equal.

When *print-pretty* is true, the current pprint dispatch table (in
*print-pprint-dispatch*) controls how objects are printed.  The
information in this table takes precedence over all other mechanisms for
specifying how to print objects.  In particular, it has priority over
user-defined print-object methods

because the current pprint dispatch table is consulted first.

The function is chosen from the current pprint dispatch table by finding
the highest priority function that is associated with a type specifier
that matches the object; if there is more than one such function, it is
implementation-dependent which is used.

However, if there is no information in the table about how to pretty print
a particular kind of object, a function is invoked which uses print-object
to print the object.  The value of *print-pretty* is still true when this
function is called, and individual methods for print-object might still
elect to produce output in a special format conditional on the value of
*print-pretty*.


File: gcl.info,  Node: Pretty Printer Margins,  Prev: Pretty Print Dispatch Tables,  Up: Pretty Printer Concepts

Pretty Printer Margins
......................

A primary goal of pretty printing is to keep the output between a pair of
margins.  The column where the output begins is taken as the left margin.
If the current column cannot be determined at the time output begins, the
left margin is assumed to be zero.  The right margin is controlled by
*print-right-margin*.


File: gcl.info,  Node: Examples of using the Pretty Printer,  Next: Notes about the Pretty Printer's Background,  Prev: Pretty Printer Concepts,  Up: The Lisp Pretty Printer

Examples of using the Pretty Printer
------------------------------------

As an example of the interaction of logical blocks, conditional newlines,
and indentation, consider the function simple-pprint-defun below.  This
function prints out lists whose cars are defun in the standard way
assuming that the list has exactly length 4.

     (defun simple-pprint-defun (*standard-output* list)
       (pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")
         (write (first list))
         (write-char #\Space)
         (pprint-newline :miser)
         (pprint-indent :current 0)
         (write (second list))
         (write-char #\Space)
         (pprint-newline :fill)
         (write (third list))
         (pprint-indent :block 1)
         (write-char #\Space)
         (pprint-newline :linear)
         (write (fourth list))))

Suppose that one evaluates the following:

     (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))

If the line width available is greater than or equal to 26, then all of the
output appears on one line.  If the line width available is reduced to 25,
a line break is inserted at the linear-style conditional newline

before the expression (* x y), producing the output shown.  The
(pprint-indent :block 1) causes (* x y) to be printed at a relative
indentation of 1 in the logical block.

      (DEFUN PROD (X Y)
        (* X Y))

If the line width available is 15, a line break is also inserted at the
fill style conditional newline before the argument list.  The call on
(pprint-indent :current 0) causes the argument list to line up under the
function name.

     (DEFUN PROD
            (X Y)
       (* X Y))

If *print-miser-width* were greater than or equal to 14, the example
output above would have been as follows, because all indentation changes
are ignored in miser mode and line breaks are inserted at miser-style
conditional newlines.

      (DEFUN
       PROD
       (X Y)
       (* X Y))

As an example of a per-line prefix, consider that evaluating the following
produces the output shown with a line width of 20 and *print-miser-width*
of nil.

      (pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")
        (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))
     
      ;;; (DEFUN PROD
      ;;;        (X Y)
      ;;;   (* X Y))

As a more complex (and realistic) example, consider the function pprint-let
below.  This specifies how to print a let form in the traditional style.
It is more complex than the example above, because it has to deal with
nested structure.  Also, unlike the example above it contains complete
code to readably print any possible list that begins with the symbol let.
The outermost pprint-logical-block form handles the printing of the input
list as a whole and specifies that parentheses should be printed in the
output.  The second pprint-logical-block form handles the list of binding
pairs.  Each pair in the list is itself printed by the innermost
pprint-logical-block.  (A loop form is used instead of merely decomposing
the pair into two objects so that readable output will be produced no
matter whether the list corresponding to the pair has one element, two
elements, or (being malformed) has more than two elements.) A space and a
fill-style conditional newline

are placed after each pair except the last.  The loop at the end of the
topmost pprint-logical-block form prints out the forms in the body of the
let form separated by spaces and linear-style conditional newlines.

      (defun pprint-let (*standard-output* list)
        (pprint-logical-block (nil list :prefix "(" :suffix ")")
          (write (pprint-pop))
          (pprint-exit-if-list-exhausted)
          (write-char #\Space)
          (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
            (pprint-exit-if-list-exhausted)
            (loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
                    (pprint-exit-if-list-exhausted)
                    (loop (write (pprint-pop))
                          (pprint-exit-if-list-exhausted)
                          (write-char #\Space)
                          (pprint-newline :linear)))
                  (pprint-exit-if-list-exhausted)
                  (write-char #\Space)
                  (pprint-newline :fill)))
          (pprint-indent :block 1)
          (loop (pprint-exit-if-list-exhausted)
                (write-char #\Space)
                (pprint-newline :linear)
                (write (pprint-pop)))))

Suppose that one evaluates the following with *print-level* being 4, and
*print-circle* being true.

      (pprint-let *standard-output*
                  '#1=(let (x (*print-length* (f (g 3)))
                            (z . 2) (k (car y)))
                        (setq x (sqrt z)) #1#))

If the line length is greater than or equal to 77, the output produced
appears on one line.  However, if the line length is 76, line breaks are
inserted at the linear-style conditional newlines separating the forms in
the body and the output below is produced.  Note that, the degenerate
binding pair x is printed readably even though it fails to be a list; a
depth abbreviation marker is printed in place of (g 3); the binding pair
(z . 2) is printed readably even though it is not a proper list; and
appropriate circularity markers are printed.

      #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))
           (SETQ X (SQRT Z))
           #1#)

If the line length is reduced to 35, a line break is inserted at one of the
fill-style conditional newlines separating the binding pairs.

      #1=(LET (X (*PRINT-PRETTY* (F #))
               (Z . 2) (K (CAR Y)))
           (SETQ X (SQRT Z))
           #1#)

Suppose that the line length is further reduced to 22 and *print-length* is
set to 3. In this situation, line breaks are inserted after both the first
and second binding pairs.  In addition, the second binding pair is itself
broken across two lines.  Clause (b) of the description of fill-style
conditional newlines (see the function pprint-newline) prevents the
binding pair (z . 2) from being printed at the end of the third line.
Note that the length abbreviation hides the circularity from view and
therefore the printing of circularity markers disappears.

      (LET (X
            (*PRINT-LENGTH*
             (F #))
            (Z . 2) ...)
        (SETQ X (SQRT Z))
        ...)

The next function prints a vector using "#(...)" notation.

     (defun pprint-vector (*standard-output* v)
       (pprint-logical-block (nil nil :prefix "#(" :suffix ")")
         (let ((end (length v)) (i 0))
           (when (plusp end)
             (loop (pprint-pop)
                   (write (aref v i))
                   (if (= (incf i) end) (return nil))
                   (write-char #\Space)
                   (pprint-newline :fill))))))

Evaluating the following with a line length of 15 produces the output
shown.

      (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))
     
      #(12 34 567 8
        9012 34 567
        89 0 1 23)

As examples of the convenience of specifying pretty printing with format
strings, consider that the functions simple-pprint-defun and pprint-let
used as examples above can be compactly defined as follows.  (The function
pprint-vector cannot be defined using format because the data structure it
traverses is not a list.)

     (defun simple-pprint-defun (*standard-output* list)
       (format T "~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>" list))
     
     (defun pprint-let (*standard-output* list)
       (format T "~:<~W~^~:<~@{~:<~@{~W~^~_~}~:>~^~:_~}~:>~1I~@{~^~_~W~}~:>" list))

In the following example, the first form restores *print-pprint-dispatch*
to the equivalent of its initial value.  The next two forms then set up a
special way to pretty print ratios.  Note that the more specific type
specifier has to be associated with a higher priority.

      (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))
     
      (set-pprint-dispatch 'ratio
        #'(lambda (s obj)
            (format s "#.(/ ~W ~W)"
                      (numerator obj) (denominator obj))))
     
      (set-pprint-dispatch '(and ratio (satisfies minusp))
        #'(lambda (s obj)
            (format s "#.(- (/ ~W ~W))"
                    (- (numerator obj)) (denominator obj)))
        5)
     
      (pprint '(1/3 -2/3))
      (#.(/ 1 3) #.(- (/ 2 3)))

The following two forms illustrate the definition of pretty printing
functions for types of code.  The first form illustrates how to specify
the traditional method for printing quoted objects using single-quote.
Note the care taken to ensure that data lists that happen to begin with
quote will be printed readably.  The second form specifies that lists
beginning with the symbol my-let should print the same way that lists
beginning with let print when the initial pprint dispatch table is in
effect.

      (set-pprint-dispatch '(cons (member quote)) ()
        #'(lambda (s list)
            (if (and (consp (cdr list)) (null (cddr list)))
               (funcall (formatter "'~W") s (cadr list))
               (pprint-fill s list))))
     
      (set-pprint-dispatch '(cons (member my-let))
                           (pprint-dispatch '(let) nil))

The next example specifies a default method for printing lists that do not
correspond to function calls.  Note that the functions pprint-linear,
pprint-fill, and pprint-tabular are all defined with optional colon-p and
at-sign-p arguments so that they can be used as pprint dispatch functions
as well as ~/.../ functions.

      (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))
                           #'pprint-fill -5)
     
      ;; Assume a line length of 9
      (pprint '(0 b c d e f g h i j k))
      (0 b c d
       e f g h
       i j k)

This final example shows how to define a pretty printing function for a
user defined data structure.

      (defstruct family mom kids)
     
      (set-pprint-dispatch 'family
        #'(lambda (s f)
            (funcall (formatter "~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>")
                    s (family-mom f) (family-kids f))))

The pretty printing function for the structure family specifies how to
adjust the layout of the output so that it can fit aesthetically into a
variety of line widths.  In addition, it obeys the printer control
variables *print-level*, *print-length*, *print-lines*, *print-circle* and
*print-escape*, and can tolerate several different kinds of malformity in
the data structure.  The output below shows what is printed out with a
right margin of 25, *print-pretty* being true, *print-escape* being false,
and a malformed kids list.

      (write (list 'principal-family
                   (make-family :mom "Lucy"
                                :kids '("Mark" "Bob" . "Dan")))
             :right-margin 25 :pretty T :escape nil :miser-width nil)
      (PRINCIPAL-FAMILY
       #<Lucy and
           Mark Bob . Dan>)

Note that a pretty printing function for a structure is different from the
structure's print-object method.  While print-object methods are
permanently associated with a structure, pretty printing functions are
stored in pprint dispatch tables and can be rapidly changed to reflect
different printing needs.  If there is no pretty printing function for a
structure in the current pprint dispatch table, its print-object method is
used instead.


File: gcl.info,  Node: Notes about the Pretty Printer's Background,  Prev: Examples of using the Pretty Printer,  Up: The Lisp Pretty Printer

Notes about the Pretty Printer's Background
-------------------------------------------

For a background reference to the abstract concepts detailed in this
section, see XP: A Common Lisp Pretty Printing System.  The details of
that paper are not binding on this document, but may be helpful in
establishing a conceptual basis for understanding this material.


File: gcl.info,  Node: Formatted Output,  Next: Printer Dictionary,  Prev: The Lisp Pretty Printer,  Up: Printer

Formatted Output
================

[Editorial Note by KMP: This is transplanted from FORMAT and will need a
bit of work before it looks good standing alone. Bear with me.]

format is useful for producing nicely formatted text, producing
good-looking messages, and so on.  format can generate and return a string
or output to destination.

The control-string argument to format is actually a format control.  That
is, it can be either a format string or a function, for example a function
returned by the formatter macro.

If it is a function, the function is called with the appropriate output
stream as its first argument and the data arguments to format as its
remaining arguments.  The function should perform whatever output is
necessary and return the unused tail of the arguments (if any).

The compilation process performed by formatter produces a function that
would do with its arguments as the format interpreter would do with those
arguments.

The remainder of this section describes what happens if the control-string
is a format string.

Control-string is composed of simple text (characters) and embedded
directives.

format writes the simple text as is; each embedded directive specifies
further text output that is to appear at the corresponding point within
the simple text.  Most directives use one or more elements of args to
create their output.

A directive consists of a tilde, optional prefix parameters separated by
commas, optional colon and at-sign modifiers, and a single character
indicating what kind of directive this is.

There is no required ordering between the at-sign and colon modifier.

The case of the directive character is ignored.  Prefix parameters are
notated as signed (sign is optional) decimal numbers, or as a single-quote
followed by a character.  For example, ~5,'0d can be used to print an
integer in decimal radix in five columns with leading zeros, or ~5,'*d to
get leading asterisks.

In place of a prefix parameter to a directive, V (or v) can be used.  In
this case, format takes an argument from args as a parameter to the
directive.  The argument should be an integer or character.  If the arg
used by a V parameter is nil, the effect is as if the parameter had been
omitted.  # can be used in place of a prefix parameter; it represents the
number of args remaining to be processed.  When used within a recursive
format, in the context of ~? or ~{, the # prefix parameter represents the
number of format arguments remaining within the recursive call.

Examples of format strings:

  "~S"        ;This is an S directive with no parameters or modifiers.  
  "~3,-4:@s"  ;This is an S directive with two parameters, 3 and -4,    
              ; and both the colon and at-sign flags.                   
  "~,+4S"     ;Here the first prefix parameter is omitted and takes     
              ; on its default value, while the second parameter is 4.  

             Figure 22-5: Examples of format control strings           


format sends the output to destination.  If destination is nil, format
creates and returns a string containing the output from control-string.
If destination is non-nil, it must be a string with a fill pointer, a
stream, or the symbol t.  If destination is a string with a fill pointer,
the output is added to the end of the string.  If destination is a stream,
the output is sent to that stream.  If destination is t, the output is
sent to standard output.

In the description of the directives that follows, the term arg in general
refers to the next item of the set of args to be processed.  The word or
phrase at the beginning of each description is a mnemonic for the
directive.

format directives do not bind any of the printer control variables
(*print-...*) except as specified in the following descriptions.
Implementations may specify the binding of new, implementation-specific
printer control variables for each format directive, but they may neither
bind any standard printer control variables not specified in description
of a format directive nor fail to bind any standard printer control
variables as specified in the description.

* Menu:

* FORMAT Basic Output::
* FORMAT Radix Control::
* FORMAT Floating-Point Printers::
* FORMAT Printer Operations::
* FORMAT Pretty Printer Operations::
* FORMAT Layout Control::
* FORMAT Control-Flow Operations::
* FORMAT Miscellaneous Operations::
* FORMAT Miscellaneous Pseudo-Operations::
* Additional Information about FORMAT Operations::
* Examples of FORMAT::
* Notes about FORMAT::


File: gcl.info,  Node: FORMAT Basic Output,  Next: FORMAT Radix Control,  Prev: Formatted Output,  Up: Formatted Output

FORMAT Basic Output
-------------------

* Menu:

* Tilde C-> Character::
* Tilde Percent-> Newline::
* Tilde Ampersand-> Fresh-Line::
* Tilde Vertical-Bar-> Page::
* Tilde Tilde-> Tilde::


File: gcl.info,  Node: Tilde C-> Character,  Next: Tilde Percent-> Newline,  Prev: FORMAT Basic Output,  Up: FORMAT Basic Output

Tilde C: Character
..................

The next arg should be a character; it is printed according to the
modifier flags.

~C prints the character as if by using write-char if it is a simple
character.  Characters that are not simple are not necessarily printed as
if by write-char, but are displayed in an implementation-defined,
abbreviated format.  For example,

      (format nil "~C" #\A) =>  "A"
      (format nil "~C" #\Space) =>  " "

~:C is the same as ~C for printing characters, but other characters are
"spelled out."  The intent is that this is a "pretty" format for printing
characters.  For simple characters that are not printing, what is spelled
out is the name of the character (see char-name).  For characters that are
not simple and not printing, what is spelled out is implementation-defined.
For example,

      (format nil "~:C" #\A) =>  "A"
      (format nil "~:C" #\Space) =>  "Space"
     ;; This next example assumes an implementation-defined "Control" attribute.
      (format nil "~:C" #\Control-Space)
     =>  "Control-Space"
     OR=> "c-Space"

~:@C prints what ~:C would, and then if the character requires unusual
shift keys on the keyboard to type it, this fact is mentioned.  For
example,

      (format nil "~:@C" #\Control-Partial) =>  "Control-\partial (Top-F)"

This is the format used for telling the user about a key he is expected to
type, in prompts, for instance.  The precise output may depend not only on
the implementation, but on the particular I/O devices in use.

~@C prints the character in a way that the Lisp reader can understand,
using #\ syntax.

~@C  binds *print-escape* to t.


File: gcl.info,  Node: Tilde Percent-> Newline,  Next: Tilde Ampersand-> Fresh-Line,  Prev: Tilde C-> Character,  Up: FORMAT Basic Output

Tilde Percent: Newline
......................

This outputs a #\Newline character, thereby terminating the current output
line and beginning a new one.  ~n% outputs n newlines.  No arg is used.


File: gcl.info,  Node: Tilde Ampersand-> Fresh-Line,  Next: Tilde Vertical-Bar-> Page,  Prev: Tilde Percent-> Newline,  Up: FORMAT Basic Output

Tilde Ampersand: Fresh-Line
...........................

Unless it can be determined that the output stream is already at the
beginning of a line, this outputs a newline.  ~n& calls fresh-line and
then outputs n- 1 newlines.  ~0& does nothing.


File: gcl.info,  Node: Tilde Vertical-Bar-> Page,  Next: Tilde Tilde-> Tilde,  Prev: Tilde Ampersand-> Fresh-Line,  Up: FORMAT Basic Output

Tilde Vertical-Bar: Page
........................

This outputs a page separator character, if possible.  ~n| does this n
times.


File: gcl.info,  Node: Tilde Tilde-> Tilde,  Prev: Tilde Vertical-Bar-> Page,  Up: FORMAT Basic Output

Tilde Tilde: Tilde
..................

This outputs a tilde.  ~n~ outputs n tildes.


File: gcl.info,  Node: FORMAT Radix Control,  Next: FORMAT Floating-Point Printers,  Prev: FORMAT Basic Output,  Up: Formatted Output

FORMAT Radix Control
--------------------

* Menu:

* Tilde R-> Radix::
* Tilde D-> Decimal::
* Tilde B-> Binary::
* Tilde O-> Octal::
* Tilde X-> Hexadecimal::


File: gcl.info,  Node: Tilde R-> Radix,  Next: Tilde D-> Decimal,  Prev: FORMAT Radix Control,  Up: FORMAT Radix Control

Tilde R: Radix
..............

~nR prints arg in radix n.  The modifier flags and any remaining
parameters are used as for the ~D directive.  ~D is the same as ~10R.  The
full form is ~radix,mincol,padchar,commachar,comma-intervalR.

If no prefix parameters are given to ~R, then a different interpretation
is given.  The argument should be an integer.  For example, if arg is 4:

*
     ~R prints arg as a cardinal English number: four.

*
     ~:R prints arg as an ordinal English number: fourth.

*
     ~@R prints arg as a Roman numeral: IV.

*
     ~:@R prints arg as an old Roman numeral: IIII.

For example:

      (format nil "~,,' ,4:B" 13) =>  "1101"
      (format nil "~,,' ,4:B" 17) =>  "1 0001"
      (format nil "~19,0,' ,4:B" 3333) =>  "0000 1101 0000 0101"
      (format nil "~3,,,' ,2:R" 17) =>  "1 22"
      (format nil "~,,'|,2:D" #xFFFF) =>   "6|55|35"

If and only if the first parameter, n, is supplied, ~R binds
*print-escape* to false, *print-radix* to false, *print-base* to n,

and *print-readably* to false.

If and only if no parameters are supplied, ~R binds *print-base* to 10.


File: gcl.info,  Node: Tilde D-> Decimal,  Next: Tilde B-> Binary,  Prev: Tilde R-> Radix,  Up: FORMAT Radix Control

Tilde D: Decimal
................

An arg, which should be an integer, is printed in decimal radix.  ~D will
never put a decimal point after the number.

~mincolD uses a column width of mincol; spaces are inserted on the left if
the number requires fewer than mincol columns for its digits and sign.  If
the number doesn't fit in mincol columns, additional columns are used as
needed.

~mincol,padcharD uses padchar as the pad character instead of space.

If arg is not an integer, it is printed in ~A format and decimal base.

The @ modifier causes the number's sign to be printed always; the default
is to print it only if the number is negative.

The : modifier causes commas to be printed between groups of digits;
commachar may be used to change the character used as the comma.
comma-interval must be an integer and defaults to 3.  When the : modifier
is given to any of these directives, the commachar is printed between
groups of comma-interval digits.

Thus the most general form of ~D is
~mincol,padchar,commachar,comma-intervalD.

~D binds *print-escape* to false, *print-radix* to false, *print-base* to
10,

and *print-readably* to false.


File: gcl.info,  Node: Tilde B-> Binary,  Next: Tilde O-> Octal,  Prev: Tilde D-> Decimal,  Up: FORMAT Radix Control

Tilde B: Binary
...............

This is just like ~D but prints in binary radix (radix 2) instead of
decimal.  The full form is therefore
~mincol,padchar,commachar,comma-intervalB.

~B binds *print-escape* to false, *print-radix* to false, *print-base* to
2,

and *print-readably* to false.


File: gcl.info,  Node: Tilde O-> Octal,  Next: Tilde X-> Hexadecimal,  Prev: Tilde B-> Binary,  Up: FORMAT Radix Control

Tilde O: Octal
..............

This is just like ~D but prints in octal radix (radix 8) instead of
decimal.  The full form is therefore
~mincol,padchar,commachar,comma-intervalO.

~O binds *print-escape* to false, *print-radix* to false, *print-base* to
8,

and *print-readably* to false.


File: gcl.info,  Node: Tilde X-> Hexadecimal,  Prev: Tilde O-> Octal,  Up: FORMAT Radix Control

Tilde X: Hexadecimal
....................

This is just like ~D but prints in hexadecimal radix (radix 16) instead of
decimal.  The full form is therefore
~mincol,padchar,commachar,comma-intervalX.

~X binds *print-escape* to false, *print-radix* to false, *print-base* to
16,

and *print-readably* to false.


File: gcl.info,  Node: FORMAT Floating-Point Printers,  Next: FORMAT Printer Operations,  Prev: FORMAT Radix Control,  Up: Formatted Output

FORMAT Floating-Point Printers
------------------------------

* Menu:

* Tilde F-> Fixed-Format Floating-Point::
* Tilde E-> Exponential Floating-Point::
* Tilde G-> General Floating-Point::
* Tilde Dollarsign-> Monetary Floating-Point::


File: gcl.info,  Node: Tilde F-> Fixed-Format Floating-Point,  Next: Tilde E-> Exponential Floating-Point,  Prev: FORMAT Floating-Point Printers,  Up: FORMAT Floating-Point Printers

Tilde F: Fixed-Format Floating-Point
....................................

The next arg is printed as a float.

The full form is ~w,d,k,overflowchar,padcharF.  The parameter w is the
width of the field to be printed; d is the number of digits to print after
the decimal point; k is a scale factor that defaults to zero.

Exactly w characters will be output.  First, leading copies of the
character padchar (which defaults to a space) are printed, if necessary,
to pad the field on the left.  If the arg is negative, then a minus sign
is printed; if the arg is not negative, then a plus sign is printed if and
only if the @ modifier was supplied.  Then a sequence of digits,
containing a single embedded decimal point, is printed; this represents
the magnitude of the value of arg times 10^k, rounded to d fractional
digits.  When rounding up and rounding down would produce printed values
equidistant from the scaled value of arg, then the implementation is free
to use either one.  For example, printing the argument 6.375 using the
format ~4,2F may correctly produce either 6.37 or 6.38.  Leading zeros are
not permitted, except that a single zero digit is output before the
decimal point if the printed value is less than one, and this single zero
digit is not output at all if w=d+1.

If it is impossible to print the value in the required format in a field
of width w, then one of two actions is taken.  If the parameter
overflowchar is supplied, then w copies of that parameter are printed
instead of the scaled value of arg.  If the overflowchar parameter is
omitted, then the scaled value is printed using more than w characters, as
many more as may be needed.

If the w parameter is omitted, then the field is of variable width.  In
effect, a value is chosen for w in such a way that no leading pad
characters need to be printed and exactly d characters will follow the
decimal point.  For example, the directive ~,2F will print exactly two
digits after the decimal point and as many as necessary before the decimal
point.

If the parameter d is omitted, then there is no constraint on the number
of digits to appear after the decimal point.  A value is chosen for d in
such a way that as many digits as possible may be printed subject to the
width constraint imposed by the parameter w and the constraint that no
trailing zero digits may appear in the fraction, except that if the
fraction to be printed is zero, then a single zero digit should appear
after the decimal point if permitted by the width constraint.

If both w and d are omitted, then the effect is to print the value using
ordinary free-format output; prin1 uses this format for any number whose
magnitude is either zero or between 10^-3 (inclusive) and 10^7 (exclusive).

If w is omitted, then if the magnitude of arg is so large (or, if d is
also omitted, so small) that more than 100 digits would have to be
printed, then an implementation is free, at its discretion, to print the
number using exponential notation instead, as if by the directive ~E (with
all parameters to ~E defaulted, not taking their values from the ~F
directive).

If arg is a rational number, then it is coerced to be a single float and
then printed.  Alternatively, an implementation is permitted to process a
rational number by any other method that has essentially the same behavior
but avoids loss of precision or overflow because of the coercion.  If w
and d are not supplied and the number has no exact decimal representation,
for example 1/3, some precision cutoff must be chosen by the
implementation since only a finite number of digits may be printed.

If arg is a complex number or some non-numeric object, then it is printed
using the format directive ~wD, thereby printing it in decimal radix and a
minimum field width of w.

~F binds *print-escape* to false

and *print-readably* to false.

