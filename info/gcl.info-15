This is Info file gcl.info, produced by Makeinfo-1.55 from the input file
gcl.texi.

This is a Texinfo GNU Common Lisp Manual based on the draft ANSI standard
for Common Lisp.

Copyright 1994 William F. Schelter


File: gcl.info,  Node: let,  Next: progv,  Prev: destructuring-bind,  Up: Data and Control Flow Dictionary

let, let*                                                [Special Operator]
---------------------------------------------------------------------------

`let'  ({var | (var [init-form])}*) {declaration}* {form}* =>  {result}*

`let*'  ({var | (var [init-form])}*) {declaration}* {form}* =>  {result}*

Arguments and Values::
......................

var--a symbol.

init-form--a form.

declaration--a declare expression; not evaluated.

form--a form.

results--the values returned by the forms.

Description::
.............

let and let* create new variable bindings and execute a series of forms
that use these bindings.  let performs the bindings in parallel and let*
does them sequentially.

The form

      (let ((var1 init-form-1)
            (var2 init-form-2)
            ...
            (varm init-form-m))
        declaration1
        declaration2
        ...
        declarationp
        form1
        form2
        ...
        formn)

first evaluates the expressions init-form-1, init-form-2, and so on,

in that order, saving the resulting values.  Then all of the variables
varj are bound to the corresponding values; each binding is lexical unless
there is a special declaration to the contrary.  The expressions formk are
then evaluated in order; the values of all but the last are discarded
(that is, the body of a let is an implicit progn).

let* is similar to let, but the bindings of variables are performed
sequentially rather than in parallel.  The expression for the init-form of
a var can refer to vars previously bound in the let*.

The form

      (let* ((var1 init-form-1)
             (var2 init-form-2)
             ...
             (varm init-form-m))
        declaration1
        declaration2
        ...
        declarationp
        form1
        form2
        ...
        formn)

first evaluates the expression init-form-1, then binds the variable var1
to that value; then it evaluates init-form-2 and binds

var2, and so on.  The expressions formj are then evaluated in order; the
values of all but the last are discarded (that is, the body of let* is an
implicit progn).

For both let and let*, if there is not an init-form associated with a var,
var is initialized to nil.

The special form let has the property that the scope of the name binding
does not include any initial value form.  For let*, a variable's scope
also includes the remaining initial value forms for subsequent variable
bindings.

Examples::
..........

      (setq a 'top) =>  TOP
      (defun dummy-function () a) =>  DUMMY-FUNCTION
      (let ((a 'inside) (b a))
         (format nil "~S ~S ~S" a b (dummy-function))) =>  "INSIDE TOP TOP"
      (let* ((a 'inside) (b a))
         (format nil "~S ~S ~S" a b (dummy-function))) =>  "INSIDE INSIDE TOP"
      (let ((a 'inside) (b a))
         (declare (special a))
         (format nil "~S ~S ~S" a b (dummy-function))) =>  "INSIDE TOP INSIDE"

The code

      (let (x)
        (declare (integer x))
        (setq x (gcd y z))
        ...)

is incorrect; although x is indeed set before it is used, and is set to a
value of the declared type integer, nevertheless x initially takes on the
value nil in violation of the type declaration.

See Also::
..........

*Note progv::


File: gcl.info,  Node: progv,  Next: setq,  Prev: let,  Up: Data and Control Flow Dictionary

progv                                                    [Special Operator]
---------------------------------------------------------------------------

`progv'  symbols values {form}* =>  {result}*

Arguments and Values::
......................

symbols--a list of symbols; evaluated.

values--a list of objects; evaluated.

forms--an implicit progn.

results--the values returned by the forms.

Description::
.............

progv creates new dynamic variable bindings and executes each form using
those bindings.  Each form is evaluated in  order.

progv allows binding one or more dynamic variables whose names may be
determined at run time.  Each form is evaluated in order with the dynamic
variables whose names are in symbols bound to corresponding values.  If
too few values are supplied, the remaining symbols are bound and then made
to have no value. If too many values are supplied, the excess values are
ignored.  The bindings of the dynamic variables are undone on exit from
progv.

Examples::
..........

      (setq *x* 1) =>  1
      (progv '(*x*) '(2) *x*) =>  2
      *x* =>  1
     
     Assuming *x* is not globally special,
     
      (let ((*x* 3))
         (progv '(*x*) '(4)
           (list *x* (symbol-value '*x*)))) =>  (3 4)

See Also::
..........

*Note let; let*:: , *Note Evaluation::

Notes::
.......

Among other things, progv is useful when writing interpreters for
languages embedded in Lisp; it provides a handle on the mechanism for
binding dynamic variables.


File: gcl.info,  Node: setq,  Next: psetq,  Prev: progv,  Up: Data and Control Flow Dictionary

setq                                                         [Special Form]
---------------------------------------------------------------------------

`setq'  {!pair}* =>  result

pair ::=var form

Pronunciation::
...............

pronounced 'set ,ky\"u

Arguments and Values::
......................

var--a symbol naming a variable other than a constant variable.

form--a form.

result--the primary value of the last form, or nil if no pairs were
supplied.

Description::
.............

Assigns values to variables.

(setq var1 form1 var2 form2 ...) is the simple variable assignment
statement of Lisp.  First form1 is evaluated and the result is stored in
the variable var1, then form2 is evaluated and the result stored in var2,
and so forth.  setq may be used for assignment of both lexical and dynamic
variables.

If any var refers to a binding made by symbol-macrolet, then that var is
treated as if setf (not setq) had been used.

Examples::
..........

      ;; A simple use of SETQ to establish values for variables.
      (setq a 1 b 2 c 3) =>  3
      a =>  1
      b =>  2
      c =>  3
     
      ;; Use of SETQ to update values by sequential assignment.
      (setq a (1+ b) b (1+ a) c (+ a b)) =>  7
      a =>  3
      b =>  4
      c =>  7
     
      ;; This illustrates the use of SETQ on a symbol macro.
      (let ((x (list 10 20 30)))
        (symbol-macrolet ((y (car x)) (z (cadr x)))
          (setq y (1+ z) z (1+ y))
          (list x y z)))
     =>  ((21 22 30) 21 22)

Side Effects::
..............

The primary value of each form is assigned to the corresponding var.

See Also::
..........

*Note psetq:: , *Note set:: , *Note setf; psetf::


File: gcl.info,  Node: psetq,  Next: block,  Prev: setq,  Up: Data and Control Flow Dictionary

psetq                                                               [Macro]
---------------------------------------------------------------------------

`psetq'  {!pair}* =>  nil

pair ::=var form

Pronunciation::
...............

psetq: pronounced \vrule width 1pt height 2pt depth 2pt\kern -1pt\raise
6pt\vrule width 1pt height 2pt depth 2ptp\=e'set ,ky\"u

Arguments and Values::
......................

var--a symbol naming a variable other than a constant variable.

form--a form.

Description::
.............

Assigns values to variables.

This is just like setq, except that the assignments happen "in parallel."
That is, first all of the forms are evaluated, and only then are the
variables set to the resulting values.  In this way, the assignment to one
variable does not affect the value computation of another in the way that
would occur with setq's sequential assignment.

If any var refers to a binding made by symbol-macrolet, then that var is
treated as if psetf (not psetq) had been used.

Examples::
..........

      ;; A simple use of PSETQ to establish values for variables.
      ;; As a matter of style, many programmers would prefer SETQ
      ;; in a simple situation like this where parallel assignment
      ;; is not needed, but the two have equivalent effect.
      (psetq a 1 b 2 c 3) =>  NIL
      a =>  1
      b =>  2
      c =>  3
     
      ;; Use of PSETQ to update values by parallel assignment.
      ;; The effect here is very different than if SETQ had been used.
      (psetq a (1+ b) b (1+ a) c (+ a b)) =>  NIL
      a =>  3
      b =>  2
      c =>  3
     
      ;; Use of PSETQ on a symbol macro.
      (let ((x (list 10 20 30)))
        (symbol-macrolet ((y (car x)) (z (cadr x)))
          (psetq y (1+ z) z (1+ y))
          (list x y z)))
     =>  ((21 11 30) 21 11)
     
      ;; Use of parallel assignment to swap values of A and B.
      (let ((a 1) (b 2))
        (psetq a b  b a)
        (values a b))
     =>  2, 1

Side Effects::
..............

The values of forms are assigned to vars.

See Also::
..........

psetf, *Note setq::


File: gcl.info,  Node: block,  Next: catch,  Prev: psetq,  Up: Data and Control Flow Dictionary

block                                                    [Special Operator]
---------------------------------------------------------------------------

`block'  name form* =>  {result}*

Arguments and Values::
......................

name--a symbol.

form--a form.

results--the values of the forms if a normal return occurs, or else, if an
explicit return occurs, the values that were transferred.

Description::
.............

block establishes a block named name and then evaluates forms as an
implicit progn.

The special operators block and return-from work together to provide a
structured, lexical, non-local exit facility.  At any point lexically
contained within forms, return-from can be used with the given name to
return control and values from the block form, except when an intervening
block with the same name has been established, in which case the outer
block is shadowed by the inner one.

The block named name has lexical scope and dynamic extent.

Once established, a block may only be exited once, whether by normal
return or explicit return.

Examples::
..........

      (block empty) =>  NIL
      (block whocares (values 1 2) (values 3 4)) =>  3, 4
      (let ((x 1))
        (block stop (setq x 2) (return-from stop) (setq x 3))
        x) =>  2
      (block early (return-from early (values 1 2)) (values 3 4)) =>  1, 2
      (block outer (block inner (return-from outer 1)) 2) =>  1
      (block twin (block twin (return-from twin 1)) 2) =>  2
      ;; Contrast behavior of this example with corresponding example of CATCH.
      (block b
        (flet ((b1 () (return-from b 1)))
          (block b (b1) (print 'unreachable))
          2)) =>  1

See Also::
..........

*Note return:: , *Note return-from:: , *Note Evaluation::

Notes::
.......


File: gcl.info,  Node: catch,  Next: go,  Prev: block,  Up: Data and Control Flow Dictionary

catch                                                    [Special Operator]
---------------------------------------------------------------------------

`catch'  tag {form}* =>  {result}*

Arguments and Values::
......................

tag--a catch tag; evaluated.

forms--an implicit progn.

results--if the forms exit normally, the values returned by the forms; if
a throw occurs to the tag, the values that are thrown.

Description::
.............

catch is used as the destination of a non-local control transfer by throw.
Tags are used to find the catch to which a throw is transferring control.
(catch 'foo form) catches a (throw 'foo form) but not a (throw 'bar form).

The order of execution of catch follows:

1.
     Tag is evaluated.  It serves as the name of the catch.

2.
     Forms are then evaluated as an implicit progn, and the results of the
     last form are returned unless a throw occurs.

3.
     If a throw occurs during the execution of one of the forms, control
     is transferred  to the catch form whose tag is eq to the tag argument
     of the throw and which is the most recently established catch with
     that tag.  No further evaluation of forms occurs.

4.
     The tag established by catch is disestablished just before the
     results are returned.

If during the execution of one of the forms, a throw is executed whose tag
is eq to the catch tag, then the values specified by the throw are
returned as the result of the dynamically most recently established catch
form with that tag.

The mechanism for catch and throw works even if throw is not within the
lexical scope of catch.  throw must occur within the dynamic extent of the
evaluation of the body of a catch with a corresponding tag.

Examples::
..........

      (catch 'dummy-tag 1 2 (throw 'dummy-tag 3) 4) =>  3
      (catch 'dummy-tag 1 2 3 4) =>  4
      (defun throw-back (tag) (throw tag t)) =>  THROW-BACK
      (catch 'dummy-tag (throw-back 'dummy-tag) 2) =>  T
     
      ;; Contrast behavior of this example with corresponding example of BLOCK.
      (catch 'c
        (flet ((c1 () (throw 'c 1)))
          (catch 'c (c1) (print 'unreachable))
          2)) =>  2

Exceptional Situations::
........................

An error of type control-error is signaled if throw is done when there is
no suitable catch tag.

See Also::
..........

*Note throw:: , *Note Evaluation::

Notes::
.......

It is customary for symbols to be used as tags, but any object is
permitted.  However, numbers should not be used because the comparison is
done using eq.

catch differs from block in that catch tags have dynamic scope while block
names have lexical scope.


File: gcl.info,  Node: go,  Next: return-from,  Prev: catch,  Up: Data and Control Flow Dictionary

go                                                       [Special Operator]
---------------------------------------------------------------------------

`go'  tag =>  #<NoValue>

Arguments and Values::
......................

tag--a go tag.

Description::
.............

go transfers control to the point in the body of an enclosing tagbody form
labeled by a tag eql to tag.  If there is no such tag  in the body, the
bodies of lexically containing tagbody forms (if any) are examined as well.
If several tags are eql to tag, control is transferred to whichever
matching tag is contained in the innermost tagbody form that contains the
go.  The consequences are undefined if there is no matching tag lexically
visible to the point of the go.

The transfer of control initiated by go is performed as described in *Note
Transfer of Control to an Exit Point::.

Examples::
..........

      (tagbody
        (setq val 2)
        (go lp)
        (incf val 3)
        lp (incf val 4)) =>  NIL
      val =>  6

The following is in error because there is a normal exit of the tagbody
before the go is executed.

      (let ((a nil))
        (tagbody t (setq a #'(lambda () (go t))))
        (funcall a))

The following is in error because the tagbody is passed over before the go
form is executed.

      (funcall (block nil
                 (tagbody a (return #'(lambda () (go a))))))

See Also::
..........

*Note tagbody::


File: gcl.info,  Node: return-from,  Next: return,  Prev: go,  Up: Data and Control Flow Dictionary

return-from                                              [Special Operator]
---------------------------------------------------------------------------

`return-from'  name [result] =>  #<NoValue>

Arguments and Values::
......................

name--a block tag; not evaluated.

result--a form; evaluated.  The default is nil.

Description::
.............

Returns control and multiple values_2 from a lexically enclosing block.

A block form named name must lexically enclose the occurrence of
return-from;  any values yielded by the evaluation of result are
immediately returned from the innermost such lexically enclosing block.

The transfer of control initiated by return-from is performed as described
in *Note Transfer of Control to an Exit Point::.

Examples::
..........

      (block alpha (return-from alpha) 1) =>  NIL
      (block alpha (return-from alpha 1) 2) =>  1
      (block alpha (return-from alpha (values 1 2)) 3) =>  1, 2
      (let ((a 0))
         (dotimes (i 10) (incf a) (when (oddp i) (return)))
         a) =>  2
      (defun temp (x)
         (if x (return-from temp 'dummy))
         44) =>  TEMP
      (temp nil) =>  44
      (temp t) =>  DUMMY
      (block out
        (flet ((exit (n) (return-from out n)))
          (block out (exit 1)))
        2) =>  1
      (block nil
        (unwind-protect (return-from nil 1)
          (return-from nil 2)))
     =>  2
      (dolist (flag '(nil t))
        (block nil
          (let ((x 5))
            (declare (special x))
            (unwind-protect (return-from nil)
              (print x))))
        (print 'here))
      |>  5
      |>  HERE
      |>  5
      |>  HERE
     =>  NIL
      (dolist (flag '(nil t))
        (block nil
          (let ((x 5))
            (declare (special x))
            (unwind-protect
                (if flag (return-from nil))
              (print x))))
        (print 'here))
      |>  5
      |>  HERE
      |>  5
      |>  HERE
     =>  NIL

The following has undefined consequences because the block form exits
normally before the return-from form is attempted.

      (funcall (block nil #'(lambda () (return-from nil)))) is an error.

See Also::
..........

*Note block:: , *Note return:: , *Note Evaluation::


File: gcl.info,  Node: return,  Next: tagbody,  Prev: return-from,  Up: Data and Control Flow Dictionary

return                                                              [Macro]
---------------------------------------------------------------------------

`return'  [result] =>  #<NoValue>

Arguments and Values::
......................

result--a form; evaluated.  The default is nil.

Description::
.............

Returns, as if by return-from, from the block named nil.

Examples::
..........

      (block nil (return) 1) =>  NIL
      (block nil (return 1) 2) =>  1
      (block nil (return (values 1 2)) 3) =>  1, 2
      (block nil (block alpha (return 1) 2)) =>  1
      (block alpha (block nil (return 1)) 2) =>  2
      (block nil (block nil (return 1) 2)) =>  1

See Also::
..........

*Note block:: , *Note return-from:: , *Note Evaluation::

Notes::
.......

      (return) == (return-from nil)
      (return form) == (return-from nil form)

The implicit blocks established by macros such as do are often named nil,
so that return can be used to exit from such forms.


File: gcl.info,  Node: tagbody,  Next: throw,  Prev: return,  Up: Data and Control Flow Dictionary

tagbody                                                  [Special Operator]
---------------------------------------------------------------------------

`tagbody'  {tag | statement}* =>  nil

Arguments and Values::
......................

tag--a go tag; not evaluated.

statement--a compound form; evaluated as described below.

Description::
.............

Executes zero or more statements in a lexical environment that provides
for control transfers to labels indicated by the tags.

The statements in a tagbody are evaluated in order from left to right, and
their values are discarded.  If at any time there are no remaining
statements, tagbody returns nil.  However, if (go tag) is evaluated,
control jumps to the part of the body labeled with the tag.  (Tags are
compared with eql.)

A tag established by tagbody has lexical scope and has dynamic extent.
Once tagbody has been exited, it is no longer valid to go to a tag in its
body.  It is permissible for go to jump to a tagbody that is not the
innermost tagbody containing that go; the tags established by a tagbody
only shadow other tags of like name.

The determination of which elements of the body are tags and which are
statements is made prior to any macro expansion of that element.  If a
statement is a macro form and its macro expansion is an atom, that atom is
treated as a statement, not a tag.

Examples::
..........

      (let (val)
         (tagbody
           (setq val 1)
           (go point-a)
           (incf val 16)
          point-c
           (incf val 04)
           (go point-b)
           (incf val 32)
          point-a
           (incf val 02)
           (go point-c)
           (incf val 64)
          point-b
           (incf val 08))
         val)
     =>  15
      (defun f1 (flag)
        (let ((n 1))
          (tagbody
            (setq n (f2 flag #'(lambda () (go out))))
           out
            (prin1 n))))
     =>  F1
      (defun f2 (flag escape)
        (if flag (funcall escape) 2))
     =>  F2
      (f1 nil)
      |>  2
     =>  NIL
      (f1 t)
      |>  1
     =>  NIL

See Also::
..........

*Note go::

Notes::
.......

The macros in Figure 5-10 have implicit tagbodies.

  do              do-external-symbols  dotimes  
  do*             do-symbols           prog     
  do-all-symbols  dolist               prog*    

  Figure 5-10: Macros that have implicit tagbodies.



File: gcl.info,  Node: throw,  Next: unwind-protect,  Prev: tagbody,  Up: Data and Control Flow Dictionary

throw                                                    [Special Operator]
---------------------------------------------------------------------------

`throw'  tag result-form =>  #<NoValue>

Arguments and Values::
......................

tag--a catch tag; evaluated.

result-form--a form; evaluated as described below.

Description::
.............

throw causes a non-local control transfer to a catch whose tag is eq to
tag.

Tag is evaluated first to produce an object called the throw tag; then
result-form is evaluated, and its results are saved. If the result-form
produces multiple values, then all the values are saved.  The most recent
outstanding catch whose tag is eq to the throw tag is exited; the saved
results are returned as the value or values of catch.

The transfer of control initiated by throw is performed as described in
*Note Transfer of Control to an Exit Point::.

Examples::
..........

      (catch 'result
         (setq i 0 j 0)
         (loop (incf j 3) (incf i)
               (if (= i 3) (throw 'result (values i j))))) =>  3, 9

      (catch nil
        (unwind-protect (throw nil 1)
          (throw nil 2))) =>  2

The consequences of the following are undefined because the catch of b is
passed over by the first throw, hence portable programs must assume that
its dynamic extent is terminated.  The binding of the catch tag is not yet
disestablished and therefore it is the target of the second throw.

      (catch 'a
        (catch 'b
          (unwind-protect (throw 'a 1)
            (throw 'b 2))))

The following prints "The inner catch returns :SECOND-THROW" and then
returns :outer-catch.

      (catch 'foo
              (format t "The inner catch returns ~s.~
                      (catch 'foo
                          (unwind-protect (throw 'foo :first-throw)
                              (throw 'foo :second-throw))))
              :outer-catch)
      |>  The inner catch returns :SECOND-THROW
     =>  :OUTER-CATCH

Exceptional Situations::
........................

If there is no outstanding catch tag that matches the throw tag, no
unwinding of the stack is performed, and an error of type control-error is
signaled.  When the error is signaled, the dynamic environment is that
which was in force at the point of the throw.

See Also::
..........

*Note block:: , *Note catch:: , *Note return-from:: , *Note
unwind-protect:: , *Note Evaluation::

Notes::
.......

catch and throw are normally used when the exit point must have dynamic
scope (e.g., the throw is not lexically enclosed by the catch), while
block and return are used when lexical scope is sufficient.


File: gcl.info,  Node: unwind-protect,  Next: nil,  Prev: throw,  Up: Data and Control Flow Dictionary

unwind-protect                                           [Special Operator]
---------------------------------------------------------------------------

`unwind-protect'  protected-form {cleanup-form}* =>  {result}*

Arguments and Values::
......................

protected-form--a form.

cleanup-form--a form.

results--the values of the protected-form.

Description::
.............

unwind-protect evaluates protected-form and guarantees that cleanup-forms
are executed before unwind-protect exits, whether it terminates normally
or is aborted by a control transfer of some kind.  unwind-protect is
intended to be used to make sure that certain side effects take place
after the evaluation of protected-form.

If a non-local exit occurs during execution of cleanup-forms, no special
action is taken.  The cleanup-forms of unwind-protect are not protected by
that unwind-protect.

unwind-protect protects against all attempts to exit from protected-form,
including go, handler-case, ignore-errors, restart-case, return-from,
throw, and with-simple-restart.

Undoing of handler and restart bindings during an exit happens in parallel
with the undoing of the bindings of dynamic variables and catch tags, in
the reverse order in which they were established.  The effect of this is
that cleanup-form sees the same handler and restart bindings, as well as
dynamic variable bindings and catch tags, as were visible when the
unwind-protect was entered.

Examples::
..........

      (tagbody
        (let ((x 3))
          (unwind-protect
            (if (numberp x) (go out))
            (print x)))
       out
        ...)

When go is executed, the call to print is executed first, and then the
transfer of control to the tag out is completed.

      (defun dummy-function (x)
         (setq state 'running)
         (unless (numberp x) (throw 'abort 'not-a-number))
         (setq state (1+ x))) =>  DUMMY-FUNCTION
      (catch 'abort (dummy-function 1)) =>  2
      state =>  2
      (catch 'abort (dummy-function 'trash)) =>  NOT-A-NUMBER
      state =>  RUNNING
      (catch 'abort (unwind-protect (dummy-function 'trash)
                       (setq state 'aborted))) =>  NOT-A-NUMBER
      state =>  ABORTED

The following code is not correct:

      (unwind-protect
        (progn (incf *access-count*)
               (perform-access))
        (decf *access-count*))

If an exit occurs before completion of incf, the decf form is executed
anyway, resulting in an incorrect value for *access-count*.  The correct
way to code this is as follows:

      (let ((old-count *access-count*))
        (unwind-protect
          (progn (incf *access-count*)
                 (perform-access))
          (setq *access-count* old-count)))

     ;;; The following returns 2.
      (block nil
        (unwind-protect (return 1)
          (return 2)))
     
     ;;; The following has undefined consequences.
      (block a
        (block b
          (unwind-protect (return-from a 1)
            (return-from b 2))))
     
     ;;; The following returns 2.
      (catch nil
        (unwind-protect (throw nil 1)
          (throw nil 2)))
     
     ;;; The following has undefined consequences because the catch of B is
     ;;; passed over by the first THROW, hence portable programs must assume
     ;;; its dynamic extent is terminated.  The binding of the catch tag is not
     ;;; yet disestablished and therefore it is the target of the second throw.
      (catch 'a
        (catch 'b
          (unwind-protect (throw 'a 1)
            (throw 'b 2))))
     
     ;;; The following prints "The inner catch returns :SECOND-THROW"
     ;;; and then returns :OUTER-CATCH.
      (catch 'foo
              (format t "The inner catch returns ~s.~
                      (catch 'foo
                          (unwind-protect (throw 'foo :first-throw)
                              (throw 'foo :second-throw))))
              :outer-catch)
     
     ;;; The following returns 10. The inner CATCH of A is passed over, but
     ;;; because that CATCH is disestablished before the THROW to A is executed,
     ;;; it isn't seen.
      (catch 'a
        (catch 'b
          (unwind-protect (1+ (catch 'a (throw 'b 1)))
            (throw 'a 10))))
     
     ;;; The following has undefined consequences because the extent of
     ;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...)
     ;;; commences.
      (catch 'foo
        (catch 'bar
            (unwind-protect (throw 'foo 3)
              (throw 'bar 4)
              (print 'xxx))))
     
     ;;; The following returns 4; XXX is not printed.
     ;;; The (THROW 'FOO ...) has no effect on the scope of the BAR
     ;;; catch tag or the extent of the (CATCH 'BAR ...) exit.
      (catch 'bar
        (catch 'foo
            (unwind-protect (throw 'foo 3)
              (throw 'bar 4)
              (print 'xxx))))
     
     ;;; The following prints 5.
      (block nil
        (let ((x 5))
          (declare (special x))
          (unwind-protect (return)
            (print x))))

See Also::
..........

*Note catch:: , *Note go:: , *Note handler-case:: , *Note restart-case:: ,
*Note return:: , *Note return-from:: , *Note throw:: , *Note Evaluation::


File: gcl.info,  Node: nil,  Next: not,  Prev: unwind-protect,  Up: Data and Control Flow Dictionary

nil                                                     [Constant Variable]
---------------------------------------------------------------------------

Constant Value::
................

nil.

Description::
.............

nil represents both boolean (and generalized boolean) false and the empty
list.

Examples::
..........

      nil =>  NIL

See Also::
..........

*Note t::


File: gcl.info,  Node: not,  Next: t,  Prev: nil,  Up: Data and Control Flow Dictionary

not                                                              [Function]
---------------------------------------------------------------------------

`not'  x =>  boolean

Arguments and Values::
......................

x--a generalized boolean (i.e., any object).

boolean--a boolean.

Description::
.............

Returns t if x is false; otherwise, returns nil.

Examples::
..........

      (not nil) =>  T
      (not '()) =>  T
      (not (integerp 'sss)) =>  T
      (not (integerp 1)) =>  NIL
      (not 3.7) =>  NIL
      (not 'apple) =>  NIL

See Also::
..........

*Note null::

Notes::
.......

not is intended to be used to invert the `truth value' of a boolean (or
generalized boolean) whereas null is intended to be used to test for the
empty list.  Operationally, not and null compute the same result; which to
use is a matter of style.


File: gcl.info,  Node: t,  Next: eq,  Prev: not,  Up: Data and Control Flow Dictionary

t                                                       [Constant Variable]
---------------------------------------------------------------------------

Constant Value::
................

t.

Description::
.............

The boolean representing true, and the canonical generalized boolean
representing true.  Although any object other than nil is considered true,
t is generally used when there is no special reason to prefer one such
object over another.

The symbol t is also sometimes used for other purposes as well.  For
example, as the name of a class, as a designator (e.g., a stream
designator) or as a special symbol for some syntactic reason (e.g., in
case and typecase to label the otherwise-clause).

Examples::
..........

      t =>  T
      (eq t 't) =>  true
      (find-class 't) =>  #<CLASS T 610703333>
      (case 'a (a 1) (t 2)) =>  1
      (case 'b (a 1) (t 2)) =>  2
      (prin1 'hello t)
      |>  HELLO
     =>  HELLO

See Also::
..........

*Note NIL::


File: gcl.info,  Node: eq,  Next: eql,  Prev: t,  Up: Data and Control Flow Dictionary

eq                                                               [Function]
---------------------------------------------------------------------------

`eq'  x y =>  generalized-boolean

Arguments and Values::
......................

x--an object.

y--an object.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if its arguments are the same, identical object; otherwise,
returns false.

Examples::
..........

      (eq 'a 'b) =>  false
      (eq 'a 'a) =>  true
      (eq 3 3)
     =>  true
     OR=> false
      (eq 3 3.0) =>  false
      (eq 3.0 3.0)
     =>  true
     OR=> false
      (eq #c(3 -4) #c(3 -4))
     =>  true
     OR=> false
      (eq #c(3 -4.0) #c(3 -4)) =>  false
      (eq (cons 'a 'b) (cons 'a 'c)) =>  false
      (eq (cons 'a 'b) (cons 'a 'b)) =>  false
      (eq '(a . b) '(a . b))
     =>  true
     OR=> false
      (progn (setq x (cons 'a 'b)) (eq x x)) =>  true
      (progn (setq x '(a . b)) (eq x x)) =>  true
      (eq #\A #\A)
     =>  true
     OR=> false
      (let ((x "Foo")) (eq x x)) =>  true
      (eq "Foo" "Foo")
     =>  true
     OR=> false
      (eq "Foo" (copy-seq "Foo")) =>  false
      (eq "FOO" "foo") =>  false
      (eq "string-seq" (copy-seq "string-seq")) =>  false
      (let ((x 5)) (eq x x))
     =>  true
     OR=> false

See Also::
..........

*Note eql:: , *Note equal:: , *Note equalp:: , *Note =; /=; <; >; <=; >=::
, *Note Compilation::

Notes::
.......

Objects that appear the same when printed are not necessarily eq to each
other.  Symbols that print the same usually are eq to each other because
of the use of the intern function.  However, numbers with the same value
need not be eq, and two similar lists are usually not identical.

An implementation is permitted to make "copies" of characters and numbers
at any time.  The effect is that Common Lisp makes no guarantee that eq is
true even when both its arguments are "the same thing" if that thing is a
character or number.

Most Common Lisp operators use eql rather than eq to compare objects, or
else they default to eql and only use eq if specifically requested to do
so.  However, the following operators are defined to use eq rather than
eql in a way that cannot be overridden by the code which employs them:

  catch           getf     throw     get             remf            
  get-properties  remprop  

  Figure 5-11: Operators that always prefer EQ over EQL



File: gcl.info,  Node: eql,  Next: equal,  Prev: eq,  Up: Data and Control Flow Dictionary

eql                                                              [Function]
---------------------------------------------------------------------------

`eql'  x y =>  generalized-boolean

Arguments and Values::
......................

x--an object.

y--an object.

generalized-boolean--a generalized boolean.

Description::
.............

The value of eql is true of two objects, x and y, in the folowing cases:
1.
     If x and y are eq.

2.
     If x and y are both numbers of the same type and the same value.

3.
     If they are both characters that represent the same character.

Otherwise the value of eql is false.

If an implementation supports positive and negative zeros as distinct
values, then (eql 0.0 -0.0) returns false.  Otherwise, when the syntax
-0.0 is read it is interpreted as the value 0.0, and so (eql 0.0 -0.0)
returns true.

Examples::
..........

      (eql 'a 'b) =>  false
      (eql 'a 'a) =>  true
      (eql 3 3) =>  true
      (eql 3 3.0) =>  false
      (eql 3.0 3.0) =>  true
      (eql #c(3 -4) #c(3 -4)) =>  true
      (eql #c(3 -4.0) #c(3 -4)) =>  false
      (eql (cons 'a 'b) (cons 'a 'c)) =>  false
      (eql (cons 'a 'b) (cons 'a 'b)) =>  false
      (eql '(a . b) '(a . b))
     =>  true
     OR=> false
      (progn (setq x (cons 'a 'b)) (eql x x)) =>  true
      (progn (setq x '(a . b)) (eql x x)) =>  true
      (eql #\A #\A) =>  true
      (eql "Foo" "Foo")
     =>  true
     OR=> false
      (eql "Foo" (copy-seq "Foo")) =>  false
      (eql "FOO" "foo") =>  false

Normally (eql 1.0s0 1.0d0) is false, under the assumption that 1.0s0 and
1.0d0 are of distinct data types.  However, implementations that do not
provide four distinct floating-point formats are permitted to "collapse"
the four formats into some smaller number of them; in such an
implementation (eql 1.0s0 1.0d0) might be true.

See Also::
..........

*Note eq:: , *Note equal:: , *Note equalp:: , *Note =; /=; <; >; <=; >=:: ,
*Note char=; char/=; char<; char>; char<=; char>=; char-equal;
char-not-equal; char-lessp; char-greaterp; char-not-greaterp;
char-not-lessp::

Notes::
.......

eql is the same as eq, except that if the arguments are characters or
numbers of the same type then their values are compared.  Thus eql tells
whether two objects are conceptually the same, whereas eq tells whether two
objects are implementationally identical.  It is for this reason that eql,
not eq, is the default comparison predicate for operators that take
sequences as arguments.

eql may not be true of two floats even when they represent the same value.
= is used to compare mathematical values.

Two complex numbers are considered to be eql if their real parts are eql
and their imaginary parts are eql.  For example, (eql #C(4 5) #C(4 5)) is
true and (eql #C(4 5) #C(4.0 5.0)) is false.  Note that while (eql #C(5.0
0.0) 5.0) is false, (eql #C(5 0) 5) is true.  In the case of (eql #C(5.0
0.0) 5.0) the two arguments are of different types, and so cannot satisfy
eql.  In the case of (eql #C(5 0) 5), #C(5 0) is not a complex number, but
is automatically reduced to the integer 5.


File: gcl.info,  Node: equal,  Next: equalp,  Prev: eql,  Up: Data and Control Flow Dictionary

equal                                                            [Function]
---------------------------------------------------------------------------

`equal'  x y =>  generalized-boolean

Arguments and Values::
......................

x--an object.

y--an object.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if x and y are structurally similar (isomorphic) objects.
Objects are treated as follows by equal.

Symbols, Numbers, and Characters
     equal is true of two objects if they are symbols that are eq, if they
     are numbers that are eql, or if they are characters that are eql.

Conses
     For conses, equal is defined recursively as the two cars being equal
     and the two cdrs being equal.

Arrays
     Two arrays are equal only if they are eq, with one exception: strings
     and bit vectors are compared element-by-element (using eql).  If
     either x or y has a fill pointer, the fill pointer limits the number
     of elements examined by equal.  Uppercase and lowercase letters in
     strings are considered by equal to be different.

Pathnames
     Two pathnames are equal if and only if all the corresponding
     components (host, device, and so on) are equivalent.  Whether or not
     uppercase and lowercase letters are considered equivalent in strings
     appearing in components is implementation-dependent.  pathnames that
     are equal should be functionally equivalent.

Other (Structures, hash-tables, instances, ...)
     Two other objects are equal only if they are eq.

equal does not descend any objects other than the ones explicitly
specified above.  Figure 5-12 summarizes the information given in the
previous list.  In addition, the figure specifies the priority of the
behavior of equal, with upper entries taking priority over lower ones.

  Type          Behavior                   
  number        uses eql                   
  character     uses eql                   
  cons          descends                   
  bit vector    descends                   
  string        descends                   
  pathname      "functionally equivalent"  
  structure     uses eq                    
  Other array   uses eq                    
  hash table    uses eq                    
  Other object  uses eq                    

  Figure 5-12: Summary and priorities of behavior of equal


Any two objects that are eql are also equal.

equal may fail to terminate if x or y is circular.

Examples::
..........

      (equal 'a 'b) =>  false
      (equal 'a 'a) =>  true
      (equal 3 3) =>  true
      (equal 3 3.0) =>  false
      (equal 3.0 3.0) =>  true
      (equal #c(3 -4) #c(3 -4)) =>  true
      (equal #c(3 -4.0) #c(3 -4)) =>  false
      (equal (cons 'a 'b) (cons 'a 'c)) =>  false
      (equal (cons 'a 'b) (cons 'a 'b)) =>  true
      (equal #\A #\A) =>  true
      (equal #\A #\a) =>  false
      (equal "Foo" "Foo") =>  true
      (equal "Foo" (copy-seq "Foo")) =>  true
      (equal "FOO" "foo") =>  false
      (equal "This-string" "This-string") =>  true
      (equal "This-string" "this-string") =>  false

See Also::
..........

*Note eq:: , *Note eql:: , *Note equalp:: , *Note =; /=; <; >; <=; >=:: ,
*Note string=; string/=; string<; string>; string<=; string>=;
string-equal; string-not-equal; string-lessp; string-greaterp;
string-not-greaterp; string-not-lessp:: , string-equal, *Note char=;
char/=; char<; char>; char<=; char>=; char-equal; char-not-equal;
char-lessp; char-greaterp; char-not-greaterp; char-not-lessp:: ,
char-equal, *Note tree-equal::

Notes::
.......

Object equality is not a concept for which there is a uniquely determined
correct algorithm. The appropriateness of an equality predicate can be
judged only in the context of the needs of some particular program.
Although these functions take any type of argument and their names sound
very generic, equal and equalp are not appropriate for every application.

A rough rule of thumb is that two objects are equal if and only if their
printed representations are the same.


File: gcl.info,  Node: equalp,  Next: identity,  Prev: equal,  Up: Data and Control Flow Dictionary

equalp                                                           [Function]
---------------------------------------------------------------------------

`equalp'  x y =>  generalized-boolean

Arguments and Values::
......................

x--an object.

y--an object.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if x and y are equal, or if they have components that are of
the same type as each other and if those components are equalp;
specifically, equalp returns true in the following cases:
Characters
     If two characters are char-equal.

Numbers
     If two numbers are the same under =.

Conses
     If the two cars in the conses are equalp and the two cdrs in the
     conses are equalp.

Arrays
     If two arrays have the same number of dimensions, the dimensions
     match, and the corresponding active elements are equalp.  The types
     for which the arrays are specialized need not match; for example, a
     string and a general array that happens to contain the same
     characters are equalp.  Because equalp performs element-by-element
     comparisons of strings and ignores the case of characters, case
     distinctions are ignored when equalp compares strings.

Structures
     If two structures S_1 and S_2 have the same class and the value of
     each slot in S_1 is the same under equalp as the value of the
     corresponding slot in S_2.

Hash Tables
     equalp descends hash-tables by first comparing the count of entries
     and the :test function; if those are the same, it compares the keys
     of the tables using the :test function and then the values of the
     matching keys using equalp recursively.

equalp does not descend any objects other than the ones explicitly
specified above.  Figure 5-13 summarizes the information given in the
previous list.  In addition, the figure specifies the priority of the
behavior of equalp, with upper entries taking priority over lower ones.

  Type          Behavior                      
  number        uses =                        
  character     uses char-equal               
  cons          descends                      
  bit vector    descends                      
  string        descends                      
  pathname      same as equal                 
  structure     descends, as described above  
  Other array   descends                      
  hash table    descends, as described above  
  Other object  uses eq                       

  Figure 5-13: Summary and priorities of behavior of equalp


Examples::
..........

      (equalp 'a 'b) =>  false
      (equalp 'a 'a) =>  true
      (equalp 3 3) =>  true
      (equalp 3 3.0) =>  true
      (equalp 3.0 3.0) =>  true
      (equalp #c(3 -4) #c(3 -4)) =>  true
      (equalp #c(3 -4.0) #c(3 -4)) =>  true
      (equalp (cons 'a 'b) (cons 'a 'c)) =>  false
      (equalp (cons 'a 'b) (cons 'a 'b)) =>  true
      (equalp #\A #\A) =>  true
      (equalp #\A #\a) =>  true
      (equalp "Foo" "Foo") =>  true
      (equalp "Foo" (copy-seq "Foo")) =>  true
      (equalp "FOO" "foo") =>  true

      (setq array1 (make-array 6 :element-type 'integer
                                 :initial-contents '(1 1 1 3 5 7)))
     =>  #(1 1 1 3 5 7)
      (setq array2 (make-array 8 :element-type 'integer
                                 :initial-contents '(1 1 1 3 5 7 2 6)
                                 :fill-pointer 6))
     =>  #(1 1 1 3 5 7)
      (equalp array1 array2) =>  true
      (setq vector1 (vector 1 1 1 3 5 7)) =>  #(1 1 1 3 5 7)
      (equalp array1 vector1) =>  true

See Also::
..........

*Note eq:: , *Note eql:: , *Note equal:: , *Note =; /=; <; >; <=; >=:: ,
*Note string=; string/=; string<; string>; string<=; string>=;
string-equal; string-not-equal; string-lessp; string-greaterp;
string-not-greaterp; string-not-lessp:: , string-equal, *Note char=;
char/=; char<; char>; char<=; char>=; char-equal; char-not-equal;
char-lessp; char-greaterp; char-not-greaterp; char-not-lessp:: , char-equal

Notes::
.......

Object equality is not a concept for which there is a uniquely determined
correct algorithm. The appropriateness of an equality predicate can be
judged only in the context of the needs of some particular program.
Although these functions take any type of argument and their names sound
very generic, equal and equalp are not appropriate for every application.


File: gcl.info,  Node: identity,  Next: complement,  Prev: equalp,  Up: Data and Control Flow Dictionary

identity                                                         [Function]
---------------------------------------------------------------------------

`identity'  object =>  object

Arguments and Values::
......................

object--an object.

Description::
.............

Returns its argument object.

Examples::
..........

      (identity 101) =>  101
      (mapcan #'identity (list (list 1 2 3) '(4 5 6))) =>  (1 2 3 4 5 6)

Notes::
.......

identity is intended for use with functions that require a function as an
argument.

(eql x (identity x)) returns true for all possible values of x, but (eq x
(identity x)) might return false when x is a number or character.

identity could be defined by

     (defun identity (x) x)


File: gcl.info,  Node: complement,  Next: constantly,  Prev: identity,  Up: Data and Control Flow Dictionary

complement                                                       [Function]
---------------------------------------------------------------------------

`complement'  function =>  complement-function

Arguments and Values::
......................

function--a function.

complement-function--a function.

Description::
.............

Returns a function that takes the same arguments as function, and has the
same side-effect behavior as function, but returns only a single value: a
generalized boolean with the opposite truth value of that which would be
returned as the primary value of function.  That is, when the function
would have returned true as its primary value the complement-function
returns false, and when the function would have returned false as its
primary value the complement-function returns true.

Examples::
..........

      (funcall (complement #'zerop) 1) =>  true
      (funcall (complement #'characterp) #\A) =>  false
      (funcall (complement #'member) 'a '(a b c)) =>  false
      (funcall (complement #'member) 'd '(a b c)) =>  true

See Also::
..........

*Note not::

Notes::
.......

      (complement x) == #'(lambda (&rest arguments) (not (apply x arguments)))

In Common Lisp, functions with names like "xxx-if-not" are related to
functions with names like "xxx-if" in that

     (xxx-if-not f . arguments) == (xxx-if (complement f) . arguments)

For example,

      (find-if-not #'zerop '(0 0 3)) ==
      (find-if (complement #'zerop) '(0 0 3)) =>  3

Note that since the "xxx-if-not" functions and the :test-not arguments
have been deprecated, uses of "xxx-if" functions or :test arguments with
complement are preferred.


File: gcl.info,  Node: constantly,  Next: every,  Prev: complement,  Up: Data and Control Flow Dictionary

constantly                                                       [Function]
---------------------------------------------------------------------------

`constantly'  value =>  function

Arguments and Values::
......................

value--an object.

function--a function.

Description::
.............

constantly returns a function that accepts any number of arguments, that
has no side-effects, and that always returns value.

Examples::
..........

      (mapcar (constantly 3) '(a b c d)) =>  (3 3 3 3)
      (defmacro with-vars (vars &body forms)
        `((lambda ,vars ,@forms) ,@(mapcar (constantly nil) vars)))
     =>  WITH-VARS
      (macroexpand '(with-vars (a b) (setq a 3 b (* a a)) (list a b)))
     =>  ((LAMBDA (A B) (SETQ A 3 B (* A A)) (LIST A B)) NIL NIL), true

See Also::
..........

*Note not::

Notes::
.......

constantly could be defined by:

      (defun constantly (object)
        #'(lambda (&rest arguments) object))

