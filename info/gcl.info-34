This is Info file gcl.info, produced by Makeinfo-1.55 from the input file
gcl.texi.

This is a Texinfo GNU Common Lisp Manual based on the draft ANSI standard
for Common Lisp.

Copyright 1994 William F. Schelter


File: gcl.info,  Node: Treatment of Newline during Input and Output,  Next: Character Encodings,  Prev: Character Names,  Up: Character Concepts

Treatment of Newline during Input and Output
--------------------------------------------

When the character #\Newline is written to an output file, the
implementation must take the appropriate action to produce a line
division.  This might involve writing out a record or translating
#\Newline to a CR/LF sequence.  When reading, a corresponding reverse
transformation must take place.


File: gcl.info,  Node: Character Encodings,  Next: Documentation of Implementation-Defined Scripts,  Prev: Treatment of Newline during Input and Output,  Up: Character Concepts

Character Encodings
-------------------

A character is sometimes represented merely by its code, and sometimes by
another integer value which is composed from the code and all
implementation-defined attributes (in an implementation-defined way that
might vary between Lisp images even in the same implementation).  This
integer, returned by the function char-int, is called the character's
"encoding." There is no corresponding function from a character's encoding
back to the character, since its primary intended uses include things like
hashing where an inverse operation is not really called for.


File: gcl.info,  Node: Documentation of Implementation-Defined Scripts,  Prev: Character Encodings,  Up: Character Concepts

Documentation of Implementation-Defined Scripts
-----------------------------------------------

An implementation must document the character scripts it supports. For
each character script supported, the documentation must describe at least
the following:
*
     Character labels, glyphs, and descriptions.  Character labels must be
     uniquely named using only Latin capital letters A-Z, hyphen (-), and
     digits 0-9.

*
     Reader canonicalization.  Any mechanisms by which read treats
     different characters as equivalent must be documented.

*
     The impact on char-upcase, char-downcase, and the case-sensitive
     format directives.  In particular, for each character with case,
     whether it is uppercase or lowercase, and which character is its
     equivalent in the opposite case.

*
     The behavior of the case-insensitive functions char-equal,
     char-not-equal, char-lessp, char-greaterp, char-not-greaterp, and
     char-not-lessp.

*
     The behavior of any character predicates; in particular, the effects
     of alpha-char-p, lower-case-p, upper-case-p, both-case-p,
     graphic-char-p, and alphanumericp.

*
     The interaction with file I/O, in particular, the supported coded
     character sets (for example, ISO8859/1-1987) and external encoding
     schemes supported are documented.


File: gcl.info,  Node: Characters Dictionary,  Prev: Character Concepts,  Up: Characters

Characters Dictionary
=====================

* Menu:

* character (System Class)::
* base-char::
* standard-char::
* extended-char::
* char=::
* character::
* characterp::
* alpha-char-p::
* alphanumericp::
* digit-char::
* digit-char-p::
* graphic-char-p::
* standard-char-p::
* char-upcase::
* upper-case-p::
* char-code::
* char-int::
* code-char::
* char-code-limit::
* char-name::
* name-char::


File: gcl.info,  Node: character (System Class),  Next: base-char,  Prev: Characters Dictionary,  Up: Characters Dictionary

character                                                    [System Class]
---------------------------------------------------------------------------

Class Precedence List::
.......................

character, t

Description::
.............

A character is an object that represents a unitary token in an aggregate
quantity of text; see *Note Character Concepts::.

The types base-char and extended-char form an exhaustive partition of the
type character.

See Also::
..........

*Note Character Concepts::, *Note Sharpsign Backslash::, *Note Printing
Characters::


File: gcl.info,  Node: base-char,  Next: standard-char,  Prev: character (System Class),  Up: Characters Dictionary

base-char                                                            [Type]
---------------------------------------------------------------------------

Supertypes::
............

base-char, character, t

Description::
.............

The type base-char is defined as the upgraded array element type of
standard-char.  An implementation can support additional subtypes of type
character (besides the ones listed in this standard) that might or might
not be supertypes of type base-char.  In addition, an implementation can
define base-char to be the same type as character.

Base characters are distinguished in the following respects:
1.
     The type standard-char is a subrepertoire of the type base-char.

2.
     The selection of base characters that are not standard characters is
     implementation defined.

3.
     Only objects of the type base-char can be elements of a base string.

4.
     No upper bound is specified for the number of characters in the
     base-char repertoire; the size of that repertoire is
     implementation-defined.  The lower bound is~96, the number of
     standard characters.

Whether a character is a base character depends on the way that an
implementation represents strings, and not any other properties of the
implementation or the host operating system.  For example, one
implementation might encode all strings as characters having 16-bit
encodings, and another might have two kinds of strings: those with
characters having 8-bit encodings and those with characters having 16-bit
encodings.  In the first implementation, the type base-char is equivalent
to the type character: there is only one kind of string.  In the second
implementation, the base characters might be those characters that could
be stored in a string of characters having 8-bit encodings.  In such an
implementation, the type base-char is a proper subtype of the type
character.

The type standard-char is a

subtype of type base-char.


File: gcl.info,  Node: standard-char,  Next: extended-char,  Prev: base-char,  Up: Characters Dictionary

standard-char                                                        [Type]
---------------------------------------------------------------------------

Supertypes::
............

standard-char,

base-char,

character, t

Description::
.............

A fixed set of 96 characters required to be present in all conforming
implementations.  Standard characters are defined in *Note Standard
Characters::.

Any character that is not simple is not a standard character.

See Also::
..........

*Note Standard Characters::


File: gcl.info,  Node: extended-char,  Next: char=,  Prev: standard-char,  Up: Characters Dictionary

extended-char                                                        [Type]
---------------------------------------------------------------------------

Supertypes::
............

extended-char, character, t

Description::
.............

The type extended-char is equivalent to the type (and character (not
base-char)).

Notes::
.......

The type extended-char might have no elements_4 in implementations in
which all characters are of type base-char.


File: gcl.info,  Node: char=,  Next: character,  Prev: extended-char,  Up: Characters Dictionary

char=, char/=, char<, char>, char<=, char>=,
--------------------------------------------

char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp,
-------------------------------------------------------------------------

char-not-lessp
--------------

                                                                [Function]

`char='  &rest characters^+ =>  generalized-boolean

`char/='  &rest characters^+ =>  generalized-boolean

`char<'  &rest characters^+ =>  generalized-boolean

`char>'  &rest characters^+ =>  generalized-boolean

`char<='  &rest characters^+ =>  generalized-boolean

`char>='  &rest characters^+ =>  generalized-boolean

`char-equal'  &rest characters^+ =>  generalized-boolean

`char-not-equal'  &rest characters^+ =>  generalized-boolean

`char-lessp'  &rest characters^+ =>  generalized-boolean

`char-greaterp'  &rest characters^+ =>  generalized-boolean

`char-not-greaterp'  &rest characters^+ =>  generalized-boolean

`char-not-lessp'  &rest characters^+ =>  generalized-boolean

Arguments and Values::
......................

character--a character.

generalized-boolean--a generalized boolean.

Description::
.............

These predicates compare characters.

char= returns true if all characters are the same; otherwise, it returns
false.

If two characters differ in any implementation-defined attributes, then
they are not char=.

char/= returns true if all characters are different; otherwise, it returns
false.

char< returns true if the characters are monotonically increasing;
otherwise, it returns false.

If two characters have identical implementation-defined attributes, then
their ordering by char< is consistent with the numerical ordering by the
predicate < on their codes.

char> returns true if the characters are monotonically decreasing;
otherwise, it returns false.

If two characters have identical implementation-defined attributes, then
their ordering by char> is consistent with the numerical ordering by the
predicate > on their codes.

char<= returns true if the characters are monotonically nondecreasing;
otherwise, it returns false.

If two characters have identical implementation-defined attributes, then
their ordering by char<= is consistent with the numerical ordering by the
predicate <= on their codes.

char>= returns true if the characters are monotonically nonincreasing;
otherwise, it returns false.

If two characters have identical implementation-defined attributes, then
their ordering by char>= is consistent with the numerical ordering by the
predicate >= on their codes.

char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp,
and char-not-lessp are similar to char=, char/=, char<, char>, char<=,
char>=, respectively, except that they ignore differences in case and

might have an implementation-defined behavior for non-simple characters.
For example, an implementation might define that char-equal, etc. ignore
certain implementation-defined attributes.  The effect, if any, of each
implementation-defined attribute upon these functions must be specified as
part of the definition of that attribute.

Examples::
..........

      (char= #\d #\d) =>  true
      (char= #\A #\a) =>  false
      (char= #\d #\x) =>  false
      (char= #\d #\D) =>  false
      (char/= #\d #\d) =>  false
      (char/= #\d #\x) =>  true
      (char/= #\d #\D) =>  true
      (char= #\d #\d #\d #\d) =>  true
      (char/= #\d #\d #\d #\d) =>  false
      (char= #\d #\d #\x #\d) =>  false
      (char/= #\d #\d #\x #\d) =>  false
      (char= #\d #\y #\x #\c) =>  false
      (char/= #\d #\y #\x #\c) =>  true
      (char= #\d #\c #\d) =>  false
      (char/= #\d #\c #\d) =>  false
      (char< #\d #\x) =>  true
      (char<= #\d #\x) =>  true
      (char< #\d #\d) =>  false
      (char<= #\d #\d) =>  true
      (char< #\a #\e #\y #\z) =>  true
      (char<= #\a #\e #\y #\z) =>  true
      (char< #\a #\e #\e #\y) =>  false
      (char<= #\a #\e #\e #\y) =>  true
      (char> #\e #\d) =>  true
      (char>= #\e #\d) =>  true
      (char> #\d #\c #\b #\a) =>  true
      (char>= #\d #\c #\b #\a) =>  true
      (char> #\d #\d #\c #\a) =>  false
      (char>= #\d #\d #\c #\a) =>  true
      (char> #\e #\d #\b #\c #\a) =>  false
      (char>= #\e #\d #\b #\c #\a) =>  false
      (char> #\z #\A) =>  implementation-dependent
      (char> #\Z #\a) =>  implementation-dependent
      (char-equal #\A #\a) =>  true
      (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char-lessp)
     =>  (#\A #\a #\b #\B #\c #\C)
      (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char<)
     =>  (#\A #\B #\C #\a #\b #\c) ;Implementation A
     =>  (#\a #\b #\c #\A #\B #\C) ;Implementation B
     =>  (#\a #\A #\b #\B #\c #\C) ;Implementation C
     =>  (#\A #\a #\B #\b #\C #\c) ;Implementation D
     =>  (#\A #\B #\a #\b #\C #\c) ;Implementation E

Exceptional Situations::
........................

Should signal an error of type program-error if at least one character is
not supplied.

See Also::
..........

*Note Character Syntax::, *Note Documentation of Implementation-Defined
Scripts::

Notes::
.......

If characters differ in their code attribute or any implementation-defined
attribute, they are considered to be different by char=.

There is no requirement that (eq c1 c2) be true merely because (char= c1
c2) is true.  While eq can distinguish two characters that char= does not,
it is distinguishing them not as characters, but in some sense on the
basis of a lower level implementation characteristic.  If (eq c1 c2) is
true, then (char= c1 c2) is also true.  eql and equal compare characters
in the same way that char= does.

The manner in which case is used by char-equal, char-not-equal, char-lessp,
char-greaterp, char-not-greaterp, and char-not-lessp implies an ordering
for standard characters such that A=a, B=b, and so on, up to Z=z, and
furthermore either 9<A or Z<0.


File: gcl.info,  Node: character,  Next: characterp,  Prev: char=,  Up: Characters Dictionary

character                                                        [Function]
---------------------------------------------------------------------------

`character'  character =>  denoted-character

Arguments and Values::
......................

character--a character designator.

denoted-character--a character.

Description::
.............

Returns the character denoted by the character designator.

Examples::
..........

      (character #\a) =>  #\a
      (character "a") =>  #\a
      (character 'a) =>  #\A
      (character '\a) =>  #\a
      (character 65.) is an error.
      (character 'apple) is an error.

Exceptional Situations::
........................

Should signal an error of type type-error if object is not a character
designator.

See Also::
..........

*Note coerce::

Notes::
.......

      (character object) == (coerce object 'character)


File: gcl.info,  Node: characterp,  Next: alpha-char-p,  Prev: character,  Up: Characters Dictionary

characterp                                                       [Function]
---------------------------------------------------------------------------

`characterp'  object =>  generalized-boolean

Arguments and Values::
......................

object--an object.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if object is of type character; otherwise, returns false.

Examples::
..........

      (characterp #\a) =>  true
      (characterp 'a) =>  false
      (characterp "a") =>  false
      (characterp 65.) =>  false
      (characterp #\Newline) =>  true
      ;; This next example presupposes an implementation
      ;; in which #\Rubout is an implementation-defined character.
      (characterp #\Rubout) =>  true

See Also::
..........

*Note character:: (type and function), *Note typep::

Notes::
.......

      (characterp object) == (typep object 'character)


File: gcl.info,  Node: alpha-char-p,  Next: alphanumericp,  Prev: characterp,  Up: Characters Dictionary

alpha-char-p                                                     [Function]
---------------------------------------------------------------------------

`alpha-char-p'  character =>  generalized-boolean

Arguments and Values::
......................

character--a character.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if character is an alphabetic_1 character; otherwise, returns
false.

Examples::
..........

      (alpha-char-p #\a) =>  true
      (alpha-char-p #\5) =>  false
      (alpha-char-p #\Newline) =>  false
      ;; This next example presupposes an implementation
      ;; in which #\\alpha is a defined character.
      (alpha-char-p #\\alpha) =>  implementation-dependent

Affected By::
.............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current readtable.)

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.

See Also::
..........

*Note alphanumericp:: , *Note Documentation of Implementation-Defined
Scripts::


File: gcl.info,  Node: alphanumericp,  Next: digit-char,  Prev: alpha-char-p,  Up: Characters Dictionary

alphanumericp                                                    [Function]
---------------------------------------------------------------------------

`alphanumericp'  character =>  generalized-boolean

Arguments and Values::
......................

character--a character.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if character is an alphabetic_1 character or a  numeric
character; otherwise, returns false.

Examples::
..........

      (alphanumericp #\Z) =>  true
      (alphanumericp #\9) =>  true
      (alphanumericp #\Newline) =>  false
      (alphanumericp #\#) =>  false

Affected By::
.............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current readtable.)

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.

See Also::
..........

*Note alpha-char-p:: , *Note graphic-char-p:: , *Note digit-char-p::

Notes::
.......

Alphanumeric characters are graphic as defined by graphic-char-p.  The
alphanumeric characters are a subset of the graphic characters.  The
standard characters A through Z, a through z, and 0 through 9 are
alphanumeric characters.

      (alphanumericp x)
        == (or (alpha-char-p x) (not (null (digit-char-p x))))


File: gcl.info,  Node: digit-char,  Next: digit-char-p,  Prev: alphanumericp,  Up: Characters Dictionary

digit-char                                                       [Function]
---------------------------------------------------------------------------

`digit-char'  weight &optional radix =>  char

Arguments and Values::
......................

weight--a non-negative integer.

radix--a radix.  The default is 10.

char--a character or false.

Description::
.............

If weight is less than radix, digit-char returns a character which has
that weight when considered as a digit in the specified radix.  If the
resulting character is to be an alphabetic_1 character, it will be an
uppercase character.

If weight is greater than or equal to radix, digit-char returns false.

Examples::
..........

      (digit-char 0) =>  #\0
      (digit-char 10 11) =>  #\A
      (digit-char 10 10) =>  false
      (digit-char 7) =>  #\7
      (digit-char 12) =>  false
      (digit-char 12 16) =>  #\C  ;not #\c
      (digit-char 6 2) =>  false
      (digit-char 1 2) =>  #\1

See Also::
..........

*Note digit-char-p:: , *Note graphic-char-p:: , *Note Character Syntax::

Notes::
.......


File: gcl.info,  Node: digit-char-p,  Next: graphic-char-p,  Prev: digit-char,  Up: Characters Dictionary

digit-char-p                                                     [Function]
---------------------------------------------------------------------------

`digit-char-p'  char &optional radix =>  weight

Arguments and Values::
......................

char--a character.

radix--a radix.  The default is 10.

weight--either a non-negative integer less than radix, or false.

Description::
.............

Tests whether char is a digit in the specified radix (i.e., with a weight
less than radix).  If it is a digit in that radix, its weight is returned
as an integer; otherwise nil is returned.

Examples::
..........

      (digit-char-p #\5)    =>  5
      (digit-char-p #\5 2)  =>  false
      (digit-char-p #\A)    =>  false
      (digit-char-p #\a)    =>  false
      (digit-char-p #\A 11) =>  10
      (digit-char-p #\a 11) =>  10
      (mapcar #'(lambda (radix)
                  (map 'list #'(lambda (x) (digit-char-p x radix))
                       "059AaFGZ"))
              '(2 8 10 16 36))
      =>  ((0 NIL NIL NIL NIL NIL NIL NIL)
          (0 5 NIL NIL NIL NIL NIL NIL)
          (0 5 9 NIL NIL NIL NIL NIL)
          (0 5 9 10 10 15 NIL NIL)
          (0 5 9 10 10 15 16 35))

Affected By::
.............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current readtable.)

See Also::
..........

*Note alphanumericp::

Notes::
.......

Digits are graphic characters.


File: gcl.info,  Node: graphic-char-p,  Next: standard-char-p,  Prev: digit-char-p,  Up: Characters Dictionary

graphic-char-p                                                   [Function]
---------------------------------------------------------------------------

`graphic-char-p'  char =>  generalized-boolean

Arguments and Values::
......................

char--a character.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if character is a graphic character; otherwise, returns false.

Examples::
..........

      (graphic-char-p #\G) =>  true
      (graphic-char-p #\#) =>  true
      (graphic-char-p #\Space) =>  true
      (graphic-char-p #\Newline) =>  false

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.

See Also::
..........

*Note read; read-preserving-whitespace:: , *Note Character Syntax::, *Note
Documentation of Implementation-Defined Scripts::


File: gcl.info,  Node: standard-char-p,  Next: char-upcase,  Prev: graphic-char-p,  Up: Characters Dictionary

standard-char-p                                                  [Function]
---------------------------------------------------------------------------

`standard-char-p'  character =>  generalized-boolean

Arguments and Values::
......................

character--a character.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if character is of type standard-char; otherwise, returns
false.

Examples::
..........

      (standard-char-p #\Space) =>  true
      (standard-char-p #\~) =>  true
      ;; This next example presupposes an implementation
      ;; in which #\Bell is a defined character.
      (standard-char-p #\Bell) =>  false

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.


File: gcl.info,  Node: char-upcase,  Next: upper-case-p,  Prev: standard-char-p,  Up: Characters Dictionary

char-upcase, char-downcase                                       [Function]
---------------------------------------------------------------------------

`char-upcase'  character =>  corresponding-character

`char-downcase'  character =>  corresponding-character

Arguments and Values::
......................

character, corresponding-character--a character.

Description::
.............

If character is a lowercase character, char-upcase returns the
corresponding uppercase character.  Otherwise, char-upcase just returns
the given character.

If character is an uppercase character, char-downcase returns the
corresponding lowercase character.  Otherwise, char-downcase just returns
the given character.

The result only ever differs from character in its code attribute; all
implementation-defined attributes are preserved.

Examples::
..........

      (char-upcase #\a) =>  #\A
      (char-upcase #\A) =>  #\A
      (char-downcase #\a) =>  #\a
      (char-downcase #\A) =>  #\a
      (char-upcase #\9) =>  #\9
      (char-downcase #\9) =>  #\9
      (char-upcase #\@) =>  #\@
      (char-downcase #\@) =>  #\@
      ;; Note that this next example might run for a very long time in
      ;; some implementations if CHAR-CODE-LIMIT happens to be very large
      ;; for that implementation.
      (dotimes (code char-code-limit)
        (let ((char (code-char code)))
          (when char
            (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))
                          ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))
                          (t (and (char= (char-upcase (char-downcase char)) char)
                                  (char= (char-downcase (char-upcase char)) char))))
              (return char)))))
     =>  NIL

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.

See Also::
..........

*Note upper-case-p; lower-case-p; both-case-p:: , *Note alpha-char-p:: ,
*Note Characters With Case::, *Note Documentation of
Implementation-Defined Scripts::

Notes::
.......

If the corresponding-char is different than character, then both the
character and the corresponding-char have case.

Since char-equal ignores the case of the characters it compares, the
corresponding-character is always the same as character under char-equal.


File: gcl.info,  Node: upper-case-p,  Next: char-code,  Prev: char-upcase,  Up: Characters Dictionary

upper-case-p, lower-case-p, both-case-p                          [Function]
---------------------------------------------------------------------------

`upper-case-p'  character =>  generalized-boolean

`lower-case-p'  character =>  generalized-boolean

`both-case-p'  character =>  generalized-boolean

Arguments and Values::
......................

character--a character.

generalized-boolean--a generalized boolean.

Description::
.............

These functions test the case of a given character.

upper-case-p returns true if character is an uppercase character;
otherwise, returns false.

lower-case-p returns true if character is a lowercase character;
otherwise, returns false.

both-case-p returns true if character is a character with case; otherwise,
returns false.

Examples::
..........

      (upper-case-p #\A) =>  true
      (upper-case-p #\a) =>  false
      (both-case-p #\a) =>  true
      (both-case-p #\5) =>  false
      (lower-case-p #\5) =>  false
      (upper-case-p #\5) =>  false
      ;; This next example presupposes an implementation
      ;; in which #\Bell is an implementation-defined character.
      (lower-case-p #\Bell) =>  false

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.

See Also::
..........

*Note char-upcase; char-downcase:: , char-downcase, *Note Characters With
Case::, *Note Documentation of Implementation-Defined Scripts::


File: gcl.info,  Node: char-code,  Next: char-int,  Prev: upper-case-p,  Up: Characters Dictionary

char-code                                                        [Function]
---------------------------------------------------------------------------

`char-code'  character =>  code

Arguments and Values::
......................

character--a character.

code--a character code.

Description::
.............

char-code returns the code attribute of character.

Examples::
..........

     ;; An implementation using ASCII character encoding
     ;; might return these values:
     (char-code #\$) =>  36
     (char-code #\a) =>  97

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.

See Also::
..........

*Note char-code-limit::


File: gcl.info,  Node: char-int,  Next: code-char,  Prev: char-code,  Up: Characters Dictionary

char-int                                                         [Function]
---------------------------------------------------------------------------

`char-int'  character =>  integer

Arguments and Values::
......................

character--a character.

integer--a non-negative integer.

Description::
.............

Returns a non-negative integer encoding the character object.  The manner
in which the integer is computed is implementation-dependent.  In contrast
to sxhash, the result is not guaranteed to be independent of the
particular Lisp image.

If character has no implementation-defined attributes, the results of
char-int and char-code are the same.

      (char= c1 c2) == (= (char-int c1) (char-int c2))

for characters c1 and c2.

Examples::
..........

      (char-int #\A) =>  65       ; implementation A
      (char-int #\A) =>  577      ; implementation B
      (char-int #\A) =>  262145   ; implementation C

See Also::
..........

*Note char-code::


File: gcl.info,  Node: code-char,  Next: char-code-limit,  Prev: char-int,  Up: Characters Dictionary

code-char                                                        [Function]
---------------------------------------------------------------------------

`code-char'  code =>  char-p

Arguments and Values::
......................

code--a character code.

char-p--a character or nil.

Description::
.............

Returns a character with the code attribute given by code.  If no such
character exists and one cannot be created, nil is returned.

Examples::
..........

     (code-char 65.) =>  #\A  ;in an implementation using ASCII codes
     (code-char (char-code #\Space)) =>  #\Space  ;in any implementation

Affected By::
.............

The implementation's character encoding.

See Also::
..........

*Note char-code::

Notes::
.......


File: gcl.info,  Node: char-code-limit,  Next: char-name,  Prev: code-char,  Up: Characters Dictionary

char-code-limit                                         [Constant Variable]
---------------------------------------------------------------------------

Constant Value::
................

A non-negative integer, the exact magnitude of which is
implementation-dependent, but which is not less than 96 (the number of
standard characters).

Description::
.............

The upper exclusive bound on the value returned by the function char-code.

See Also::
..........

*Note char-code::

Notes::
.......

The value of char-code-limit might be larger than the actual number of
characters supported by the implementation.


File: gcl.info,  Node: char-name,  Next: name-char,  Prev: char-code-limit,  Up: Characters Dictionary

char-name                                                        [Function]
---------------------------------------------------------------------------

`char-name'  character =>  name

Arguments and Values::
......................

character--a character.

name--a string or nil.

Description::
.............

Returns a string that is the name of the character, or nil if the
character has no name.

All non-graphic characters are required to have names unless they have
some implementation-defined attribute which is not null.  Whether or not
other characters have names is implementation-dependent.

The standard characters <Newline> and <Space> have the respective names
"Newline" and "Space".  The semi-standard characters <Tab>, <Page>,
<Rubout>, <Linefeed>, <Return>, and <Backspace> (if they are supported by
the implementation) have the respective names "Tab",  "Page",  "Rubout",
"Linefeed",  "Return", and "Backspace" (in the indicated case, even though
name lookup by "#\" and by the function name-char is not case sensitive).

Examples::
..........

      (char-name #\ ) =>  "Space"
      (char-name #\Space) =>  "Space"
      (char-name #\Page) =>  "Page"
     
      (char-name #\a)
     =>  NIL
     OR=> "LOWERCASE-a"
     OR=> "Small-A"
     OR=> "LA01"
     
      (char-name #\A)
     =>  NIL
     OR=> "UPPERCASE-A"
     OR=> "Capital-A"
     OR=> "LA02"
     
      ;; Even though its CHAR-NAME can vary, #\A prints as #\A
      (prin1-to-string (read-from-string (format nil "#\\~A" (or (char-name #\A) "A"))))
     =>  "#\\A"

Exceptional Situations::
........................

Should signal an error of type type-error if character is not a character.

See Also::
..........

*Note name-char:: , *Note Printing Characters::

Notes::
.......

Non-graphic characters having names are written by the Lisp printer as
"#\" followed by the their name; see *Note Printing Characters::.


File: gcl.info,  Node: name-char,  Prev: char-name,  Up: Characters Dictionary

name-char                                                        [Function]
---------------------------------------------------------------------------

`name-char'  name =>  char-p

Arguments and Values::
......................

name--a string designator.

char-p--a character or nil.

Description::
.............

Returns the character object whose name is name (as determined by
string-equal--i.e., lookup is not case sensitive).  If such a character
does not exist, nil is returned.

Examples::
..........

     (name-char 'space) =>  #\Space
     (name-char "space") =>  #\Space
     (name-char "Space") =>  #\Space
     (let ((x (char-name #\a)))
       (or (not x) (eql (name-char x) #\a))) =>  true

Exceptional Situations::
........................

Should signal an error of type type-error if name is not a string
designator.

See Also::
..........

*Note char-name::


File: gcl.info,  Node: Conses,  Next: Arrays,  Prev: Characters,  Up: Top

Conses
******

* Menu:

* Cons Concepts::
* Conses Dictionary::


File: gcl.info,  Node: Cons Concepts,  Next: Conses Dictionary,  Prev: Conses,  Up: Conses

Cons Concepts
=============

A cons is a compound data object having two components called the car and
the cdr.

  car  cons    rplacd     cdr  rplaca          

  Figure 14-1: Some defined names relating to conses.


Depending on context, a group of connected conses can be viewed in a
variety of different ways.  A variety of operations is provided to support
each of these various views.

* Menu:

* Conses as Trees::
* Conses as Lists::


File: gcl.info,  Node: Conses as Trees,  Next: Conses as Lists,  Prev: Cons Concepts,  Up: Cons Concepts

Conses as Trees
---------------

A tree is a binary recursive data structure made up of conses and atoms:
the conses are themselves also trees (sometimes called "subtrees" or
"branches"), and the atoms are terminal nodes (sometimes called leaves ).
Typically, the leaves represent data while the branches establish some
relationship among that data.

  caaaar  caddar  cdar       nsubst         
  caaadr  cadddr  cddaar     nsubst-if      
  caaar   caddr   cddadr     nsubst-if-not  
  caadar  cadr    cddar      nthcdr         
  caaddr  cdaaar  cdddar     sublis         
  caadr   cdaadr  cddddr     subst          
  caar    cdaar   cdddr      subst-if       
  cadaar  cdadar  cddr       subst-if-not   
  cadadr  cdaddr  copy-tree  tree-equal     
  cadar   cdadr   nsublis                   

  Figure 14-2: Some defined names relating to trees.


* Menu:

* General Restrictions on Parameters that must be Trees::


File: gcl.info,  Node: General Restrictions on Parameters that must be Trees,  Prev: Conses as Trees,  Up: Conses as Trees

General Restrictions on Parameters that must be Trees
.....................................................

Except as explicitly stated otherwise, for any standardized function that
takes a parameter that is required to be a tree, the consequences are
undefined if that tree is circular.


File: gcl.info,  Node: Conses as Lists,  Prev: Conses as Trees,  Up: Cons Concepts

Conses as Lists
---------------

A list is a chain of conses in which the car of each cons is an element of
the list, and the cdr of each cons is either the next link in the chain or
a terminating atom.

A proper list is a list terminated by the empty list.  The empty list is a
proper list, but is not a cons.

An improper list is a list that is not a proper list; that is, it is a
circular list or a dotted list.

A dotted list is a list that has a terminating atom that is not the empty
list.  A non-nil atom by itself is not considered to be a list of any
kind--not even a dotted list.

A circular list is a chain of conses that has no termination because some
cons in the chain is the cdr of a later cons.

  append      last           nbutlast  rest       
  butlast     ldiff          nconc     revappend  
  copy-alist  list           ninth     second     
  copy-list   list*          nreconc   seventh    
  eighth      list-length    nth       sixth      
  endp        make-list      nthcdr    tailp      
  fifth       member         pop       tenth      
  first       member-if      push      third      
  fourth      member-if-not  pushnew              

  Figure 14-3: Some defined names relating to lists.


* Menu:

* Lists as Association Lists::
* Lists as Sets::
* General Restrictions on Parameters that must be Lists::


File: gcl.info,  Node: Lists as Association Lists,  Next: Lists as Sets,  Prev: Conses as Lists,  Up: Conses as Lists

Lists as Association Lists
..........................

An association list is a list of conses representing an association of
keys with values, where the car of each cons is the key and the cdr is the
value associated with that key.

  acons  assoc-if      pairlis  rassoc-if      
  assoc  assoc-if-not  rassoc   rassoc-if-not  

  Figure 14-4: Some defined names related to assocation lists.



File: gcl.info,  Node: Lists as Sets,  Next: General Restrictions on Parameters that must be Lists,  Prev: Lists as Association Lists,  Up: Conses as Lists

Lists as Sets
.............

Lists are sometimes viewed as sets by considering their elements unordered
and by assuming there is no duplication of elements.

  adjoin         nset-difference    set-difference    union  
  intersection   nset-exclusive-or  set-exclusive-or         
  nintersection  nunion             subsetp                  

       Figure 14-5: Some defined names related to sets.     



File: gcl.info,  Node: General Restrictions on Parameters that must be Lists,  Prev: Lists as Sets,  Up: Conses as Lists

General Restrictions on Parameters that must be Lists
.....................................................

Except as explicitly specified otherwise, any standardized function that
takes a parameter that is required to be a list should be prepared to
signal an error of type type-error if the value received is a dotted list.

Except as explicitly specified otherwise, for any standardized function
that takes a parameter that is required to be a list, the consequences are
undefined if that list is circular.


File: gcl.info,  Node: Conses Dictionary,  Prev: Cons Concepts,  Up: Conses

Conses Dictionary
=================

* Menu:

* list::
* null (System Class)::
* cons (System Class)::
* atom (Type)::
* cons::
* consp::
* atom::
* rplaca::
* car::
* copy-tree::
* sublis::
* subst::
* tree-equal::
* copy-list::
* list::
* list-length::
* listp::
* make-list::
* push::
* pop::
* first::
* nth::
* endp::
* null::
* nconc::
* append::
* revappend::
* butlast::
* last::
* ldiff::
* nthcdr::
* rest::
* member::
* mapc::
* acons::
* assoc::
* copy-alist::
* pairlis::
* rassoc::
* get-properties::
* getf::
* remf::
* intersection::
* adjoin::
* pushnew::
* set-difference::
* set-exclusive-or::
* subsetp::
* union::


File: gcl.info,  Node: list,  Next: null (System Class),  Prev: Conses Dictionary,  Up: Conses Dictionary

list                                                         [System Class]
---------------------------------------------------------------------------

Class Precedence List::
.......................

list, sequence, t

Description::
.............

A list is a chain of conses in which the car of each cons is an element of
the list, and the cdr of each cons is either the next link in the chain or
a terminating atom.

A proper list is a chain of conses terminated by the empty list , (),
which is  itself a proper list.  A dotted list is a list which has a
terminating atom that is not the empty list.  A circular list is a chain
of conses that has no termination because some cons in the chain is the
cdr of a later cons.

Dotted lists and circular lists are also lists, but usually the
unqualified term "list" within this specification means proper list.
Nevertheless, the type list unambiguously includes dotted lists and
circular lists.

For each element of a list there is a cons.  The empty list has no
elements and is not a cons.

The types cons and null form an exhaustive partition of the type list.

See Also::
..........

*Note Left-Parenthesis::, *Note Printing Lists and Conses::


File: gcl.info,  Node: null (System Class),  Next: cons (System Class),  Prev: list,  Up: Conses Dictionary

null                                                         [System Class]
---------------------------------------------------------------------------

Class Precedence List::
.......................

null, symbol, list, sequence, t

Description::
.............

The only object of type null is nil, which represents the empty list and
can also be notated ().

See Also::
..........

*Note Symbols as Tokens::, *Note Left-Parenthesis::, *Note Printing
Symbols::


File: gcl.info,  Node: cons (System Class),  Next: atom (Type),  Prev: null (System Class),  Up: Conses Dictionary

cons                                                         [System Class]
---------------------------------------------------------------------------

Class Precedence List::
.......................

cons, list, sequence, t

Description::
.............

A cons is a compound object having two components, called the car and cdr.
These form a dotted pair.  Each component can be any object.

Compound Type Specifier Kind::
..............................

Specializing.

Compound Type Specifier Syntax::
................................

(`cons'{[car-typespec [cdr-typespec]]})

Compound Type Specifier Arguments::
...................................

car-typespec--a type specifier, or the symbol *.  The default is the
symbol *.

cdr-typespec--a type specifier, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description::
.....................................

This denotes the set of conses whose car is constrained to be of type
car-typespec and whose cdr is constrained to be of type cdr-typespec.  (If
either car-typespec or cdr-typespec is *, it is as if the type t had been
denoted.)

See Also::
..........

*Note Left-Parenthesis::, *Note Printing Lists and Conses::


File: gcl.info,  Node: atom (Type),  Next: cons,  Prev: cons (System Class),  Up: Conses Dictionary

atom                                                                 [Type]
---------------------------------------------------------------------------

Supertypes::
............

atom, t

Description::
.............

It is equivalent to (not cons).


File: gcl.info,  Node: cons,  Next: consp,  Prev: atom (Type),  Up: Conses Dictionary

cons                                                             [Function]
---------------------------------------------------------------------------

`cons'  object-1 object-2 =>  cons

Arguments and Values::
......................

object-1--an object.

object-2--an object.

cons--a cons.

Description::
.............

Creates a fresh cons, the car of which is object-1 and the cdr of which is
object-2.

Examples::
..........

      (cons 1 2) =>  (1 . 2)
      (cons 1 nil) =>  (1)
      (cons nil 2) =>  (NIL . 2)
      (cons nil nil) =>  (NIL)
      (cons 1 (cons 2 (cons 3 (cons 4 nil)))) =>  (1 2 3 4)
      (cons 'a 'b) =>  (A . B)
      (cons 'a (cons 'b (cons 'c '()))) =>  (A B C)
      (cons 'a '(b c d)) =>  (A B C D)

See Also::
..........

*Note list::

Notes::
.......

If object-2 is a list, cons can be thought of as producing a new list
which is like it but has object-1 prepended.


File: gcl.info,  Node: consp,  Next: atom,  Prev: cons,  Up: Conses Dictionary

consp                                                            [Function]
---------------------------------------------------------------------------

`consp'  object =>  generalized-boolean

Arguments and Values::
......................

object--an object.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if object is of type cons; otherwise, returns false.

Examples::
..........

      (consp nil) =>  false
      (consp (cons 1 2)) =>  true

The empty list is not a cons, so

      (consp '()) == (consp 'nil) =>  false

See Also::
..........

*Note listp::

Notes::
.......

      (consp object) == (typep object 'cons) == (not (typep object 'atom)) == (typep object '(not atom))


File: gcl.info,  Node: atom,  Next: rplaca,  Prev: consp,  Up: Conses Dictionary

atom                                                             [Function]
---------------------------------------------------------------------------

`atom'  object =>  generalized-boolean

Arguments and Values::
......................

object--an object.

generalized-boolean--a generalized boolean.

Description::
.............

Returns true if object is of type atom; otherwise, returns false.

Examples::
..........

      (atom 'sss) =>  true
      (atom (cons 1 2)) =>  false
      (atom nil) =>  true
      (atom '()) =>  true
      (atom 3) =>  true

Notes::
.......

      (atom object) == (typep object 'atom) == (not (consp object))
      == (not (typep object 'cons)) == (typep object '(not cons))


File: gcl.info,  Node: rplaca,  Next: car,  Prev: atom,  Up: Conses Dictionary

rplaca, rplacd                                                   [Function]
---------------------------------------------------------------------------

`rplaca'  cons object =>  cons

`rplacd'  cons object =>  cons

Pronunciation::
...............

rplaca: pronounced ,r\=e 'plak e or pronounced ,re 'plak e

rplacd: pronounced ,r\=e 'plak de or pronounced ,re 'plak de or pronounced
,r\=e 'plak d\=e or pronounced ,re 'plak d\=e

Arguments and Values::
......................

cons--a cons.

object--an object.

Description::
.............

rplaca replaces the car of the cons with object.

rplacd replaces the cdr of the cons with object.

Examples::
..........

      (defparameter *some-list* (list* 'one 'two 'three 'four)) =>  *some-list*
      *some-list* =>  (ONE TWO THREE . FOUR)
      (rplaca *some-list* 'uno) =>  (UNO TWO THREE . FOUR)
      *some-list* =>  (UNO TWO THREE . FOUR)
      (rplacd (last *some-list*) (list 'IV)) =>  (THREE IV)
      *some-list* =>  (UNO TWO THREE IV)

Side Effects::
..............

The cons is modified.

Should signal an error of type type-error if cons is not a cons.

