{
    "name": "pprint-fill",
    "prev": "pprint-exit-if-list-exhausted",
    "next": "pprint-indent",
    "up": "Printer Dictionary",
    "header": {
        "type": "Function",
        "text": "pprint-fill, pprint-linear, pprint-tabular"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "pprint-fill",
                    "text": " stream object &optional colon-p at-sign-p =>  nil\n"
                },
                {
                    "name": "pprint-linear",
                    "text": " stream object &optional colon-p at-sign-p =>  nil\n\n"
                },
                {
                    "name": "pprint-tabular",
                    "text": " stream object &optional colon-p at-sign-p tabsize =>  nil\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "stream",
                    "desc": "an output stream designator."
                },
                {
                    "name": "object",
                    "desc": "an object."
                },
                {
                    "name": "colon-p",
                    "desc": "a generalized boolean.  The default is true."
                },
                {
                    "name": "at-sign-p",
                    "desc": "a generalized boolean.  The default is implementation-dependent."
                },
                {
                    "name": "tabsize",
                    "desc": "a non-negative integer.  The default is 16."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The functions pprint-fill, pprint-linear, and pprint-tabular specify\nparticular ways of pretty printing a list to stream.  Each function prints\nparentheses around the output if and only if colon-p is true.  Each\nfunction ignores its at-sign-p argument.  (Both arguments are included\neven though only one is needed so that these functions can be used via\n~/.../ and as set-pprint-dispatch functions, as well as directly.) Each\nfunction handles abbreviation and the detection of circularity and sharing\ncorrectly, and uses write to print object when it is a non-list.\nIf object is a list and if the value of *print-pretty* is false, each of\nthese functions prints object using a minimum of whitespace, as described\nin *Note Printing Lists and Conses::.  Otherwise (if object is a list and\nif the value of *print-pretty* is true):\n*\n     The function pprint-linear prints a list either all on one line, or\n     with each element on a separate line.\n*\n     The function pprint-fill prints a list with as many elements as\n     possible on each line.\n*\n     The function pprint-tabular is the same as pprint-fill except that it\n     prints the elements so that they line up in columns.  The tabsize\n     specifies the column spacing in ems, which is the total spacing from\n     the leading edge of one column to the leading edge of the next.\n"
        },
        {
            "type": "Examples",
            "text": "Evaluating the following with a line length of 25 produces the output\nshown.\n     (progn (princ \"Roads \")\n            (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))\n     Roads ELM     MAIN\n           MAPLE   CENTER\n"
        },
        {
            "type": "Side Effects",
            "text": "Performs output to the indicated stream.\n"
        },
        {
            "type": "Affected By",
            "text": "The cursor position on the indicated stream, if it can be determined.\n"
        },
        {
            "type": "Notes",
            "text": "The function pprint-tabular could be defined as follows:\n     (defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))\n       (declare (ignore at-sign-p))\n       (when (null tabsize) (setq tabsize 16))\n       (pprint-logical-block (s list :prefix (if colon-p \"(\" \"\")\n                                     :suffix (if colon-p \")\" \"\"))\n         (pprint-exit-if-list-exhausted)\n         (loop (write (pprint-pop) :stream s)\n               (pprint-exit-if-list-exhausted)\n               (write-char #\\Space s)\n               (pprint-tab :section-relative 0 tabsize s)\n               (pprint-newline :fill s))))\nNote that it would have been inconvenient to specify this function using\nformat, because of the need to pass its tabsize argument through to a ~:T\nformat directive nested within an iteration over a list.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: pprint-fill,  Next: pprint-indent,  Prev: pprint-exit-if-list-exhausted,  Up: Printer Dictionary\n\npprint-fill, pprint-linear, pprint-tabular                       [Function]\n---------------------------------------------------------------------------\n\n`pprint-fill'  stream object &optional colon-p at-sign-p =>  nil\n\n`pprint-linear'  stream object &optional colon-p at-sign-p =>  nil\n\n`pprint-tabular'  stream object &optional colon-p at-sign-p tabsize =>  nil\n\nArguments and Values::\n......................\n\nstream--an output stream designator.\n\nobject--an object.\n\ncolon-p--a generalized boolean.  The default is true.\n\nat-sign-p--a generalized boolean.  The default is implementation-dependent.\n\ntabsize--a non-negative integer.  The default is 16.\n\nDescription::\n.............\n\nThe functions pprint-fill, pprint-linear, and pprint-tabular specify\nparticular ways of pretty printing a list to stream.  Each function prints\nparentheses around the output if and only if colon-p is true.  Each\nfunction ignores its at-sign-p argument.  (Both arguments are included\neven though only one is needed so that these functions can be used via\n~/.../ and as set-pprint-dispatch functions, as well as directly.) Each\nfunction handles abbreviation and the detection of circularity and sharing\ncorrectly, and uses write to print object when it is a non-list.\n\nIf object is a list and if the value of *print-pretty* is false, each of\nthese functions prints object using a minimum of whitespace, as described\nin *Note Printing Lists and Conses::.  Otherwise (if object is a list and\nif the value of *print-pretty* is true):\n\n*\n     The function pprint-linear prints a list either all on one line, or\n     with each element on a separate line.\n\n*\n     The function pprint-fill prints a list with as many elements as\n     possible on each line.\n\n*\n     The function pprint-tabular is the same as pprint-fill except that it\n     prints the elements so that they line up in columns.  The tabsize\n     specifies the column spacing in ems, which is the total spacing from\n     the leading edge of one column to the leading edge of the next.\n\nExamples::\n..........\n\nEvaluating the following with a line length of 25 produces the output\nshown.\n\n     (progn (princ \"Roads \")\n            (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))\n     Roads ELM     MAIN\n           MAPLE   CENTER\n\nSide Effects::\n..............\n\nPerforms output to the indicated stream.\n\nAffected By::\n.............\n\nThe cursor position on the indicated stream, if it can be determined.\n\nNotes::\n.......\n\nThe function pprint-tabular could be defined as follows:\n\n     (defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))\n       (declare (ignore at-sign-p))\n       (when (null tabsize) (setq tabsize 16))\n       (pprint-logical-block (s list :prefix (if colon-p \"(\" \"\")\n                                     :suffix (if colon-p \")\" \"\"))\n         (pprint-exit-if-list-exhausted)\n         (loop (write (pprint-pop) :stream s)\n               (pprint-exit-if-list-exhausted)\n               (write-char #\\Space s)\n               (pprint-tab :section-relative 0 tabsize s)\n               (pprint-newline :fill s))))\n\nNote that it would have been inconvenient to specify this function using\nformat, because of the need to pass its tabsize argument through to a ~:T\nformat directive nested within an iteration over a list.\n\n"
}