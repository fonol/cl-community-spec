{
    "name": "Expanding Loop Forms",
    "prev": "Parsing Loop Clauses",
    "next": "Summary of Loop Clauses",
    "up": "Overview of the Loop Facility",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Expanding Loop Forms",
            "text": "A loop macro form expands into a form containing one or more binding forms\n(that establish bindings of loop variables) and a block and a tagbody\n(that express a looping control structure). The variables established in\nloop are bound as if by let or lambda.\nImplementations can interleave the setting of initial values with the\nbindings.  However, the assignment of the initial values is always\ncalculated in the order specified by the user.  A variable is thus\nsometimes bound to a meaningless value of the correct type, and then later\nin the prologue it is set to the true initial value by using setq.\nOne implication of this interleaving is that it is implementation-dependent\nwhether the lexical environment in which the initial value forms\n(variously called the form1, form2, form3, step-fun, vector, hash-table,\nand package) in any for-as-subclause, except for-as-equals-then, are\nevaluated includes only the loop variables preceding that form or includes\nmore or all of the loop variables; the form1 and form2 in a\nfor-as-equals-then form includes the lexical environment of all the loop\nvariables.\nAfter the form is expanded, it consists of three basic parts in the\ntagbody: the loop prologue, the loop body, and the loop epilogue.\nLoop prologue\n     The loop prologue contains forms that are executed before iteration\n     begins, such as any automatic variable initializations prescribed by\n     the variable clauses, along with any initially clauses in the order\n     they appear in the source.\nLoop body\n     The loop body contains those forms that are executed during iteration,\n     including application-specific calculations, termination tests, and\n     variable stepping_1.\nLoop epilogue\n     The loop epilogue contains forms that are executed after iteration\n     terminates, such as finally clauses, if any, along with any implicit\n     return value from an accumulation clause or an termination-test\n     clause.\nSome clauses from the source form contribute code only to the loop\nprologue; these clauses must come before other clauses that are in the\nmain body of the loop form.  Others contribute code only to the loop\nepilogue.  All other clauses contribute to the final translated form in\nthe same order given in the original source form of the loop.\nExpansion of the loop macro produces an implicit block named nil\nunless named is supplied.\nThus, return-from (and sometimes return) can be used to return values from\nloop or to exit loop.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Expanding Loop Forms,  Next: Summary of Loop Clauses,  Prev: Parsing Loop Clauses,  Up: Overview of the Loop Facility\n\nExpanding Loop Forms\n....................\n\nA loop macro form expands into a form containing one or more binding forms\n(that establish bindings of loop variables) and a block and a tagbody\n(that express a looping control structure). The variables established in\nloop are bound as if by let or lambda.\n\nImplementations can interleave the setting of initial values with the\nbindings.  However, the assignment of the initial values is always\ncalculated in the order specified by the user.  A variable is thus\nsometimes bound to a meaningless value of the correct type, and then later\nin the prologue it is set to the true initial value by using setq.\n\nOne implication of this interleaving is that it is implementation-dependent\nwhether the lexical environment in which the initial value forms\n(variously called the form1, form2, form3, step-fun, vector, hash-table,\nand package) in any for-as-subclause, except for-as-equals-then, are\nevaluated includes only the loop variables preceding that form or includes\nmore or all of the loop variables; the form1 and form2 in a\nfor-as-equals-then form includes the lexical environment of all the loop\nvariables.\n\nAfter the form is expanded, it consists of three basic parts in the\ntagbody: the loop prologue, the loop body, and the loop epilogue.\n\nLoop prologue\n     The loop prologue contains forms that are executed before iteration\n     begins, such as any automatic variable initializations prescribed by\n     the variable clauses, along with any initially clauses in the order\n     they appear in the source.\n\nLoop body\n     The loop body contains those forms that are executed during iteration,\n     including application-specific calculations, termination tests, and\n     variable stepping_1.\n\nLoop epilogue\n     The loop epilogue contains forms that are executed after iteration\n     terminates, such as finally clauses, if any, along with any implicit\n     return value from an accumulation clause or an termination-test\n     clause.\n\nSome clauses from the source form contribute code only to the loop\nprologue; these clauses must come before other clauses that are in the\nmain body of the loop form.  Others contribute code only to the loop\nepilogue.  All other clauses contribute to the final translated form in\nthe same order given in the original source form of the loop.\n\nExpansion of the loop macro produces an implicit block named nil\n\nunless named is supplied.\n\nThus, return-from (and sometimes return) can be used to return values from\nloop or to exit loop.\n\n"
}