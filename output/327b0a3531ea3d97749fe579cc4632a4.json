{
    "name": "signum",
    "prev": "mod",
    "next": "sqrt",
    "up": "Numbers Dictionary",
    "header": {
        "type": "Function",
        "text": "signum"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "signum",
                    "text": " number =>  signed-prototype\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "number",
                    "desc": "a number."
                },
                {
                    "name": "signed-prototype",
                    "desc": "a number."
                }
            ]
        },
        {
            "type": "Description",
            "text": "signum determines a numerical value that indicates whether number is\nnegative, zero, or positive.\nFor a rational, signum returns one of -1, 0, or 1 according to whether\nnumber is negative, zero, or positive.  For a float, the result is a float\nof the same format whose value is minus one, zero, or one.  For a complex\nnumber z, (signum z) is a complex number of the same phase but with unit\nmagnitude, unless z is a complex zero, in which case the result is z.\nFor rational arguments, signum is a rational function, but it may be\nirrational for complex arguments.\nIf number is a float, the result is a float.  If number is a rational, the\nresult is a rational.  If number is a complex float, the result is a\ncomplex float.  If number is a complex rational, the result is a complex,\nbut it is implementation-dependent whether that result is a complex\nrational or a complex float.\n"
        },
        {
            "type": "Examples",
            "text": "      (signum 0) =>  0\n      (signum 99) =>  1\n      (signum 4/5) =>  1\n      (signum -99/100) =>  -1\n      (signum 0.0) =>  0.0\n      (signum #c(0 33)) =>  #C(0.0 1.0)\n      (signum #c(7.5 10.0)) =>  #C(0.6 0.8)\n      (signum #c(0.0 -14.7)) =>  #C(0.0 -1.0)\n      (eql (signum -0.0) -0.0) =>  true\n"
        },
        {
            "type": "See Also",
            "text": "*Note Rule of Float Substitutability::\n"
        },
        {
            "type": "Notes",
            "text": "      (signum x) == (if (zerop x) x (/ x (abs x)))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: signum,  Next: sqrt,  Prev: mod,  Up: Numbers Dictionary\n\nsignum                                                           [Function]\n---------------------------------------------------------------------------\n\n`signum'  number =>  signed-prototype\n\nArguments and Values::\n......................\n\nnumber--a number.\n\nsigned-prototype--a number.\n\nDescription::\n.............\n\nsignum determines a numerical value that indicates whether number is\nnegative, zero, or positive.\n\nFor a rational, signum returns one of -1, 0, or 1 according to whether\nnumber is negative, zero, or positive.  For a float, the result is a float\nof the same format whose value is minus one, zero, or one.  For a complex\nnumber z, (signum z) is a complex number of the same phase but with unit\nmagnitude, unless z is a complex zero, in which case the result is z.\n\nFor rational arguments, signum is a rational function, but it may be\nirrational for complex arguments.\n\nIf number is a float, the result is a float.  If number is a rational, the\nresult is a rational.  If number is a complex float, the result is a\ncomplex float.  If number is a complex rational, the result is a complex,\nbut it is implementation-dependent whether that result is a complex\nrational or a complex float.\n\nExamples::\n..........\n\n      (signum 0) =>  0\n      (signum 99) =>  1\n      (signum 4/5) =>  1\n      (signum -99/100) =>  -1\n      (signum 0.0) =>  0.0\n      (signum #c(0 33)) =>  #C(0.0 1.0)\n      (signum #c(7.5 10.0)) =>  #C(0.6 0.8)\n      (signum #c(0.0 -14.7)) =>  #C(0.0 -1.0)\n      (eql (signum -0.0) -0.0) =>  true\n\nSee Also::\n..........\n\n*Note Rule of Float Substitutability::\n\nNotes::\n.......\n\n      (signum x) == (if (zerop x) x (/ x (abs x)))\n\n"
}