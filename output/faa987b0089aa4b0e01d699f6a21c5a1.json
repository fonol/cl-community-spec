{
    "name": "locally",
    "prev": "special",
    "next": "the",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "locally"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "locally",
                    "text": " {declaration}* {form}* =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "Declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values of the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Sequentially evaluates a body of forms in a lexical environment where the\ngiven declarations have effect.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun sample-function (y)  ;this y is regarded as special\n        (declare (special y))\n        (let ((y t))              ;this y is regarded as lexical\n          (list y\n                (locally (declare (special y))\n                  ;; this next y is regarded as special\n                  y))))\n     =>  SAMPLE-FUNCTION\n      (sample-function nil) =>  (T NIL)\n      (setq x '(1 2 3) y '(4 . 5)) =>  (4 . 5)\n     ;;; The following declarations are not notably useful in specific.\n     ;;; They just offer a sample of valid declaration syntax using LOCALLY.\n      (locally (declare (inline floor) (notinline car cdr))\n               (declare (optimize space))\n         (floor (car x) (cdr y))) =>  0, 1\n     ;;; This example shows a definition of a function that has a particular set\n     ;;; of OPTIMIZE settings made locally to that definition.\n      (locally (declare (optimize (safety 3) (space 3) (speed 0)))\n        (defun frob (w x y &optional (z (foo x y)))\n          (mumble x y z w)))\n     =>  FROB\n     ;;; This is like the previous example, except that the optimize settings\n     ;;; remain in effect for subsequent definitions in the same compilation unit.\n      (declaim (optimize (safety 3) (space 3) (speed 0)))\n      (defun frob (w x y &optional (z (foo x y)))\n        (mumble x y z w))\n     =>  FROB\n"
        },
        {
            "type": "See Also",
            "text": "declare\n"
        },
        {
            "type": "Notes",
            "text": "The special declaration may be used with locally to affect references to,\nrather than bindings of, variables.\nIf a locally form is a top level form, the body forms are also processed\nas top level forms.  See *Note File Compilation::.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: locally,  Next: the,  Prev: special,  Up: Evaluation and Compilation Dictionary\n\nlocally                                                  [Special Operator]\n---------------------------------------------------------------------------\n\n`locally'  {declaration}* {form}* =>  {result}*\n\nArguments and Values::\n......................\n\nDeclaration--a declare expression; not evaluated.\n\nforms--an implicit progn.\n\nresults--the values of the forms.\n\nDescription::\n.............\n\nSequentially evaluates a body of forms in a lexical environment where the\ngiven declarations have effect.\n\nExamples::\n..........\n\n      (defun sample-function (y)  ;this y is regarded as special\n        (declare (special y))\n        (let ((y t))              ;this y is regarded as lexical\n          (list y\n                (locally (declare (special y))\n                  ;; this next y is regarded as special\n                  y))))\n     =>  SAMPLE-FUNCTION\n      (sample-function nil) =>  (T NIL)\n      (setq x '(1 2 3) y '(4 . 5)) =>  (4 . 5)\n     \n     ;;; The following declarations are not notably useful in specific.\n     ;;; They just offer a sample of valid declaration syntax using LOCALLY.\n      (locally (declare (inline floor) (notinline car cdr))\n               (declare (optimize space))\n         (floor (car x) (cdr y))) =>  0, 1\n\n     ;;; This example shows a definition of a function that has a particular set\n     ;;; of OPTIMIZE settings made locally to that definition.\n      (locally (declare (optimize (safety 3) (space 3) (speed 0)))\n        (defun frob (w x y &optional (z (foo x y)))\n          (mumble x y z w)))\n     =>  FROB\n     \n     ;;; This is like the previous example, except that the optimize settings\n     ;;; remain in effect for subsequent definitions in the same compilation unit.\n      (declaim (optimize (safety 3) (space 3) (speed 0)))\n      (defun frob (w x y &optional (z (foo x y)))\n        (mumble x y z w))\n     =>  FROB\n\nSee Also::\n..........\n\ndeclare\n\nNotes::\n.......\n\nThe special declaration may be used with locally to affect references to,\nrather than bindings of, variables.\n\nIf a locally form is a top level form, the body forms are also processed\nas top level forms.  See *Note File Compilation::.\n\n"
}