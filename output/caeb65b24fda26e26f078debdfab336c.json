{
    "name": "Symbols as Tokens",
    "prev": "The Consing Dot",
    "next": "Valid Patterns for Tokens",
    "up": "Interpretation of Tokens",
    "header": {
        "type": null,
        "text": "Symbols as Tokens"
    },
    "sections": [
        {
            "type": "",
            "text": "Any token that is not a potential number, does not contain a package\nmarker, and does not consist entirely of dots will always be interpreted\nas a symbol.  Any token that is a potential number but does not fit the\nnumber syntax is a reserved token and has an implementation-dependent\ninterpretation.  In all other cases, the token is construed to be the name\nof a symbol.\nExamples of the printed representation of symbols are in Figure 2-15.  For\npresentational simplicity, these examples assume that the readtable case\nof the current readtable is :upcase.\n  FROBBOZ         The symbol whose name is FROBBOZ.                \n  frobboz         Another way to notate the same symbol.           \n  fRObBoz         Yet another way to notate it.                    \n  unwind-protect  A symbol with a hyphen in its name.              \n  +$             The symbol named +$.                            \n  1+              The symbol named 1+.                             \n  +1              This is the integer 1, not a symbol.             \n  pascal_style    This symbol has an underscore in its name.       \n  file.rel.43     This symbol has periods in its name.             \n  \\(              The symbol whose name is (.                      \n  \\+1             The symbol whose name is +1.                     \n  +\\1             Also the symbol whose name is +1.                \n  \\frobboz        The symbol whose name is fROBBOZ.                \n  3.14159265\\s0   The symbol whose name is 3.14159265s0.           \n  3.14159265\\S0   A different symbol, whose name is 3.14159265S0.  \n  3.14159265s0    A possible short float approximation to \\pi.     \n  Figure 2-15: Examples of the printed representation of symbols (Part 1 of 2)\n  APL\\\\360               The symbol whose name is APL\\360.       \n  apl\\\\360               Also the symbol whose name is APL\\360.  \n  \\(b^2\\)\\ -\\ 4*a*c    The name is (B^2) - 4*A*C.            \n                         Parentheses and two spaces in it.       \n  \\(\\b^2\\)\\ -\\4*\\a*\\c  The name is (b^2) - 4*a*c.            \n                         Letters explicitly lowercase.           \n  |\"|                    The same as writing \\\".                 \n  |(b^2) - 4*a*c|      The name is (b^2) - 4*a*c.            \n  |frobboz|              The name is frobboz, not FROBBOZ.       \n  |APL\\360|              The name is APL360.                     \n  |APL\\\\360|             The name is APL\\360.                    \n  |apl\\\\360|             The name is apl\\360.                    \n  |\\|\\||                 Same as \\|\\| --the name is ||.          \n  |(B^2) - 4*A*C|      The name is (B^2) - 4*A*C.            \n                         Parentheses and two spaces in it.       \n  |(b^2) - 4*a*c|      The name is (b^2) - 4*a*c.            \n  Figure 2-16: Examples of the printed representation of symbols (Part 2 of 2)\nIn the process of parsing a symbol, it is implementation-dependent which\nimplementation-defined attributes are removed from the characters forming\na token that represents a symbol.\nWhen parsing the syntax for a symbol, the Lisp reader looks up the name of\nthat symbol in the current package.  This lookup may involve looking in\nother packages whose external symbols are inherited by the current\npackage.  If the name is found, the corresponding symbol is returned.  If\nthe name is not found (that is, there is no symbol of that name accessible\nin the current package), a new symbol is created and is placed in the\ncurrent package as an internal symbol.  The current package becomes the\nowner (home package) of the symbol, and the symbol becomes interned in the\ncurrent package.  If the name is later read again while this same package\nis current, the same symbol will be found and returned.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Symbols as Tokens,  Next: Valid Patterns for Tokens,  Prev: The Consing Dot,  Up: Interpretation of Tokens\n\nSymbols as Tokens\n-----------------\n\nAny token that is not a potential number, does not contain a package\nmarker, and does not consist entirely of dots will always be interpreted\nas a symbol.  Any token that is a potential number but does not fit the\nnumber syntax is a reserved token and has an implementation-dependent\ninterpretation.  In all other cases, the token is construed to be the name\nof a symbol.\n\nExamples of the printed representation of symbols are in Figure 2-15.  For\npresentational simplicity, these examples assume that the readtable case\nof the current readtable is :upcase.\n\n  FROBBOZ         The symbol whose name is FROBBOZ.                \n  frobboz         Another way to notate the same symbol.           \n  fRObBoz         Yet another way to notate it.                    \n  unwind-protect  A symbol with a hyphen in its name.              \n  +$             The symbol named +$.                            \n  1+              The symbol named 1+.                             \n  +1              This is the integer 1, not a symbol.             \n  pascal_style    This symbol has an underscore in its name.       \n  file.rel.43     This symbol has periods in its name.             \n  \\(              The symbol whose name is (.                      \n  \\+1             The symbol whose name is +1.                     \n  +\\1             Also the symbol whose name is +1.                \n  \\frobboz        The symbol whose name is fROBBOZ.                \n  3.14159265\\s0   The symbol whose name is 3.14159265s0.           \n  3.14159265\\S0   A different symbol, whose name is 3.14159265S0.  \n  3.14159265s0    A possible short float approximation to \\pi.     \n\n  Figure 2-15: Examples of the printed representation of symbols (Part 1 of 2)\n\n\n  APL\\\\360               The symbol whose name is APL\\360.       \n  apl\\\\360               Also the symbol whose name is APL\\360.  \n  \\(b^2\\)\\ -\\ 4*a*c    The name is (B^2) - 4*A*C.            \n                         Parentheses and two spaces in it.       \n  \\(\\b^2\\)\\ -\\4*\\a*\\c  The name is (b^2) - 4*a*c.            \n                         Letters explicitly lowercase.           \n  |\"|                    The same as writing \\\".                 \n  |(b^2) - 4*a*c|      The name is (b^2) - 4*a*c.            \n  |frobboz|              The name is frobboz, not FROBBOZ.       \n  |APL\\360|              The name is APL360.                     \n  |APL\\\\360|             The name is APL\\360.                    \n  |apl\\\\360|             The name is apl\\360.                    \n  |\\|\\||                 Same as \\|\\| --the name is ||.          \n  |(B^2) - 4*A*C|      The name is (B^2) - 4*A*C.            \n                         Parentheses and two spaces in it.       \n  |(b^2) - 4*a*c|      The name is (b^2) - 4*a*c.            \n\n  Figure 2-16: Examples of the printed representation of symbols (Part 2 of 2)\n\n\nIn the process of parsing a symbol, it is implementation-dependent which\nimplementation-defined attributes are removed from the characters forming\na token that represents a symbol.\n\nWhen parsing the syntax for a symbol, the Lisp reader looks up the name of\nthat symbol in the current package.  This lookup may involve looking in\nother packages whose external symbols are inherited by the current\npackage.  If the name is found, the corresponding symbol is returned.  If\nthe name is not found (that is, there is no symbol of that name accessible\nin the current package), a new symbol is created and is placed in the\ncurrent package as an internal symbol.  The current package becomes the\nowner (home package) of the symbol, and the symbol becomes interned in the\ncurrent package.  If the name is later read again while this same package\nis current, the same symbol will be found and returned.\n\n"
}