{
    "name": "Destructuring",
    "prev": "Order of Execution",
    "next": "Restrictions on Side-Effects",
    "up": "Overview of the Loop Facility",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Destructuring",
            "text": "The d-type-spec argument is used for destructuring.  If the d-type-spec\nargument consists solely of the type fixnum, float, t, or nil, the of-type\nkeyword is optional.  The of-type construct is optional in these cases to\nprovide backwards compatibility; thus, the following two expressions are\nthe same:\n     ;;; This expression uses the old syntax for type specifiers.\n      (loop for i fixnum upfrom 3 ...)\n     ;;; This expression uses the new syntax for type specifiers.\n      (loop for i of-type fixnum upfrom 3 ...)\n     ;; Declare X and Y to be of type VECTOR and FIXNUM respectively.\n      (loop for (x y) of-type (vector fixnum)\n            in l do ...)\nA type specifier for a destructuring pattern is a tree of type specifiers\nwith the same shape as the tree of variable names, with the following\nexceptions:\n*\n     When aligning the trees, an atom in the tree of type specifiers that\n     matches a cons in the variable tree declares the same type for each\n     variable in the subtree rooted at the cons.\n*\n     A cons in the tree of type specifiers that matches an atom in the\n     tree of variable names is a compound type specifer.\nDestructuring allows binding of a set of variables to a corresponding set\nof values anywhere that a value can normally be bound to a single\nvariable.  During loop expansion, each variable in the variable list is\nmatched with the values in the values list.  If there are more variables\nin the variable list than there are values in the values list, the\nremaining variables are given a value of nil.  If there are more values\nthan variables listed, the extra values are discarded.\nTo assign values from a list to the variables a, b, and c, the for clause\ncould be used to bind the variable numlist to the car of the supplied form,\nand then another for clause could be used to bind the variables a, b, and\nc sequentially.\n     ;; Collect values by using FOR constructs.\n      (loop for numlist in '((1 2 4.0) (5 6 8.3) (8 9 10.4))\n            for a of-type integer = (first numlist)\n            and b of-type integer = (second numlist)\n            and c of-type float = (third numlist)\n            collect (list c b a))\n     =>  ((4.0 2 1) (8.3 6 5) (10.4 9 8))\nDestructuring makes this process easier by allowing the variables to be\nbound in each loop iteration.  Types can be declared by using a list of\ntype-spec arguments.  If all the types are the same, a shorthand\ndestructuring syntax can be used, as the second example illustrates.\n     ;; Destructuring simplifies the process.\n      (loop for (a b c) of-type (integer integer float) in\n            '((1 2 4.0) (5 6 8.3) (8 9 10.4))\n            collect (list c b a))\n     =>  ((4.0 2 1) (8.3 6 5) (10.4 9 8))\n     ;; If all the types are the same, this way is even simpler.\n      (loop for (a b c) of-type float in\n            '((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))\n            collect (list c b a))\n     =>  ((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))\nIf destructuring is used to declare or initialize a number of groups of\nvariables into types, the loop keyword and can be used to simplify the\nprocess further.\n     ;; Initialize and declare variables in parallel by using the AND construct.\\kern-7pt\n      (loop with (a b) of-type float = '(1.0 2.0)\n            and (c d) of-type integer = '(3 4)\n            and (e f)\n            return (list a b c d e f))\n     =>  (1.0 2.0 3 4 NIL NIL)\nIf nil is used in a destructuring list, no variable is provided for its\nplace.\n      (loop for (a nil b) = '(1 2 3)\n            do (return (list a b)))\n     =>  (1 3)\nNote that dotted lists can specify destructuring.\n      (loop for (x . y) = '(1 . 2)\n            do (return y))\n     =>  2\n      (loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in\n            '(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))\n            collect (list a b c d))\n     =>  ((1.2 2.4 3 4) (3.4 4.6 5 6))\nAn error of type program-error is signaled (at macro expansion time) if\nthe same variable is bound twice in any variable-binding clause of a\nsingle loop expression.  Such variables include local variables, iteration\ncontrol variables, and variables found by destructuring.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Destructuring,  Next: Restrictions on Side-Effects,  Prev: Order of Execution,  Up: Overview of the Loop Facility\n\nDestructuring\n.............\n\nThe d-type-spec argument is used for destructuring.  If the d-type-spec\nargument consists solely of the type fixnum, float, t, or nil, the of-type\nkeyword is optional.  The of-type construct is optional in these cases to\nprovide backwards compatibility; thus, the following two expressions are\nthe same:\n\n     ;;; This expression uses the old syntax for type specifiers.\n      (loop for i fixnum upfrom 3 ...)\n     \n     ;;; This expression uses the new syntax for type specifiers.\n      (loop for i of-type fixnum upfrom 3 ...)\n     \n     ;; Declare X and Y to be of type VECTOR and FIXNUM respectively.\n      (loop for (x y) of-type (vector fixnum)\n            in l do ...)\n\nA type specifier for a destructuring pattern is a tree of type specifiers\nwith the same shape as the tree of variable names, with the following\nexceptions:\n\n*\n     When aligning the trees, an atom in the tree of type specifiers that\n     matches a cons in the variable tree declares the same type for each\n     variable in the subtree rooted at the cons.\n\n*\n     A cons in the tree of type specifiers that matches an atom in the\n     tree of variable names is a compound type specifer.\n\nDestructuring allows binding of a set of variables to a corresponding set\nof values anywhere that a value can normally be bound to a single\nvariable.  During loop expansion, each variable in the variable list is\nmatched with the values in the values list.  If there are more variables\nin the variable list than there are values in the values list, the\nremaining variables are given a value of nil.  If there are more values\nthan variables listed, the extra values are discarded.\n\nTo assign values from a list to the variables a, b, and c, the for clause\ncould be used to bind the variable numlist to the car of the supplied form,\nand then another for clause could be used to bind the variables a, b, and\nc sequentially.\n\n     ;; Collect values by using FOR constructs.\n      (loop for numlist in '((1 2 4.0) (5 6 8.3) (8 9 10.4))\n            for a of-type integer = (first numlist)\n            and b of-type integer = (second numlist)\n            and c of-type float = (third numlist)\n            collect (list c b a))\n     =>  ((4.0 2 1) (8.3 6 5) (10.4 9 8))\n\nDestructuring makes this process easier by allowing the variables to be\nbound in each loop iteration.  Types can be declared by using a list of\ntype-spec arguments.  If all the types are the same, a shorthand\ndestructuring syntax can be used, as the second example illustrates.\n\n     ;; Destructuring simplifies the process.\n      (loop for (a b c) of-type (integer integer float) in\n            '((1 2 4.0) (5 6 8.3) (8 9 10.4))\n            collect (list c b a))\n     =>  ((4.0 2 1) (8.3 6 5) (10.4 9 8))\n     \n     ;; If all the types are the same, this way is even simpler.\n      (loop for (a b c) of-type float in\n            '((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))\n            collect (list c b a))\n     =>  ((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))\n\nIf destructuring is used to declare or initialize a number of groups of\nvariables into types, the loop keyword and can be used to simplify the\nprocess further.\n\n     ;; Initialize and declare variables in parallel by using the AND construct.\\kern-7pt\n      (loop with (a b) of-type float = '(1.0 2.0)\n            and (c d) of-type integer = '(3 4)\n            and (e f)\n            return (list a b c d e f))\n     =>  (1.0 2.0 3 4 NIL NIL)\n\nIf nil is used in a destructuring list, no variable is provided for its\nplace.\n\n      (loop for (a nil b) = '(1 2 3)\n            do (return (list a b)))\n     =>  (1 3)\n\nNote that dotted lists can specify destructuring.\n\n      (loop for (x . y) = '(1 . 2)\n            do (return y))\n     =>  2\n      (loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in\n            '(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))\n            collect (list a b c d))\n     =>  ((1.2 2.4 3 4) (3.4 4.6 5 6))\n\nAn error of type program-error is signaled (at macro expansion time) if\nthe same variable is bound twice in any variable-binding clause of a\nsingle loop expression.  Such variables include local variables, iteration\ncontrol variables, and variables found by destructuring.\n\n"
}