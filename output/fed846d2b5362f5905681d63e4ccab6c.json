{
    "name": "Conses as Forms",
    "prev": "Symbols Naming Both Lexical and Dynamic Variables",
    "next": "Special Forms",
    "up": "The Evaluation Model",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Conses as Forms",
            "text": "A cons that is used as a form is called a compound form.\nIf the car of that compound form is a symbol, that symbol is the name of\nan operator, and the form is either a special form, a macro form, or a\nfunction form, depending on the function binding of the operator in the\ncurrent lexical environment.  If the operator is neither a special operator\nnor a macro name, it is assumed to be a function name (even if there is no\ndefinition for such a function).\nIf the car of the compound form is not a symbol, then that car must be a\nlambda expression, in which case the compound form is a lambda form.\nHow a compound form is processed depends on whether it is classified as a\nspecial form, a macro form, a function form, or a lambda form.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Conses as Forms,  Next: Special Forms,  Prev: Symbols Naming Both Lexical and Dynamic Variables,  Up: The Evaluation Model\n\nConses as Forms\n...............\n\nA cons that is used as a form is called a compound form.\n\nIf the car of that compound form is a symbol, that symbol is the name of\nan operator, and the form is either a special form, a macro form, or a\nfunction form, depending on the function binding of the operator in the\ncurrent lexical environment.  If the operator is neither a special operator\nnor a macro name, it is assumed to be a function name (even if there is no\ndefinition for such a function).\n\nIf the car of the compound form is not a symbol, then that car must be a\nlambda expression, in which case the compound form is a lambda form.\n\nHow a compound form is processed depends on whether it is classified as a\nspecial form, a macro form, a function form, or a lambda form.\n\n"
}