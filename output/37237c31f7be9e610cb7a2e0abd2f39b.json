{
    "name": "type-error-datum",
    "prev": "type-error",
    "next": "simple-type-error",
    "up": "Types and Classes Dictionary",
    "header": {
        "type": "Function",
        "text": "type-error-datum, type-error-expected-type"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "type-error-datum",
                    "text": " condition =>  datum\n"
                },
                {
                    "name": "type-error-expected-type",
                    "text": " condition =>  expected-type\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "condition",
                    "desc": "a condition of type type-error."
                },
                {
                    "name": "datum",
                    "desc": "an object."
                },
                {
                    "name": "expected-type",
                    "desc": "a type specifier."
                }
            ]
        },
        {
            "type": "Description",
            "text": "type-error-datum returns the offending datum in the situation represented\nby the condition.\ntype-error-expected-type returns the expected type of the offending datum\nin the situation represented by the condition.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun fix-digits (condition)\n        (check-type condition type-error)\n        (let* ((digits '(zero one two three four\n                        five six seven eight nine))\n              (val (position (type-error-datum condition) digits)))\n          (if (and val (subtypep 'fixnum (type-error-expected-type condition)))\n              (store-value 7))))\n      (defun foo (x)\n        (handler-bind ((type-error #'fix-digits))\n          (check-type x number)\n          (+ x 3)))\n      (foo 'seven)\n     =>  10\n"
        },
        {
            "type": "See Also",
            "text": "type-error, *Note Conditions::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: type-error-datum,  Next: simple-type-error,  Prev: type-error,  Up: Types and Classes Dictionary\n\ntype-error-datum, type-error-expected-type                       [Function]\n---------------------------------------------------------------------------\n\n`type-error-datum'  condition =>  datum\n\n`type-error-expected-type'  condition =>  expected-type\n\nArguments and Values::\n......................\n\ncondition--a condition of type type-error.\n\ndatum--an object.\n\nexpected-type--a type specifier.\n\nDescription::\n.............\n\ntype-error-datum returns the offending datum in the situation represented\nby the condition.\n\ntype-error-expected-type returns the expected type of the offending datum\nin the situation represented by the condition.\n\nExamples::\n..........\n\n      (defun fix-digits (condition)\n        (check-type condition type-error)\n        (let* ((digits '(zero one two three four\n                        five six seven eight nine))\n              (val (position (type-error-datum condition) digits)))\n          (if (and val (subtypep 'fixnum (type-error-expected-type condition)))\n              (store-value 7))))\n     \n      (defun foo (x)\n        (handler-bind ((type-error #'fix-digits))\n          (check-type x number)\n          (+ x 3)))\n     \n      (foo 'seven)\n     =>  10\n\nSee Also::\n..........\n\ntype-error, *Note Conditions::\n\n"
}