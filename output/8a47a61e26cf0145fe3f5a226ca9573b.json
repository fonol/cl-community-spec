{
    "name": "prog",
    "prev": "nth-value",
    "next": "prog1",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "prog, prog*"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "prog",
                    "text": " ({var | (var [init-form])}*) {declaration}* {tag | statement}*=>  {result}*\n\n"
                },
                {
                    "name": "prog*",
                    "text": " ({var | (var [init-form])}*) {declaration}* {tag | statement}*\n=>  {result}*\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "var",
                    "desc": "variable name."
                },
                {
                    "name": "init-form",
                    "desc": "a form."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "tag",
                    "desc": "a go tag; not evaluated."
                },
                {
                    "name": "statement",
                    "desc": "a compound form; evaluated as described below."
                },
                {
                    "name": "results",
                    "desc": "nil if a normal return occurs, or else, if an explicit return"
                }
            ]
        },
        {
            "type": "Description",
            "text": "Three distinct operations are performed by prog and prog*: they bind local\nvariables, they permit use of the return statement, and they permit use of\nthe go statement.  A typical prog looks like this:\n      (prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))\n            {declaration}*\n            statement1\n       tag1\n            statement2\n            statement3\n            statement4\n       tag2\n            statement5\n            ...\n            )\nFor prog, init-forms are evaluated first, in the order in which they are\nsupplied. The vars are then bound to the corresponding values in parallel.\nIf no init-form is supplied for a given var, that var is  bound to nil.\nThe body of prog is executed as if it were a tagbody form; the go\nstatement can be used to transfer control to a tag.  Tags label statements.\nprog implicitly establishes a block named nil around the entire prog form,\nso that return can be used at any time to exit from the prog form.\nThe difference between prog* and prog is that in prog* the binding and\ninitialization of the vars is done sequentially, so that the init-form for\neach one can use the values of previous ones.\n"
        },
        {
            "type": "Examples",
            "text": "     (prog* ((y z) (x (car y)))\n            (return x))\nreturns the car of the value of z.\n      (setq a 1) =>  1\n      (prog ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  /=\n      (prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  =\n      (prog () 'no-return-value) =>  NIL\n      (defun king-of-confusion (w)\n        \"Take a cons of two lists and make a list of conses.\n         Think of this function as being like a zipper.\"\n        (prog (x y z)          ;Initialize x, y, z to NIL\n             (setq y (car w) z (cdr w))\n         loop\n             (cond ((null y) (return x))\n                   ((null z) (go err)))\n         rejoin\n             (setq x (cons (cons (car y) (car z)) x))\n             (setq y (cdr y) z (cdr z))\n             (go loop)\n         err\n             (cerror \"Will self-pair extraneous items\"\n                     \"Mismatch - gleep!  ~S\" y)\n             (setq z y)\n             (go rejoin))) =>  KING-OF-CONFUSION\nThis can be accomplished more perspicuously as follows:\n      (defun prince-of-clarity (w)\n        \"Take a cons of two lists and make a list of conses.\n         Think of this function as being like a zipper.\"\n        (do ((y (car w) (cdr y))\n             (z (cdr w) (cdr z))\n             (x '() (cons (cons (car y) (car z)) x)))\n            ((null y) x)\n          (when (null z)\n            (cerror \"Will self-pair extraneous items\"\n                   \"Mismatch - gleep!  ~S\" y)\n            (setq z y)))) =>  PRINCE-OF-CLARITY\n"
        },
        {
            "type": "See Also",
            "text": "*Note block:: , *Note let; let*:: , *Note tagbody:: , *Note go:: , *Note\nreturn:: , *Note Evaluation::\n"
        },
        {
            "type": "Notes",
            "text": "prog can be explained in terms of block, let, and tagbody as follows:\n      (prog variable-list declaration . body)\n         == (block nil (let variable-list declaration (tagbody . body)))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: prog,  Next: prog1,  Prev: nth-value,  Up: Data and Control Flow Dictionary\n\nprog, prog*                                                         [Macro]\n---------------------------------------------------------------------------\n\n`prog'  ({var | (var [init-form])}*) {declaration}* {tag | statement}*\n=>  {result}*\n\n`prog*'  ({var | (var [init-form])}*) {declaration}* {tag | statement}*\n=>  {result}*\n\nArguments and Values::\n......................\n\nvar--variable name.\n\ninit-form--a form.\n\ndeclaration--a declare expression; not evaluated.\n\ntag--a go tag; not evaluated.\n\nstatement--a compound form; evaluated as described below.\n\nresults--nil if a normal return occurs, or else, if an explicit return\noccurs, the values that were transferred.\n\nDescription::\n.............\n\nThree distinct operations are performed by prog and prog*: they bind local\nvariables, they permit use of the return statement, and they permit use of\nthe go statement.  A typical prog looks like this:\n\n      (prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))\n            {declaration}*\n            statement1\n       tag1\n            statement2\n            statement3\n            statement4\n       tag2\n            statement5\n            ...\n            )\n\nFor prog, init-forms are evaluated first, in the order in which they are\nsupplied. The vars are then bound to the corresponding values in parallel.\nIf no init-form is supplied for a given var, that var is  bound to nil.\n\nThe body of prog is executed as if it were a tagbody form; the go\nstatement can be used to transfer control to a tag.  Tags label statements.\n\nprog implicitly establishes a block named nil around the entire prog form,\nso that return can be used at any time to exit from the prog form.\n\nThe difference between prog* and prog is that in prog* the binding and\ninitialization of the vars is done sequentially, so that the init-form for\neach one can use the values of previous ones.\n\nExamples::\n..........\n\n     (prog* ((y z) (x (car y)))\n            (return x))\n\nreturns the car of the value of z.\n\n      (setq a 1) =>  1\n      (prog ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  /=\n      (prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  =\n      (prog () 'no-return-value) =>  NIL\n\n      (defun king-of-confusion (w)\n        \"Take a cons of two lists and make a list of conses.\n         Think of this function as being like a zipper.\"\n        (prog (x y z)          ;Initialize x, y, z to NIL\n             (setq y (car w) z (cdr w))\n         loop\n             (cond ((null y) (return x))\n                   ((null z) (go err)))\n         rejoin\n             (setq x (cons (cons (car y) (car z)) x))\n             (setq y (cdr y) z (cdr z))\n             (go loop)\n         err\n             (cerror \"Will self-pair extraneous items\"\n                     \"Mismatch - gleep!  ~S\" y)\n             (setq z y)\n             (go rejoin))) =>  KING-OF-CONFUSION\n\nThis can be accomplished more perspicuously as follows:\n\n      (defun prince-of-clarity (w)\n        \"Take a cons of two lists and make a list of conses.\n         Think of this function as being like a zipper.\"\n        (do ((y (car w) (cdr y))\n             (z (cdr w) (cdr z))\n             (x '() (cons (cons (car y) (car z)) x)))\n            ((null y) x)\n          (when (null z)\n            (cerror \"Will self-pair extraneous items\"\n                   \"Mismatch - gleep!  ~S\" y)\n            (setq z y)))) =>  PRINCE-OF-CLARITY\n\nSee Also::\n..........\n\n*Note block:: , *Note let; let*:: , *Note tagbody:: , *Note go:: , *Note\nreturn:: , *Note Evaluation::\n\nNotes::\n.......\n\nprog can be explained in terms of block, let, and tagbody as follows:\n\n      (prog variable-list declaration . body)\n         == (block nil (let variable-list declaration (tagbody . body)))\n\n"
}