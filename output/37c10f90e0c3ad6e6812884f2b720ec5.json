{
    "name": "Condition Designators",
    "prev": "Creating Conditions",
    "next": null,
    "up": "Creating Conditions",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Condition Designators",
            "text": "A number of the functions in the condition system take arguments which are\nidentified as condition designators .  By convention, those arguments are\nnotated as\ndatum &rest arguments\nTaken together, the datum and the arguments are \"designators for a\ncondition of default type default-type.\" How the denoted condition is\ncomputed depends on the type of the datum:\n* If the datum is a symbol\n     naming a condition type ...  The denoted condition is the result of\n           (apply #'make-condition datum arguments)\n* If the datum is a format control ...\n     The denoted condition is the result of\n           (make-condition defaulted-type\n                           :format-control datum\n                           :format-arguments arguments)\n     where the defaulted-type is a subtype of default-type.\n* If the datum is a condition ...\n     The denoted condition is the datum itself.  In this case, unless\n     otherwise specified by the description of the operator in question,\n     the arguments must be null; that is, the consequences are undefined\n     if any arguments were supplied.\nNote that the default-type gets used only in the case where the datum\nstring is supplied.  In the other situations, the resulting condition is\nnot necessarily of type default-type.\nHere are some illustrations of how different condition designators can\ndenote equivalent condition objects:\n     (let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))\n       (error c))\n     == (error 'arithmetic-error :operator '/ :operands '(7 0))\n     (error \"Bad luck.\")\n     == (error 'simple-error :format-control \"Bad luck.\" :format-arguments '())\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Condition Designators,  Prev: Creating Conditions,  Up: Creating Conditions\n\nCondition Designators\n.....................\n\nA number of the functions in the condition system take arguments which are\nidentified as condition designators .  By convention, those arguments are\nnotated as\n\ndatum &rest arguments\n\nTaken together, the datum and the arguments are \"designators for a\ncondition of default type default-type.\" How the denoted condition is\ncomputed depends on the type of the datum:\n\n* If the datum is a symbol\n     naming a condition type ...  The denoted condition is the result of\n\n           (apply #'make-condition datum arguments)\n\n* If the datum is a format control ...\n     The denoted condition is the result of\n\n           (make-condition defaulted-type\n                           :format-control datum\n                           :format-arguments arguments)\n\n     where the defaulted-type is a subtype of default-type.\n\n* If the datum is a condition ...\n     The denoted condition is the datum itself.  In this case, unless\n     otherwise specified by the description of the operator in question,\n     the arguments must be null; that is, the consequences are undefined\n     if any arguments were supplied.\n\nNote that the default-type gets used only in the case where the datum\nstring is supplied.  In the other situations, the resulting condition is\nnot necessarily of type default-type.\n\nHere are some illustrations of how different condition designators can\ndenote equivalent condition objects:\n\n     (let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))\n       (error c))\n     == (error 'arithmetic-error :operator '/ :operands '(7 0))\n     \n     (error \"Bad luck.\")\n     == (error 'simple-error :format-control \"Bad luck.\" :format-arguments '())\n\n"
}