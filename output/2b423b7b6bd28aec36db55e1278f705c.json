{
    "name": "Pathnames as Filenames",
    "prev": "Namestrings as Filenames",
    "next": "Parsing Namestrings Into Pathnames",
    "up": "Overview of Filenames",
    "header": {
        "type": null,
        "text": "Pathnames as Filenames"
    },
    "sections": [
        {
            "type": "",
            "text": "Pathnames are structured objects that can represent, in an\nimplementation-independent way, the filenames that are used natively by an\nunderlying file system.\nIn addition, pathnames can also represent certain partially composed\nfilenames for which an underlying file system might not have a specific\nnamestring representation.\nA pathname need not correspond to any file that actually exists, and more\nthan one pathname can refer to the same file.  For example, the pathname\nwith a version of :newest might refer to the same file as a pathname with\nthe same components except a certain number as the version.  Indeed, a\npathname with version :newest might refer to different files as time\npasses, because the meaning of such a pathname depends on the state of the\nfile system.\nSome file systems naturally use a structural model for their filenames,\nwhile others do not.  Within the Common Lisp pathname model, all filenames\nare seen as having a particular structure, even if that structure is not\nreflected in the underlying file system.  The nature of the mapping\nbetween structure imposed by pathnames and the structure, if any, that is\nused by the underlying file system is implementation-defined.\nEvery pathname has six components: a host, a device, a directory, a name,\na type, and a version.  By naming files with pathnames, Common Lisp\nprograms can work in essentially the same way even in file systems that\nseem superficially quite different.  For a detailed description of these\ncomponents, see *Note Pathname Components::.\nThe mapping of the pathname components into the concepts peculiar to each\nfile system is implementation-defined.  There exist conceivable pathnames\nfor which there is no mapping to a syntactically valid filename in a\nparticular implementation.  An implementation may use various strategies\nin an attempt to find a mapping; for example, an implementation may\nquietly truncate filenames that exceed length limitations imposed by the\nunderlying file system, or ignore certain pathname components for which\nthe file system provides no support.  If such a mapping cannot be found,\nan error of type file-error is signaled.\nThe time at which this mapping and associated error signaling occurs is\nimplementation-dependent.  Specifically, it may occur at the time the\npathname is constructed, when coercing a pathname to a namestring, or when\nan attempt is made to open or otherwise access the file designated by the\npathname.\nFigure 19-1 lists some defined names that are applicable to pathnames.\n  *default-pathname-defaults*  namestring          pathname-name          \n  directory-namestring         open                pathname-type          \n  enough-namestring            parse-namestring    pathname-version       \n  file-namestring              pathname            pathnamep              \n  file-string-length           pathname-device     translate-pathname     \n  host-namestring              pathname-directory  truename               \n  make-pathname                pathname-host       user-homedir-pathname  \n  merge-pathnames              pathname-match-p    wild-pathname-p        \n                     Figure 19-1: Pathname Operations                    \n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Pathnames as Filenames,  Next: Parsing Namestrings Into Pathnames,  Prev: Namestrings as Filenames,  Up: Overview of Filenames\n\nPathnames as Filenames\n----------------------\n\nPathnames are structured objects that can represent, in an\nimplementation-independent way, the filenames that are used natively by an\nunderlying file system.\n\nIn addition, pathnames can also represent certain partially composed\nfilenames for which an underlying file system might not have a specific\nnamestring representation.\n\nA pathname need not correspond to any file that actually exists, and more\nthan one pathname can refer to the same file.  For example, the pathname\nwith a version of :newest might refer to the same file as a pathname with\nthe same components except a certain number as the version.  Indeed, a\npathname with version :newest might refer to different files as time\npasses, because the meaning of such a pathname depends on the state of the\nfile system.\n\nSome file systems naturally use a structural model for their filenames,\nwhile others do not.  Within the Common Lisp pathname model, all filenames\nare seen as having a particular structure, even if that structure is not\nreflected in the underlying file system.  The nature of the mapping\nbetween structure imposed by pathnames and the structure, if any, that is\nused by the underlying file system is implementation-defined.\n\nEvery pathname has six components: a host, a device, a directory, a name,\na type, and a version.  By naming files with pathnames, Common Lisp\nprograms can work in essentially the same way even in file systems that\nseem superficially quite different.  For a detailed description of these\ncomponents, see *Note Pathname Components::.\n\nThe mapping of the pathname components into the concepts peculiar to each\nfile system is implementation-defined.  There exist conceivable pathnames\nfor which there is no mapping to a syntactically valid filename in a\nparticular implementation.  An implementation may use various strategies\nin an attempt to find a mapping; for example, an implementation may\nquietly truncate filenames that exceed length limitations imposed by the\nunderlying file system, or ignore certain pathname components for which\nthe file system provides no support.  If such a mapping cannot be found,\nan error of type file-error is signaled.\n\nThe time at which this mapping and associated error signaling occurs is\nimplementation-dependent.  Specifically, it may occur at the time the\npathname is constructed, when coercing a pathname to a namestring, or when\nan attempt is made to open or otherwise access the file designated by the\npathname.\n\nFigure 19-1 lists some defined names that are applicable to pathnames.\n\n  *default-pathname-defaults*  namestring          pathname-name          \n  directory-namestring         open                pathname-type          \n  enough-namestring            parse-namestring    pathname-version       \n  file-namestring              pathname            pathnamep              \n  file-string-length           pathname-device     translate-pathname     \n  host-namestring              pathname-directory  truename               \n  make-pathname                pathname-host       user-homedir-pathname  \n  merge-pathnames              pathname-match-p    wild-pathname-p        \n\n                     Figure 19-1: Pathname Operations                    \n\n\n"
}