{
    "name": "export",
    "prev": "package",
    "next": "find-symbol",
    "up": "Packages Dictionary",
    "header": {
        "type": "Function",
        "text": "export"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "export",
                    "text": " symbols &optional package =>  t\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "symbols",
                    "desc": "a designator for a list of symbols."
                }
            ]
        },
        {
            "type": "Description",
            "text": "export makes one or more symbols that are accessible in package (whether\ndirectly or by inheritance) be external symbols of that package.\nIf any of the symbols is already accessible as an external symbol of\npackage, export has no effect on that symbol.  If the symbol is present in\npackage as an internal symbol, it is simply changed to external status.\nIf it is accessible as an internal symbol via use-package, it is first\nimported into package, then exported.  (The symbol is then present in the\npackage whether or not package continues to use the package through which\nthe symbol was originally inherited.)\nexport makes each symbol accessible to all the packages that use package.\nAll of these packages are checked for name conflicts: (export s p) does\n(find-symbol (symbol-name s) q) for each package q in\n(package-used-by-list p).  Note that in the usual case of an export during\nthe initial definition of a package, the result of package-used-by-list is\nnil and the name-conflict checking takes negligible time.  When multiple\nchanges are to be made, for example when export is given a list of\nsymbols, it is permissible for the implementation to process each change\nseparately, so that aborting from a name conflict caused by any but the\nfirst symbol in the list does not unexport the first symbol in the list.\nHowever, aborting from a name-conflict error caused by export of one of\nsymbols does not leave that symbol accessible to some packages and\ninaccessible to others; with respect to each of symbols processed, export\nbehaves as if it were as an atomic operation.\nA name conflict in export between one of symbols being exported and a\nsymbol already present in a package that would inherit the newly-exported\nsymbol may be resolved in favor of the exported symbol by uninterning the\nother one, or in favor of the already-present symbol by making it a\nshadowing symbol.\n"
        },
        {
            "type": "Examples",
            "text": "      (make-package 'temp :use nil) =>  #<PACKAGE \"TEMP\">\n      (use-package 'temp) =>  T\n      (intern \"TEMP-SYM\" 'temp) =>  TEMP::TEMP-SYM, NIL\n      (find-symbol \"TEMP-SYM\") =>  NIL, NIL\n      (export (find-symbol \"TEMP-SYM\" 'temp) 'temp) =>  T\n      (find-symbol \"TEMP-SYM\") =>  TEMP-SYM, :INHERITED\n"
        },
        {
            "type": "Side Effects",
            "text": "The package system is modified.\n"
        },
        {
            "type": "Affected By",
            "text": "Accessible symbols.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If any of the symbols is not accessible at all in package, an error of\ntype package-error is signaled that is correctable by permitting the user\nto interactively specify whether that symbol should be imported.\n"
        },
        {
            "type": "See Also",
            "text": "*Note import:: , *Note unexport:: , *Note Package Concepts::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: export,  Next: find-symbol,  Prev: package,  Up: Packages Dictionary\n\nexport                                                           [Function]\n---------------------------------------------------------------------------\n\n`export'  symbols &optional package =>  t\n\nArguments and Values::\n......................\n\nsymbols--a designator for a list of symbols.\n\npackage--a package designator.\n\nThe default is the current package.\n\nDescription::\n.............\n\nexport makes one or more symbols that are accessible in package (whether\ndirectly or by inheritance) be external symbols of that package.\n\nIf any of the symbols is already accessible as an external symbol of\npackage, export has no effect on that symbol.  If the symbol is present in\npackage as an internal symbol, it is simply changed to external status.\nIf it is accessible as an internal symbol via use-package, it is first\nimported into package, then exported.  (The symbol is then present in the\npackage whether or not package continues to use the package through which\nthe symbol was originally inherited.)\n\nexport makes each symbol accessible to all the packages that use package.\nAll of these packages are checked for name conflicts: (export s p) does\n(find-symbol (symbol-name s) q) for each package q in\n(package-used-by-list p).  Note that in the usual case of an export during\nthe initial definition of a package, the result of package-used-by-list is\nnil and the name-conflict checking takes negligible time.  When multiple\nchanges are to be made, for example when export is given a list of\nsymbols, it is permissible for the implementation to process each change\nseparately, so that aborting from a name conflict caused by any but the\nfirst symbol in the list does not unexport the first symbol in the list.\nHowever, aborting from a name-conflict error caused by export of one of\nsymbols does not leave that symbol accessible to some packages and\ninaccessible to others; with respect to each of symbols processed, export\nbehaves as if it were as an atomic operation.\n\nA name conflict in export between one of symbols being exported and a\nsymbol already present in a package that would inherit the newly-exported\nsymbol may be resolved in favor of the exported symbol by uninterning the\nother one, or in favor of the already-present symbol by making it a\nshadowing symbol.\n\nExamples::\n..........\n\n      (make-package 'temp :use nil) =>  #<PACKAGE \"TEMP\">\n      (use-package 'temp) =>  T\n      (intern \"TEMP-SYM\" 'temp) =>  TEMP::TEMP-SYM, NIL\n      (find-symbol \"TEMP-SYM\") =>  NIL, NIL\n      (export (find-symbol \"TEMP-SYM\" 'temp) 'temp) =>  T\n      (find-symbol \"TEMP-SYM\") =>  TEMP-SYM, :INHERITED\n\nSide Effects::\n..............\n\nThe package system is modified.\n\nAffected By::\n.............\n\nAccessible symbols.\n\nExceptional Situations::\n........................\n\nIf any of the symbols is not accessible at all in package, an error of\ntype package-error is signaled that is correctable by permitting the user\nto interactively specify whether that symbol should be imported.\n\nSee Also::\n..........\n\n*Note import:: , *Note unexport:: , *Note Package Concepts::\n\n"
}