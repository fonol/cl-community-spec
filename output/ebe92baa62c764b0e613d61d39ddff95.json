{
    "name": "unread-char",
    "prev": "terpri",
    "next": "write-char",
    "up": "Streams Dictionary",
    "header": {
        "type": "Function",
        "text": "unread-char"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "unread-char",
                    "text": " character &optional input-stream =>  nil\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "character",
                    "desc": "a character; must be the last character that was read from"
                },
                {
                    "name": "character",
                    "desc": "a character; must be the last character that was read frominput-stream.\n"
                },
                {
                    "name": "input-stream",
                    "desc": "an input stream designator.  The default is standard input."
                }
            ]
        },
        {
            "type": "Description",
            "text": "unread-char places character back onto the front of input-stream so that\nit will again be the next character in input-stream.\nWhen input-stream is an echo stream, no attempt is made to undo any\nechoing of the character that might already have been done on\ninput-stream. However, characters placed on input-stream by unread-char\nare marked in such a way as to inhibit later re-echo by read-char.\nIt is an error to invoke unread-char twice consecutively on the same stream\nwithout an intervening call to read-char (or some other input operation\nwhich implicitly reads characters) on that stream.\nInvoking peek-char or read-char commits all previous characters.  The\nconsequences of invoking unread-char on any character preceding that which\nis returned by peek-char (including those passed over by peek-char that\nhas a non-nil peek-type) are unspecified.  In particular, the consequences\nof invoking unread-char after peek-char are unspecified.\n"
        },
        {
            "type": "Examples",
            "text": "      (with-input-from-string (is \"0123\")\n         (dotimes (i 6)\n           (let ((c (read-char is)))\n             (if (evenp i) (format t \"~&~S ~S~\n      |>  0 #\\0\n      |>  2 #\\1\n      |>  4 #\\2\n     =>  NIL\n"
        },
        {
            "type": "Affected By",
            "text": "*standard-input*, *terminal-io*.\n"
        },
        {
            "type": "See Also",
            "text": "*Note peek-char:: , *Note read-char:: , *Note Stream Concepts::\n"
        },
        {
            "type": "Notes",
            "text": "unread-char is intended to be an efficient mechanism for allowing the Lisp\nreader and other parsers to perform one-character lookahead in\ninput-stream.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: unread-char,  Next: write-char,  Prev: terpri,  Up: Streams Dictionary\n\nunread-char                                                      [Function]\n---------------------------------------------------------------------------\n\n`unread-char'  character &optional input-stream =>  nil\n\nArguments and Values::\n......................\n\ncharacter--a character; must be the last character that was read from\ninput-stream.\n\ninput-stream--an input stream designator.  The default is standard input.\n\nDescription::\n.............\n\nunread-char places character back onto the front of input-stream so that\nit will again be the next character in input-stream.\n\nWhen input-stream is an echo stream, no attempt is made to undo any\nechoing of the character that might already have been done on\ninput-stream. However, characters placed on input-stream by unread-char\nare marked in such a way as to inhibit later re-echo by read-char.\n\nIt is an error to invoke unread-char twice consecutively on the same stream\nwithout an intervening call to read-char (or some other input operation\nwhich implicitly reads characters) on that stream.\n\nInvoking peek-char or read-char commits all previous characters.  The\nconsequences of invoking unread-char on any character preceding that which\nis returned by peek-char (including those passed over by peek-char that\nhas a non-nil peek-type) are unspecified.  In particular, the consequences\nof invoking unread-char after peek-char are unspecified.\n\nExamples::\n..........\n\n      (with-input-from-string (is \"0123\")\n         (dotimes (i 6)\n           (let ((c (read-char is)))\n             (if (evenp i) (format t \"~&~S ~S~\n      |>  0 #\\0\n      |>  2 #\\1\n      |>  4 #\\2\n     =>  NIL\n\nAffected By::\n.............\n\n*standard-input*, *terminal-io*.\n\nSee Also::\n..........\n\n*Note peek-char:: , *Note read-char:: , *Note Stream Concepts::\n\nNotes::\n.......\n\nunread-char is intended to be an efficient mechanism for allowing the Lisp\nreader and other parsers to perform one-character lookahead in\ninput-stream.\n\n"
}