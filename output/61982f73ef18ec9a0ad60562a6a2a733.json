{
    "name": "Definition of Similarity",
    "prev": "Similarity of Aggregate Objects",
    "next": "Extensions to Similarity Rules",
    "up": "Literal Objects in Compiled Files",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Definition of Similarity",
            "text": "Two objects S (in source code) and C (in compiled code) are defined to be\nsimilar if and only if they are both of one of the types listed here (or\ndefined by the implementation) and they both satisfy all additional\nrequirements of similarity indicated for that type.\nnumber\n     Two numbers S and C are similar if they are of the same type and\n     represent the same mathematical value.\ncharacter\n     Two simple characters S and C are similar if they have similar code\n     attributes.\n     Implementations providing additional, implementation-defined\n     attributes must define whether and how non-simple characters can be\n     regarded as similar.\nsymbol\n     Two apparently uninterned symbols S and C are similar if their names\n     are similar.\n     Two interned symbols S and C are similar if their names are similar,\n     and if either S is accessible in the current package at compile time\n     and C is accessible in the current package at load time, or C is\n     accessible in the package that is similar to the home package of S.\n     (Note that similarity of symbols is dependent on neither the current\n     readtable nor how the function read would parse the characters in the\n     name of the symbol.)\npackage\n     Two packages S and C are similar if their names are similar.\n     Note that although a package object is an externalizable object, the\n     programmer is responsible for ensuring that the corresponding package\n     is already in existence when code referencing it as a literal object\n     is loaded.  The loader finds the corresponding package object as if\n     by calling find-package with that name as an argument.  An error is\n     signaled by the loader if no package exists at load time.\nrandom-state\n     Two random states S and C are similar if S would always produce the\n     same sequence of pseudo-random numbers as a copy_5 of C when given as\n     the random-state argument to the function random, assuming equivalent\n     limit arguments in each case.\n     (Note that since C has been processed by the file compiler, it cannot\n     be used directly as an argument to random because random would\n     perform a side effect.)\ncons\n     Two conses, S and C, are similar if the car_2 of S is similar to the\n     car_2 of C, and the cdr_2 of S is similar to the cdr_2 of C.\narray\n     Two one-dimensional arrays, S and C, are similar if the length of S\n     is similar to the length of C, the actual array element type of S is\n     similar to the actual array element type of C, and each active\n     element of S is similar to the corresponding element of C.\n     Two arrays of rank other than one, S and C, are similar if the rank\n     of S is similar to the rank of C, each dimension_1 of S is similar to\n     the corresponding dimension_1 of C, the actual array element type of\n     S is similar to the actual array element type of C, and each element\n     of S is similar to the corresponding element of C.\n     In addition, if S is a simple array, then C must also be a simple\n     array.  If S is a displaced array, has a fill pointer, or is actually\n     adjustable, C is permitted to lack any or all of these qualities.\nhash-table\n     Two hash tables S and C are similar if they meet the following three\n     requirements:\n    1.\n          They both have the same test (e.g., they are both eql hash\n          tables).\n    2.\n          There is a unique one-to-one correspondence between the keys of\n          the two hash tables, such that the corresponding keys are\n          similar.\n    3.\n          For all keys, the values associated with two corresponding keys\n          are similar.\n     If there is more than one possible one-to-one correspondence between\n     the keys of S and C, the consequences are unspecified.  A conforming\n     program cannot use a table such as S as an externalizable constant.\npathname\n     Two pathnames S and C are similar if all corresponding pathname\n     components are similar.\nfunction\n     Functions are not externalizable objects.\nstructure-object and standard-object\n     A general-purpose concept of similarity does not exist for structures\n     and standard objects.  However, a conforming program is permitted to\n     define a make-load-form method for any class K defined by that\n     program that is a subclass of either structure-object or\n     standard-object.  The effect of such a method is to define that an\n     object S of type K in source code is similar to an object C of type K\n     in compiled code if C was constructed from code produced by calling\n     make-load-form on S.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Definition of Similarity,  Next: Extensions to Similarity Rules,  Prev: Similarity of Aggregate Objects,  Up: Literal Objects in Compiled Files\n\nDefinition of Similarity\n........................\n\nTwo objects S (in source code) and C (in compiled code) are defined to be\nsimilar if and only if they are both of one of the types listed here (or\ndefined by the implementation) and they both satisfy all additional\nrequirements of similarity indicated for that type.\n\nnumber\n     Two numbers S and C are similar if they are of the same type and\n     represent the same mathematical value.\n\ncharacter\n     Two simple characters S and C are similar if they have similar code\n     attributes.\n\n     Implementations providing additional, implementation-defined\n     attributes must define whether and how non-simple characters can be\n     regarded as similar.\n\nsymbol\n     Two apparently uninterned symbols S and C are similar if their names\n     are similar.\n\n     Two interned symbols S and C are similar if their names are similar,\n     and if either S is accessible in the current package at compile time\n     and C is accessible in the current package at load time, or C is\n     accessible in the package that is similar to the home package of S.\n\n     (Note that similarity of symbols is dependent on neither the current\n     readtable nor how the function read would parse the characters in the\n     name of the symbol.)\n\npackage\n     Two packages S and C are similar if their names are similar.\n\n     Note that although a package object is an externalizable object, the\n     programmer is responsible for ensuring that the corresponding package\n     is already in existence when code referencing it as a literal object\n     is loaded.  The loader finds the corresponding package object as if\n     by calling find-package with that name as an argument.  An error is\n     signaled by the loader if no package exists at load time.\n\nrandom-state\n     Two random states S and C are similar if S would always produce the\n     same sequence of pseudo-random numbers as a copy_5 of C when given as\n     the random-state argument to the function random, assuming equivalent\n     limit arguments in each case.\n\n     (Note that since C has been processed by the file compiler, it cannot\n     be used directly as an argument to random because random would\n     perform a side effect.)\n\ncons\n     Two conses, S and C, are similar if the car_2 of S is similar to the\n     car_2 of C, and the cdr_2 of S is similar to the cdr_2 of C.\n\narray\n     Two one-dimensional arrays, S and C, are similar if the length of S\n     is similar to the length of C, the actual array element type of S is\n     similar to the actual array element type of C, and each active\n     element of S is similar to the corresponding element of C.\n\n     Two arrays of rank other than one, S and C, are similar if the rank\n     of S is similar to the rank of C, each dimension_1 of S is similar to\n     the corresponding dimension_1 of C, the actual array element type of\n     S is similar to the actual array element type of C, and each element\n     of S is similar to the corresponding element of C.\n\n     In addition, if S is a simple array, then C must also be a simple\n     array.  If S is a displaced array, has a fill pointer, or is actually\n     adjustable, C is permitted to lack any or all of these qualities.\n\nhash-table\n     Two hash tables S and C are similar if they meet the following three\n     requirements:\n\n    1.\n          They both have the same test (e.g., they are both eql hash\n          tables).\n\n    2.\n          There is a unique one-to-one correspondence between the keys of\n          the two hash tables, such that the corresponding keys are\n          similar.\n\n    3.\n          For all keys, the values associated with two corresponding keys\n          are similar.\n\n     If there is more than one possible one-to-one correspondence between\n     the keys of S and C, the consequences are unspecified.  A conforming\n     program cannot use a table such as S as an externalizable constant.\n\npathname\n     Two pathnames S and C are similar if all corresponding pathname\n     components are similar.\n\nfunction\n     Functions are not externalizable objects.\n\nstructure-object and standard-object\n     A general-purpose concept of similarity does not exist for structures\n     and standard objects.  However, a conforming program is permitted to\n     define a make-load-form method for any class K defined by that\n     program that is a subclass of either structure-object or\n     standard-object.  The effect of such a method is to define that an\n     object S of type K in source code is similar to an object C of type K\n     in compiled code if C was constructed from code produced by calling\n     make-load-form on S.\n\n"
}