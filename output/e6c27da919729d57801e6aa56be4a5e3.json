{
    "name": "complement",
    "prev": "identity",
    "next": "constantly",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Function",
        "text": "complement"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "complement",
                    "text": " function =>  complement-function\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "function",
                    "desc": "a function."
                },
                {
                    "name": "complement-function",
                    "desc": "a function."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Returns a function that takes the same arguments as function, and has the\nsame side-effect behavior as function, but returns only a single value: a\ngeneralized boolean with the opposite truth value of that which would be\nreturned as the primary value of function.  That is, when the function\nwould have returned true as its primary value the complement-function\nreturns false, and when the function would have returned false as its\nprimary value the complement-function returns true.\n"
        },
        {
            "type": "Examples",
            "text": "      (funcall (complement #'zerop) 1) =>  true\n      (funcall (complement #'characterp) #\\A) =>  false\n      (funcall (complement #'member) 'a '(a b c)) =>  false\n      (funcall (complement #'member) 'd '(a b c)) =>  true\n"
        },
        {
            "type": "See Also",
            "text": "*Note not::\n"
        },
        {
            "type": "Notes",
            "text": "      (complement x) == #'(lambda (&rest arguments) (not (apply x arguments)))\nIn Common Lisp, functions with names like \"xxx-if-not\" are related to\nfunctions with names like \"xxx-if\" in that\n     (xxx-if-not f . arguments) == (xxx-if (complement f) . arguments)\nFor example,\n      (find-if-not #'zerop '(0 0 3)) ==\n      (find-if (complement #'zerop) '(0 0 3)) =>  3\nNote that since the \"xxx-if-not\" functions and the :test-not arguments\nhave been deprecated, uses of \"xxx-if\" functions or :test arguments with\ncomplement are preferred.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: complement,  Next: constantly,  Prev: identity,  Up: Data and Control Flow Dictionary\n\ncomplement                                                       [Function]\n---------------------------------------------------------------------------\n\n`complement'  function =>  complement-function\n\nArguments and Values::\n......................\n\nfunction--a function.\n\ncomplement-function--a function.\n\nDescription::\n.............\n\nReturns a function that takes the same arguments as function, and has the\nsame side-effect behavior as function, but returns only a single value: a\ngeneralized boolean with the opposite truth value of that which would be\nreturned as the primary value of function.  That is, when the function\nwould have returned true as its primary value the complement-function\nreturns false, and when the function would have returned false as its\nprimary value the complement-function returns true.\n\nExamples::\n..........\n\n      (funcall (complement #'zerop) 1) =>  true\n      (funcall (complement #'characterp) #\\A) =>  false\n      (funcall (complement #'member) 'a '(a b c)) =>  false\n      (funcall (complement #'member) 'd '(a b c)) =>  true\n\nSee Also::\n..........\n\n*Note not::\n\nNotes::\n.......\n\n      (complement x) == #'(lambda (&rest arguments) (not (apply x arguments)))\n\nIn Common Lisp, functions with names like \"xxx-if-not\" are related to\nfunctions with names like \"xxx-if\" in that\n\n     (xxx-if-not f . arguments) == (xxx-if (complement f) . arguments)\n\nFor example,\n\n      (find-if-not #'zerop '(0 0 3)) ==\n      (find-if (complement #'zerop) '(0 0 3)) =>  3\n\nNote that since the \"xxx-if-not\" functions and the :test-not arguments\nhave been deprecated, uses of \"xxx-if\" functions or :test arguments with\ncomplement are preferred.\n\n"
}