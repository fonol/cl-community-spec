{
    "name": "subst",
    "prev": "sublis",
    "next": "tree-equal",
    "up": "Conses Dictionary",
    "header": {
        "type": null,
        "text": "subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "subst",
                    "text": " new old  tree &key key test test-not =>  new-tree\n"
                },
                {
                    "name": "subst-if",
                    "text": " new predicate tree &key key =>  new-tree\n\n"
                },
                {
                    "name": "subst-if-not",
                    "text": " new predicate tree &key key =>  new-tree\n\n"
                },
                {
                    "name": "nsubst",
                    "text": " new old  tree &key key test test-not =>  new-tree\n\n"
                },
                {
                    "name": "nsubst-if",
                    "text": " new predicate tree &key key =>  new-tree\n\n"
                },
                {
                    "name": "nsubst-if-not",
                    "text": " new predicate tree &key key =>  new-tree\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "new",
                    "desc": "an object."
                },
                {
                    "name": "old",
                    "desc": "an object."
                },
                {
                    "name": "predicate",
                    "desc": "a symbol that names a function, or a function of one argument"
                },
                {
                    "name": "predicate",
                    "desc": "a symbol that names a function, or a function of one argumentthat returns a generalized boolean value.\n"
                },
                {
                    "name": "tree",
                    "desc": "a tree."
                },
                {
                    "name": "test",
                    "desc": "a designator for a function of two arguments that returns a"
                },
                {
                    "name": "test",
                    "desc": "a designator for a function of two arguments that returns ageneralized boolean.\n"
                },
                {
                    "name": "test-not",
                    "desc": "a designator for a function of two arguments that returns a"
                },
                {
                    "name": "test-not",
                    "desc": "a designator for a function of two arguments that returns ageneralized boolean.\n"
                },
                {
                    "name": "key",
                    "desc": "a designator for a function of one argument, or nil."
                },
                {
                    "name": "new-tree",
                    "desc": "a tree."
                }
            ]
        },
        {
            "type": "Description",
            "text": "subst, subst-if, and subst-if-not perform substitution operations on tree.\nEach function searches tree for occurrences of a particular old item of an\nelement or subexpression that satisfies the test.\nnsubst, nsubst-if, and nsubst-if-not are like subst, subst-if, and\nsubst-if-not respectively, except that the original tree is  modified.\nsubst makes a copy of tree, substituting new for every subtree or leaf of\ntree (whether the subtree or leaf is a car or a cdr of its parent) such\nthat old and the subtree or leaf satisfy the test.\nnsubst is a destructive version of subst.  The list structure of tree is\naltered by destructively replacing with new each leaf of the tree such\nthat old and the leaf satisfy the test.\nFor subst, subst-if, and subst-if-not, if the functions succeed, a new\ncopy of the tree is returned in which each  occurrence of such an element\nis replaced by the new element or subexpression.  If no changes are made,\nthe original tree may be returned.  The original tree is left unchanged,\nbut the result tree may share storage with it.\nFor nsubst, nsubst-if, and nsubst-if-not the original tree is  modified\nand returned as the function result, but the result may not be eq to tree.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))\n      (subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))\n      (subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))\n      (eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent\n      (subst 'tempest 'hurricane\n             '(shakespeare wrote (the hurricane)))\n     =>  (SHAKESPEARE WROTE (THE TEMPEST))\n      (subst 'foo 'nil '(shakespeare wrote (twelfth night)))\n     =>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)\n      (subst '(a . cons) '(old . pair)\n             '((old . spice) ((old . shoes) old . pair) (old . pair))\n             :test #'equal)\n     =>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))\n      (subst-if 5 #'listp tree1) =>  5\n      (subst-if-not '(x) #'consp tree1)\n     =>  (1 X)\n      tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))\n      (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y))))\n     =>  (1 (1 2) X X)\n      tree1 =>  (1 (1 2) X X)\n"
        },
        {
            "type": "Side Effects",
            "text": "nsubst, nsubst-if, and nsubst-if-not might alter the tree structure of\ntree.\n"
        },
        {
            "type": "See Also",
            "text": "*Note substitute; substitute-if; substitute-if-not; nsubstitute;\nnsubstitute-if; nsubstitute-if-not:: , nsubstitute,\n*Note Compiler Terminology::,\n*Note Traversal Rules and Side Effects::\n"
        },
        {
            "type": "Notes",
            "text": "The :test-not parameter is deprecated.\nThe functions subst-if-not and nsubst-if-not are deprecated.\nOne possible definition of subst:\n      (defun subst (old new tree &rest x &key test test-not key)\n        (cond ((satisfies-the-test old tree :test test\n                                      :test-not test-not :key key)\n              new)\n             ((atom tree) tree)\n             (t (let ((a (apply #'subst old new (car tree) x))\n                      (d (apply #'subst old new (cdr tree) x)))\n                  (if (and (eql a (car tree))\n                           (eql d (cdr tree)))\n                      tree\n                      (cons a d))))))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: subst,  Next: tree-equal,  Prev: sublis,  Up: Conses Dictionary\n\nsubst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not\n---------------------------------------------------------------\n\n                                                                [Function]\n\n`subst'  new old  tree &key key test test-not =>  new-tree\n\n`subst-if'  new predicate tree &key key =>  new-tree\n\n`subst-if-not'  new predicate tree &key key =>  new-tree\n\n`nsubst'  new old  tree &key key test test-not =>  new-tree\n\n`nsubst-if'  new predicate tree &key key =>  new-tree\n\n`nsubst-if-not'  new predicate tree &key key =>  new-tree\n\nArguments and Values::\n......................\n\nnew--an object.\n\nold--an object.\n\npredicate--a symbol that names a function, or a function of one argument\nthat returns a generalized boolean value.\n\ntree--a tree.\n\ntest--a designator for a function of two arguments that returns a\ngeneralized boolean.\n\ntest-not--a designator for a function of two arguments that returns a\ngeneralized boolean.\n\nkey--a designator for a function of one argument, or nil.\n\nnew-tree--a tree.\n\nDescription::\n.............\n\nsubst, subst-if, and subst-if-not perform substitution operations on tree.\nEach function searches tree for occurrences of a particular old item of an\nelement or subexpression that satisfies the test.\n\nnsubst, nsubst-if, and nsubst-if-not are like subst, subst-if, and\nsubst-if-not respectively, except that the original tree is  modified.\n\nsubst makes a copy of tree, substituting new for every subtree or leaf of\ntree (whether the subtree or leaf is a car or a cdr of its parent) such\nthat old and the subtree or leaf satisfy the test.\n\nnsubst is a destructive version of subst.  The list structure of tree is\naltered by destructively replacing with new each leaf of the tree such\nthat old and the leaf satisfy the test.\n\nFor subst, subst-if, and subst-if-not, if the functions succeed, a new\ncopy of the tree is returned in which each  occurrence of such an element\nis replaced by the new element or subexpression.  If no changes are made,\nthe original tree may be returned.  The original tree is left unchanged,\nbut the result tree may share storage with it.\n\nFor nsubst, nsubst-if, and nsubst-if-not the original tree is  modified\nand returned as the function result, but the result may not be eq to tree.\n\nExamples::\n..........\n\n      (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))\n      (subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))\n      (subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))\n      (eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent\n      (subst 'tempest 'hurricane\n             '(shakespeare wrote (the hurricane)))\n     =>  (SHAKESPEARE WROTE (THE TEMPEST))\n      (subst 'foo 'nil '(shakespeare wrote (twelfth night)))\n     =>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)\n      (subst '(a . cons) '(old . pair)\n             '((old . spice) ((old . shoes) old . pair) (old . pair))\n             :test #'equal)\n     =>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))\n     \n      (subst-if 5 #'listp tree1) =>  5\n      (subst-if-not '(x) #'consp tree1)\n     =>  (1 X)\n     \n      tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))\n      (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y))))\n     =>  (1 (1 2) X X)\n      tree1 =>  (1 (1 2) X X)\n\nSide Effects::\n..............\n\nnsubst, nsubst-if, and nsubst-if-not might alter the tree structure of\ntree.\n\nSee Also::\n..........\n\n*Note substitute; substitute-if; substitute-if-not; nsubstitute;\nnsubstitute-if; nsubstitute-if-not:: , nsubstitute,\n\n*Note Compiler Terminology::,\n\n*Note Traversal Rules and Side Effects::\n\nNotes::\n.......\n\nThe :test-not parameter is deprecated.\n\nThe functions subst-if-not and nsubst-if-not are deprecated.\n\nOne possible definition of subst:\n\n      (defun subst (old new tree &rest x &key test test-not key)\n        (cond ((satisfies-the-test old tree :test test\n                                      :test-not test-not :key key)\n              new)\n             ((atom tree) tree)\n             (t (let ((a (apply #'subst old new (car tree) x))\n                      (d (apply #'subst old new (cdr tree) x)))\n                  (if (and (eql a (car tree))\n                           (eql d (cdr tree)))\n                      tree\n                      (cons a d))))))\n\n"
}