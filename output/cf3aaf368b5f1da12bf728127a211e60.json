{
    "name": "with-slots",
    "prev": "with-accessors",
    "next": "defclass",
    "up": "Objects Dictionary",
    "header": {
        "type": "Macro",
        "text": "with-slots"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "with-slots",
                    "text": " ({slot-entry}*) instance-form {declaration}* {form}*=>  {result}*\n\nslot-entry ::=slot-name | (variable-name slot-name)\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "slot-name",
                    "desc": "a slot name; not evaluated."
                },
                {
                    "name": "variable-name",
                    "desc": "a variable name; not evaluated."
                },
                {
                    "name": "instance-form",
                    "desc": "a form; evaluted to produce instance."
                },
                {
                    "name": "instance",
                    "desc": "an object."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The macro with-slots establishes a lexical environment for referring to\nthe slots in the instance named by the given slot-names as though they\nwere variables.  Within such a context the value of the slot can be\nspecified by using its slot name, as if it were a lexically bound\nvariable.  Both setf and setq can be used to set the value of the slot.\nThe macro with-slots translates an appearance of the slot name as a\nvariable into a call to slot-value.\n"
        },
        {
            "type": "Examples",
            "text": "      (defclass thing ()\n                ((x :initarg :x :accessor thing-x)\n                 (y :initarg :y :accessor thing-y)))\n     =>  #<STANDARD-CLASS THING 250020173>\n      (defmethod (setf thing-x) :before (new-x (thing thing))\n        (format t \"~&Changing X from ~D to ~D in ~S.~\n                (thing-x thing) new-x thing))\n      (setq thing (make-instance 'thing :x 0 :y 1)) =>  #<THING 62310540>\n      (with-slots (x y) thing (incf x) (incf y)) =>  2\n      (values (thing-x thing) (thing-y thing)) =>  1, 2\n      (setq thing1 (make-instance 'thing :x 1 :y 2)) =>  #<THING 43135676>\n      (setq thing2 (make-instance 'thing :x 7 :y 8)) =>  #<THING 43147374>\n      (with-slots ((x1 x) (y1 y))\n                  thing1\n        (with-slots ((x2 x) (y2 y))\n                    thing2\n          (list (list x1 (thing-x thing1) y1 (thing-y thing1)\n                      x2 (thing-x thing2) y2 (thing-y thing2))\n                (setq x1 (+ y1 x2))\n                (list x1 (thing-x thing1) y1 (thing-y thing1)\n                      x2 (thing-x thing2) y2 (thing-y thing2))\n                (setf (thing-x thing2) (list x1))\n                (list x1 (thing-x thing1) y1 (thing-y thing1)\n                      x2 (thing-x thing2) y2 (thing-y thing2)))))\n      |>  Changing X from 7 to (9) in #<THING 43147374>.\n     =>  ((1 1 2 2 7 7 8 8)\n          9\n          (9 9 2 2 7 7 8 8)\n          (9)\n          (9 9 2 2 (9) (9) 8 8))\n"
        },
        {
            "type": "Affected By",
            "text": "defclass\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "The consequences are undefined if any slot-name is not the name of a slot\nin the instance.\n"
        },
        {
            "type": "See Also",
            "text": "*Note with-accessors:: , *Note slot-value:: , *Note symbol-macrolet::\n"
        },
        {
            "type": "Notes",
            "text": "A with-slots expression of the form:\n     (with-slots (slot-entry_1 ...slot-entry_n) instance-form form_1 ...form_k)\nexpands into the equivalent of\n     (let ((in instance-form))\n      (symbol-macrolet (Q_1... Q_n) form_1 ...form_k))\nwhere Q_i is\n     (slot-entry_i ()\n     (slot-value in 'slot-entry_i))\nif slot-entry_i is a symbol and is\n     (variable-name_i ()\n     (slot-value in 'slot-name_i))\nif slot-entry_i is of the form\n     (variable-name_i\n     slot-name_i)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: with-slots,  Next: defclass,  Prev: with-accessors,  Up: Objects Dictionary\n\nwith-slots                                                          [Macro]\n---------------------------------------------------------------------------\n\n`with-slots'  ({slot-entry}*) instance-form {declaration}* {form}*\n=>  {result}*\n\nslot-entry ::=slot-name | (variable-name slot-name)\n\nArguments and Values::\n......................\n\nslot-name--a slot name; not evaluated.\n\nvariable-name--a variable name; not evaluated.\n\ninstance-form--a form; evaluted to produce instance.\n\ninstance--an object.\n\ndeclaration--a declare expression; not evaluated.\n\nforms--an implicit progn.\n\nresults--the values returned by the forms.\n\nDescription::\n.............\n\nThe macro with-slots establishes a lexical environment for referring to\nthe slots in the instance named by the given slot-names as though they\nwere variables.  Within such a context the value of the slot can be\nspecified by using its slot name, as if it were a lexically bound\nvariable.  Both setf and setq can be used to set the value of the slot.\n\nThe macro with-slots translates an appearance of the slot name as a\nvariable into a call to slot-value.\n\nExamples::\n..........\n\n      (defclass thing ()\n                ((x :initarg :x :accessor thing-x)\n                 (y :initarg :y :accessor thing-y)))\n     =>  #<STANDARD-CLASS THING 250020173>\n      (defmethod (setf thing-x) :before (new-x (thing thing))\n        (format t \"~&Changing X from ~D to ~D in ~S.~\n                (thing-x thing) new-x thing))\n      (setq thing (make-instance 'thing :x 0 :y 1)) =>  #<THING 62310540>\n      (with-slots (x y) thing (incf x) (incf y)) =>  2\n      (values (thing-x thing) (thing-y thing)) =>  1, 2\n      (setq thing1 (make-instance 'thing :x 1 :y 2)) =>  #<THING 43135676>\n      (setq thing2 (make-instance 'thing :x 7 :y 8)) =>  #<THING 43147374>\n      (with-slots ((x1 x) (y1 y))\n                  thing1\n        (with-slots ((x2 x) (y2 y))\n                    thing2\n          (list (list x1 (thing-x thing1) y1 (thing-y thing1)\n                      x2 (thing-x thing2) y2 (thing-y thing2))\n                (setq x1 (+ y1 x2))\n                (list x1 (thing-x thing1) y1 (thing-y thing1)\n                      x2 (thing-x thing2) y2 (thing-y thing2))\n                (setf (thing-x thing2) (list x1))\n                (list x1 (thing-x thing1) y1 (thing-y thing1)\n                      x2 (thing-x thing2) y2 (thing-y thing2)))))\n      |>  Changing X from 7 to (9) in #<THING 43147374>.\n     =>  ((1 1 2 2 7 7 8 8)\n          9\n          (9 9 2 2 7 7 8 8)\n          (9)\n          (9 9 2 2 (9) (9) 8 8))\n\nAffected By::\n.............\n\ndefclass\n\nExceptional Situations::\n........................\n\nThe consequences are undefined if any slot-name is not the name of a slot\nin the instance.\n\nSee Also::\n..........\n\n*Note with-accessors:: , *Note slot-value:: , *Note symbol-macrolet::\n\nNotes::\n.......\n\nA with-slots expression of the form:\n\n                                     \n\n     (with-slots (slot-entry_1 ...slot-entry_n) instance-form form_1 ...form_k)\n\nexpands into the equivalent of\n\n                                     \n\n     (let ((in instance-form))\n\n      (symbol-macrolet (Q_1... Q_n) form_1 ...form_k))\n\nwhere Q_i is\n\n                                     \n     (slot-entry_i ()\n     (slot-value in 'slot-entry_i))\n\nif slot-entry_i is a symbol and is\n\n                                     \n     (variable-name_i ()\n     (slot-value in 'slot-name_i))\n\nif slot-entry_i is of the form\n\n                                     \n     (variable-name_i\n     slot-name_i)\n\n"
}