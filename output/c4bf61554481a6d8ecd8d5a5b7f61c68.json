{
    "name": "Macro Lambda Lists",
    "prev": "Specialized Lambda Lists",
    "next": "Destructuring Lambda Lists",
    "up": "Lambda Lists",
    "header": {
        "type": null,
        "text": "Macro Lambda Lists"
    },
    "sections": [
        {
            "type": "",
            "text": "A macro lambda list is used in describing macros defined by the operators\nin Figure 3-17.\n  define-compiler-macro  defmacro  macrolet  \n  define-setf-expander                       \n  Figure 3-17: Operators that use Macro Lambda Lists\nWith the additional restriction that an environment parameter may appear\nonly once (at any of the positions indicated), a macro lambda list has the\nfollowing syntax:\nreqvars ::={var | !pattern}*\noptvars ::=[&optional {var | ({var | !pattern} [init-form [supplied-p-parameter]])}*]\nrestvar ::=[{&rest | &body} {var | !pattern}]\nkeyvars ::=[&key {var | ({var | (keyword-name {var | !pattern})} [init-form [supplied-p-parameter]])}*\n            [&allow-other-keys]]\nauxvars ::=[&aux {var | (var [init-form])}*]\nenvvar ::=[&environment var]\nwholevar ::=[&whole var]\nlambda-list ::=(!wholevar !envvar !reqvars !envvar !optvars !envvar\n                !restvar !envvar !keyvars !envvar !auxvars !envvar) |\n                (!wholevar !envvar !reqvars !envvar !optvars !envvar . var)\npattern ::=(!wholevar !reqvars !optvars !restvar !keyvars !auxvars) |\n            (!wholevar !reqvars !optvars . var)\nA macro lambda list can contain the lambda list keywords shown in Figure\n3-18.\n  &allow-other-keys  &environment  &rest   \n  &aux               &key          &whole  \n  &body              &optional             \n  Figure 3-18: Lambda List Keywords used by Macro Lambda Lists\nOptional parameters (introduced by &optional) and keyword parameters\n(introduced by &key) can be supplied in a macro lambda list, just as in an\nordinary lambda list.  Both may contain default initialization forms and\nsupplied-p parameters.\n&body\nis identical in function to &rest, but it can be used to inform certain\noutput-formatting and editing functions that the remainder of the form is\ntreated as a body, and should be indented accordingly.  Only one of &body\nor &rest can be used at any particular level; see *Note Destructuring by\nLambda Lists::.\n&body can appear at any level of a macro lambda list; for details, see\n*Note Destructuring by Lambda Lists::.\n&whole\nis followed by a single variable that is bound to the entire macro-call\nform; this is the value that the macro function receives as its first\nargument.\nIf &whole and a following variable appear, they must appear first in\nlambda-list,\nbefore any other parameter or lambda list keyword.\n&whole can appear at any level of a macro lambda list.  At inner levels,\nthe &whole variable is bound to the corresponding part of the argument, as\nwith &rest, but unlike &rest, other arguments are also allowed.  The use\nof &whole does not affect the pattern of arguments specified.\n&environment\nis followed by a single variable that is bound to an environment\nrepresenting the lexical environment in which the macro call is to be\ninterpreted.  This environment should be used with\nmacro-function,\nget-setf-expansion,\ncompiler-macro-function,\nand macroexpand (for example) in computing the expansion of the macro, to\nensure that any lexical bindings or definitions established in the\ncompilation environment are taken into account.\n&environment can only appear at the top level of a macro lambda list, and\ncan only appear once, but can appear anywhere in that list;\nthe &environment parameter is bound along with &whole before any other\nvariables in the lambda list, regardless of where &environment appears in\nthe lambda list.\nThe object that is bound to the environment parameter has dynamic extent.\nDestructuring allows a macro lambda list to express the structure of a\nmacro call syntax.  If no lambda list keywords appear, then the macro\nlambda list is a tree containing parameter names at the leaves.  The\npattern and the macro form must have compatible tree structure; that is,\ntheir tree structure must be equivalent, or it must differ only in that\nsome leaves of the pattern match non-atomic objects of the macro form.\nFor information about error detection in this situation, see *Note\nDestructuring Mismatch::.\nA destructuring lambda list (whether at top level or embedded) can be\ndotted, ending in a parameter name.  This situation is treated exactly as\nif the parameter name that ends the list had appeared preceded by &rest.\nIt is permissible for a macro form (or a subexpression of a macro form) to\nbe a dotted list only  when (... &rest var) or (... . var) is used to match\nit. It is the responsibility of the macro to recognize and deal with such\nsituations.\n[Editorial Note by KMP: Apparently the dotted-macro-forms cleanup doesn't\nallow for the macro to `manually' notice dotted forms and fix them as well.\nIt shouldn't be required that this be done only by &REST or a dotted\npattern; it should only matter that ultimately the non-macro result of a\nfull-macro expansion not contain dots.  Anyway, I plan to address this\neditorially unless someone raises an objection.]\n* Menu:\n* Destructuring by Lambda Lists::\n* Data-directed Destructuring by Lambda Lists::\n* Examples of Data-directed Destructuring by Lambda Lists::\n* Lambda-list-directed Destructuring by Lambda Lists::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Macro Lambda Lists,  Next: Destructuring Lambda Lists,  Prev: Specialized Lambda Lists,  Up: Lambda Lists\n\nMacro Lambda Lists\n------------------\n\nA macro lambda list is used in describing macros defined by the operators\nin Figure 3-17.\n\n  define-compiler-macro  defmacro  macrolet  \n  define-setf-expander                       \n\n  Figure 3-17: Operators that use Macro Lambda Lists\n\n\nWith the additional restriction that an environment parameter may appear\nonly once (at any of the positions indicated), a macro lambda list has the\nfollowing syntax:\n\nreqvars ::={var | !pattern}*\n\noptvars ::=[&optional {var | ({var | !pattern} [init-form [supplied-p-parameter]])}*]\n\nrestvar ::=[{&rest | &body} {var | !pattern}]\n\nkeyvars ::=[&key {var | ({var | (keyword-name {var | !pattern})} [init-form [supplied-p-parameter]])}*\n            [&allow-other-keys]]\n\nauxvars ::=[&aux {var | (var [init-form])}*]\n\nenvvar ::=[&environment var]\n\nwholevar ::=[&whole var]\n\nlambda-list ::=(!wholevar !envvar !reqvars !envvar !optvars !envvar\n                !restvar !envvar !keyvars !envvar !auxvars !envvar) |\n                (!wholevar !envvar !reqvars !envvar !optvars !envvar . var)\n\npattern ::=(!wholevar !reqvars !optvars !restvar !keyvars !auxvars) |\n            (!wholevar !reqvars !optvars . var)\n\nA macro lambda list can contain the lambda list keywords shown in Figure\n3-18.\n\n  &allow-other-keys  &environment  &rest   \n  &aux               &key          &whole  \n  &body              &optional             \n\n  Figure 3-18: Lambda List Keywords used by Macro Lambda Lists\n\n\nOptional parameters (introduced by &optional) and keyword parameters\n(introduced by &key) can be supplied in a macro lambda list, just as in an\nordinary lambda list.  Both may contain default initialization forms and\nsupplied-p parameters.\n\n&body\n\nis identical in function to &rest, but it can be used to inform certain\noutput-formatting and editing functions that the remainder of the form is\ntreated as a body, and should be indented accordingly.  Only one of &body\nor &rest can be used at any particular level; see *Note Destructuring by\nLambda Lists::.\n\n&body can appear at any level of a macro lambda list; for details, see\n*Note Destructuring by Lambda Lists::.\n\n&whole\n\nis followed by a single variable that is bound to the entire macro-call\nform; this is the value that the macro function receives as its first\nargument.\n\nIf &whole and a following variable appear, they must appear first in\nlambda-list,\n\nbefore any other parameter or lambda list keyword.\n\n&whole can appear at any level of a macro lambda list.  At inner levels,\nthe &whole variable is bound to the corresponding part of the argument, as\nwith &rest, but unlike &rest, other arguments are also allowed.  The use\nof &whole does not affect the pattern of arguments specified.\n\n&environment\n\nis followed by a single variable that is bound to an environment\nrepresenting the lexical environment in which the macro call is to be\ninterpreted.  This environment should be used with\n\nmacro-function,\n\nget-setf-expansion,\n\ncompiler-macro-function,\n\nand macroexpand (for example) in computing the expansion of the macro, to\nensure that any lexical bindings or definitions established in the\ncompilation environment are taken into account.\n\n&environment can only appear at the top level of a macro lambda list, and\ncan only appear once, but can appear anywhere in that list;\n\nthe &environment parameter is bound along with &whole before any other\nvariables in the lambda list, regardless of where &environment appears in\nthe lambda list.\n\nThe object that is bound to the environment parameter has dynamic extent.\n\nDestructuring allows a macro lambda list to express the structure of a\nmacro call syntax.  If no lambda list keywords appear, then the macro\nlambda list is a tree containing parameter names at the leaves.  The\npattern and the macro form must have compatible tree structure; that is,\ntheir tree structure must be equivalent, or it must differ only in that\nsome leaves of the pattern match non-atomic objects of the macro form.\n\nFor information about error detection in this situation, see *Note\nDestructuring Mismatch::.\n\nA destructuring lambda list (whether at top level or embedded) can be\ndotted, ending in a parameter name.  This situation is treated exactly as\nif the parameter name that ends the list had appeared preceded by &rest.\n\nIt is permissible for a macro form (or a subexpression of a macro form) to\nbe a dotted list only  when (... &rest var) or (... . var) is used to match\nit. It is the responsibility of the macro to recognize and deal with such\nsituations.\n\n[Editorial Note by KMP: Apparently the dotted-macro-forms cleanup doesn't\nallow for the macro to `manually' notice dotted forms and fix them as well.\nIt shouldn't be required that this be done only by &REST or a dotted\npattern; it should only matter that ultimately the non-macro result of a\nfull-macro expansion not contain dots.  Anyway, I plan to address this\neditorially unless someone raises an objection.]\n\n* Menu:\n\n* Destructuring by Lambda Lists::\n* Data-directed Destructuring by Lambda Lists::\n* Examples of Data-directed Destructuring by Lambda Lists::\n* Lambda-list-directed Destructuring by Lambda Lists::\n\n"
}