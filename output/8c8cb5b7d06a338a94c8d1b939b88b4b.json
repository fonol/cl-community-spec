{
    "name": "Error Terminology",
    "prev": "Notational Conventions",
    "next": "Sections Not Formally Part Of This Standard",
    "up": "Definitions",
    "header": {
        "type": null,
        "text": "Error Terminology"
    },
    "sections": [
        {
            "type": "",
            "text": "Situations in which errors might, should, or must be signaled are described\nin the standard.  The wording used to describe such situations is intended\nto have precise meaning. The following list is a glossary of those\nmeanings.\nSafe code\n     This is code processed with the safety optimization at its highest\n     setting (3).  safety is a lexical property of code.  The phrase \"the\n     function F should signal an error\" means that if F is invoked from\n     code processed with the highest safety optimization, an error is\n     signaled.  It is implementation-dependent whether F or the calling\n     code signals the error.\nUnsafe code\n     This is code processed with lower safety levels.\n     Unsafe code might do error checking.  Implementations are permitted to\n     treat all code as safe code all the time.\nAn error is signaled\n     This means that an error is signaled in both safe and unsafe code.\n     Conforming code may rely on the fact that the error is signaled in\n     both safe and unsafe code.  Every implementation is required to\n     detect the error in both safe and unsafe code. For example, \"an error\n     is signaled if unexport is given a symbol not accessible in the\n     current package.\"\n     If an explicit error type is not specified, the default is error.\nAn error should be signaled\n     This means that an error is signaled in safe code, and an error might\n     be signaled in unsafe code.  Conforming code may rely on the fact\n     that the error is signaled in safe code.  Every implementation is\n     required to detect the error at least in safe code.  When the error\n     is not signaled, the \"consequences are undefined\" (see below).  For\n     example, \"+ should signal an error of type type-error if any argument\n     is not of type number.\"\nShould be prepared to signal an error\n     This is similar to \"should be signaled\" except that it does not imply\n     that `extra effort' has to be taken on the part of an operator to\n     discover an erroneous situation if the normal action of that operator\n     can be performed successfully with only `lazy' checking.  An\n     implementation is always permitted to signal an error, but even in\n     safe code, it is only required to signal the error when failing to\n     signal it might lead to incorrect results.  In unsafe code, the\n     consequences are undefined.\n     For example, defining that ``find should be prepared to signal an\n     error of type type-error if its second argument is not a proper list\"\n     does not imply that an error is always signaled.  The form\n           (find 'a '(a b . c))\n     must either signal an error of type type-error in safe code, else\n     return A.  In unsafe code, the consequences are undefined.  By\n     contrast,\n           (find 'd '(a b . c))\n     must signal an error of type type-error in safe code.  In unsafe\n     code, the consequences are undefined.  Also,\n           (find 'd '#1=(a b . #1#))\n     in safe code might return nil (as an implementation-defined\n     extension), might never return, or might signal an error of type\n     type-error.  In unsafe code, the consequences are undefined.\n     Typically, the \"should be prepared to signal\" terminology is used in\n     type checking situations where there are efficiency considerations\n     that make it impractical to detect errors that are not relevant to the\n     correct operation of the operator.\nThe consequences are unspecified\n     This means that the consequences are unpredictable but harmless.\n     Implementations are permitted to specify the consequences of this\n     situation. No conforming code may depend on the results or effects of\n     this situation, and all conforming code is required to treat the\n     results and effects of this situation as unpredictable but harmless.\n     For example, \"if the second argument to shared-initialize specifies a\n     name that does not correspond to any slots accessible in the object,\n     the results are unspecified.\"\nThe consequences are undefined\n     This means that the consequences are unpredictable. The consequences\n     may range from harmless to fatal.  No conforming code may depend on\n     the results or effects. Conforming code must treat the consequences as\n     unpredictable.  In places where the words \"must,\" \"must not,\" or \"may\n     not\" are used, then \"the consequences are undefined\" if the stated\n     requirement is not met and no specific consequence is explicitly\n     stated.  An implementation is permitted to signal an error in this\n     case.\n     For example: \"Once a name has been declared by defconstant to be\n     constant, any further assignment or binding of that variable has\n     undefined consequences.\"\nAn error might be signaled\n     This means that the situation has undefined consequences; however, if\n     an error is signaled, it is of the specified type.  For example,\n     \"open might signal an error of type file-error.\"\nThe return values are unspecified\n     This means that only the number and nature of the return values of a\n     form are not specified.  However, the issue of whether or not any\n     side-effects or transfer of control occurs is still well-specified.\n     A program can be well-specified even if it uses a function whose\n     returns values are unspecified.  For example, even if the return\n     values of some function F are unspecified, an expression such as\n     (length (list (F))) is still well-specified because it does not rely\n     on any particular aspect of the value or values returned by F.\nImplementations may be extended to cover this situation\n     This means that the situation has undefined consequences; however, a\n     conforming implementation is free to treat the situation in a more\n     specific way.  For example, an implementation might define that\n     an error is signaled, or that      an error should be signaled, or\n     even that a certain well-defined non-error behavior occurs.\n     No conforming code may depend on the consequences of such a situation;\n     all conforming code must treat the consequences of the situation as\n     undefined. Implementations are required to document how the situation\n     is treated.\n     For example, \"implementations may be extended to define other type\n     specifiers to have a corresponding class.\"\nImplementations are free to extend the syntax\n     This means that in this situation implementations are permitted to\n     define unambiguous extensions to the syntax of the form being\n     described.  No conforming code may depend on this extension.\n     Implementations are required to document each such extension. All\n     conforming code is required to treat the syntax as meaningless. The\n     standard might disallow certain extensions while allowing others. For\n     example, \"no implementation is free to extend the syntax of defclass.\"\nA warning might be issued\n     This means that implementations are encouraged to issue a warning if\n     the context is appropriate (e.g., when compiling).  However, a\n     conforming implementation is not required to issue a warning.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Error Terminology,  Next: Sections Not Formally Part Of This Standard,  Prev: Notational Conventions,  Up: Definitions\n\nError Terminology\n-----------------\n\nSituations in which errors might, should, or must be signaled are described\nin the standard.  The wording used to describe such situations is intended\nto have precise meaning. The following list is a glossary of those\nmeanings.\n\nSafe code\n     This is code processed with the safety optimization at its highest\n     setting (3).  safety is a lexical property of code.  The phrase \"the\n     function F should signal an error\" means that if F is invoked from\n     code processed with the highest safety optimization, an error is\n     signaled.  It is implementation-dependent whether F or the calling\n     code signals the error.\n\nUnsafe code\n     This is code processed with lower safety levels.\n\n     Unsafe code might do error checking.  Implementations are permitted to\n     treat all code as safe code all the time.\n\nAn error is signaled\n     This means that an error is signaled in both safe and unsafe code.\n     Conforming code may rely on the fact that the error is signaled in\n     both safe and unsafe code.  Every implementation is required to\n     detect the error in both safe and unsafe code. For example, \"an error\n     is signaled if unexport is given a symbol not accessible in the\n     current package.\"\n\n     If an explicit error type is not specified, the default is error.\n\nAn error should be signaled\n     This means that an error is signaled in safe code, and an error might\n     be signaled in unsafe code.  Conforming code may rely on the fact\n     that the error is signaled in safe code.  Every implementation is\n     required to detect the error at least in safe code.  When the error\n     is not signaled, the \"consequences are undefined\" (see below).  For\n     example, \"+ should signal an error of type type-error if any argument\n     is not of type number.\"\n\nShould be prepared to signal an error\n     This is similar to \"should be signaled\" except that it does not imply\n     that `extra effort' has to be taken on the part of an operator to\n     discover an erroneous situation if the normal action of that operator\n     can be performed successfully with only `lazy' checking.  An\n     implementation is always permitted to signal an error, but even in\n     safe code, it is only required to signal the error when failing to\n     signal it might lead to incorrect results.  In unsafe code, the\n     consequences are undefined.\n\n     For example, defining that ``find should be prepared to signal an\n     error of type type-error if its second argument is not a proper list\"\n     does not imply that an error is always signaled.  The form\n\n           (find 'a '(a b . c))\n\n     must either signal an error of type type-error in safe code, else\n     return A.  In unsafe code, the consequences are undefined.  By\n     contrast,\n\n           (find 'd '(a b . c))\n\n     must signal an error of type type-error in safe code.  In unsafe\n     code, the consequences are undefined.  Also,\n\n           (find 'd '#1=(a b . #1#))\n\n     in safe code might return nil (as an implementation-defined\n     extension), might never return, or might signal an error of type\n     type-error.  In unsafe code, the consequences are undefined.\n\n     Typically, the \"should be prepared to signal\" terminology is used in\n     type checking situations where there are efficiency considerations\n     that make it impractical to detect errors that are not relevant to the\n     correct operation of the operator.\n\nThe consequences are unspecified\n     This means that the consequences are unpredictable but harmless.\n     Implementations are permitted to specify the consequences of this\n     situation. No conforming code may depend on the results or effects of\n     this situation, and all conforming code is required to treat the\n     results and effects of this situation as unpredictable but harmless.\n     For example, \"if the second argument to shared-initialize specifies a\n     name that does not correspond to any slots accessible in the object,\n     the results are unspecified.\"\n\nThe consequences are undefined\n     This means that the consequences are unpredictable. The consequences\n     may range from harmless to fatal.  No conforming code may depend on\n     the results or effects. Conforming code must treat the consequences as\n     unpredictable.  In places where the words \"must,\" \"must not,\" or \"may\n     not\" are used, then \"the consequences are undefined\" if the stated\n     requirement is not met and no specific consequence is explicitly\n     stated.  An implementation is permitted to signal an error in this\n     case.\n\n     For example: \"Once a name has been declared by defconstant to be\n     constant, any further assignment or binding of that variable has\n     undefined consequences.\"\n\nAn error might be signaled\n     This means that the situation has undefined consequences; however, if\n     an error is signaled, it is of the specified type.  For example,\n     \"open might signal an error of type file-error.\"\n\nThe return values are unspecified\n     This means that only the number and nature of the return values of a\n     form are not specified.  However, the issue of whether or not any\n     side-effects or transfer of control occurs is still well-specified.\n\n     A program can be well-specified even if it uses a function whose\n     returns values are unspecified.  For example, even if the return\n     values of some function F are unspecified, an expression such as\n     (length (list (F))) is still well-specified because it does not rely\n     on any particular aspect of the value or values returned by F.\n\nImplementations may be extended to cover this situation\n     This means that the situation has undefined consequences; however, a\n     conforming implementation is free to treat the situation in a more\n     specific way.  For example, an implementation might define that\n     an error is signaled, or that      an error should be signaled, or\n     even that a certain well-defined non-error behavior occurs.\n\n     No conforming code may depend on the consequences of such a situation;\n     all conforming code must treat the consequences of the situation as\n     undefined. Implementations are required to document how the situation\n     is treated.\n\n     For example, \"implementations may be extended to define other type\n     specifiers to have a corresponding class.\"\n\nImplementations are free to extend the syntax\n     This means that in this situation implementations are permitted to\n     define unambiguous extensions to the syntax of the form being\n     described.  No conforming code may depend on this extension.\n     Implementations are required to document each such extension. All\n     conforming code is required to treat the syntax as meaningless. The\n     standard might disallow certain extensions while allowing others. For\n     example, \"no implementation is free to extend the syntax of defclass.\"\n\nA warning might be issued\n     This means that implementations are encouraged to issue a warning if\n     the context is appropriate (e.g., when compiling).  However, a\n     conforming implementation is not required to issue a warning.\n\n"
}