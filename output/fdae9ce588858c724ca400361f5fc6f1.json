{
    "name": "string=",
    "prev": "string-trim",
    "next": "stringp",
    "up": "Strings Dictionary",
    "header": {
        "type": null,
        "text": "string-greaterp, string-not-greaterp, string-not-lessp"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "string=",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>generalized-boolean\n\n"
                },
                {
                    "name": "string/=",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n"
                },
                {
                    "name": "string<",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n"
                },
                {
                    "name": "string>",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n"
                },
                {
                    "name": "string<=",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n"
                },
                {
                    "name": "string>=",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n"
                },
                {
                    "name": "string-equal",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>\ngeneralized-boolean\n\n"
                },
                {
                    "name": "string-not-equal",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n"
                },
                {
                    "name": "string-lessp",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n"
                },
                {
                    "name": "string-greaterp",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n"
                },
                {
                    "name": "string-not-greaterp",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n"
                },
                {
                    "name": "string-not-lessp",
                    "text": " string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "string1",
                    "desc": "a string designator."
                },
                {
                    "name": "string2",
                    "desc": "a string designator."
                },
                {
                    "name": "start1, end1",
                    "desc": "bounding index designators of string1.  The defaults for"
                },
                {
                    "name": "start1, end1",
                    "desc": "bounding index designators of string1.  The defaults forstart and end are 0 and nil, respectively.\n"
                },
                {
                    "name": "start2, end2",
                    "desc": "bounding index designators of string2.  The defaults for"
                },
                {
                    "name": "start2, end2",
                    "desc": "bounding index designators of string2.  The defaults forstart and end are 0 and nil, respectively.\n"
                },
                {
                    "name": "generalized-boolean",
                    "desc": "a generalized boolean."
                },
                {
                    "name": "mismatch-index",
                    "desc": "a bounding index of string1, or nil."
                }
            ]
        },
        {
            "type": "Description",
            "text": "These functions perform lexicographic comparisons on string1 and string2.\nstring= and string-equal are called equality functions; the others are\ncalled inequality functions.  The comparison operations these functions\nperform are restricted to the subsequence of string1 bounded by start1 and\nend1 and to the subsequence of string2 bounded by start2 and end2.\nA string a is equal to a string b if it contains the same number of\ncharacters, and the corresponding characters are the same under char= or\nchar-equal, as appropriate.\nA string a is less than a string b if in the first position in which they\ndiffer the character of a is less than the corresponding character of b\naccording to char< or char-lessp as appropriate, or if string a is a\nproper prefix of string b (of shorter length and matching in all the\ncharacters of a).\nThe equality functions return a generalized boolean that is true if the\nstrings are equal, or false otherwise.\nThe inequality functions return a mismatch-index that is true if the\nstrings are not equal, or false otherwise.  When the mismatch-index is\ntrue, it is an integer representing the first character position at which\nthe two substrings differ, as an offset from the beginning of string1.\nThe comparison has one of the following results:\nstring=\n     string= is true if the supplied substrings are of the same length and\n     contain the same characters in corresponding positions; otherwise it\n     is false.\nstring/=\n     string/= is true if the supplied substrings are different; otherwise\n     it is false.\nstring-equal\n     string-equal is just like string= except that differences in case are\n     ignored; two characters are considered to be the same if char-equal\n     is true of them.\nstring<\n     string< is true if substring1 is less than substring2; otherwise it\n     is false.\nstring>\n     string> is true if substring1 is greater than substring2; otherwise\n     it is false.\nstring-lessp, string-greaterp\n     string-lessp and string-greaterp are exactly like string< and\n     string>, respectively, except that distinctions between uppercase and\n     lowercase letters are ignored.  It is as if char-lessp were used\n     instead of char< for comparing characters.\nstring<=\n     string<= is true if substring1 is less than or equal to substring2;\n     otherwise it is false.\nstring>=\n     string>= is true if substring1 is greater than or equal to substring2;\n     otherwise it is false.\nstring-not-greaterp, string-not-lessp\n     string-not-greaterp and string-not-lessp are exactly like string<=\n     and string>=, respectively, except that distinctions between\n     uppercase and lowercase letters are ignored.  It is as if char-lessp\n     were used instead of char< for comparing characters.\n"
        },
        {
            "type": "Examples",
            "text": "      (string= \"foo\" \"foo\") =>  true\n      (string= \"foo\" \"Foo\") =>  false\n      (string= \"foo\" \"bar\") =>  false\n      (string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true\n      (string-equal \"foo\" \"Foo\") =>  true\n      (string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true\n      (string< \"aaaa\" \"aaab\") =>  3\n      (string>= \"aaaaa\" \"aaaa\") =>  4\n      (string-not-greaterp \"Abcde\" \"abcdE\") =>  5\n      (string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7\n                                           :start2 2 :end2 6) =>  6\n      (string-not-equal \"AAAA\" \"aaaA\") =>  false\n"
        },
        {
            "type": "See Also",
            "text": "*Note char=; char/=; char<; char>; char<=; char>=; char-equal;\nchar-not-equal; char-lessp; char-greaterp; char-not-greaterp;\nchar-not-lessp::\n"
        },
        {
            "type": "Notes",
            "text": "equal calls string= if applied to two strings.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: string=,  Next: stringp,  Prev: string-trim,  Up: Strings Dictionary\n\nstring=, string/=, string<, string>, string<=, string>=,\n--------------------------------------------------------\n\nstring-equal, string-not-equal, string-lessp,\n---------------------------------------------\n\nstring-greaterp, string-not-greaterp, string-not-lessp\n------------------------------------------------------\n\n                                                                [Function]\n\n`string='  string1 string2 &key start1 end1 start2 end2 =>\ngeneralized-boolean\n\n`string/='  string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n`string<'  string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n`string>'  string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n`string<='  string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n`string>='  string1 string2 &key start1 end1 start2 end2 =>  mismatch-index\n\n`string-equal'  string1 string2 &key start1 end1 start2 end2 =>\ngeneralized-boolean\n\n`string-not-equal'  string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n`string-lessp'  string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n`string-greaterp'  string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n`string-not-greaterp'  string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\n`string-not-lessp'  string1 string2 &key start1 end1 start2 end2 =>\nmismatch-index\n\nArguments and Values::\n......................\n\nstring1--a string designator.\n\nstring2--a string designator.\n\nstart1, end1--bounding index designators of string1.  The defaults for\nstart and end are 0 and nil, respectively.\n\nstart2, end2--bounding index designators of string2.  The defaults for\nstart and end are 0 and nil, respectively.\n\ngeneralized-boolean--a generalized boolean.\n\nmismatch-index--a bounding index of string1, or nil.\n\nDescription::\n.............\n\nThese functions perform lexicographic comparisons on string1 and string2.\nstring= and string-equal are called equality functions; the others are\ncalled inequality functions.  The comparison operations these functions\nperform are restricted to the subsequence of string1 bounded by start1 and\nend1 and to the subsequence of string2 bounded by start2 and end2.\n\nA string a is equal to a string b if it contains the same number of\ncharacters, and the corresponding characters are the same under char= or\nchar-equal, as appropriate.\n\nA string a is less than a string b if in the first position in which they\ndiffer the character of a is less than the corresponding character of b\naccording to char< or char-lessp as appropriate, or if string a is a\nproper prefix of string b (of shorter length and matching in all the\ncharacters of a).\n\nThe equality functions return a generalized boolean that is true if the\nstrings are equal, or false otherwise.\n\nThe inequality functions return a mismatch-index that is true if the\nstrings are not equal, or false otherwise.  When the mismatch-index is\ntrue, it is an integer representing the first character position at which\nthe two substrings differ, as an offset from the beginning of string1.\n\nThe comparison has one of the following results:\n\nstring=\n     string= is true if the supplied substrings are of the same length and\n     contain the same characters in corresponding positions; otherwise it\n     is false.\n\nstring/=\n     string/= is true if the supplied substrings are different; otherwise\n     it is false.\n\nstring-equal\n     string-equal is just like string= except that differences in case are\n     ignored; two characters are considered to be the same if char-equal\n     is true of them.\n\nstring<\n     string< is true if substring1 is less than substring2; otherwise it\n     is false.\n\nstring>\n     string> is true if substring1 is greater than substring2; otherwise\n     it is false.\n\nstring-lessp, string-greaterp\n     string-lessp and string-greaterp are exactly like string< and\n     string>, respectively, except that distinctions between uppercase and\n     lowercase letters are ignored.  It is as if char-lessp were used\n     instead of char< for comparing characters.\n\nstring<=\n     string<= is true if substring1 is less than or equal to substring2;\n     otherwise it is false.\n\nstring>=\n     string>= is true if substring1 is greater than or equal to substring2;\n     otherwise it is false.\n\nstring-not-greaterp, string-not-lessp\n     string-not-greaterp and string-not-lessp are exactly like string<=\n     and string>=, respectively, except that distinctions between\n     uppercase and lowercase letters are ignored.  It is as if char-lessp\n     were used instead of char< for comparing characters.\n\nExamples::\n..........\n\n      (string= \"foo\" \"foo\") =>  true\n      (string= \"foo\" \"Foo\") =>  false\n      (string= \"foo\" \"bar\") =>  false\n      (string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true\n      (string-equal \"foo\" \"Foo\") =>  true\n      (string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true\n      (string< \"aaaa\" \"aaab\") =>  3\n      (string>= \"aaaaa\" \"aaaa\") =>  4\n      (string-not-greaterp \"Abcde\" \"abcdE\") =>  5\n      (string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7\n                                           :start2 2 :end2 6) =>  6\n      (string-not-equal \"AAAA\" \"aaaA\") =>  false\n\nSee Also::\n..........\n\n*Note char=; char/=; char<; char>; char<=; char>=; char-equal;\nchar-not-equal; char-lessp; char-greaterp; char-not-greaterp;\nchar-not-lessp::\n\nNotes::\n.......\n\nequal calls string= if applied to two strings.\n\n"
}