{
    "name": "declare",
    "prev": "declaim",
    "next": "ignore",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Symbol",
        "text": "declare"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "declare",
                    "text": " {declaration-specifier}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments",
            "text": "declaration-specifier--a declaration specifier; not evaluated.\n"
        },
        {
            "type": "Description",
            "text": "A declare expression, sometimes called a declaration, can occur only at\nthe beginning of the bodies of certain forms; that is, it may be preceded\nonly by other declare expressions, or by a documentation string if the\ncontext permits.\nA declare expression can occur in a lambda expression or in any of the\nforms listed in Figure 3-23.\n  defgeneric                 do-external-symbols   prog                      \n  define-compiler-macro      do-symbols            prog*                     \n  define-method-combination  dolist                restart-case              \n  define-setf-expander       dotimes               symbol-macrolet           \n  defmacro                   flet                  with-accessors            \n  defmethod                  handler-case          with-hash-table-iterator  \n  defsetf                    labels                with-input-from-string    \n  deftype                    let                   with-open-file            \n  defun                      let*                  with-open-stream          \n  destructuring-bind         locally               with-output-to-string     \n  do                         macrolet              with-package-iterator     \n  do*                        multiple-value-bind   with-slots                \n  do-all-symbols             pprint-logical-block                            \n       Figure 3-23: Standardized Forms In Which Declarations Can Occur      \nA declare expression can only occur where specified by the syntax of these\nforms.  The consequences of attempting to evaluate a declare expression\nare undefined.  In situations where such expressions can appear, explicit\nchecks are made for their presence and they are never actually evaluated;\nit is for this reason that they are called  \"declare expressions\" rather\nthan \"declare forms.\"\nMacro forms cannot expand into declarations; declare expressions must\nappear as actual subexpressions of the form to which they refer.\nFigure 3-24 shows a list of declaration identifiers that can be used with\ndeclare.\n  dynamic-extent  ignore     optimize  \n  ftype           inline     special   \n  ignorable       notinline  type      \n  Figure 3-24: Local Declaration Specifiers\nAn implementation is free to support other (implementation-defined)\ndeclaration identifiers as well.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun nonsense (k x z)\n        (foo z x)                     ;First call to foo\n        (let ((j (foo k x))           ;Second call to foo\n              (x (* k k)))\n          (declare (inline foo) (special x z))\n          (foo x j z)))               ;Third call to foo\nIn this example, the inline declaration applies only to the third call to\nfoo, but not to the first or second ones.  The special declaration of x\ncauses let to make a dynamic binding for x, and causes the reference to x\nin the body of let to be a dynamic reference.  The reference to x in the\nsecond call to foo is a local reference to the second parameter of\nnonsense.  The reference to x in the first call to foo is a local\nreference, not a special one.  The special declaration of z causes the\nreference to z in the third call to foo to be a dynamic reference; it does\nnot refer to the parameter to nonsense named z, because that parameter\nbinding has not been declared to be special.  (The special declaration of\nz does not appear in the body of defun,  but in an inner form, and\ntherefore does not affect the binding of the parameter.)\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "The consequences  of trying to use a declare expression as a form to be\nevaluated are undefined.\n[Editorial Note by KMP: Probably we need to say something here about\nill-formed declare expressions.]\n"
        },
        {
            "type": "See Also",
            "text": "*Note proclaim:: , *Note Type Specifiers::, declaration, dynamic-extent,\nftype, ignorable, ignore, inline, notinline, optimize, type\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: declare,  Next: ignore,  Prev: declaim,  Up: Evaluation and Compilation Dictionary\n\ndeclare                                                            [Symbol]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n`declare'  {declaration-specifier}*\n\nArguments::\n...........\n\ndeclaration-specifier--a declaration specifier; not evaluated.\n\nDescription::\n.............\n\nA declare expression, sometimes called a declaration, can occur only at\nthe beginning of the bodies of certain forms; that is, it may be preceded\nonly by other declare expressions, or by a documentation string if the\ncontext permits.\n\nA declare expression can occur in a lambda expression or in any of the\nforms listed in Figure 3-23.\n\n  defgeneric                 do-external-symbols   prog                      \n  define-compiler-macro      do-symbols            prog*                     \n  define-method-combination  dolist                restart-case              \n  define-setf-expander       dotimes               symbol-macrolet           \n  defmacro                   flet                  with-accessors            \n  defmethod                  handler-case          with-hash-table-iterator  \n  defsetf                    labels                with-input-from-string    \n  deftype                    let                   with-open-file            \n  defun                      let*                  with-open-stream          \n  destructuring-bind         locally               with-output-to-string     \n  do                         macrolet              with-package-iterator     \n  do*                        multiple-value-bind   with-slots                \n  do-all-symbols             pprint-logical-block                            \n\n       Figure 3-23: Standardized Forms In Which Declarations Can Occur      \n\n\nA declare expression can only occur where specified by the syntax of these\nforms.  The consequences of attempting to evaluate a declare expression\nare undefined.  In situations where such expressions can appear, explicit\nchecks are made for their presence and they are never actually evaluated;\nit is for this reason that they are called  \"declare expressions\" rather\nthan \"declare forms.\"\n\nMacro forms cannot expand into declarations; declare expressions must\nappear as actual subexpressions of the form to which they refer.\n\nFigure 3-24 shows a list of declaration identifiers that can be used with\ndeclare.\n\n  dynamic-extent  ignore     optimize  \n  ftype           inline     special   \n  ignorable       notinline  type      \n\n  Figure 3-24: Local Declaration Specifiers\n\n\nAn implementation is free to support other (implementation-defined)\ndeclaration identifiers as well.\n\nExamples::\n..........\n\n      (defun nonsense (k x z)\n        (foo z x)                     ;First call to foo\n        (let ((j (foo k x))           ;Second call to foo\n              (x (* k k)))\n          (declare (inline foo) (special x z))\n          (foo x j z)))               ;Third call to foo\n\nIn this example, the inline declaration applies only to the third call to\nfoo, but not to the first or second ones.  The special declaration of x\ncauses let to make a dynamic binding for x, and causes the reference to x\nin the body of let to be a dynamic reference.  The reference to x in the\nsecond call to foo is a local reference to the second parameter of\nnonsense.  The reference to x in the first call to foo is a local\nreference, not a special one.  The special declaration of z causes the\nreference to z in the third call to foo to be a dynamic reference; it does\nnot refer to the parameter to nonsense named z, because that parameter\nbinding has not been declared to be special.  (The special declaration of\nz does not appear in the body of defun,  but in an inner form, and\ntherefore does not affect the binding of the parameter.)\n\nExceptional Situations::\n........................\n\nThe consequences  of trying to use a declare expression as a form to be\nevaluated are undefined.\n\n[Editorial Note by KMP: Probably we need to say something here about\nill-formed declare expressions.]\n\nSee Also::\n..........\n\n*Note proclaim:: , *Note Type Specifiers::, declaration, dynamic-extent,\nftype, ignorable, ignore, inline, notinline, optimize, type\n\n"
}