{
    "name": "symbol-package",
    "prev": "symbol-name",
    "next": "symbol-plist",
    "up": "Symbols Dictionary",
    "header": {
        "type": "Function",
        "text": "symbol-package"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "symbol-package",
                    "text": " symbol =>  contents\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "symbol",
                    "desc": "a symbol."
                },
                {
                    "name": "contents",
                    "desc": "a package object or nil."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Returns the home package of symbol.\n"
        },
        {
            "type": "Examples",
            "text": "      (in-package \"CL-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">\n      (symbol-package 'car) =>  #<PACKAGE \"COMMON-LISP\">\n      (symbol-package 'bus) =>  #<PACKAGE \"COMMON-LISP-USER\">\n      (symbol-package :optional) =>  #<PACKAGE \"KEYWORD\">\n      ;; Gensyms are uninterned, so have no home package.\n      (symbol-package (gensym)) =>  NIL\n      (make-package 'pk1) =>  #<PACKAGE \"PK1\">\n      (intern \"SAMPLE1\" \"PK1\") =>  PK1::SAMPLE1, NIL\n      (export (find-symbol \"SAMPLE1\" \"PK1\") \"PK1\") =>  T\n      (make-package 'pk2 :use '(pk1)) =>  #<PACKAGE \"PK2\">\n      (find-symbol \"SAMPLE1\" \"PK2\") =>  PK1:SAMPLE1, :INHERITED\n      (symbol-package 'pk1::sample1) =>  #<PACKAGE \"PK1\">\n      (symbol-package 'pk2::sample1) =>  #<PACKAGE \"PK1\">\n      (symbol-package 'pk1::sample2) =>  #<PACKAGE \"PK1\">\n      (symbol-package 'pk2::sample2) =>  #<PACKAGE \"PK2\">\n      ;; The next several forms create a scenario in which a symbol\n      ;; is not really uninterned, but is \"apparently uninterned\",\n      ;; and so SYMBOL-PACKAGE still returns NIL.\n      (setq s3 'pk1::sample3) =>  PK1::SAMPLE3\n      (import s3 'pk2) =>  T\n      (unintern s3 'pk1) =>  T\n      (symbol-package s3) =>  NIL\n      (eq s3 'pk2::sample3) =>  T\n"
        },
        {
            "type": "Affected By",
            "text": "import, intern, unintern\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if symbol is not a symbol.\n"
        },
        {
            "type": "See Also",
            "text": "*Note intern::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: symbol-package,  Next: symbol-plist,  Prev: symbol-name,  Up: Symbols Dictionary\n\nsymbol-package                                                   [Function]\n---------------------------------------------------------------------------\n\n`symbol-package'  symbol =>  contents\n\nArguments and Values::\n......................\n\nsymbol--a symbol.\n\ncontents--a package object or nil.\n\nDescription::\n.............\n\nReturns the home package of symbol.\n\nExamples::\n..........\n\n      (in-package \"CL-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">\n      (symbol-package 'car) =>  #<PACKAGE \"COMMON-LISP\">\n      (symbol-package 'bus) =>  #<PACKAGE \"COMMON-LISP-USER\">\n      (symbol-package :optional) =>  #<PACKAGE \"KEYWORD\">\n      ;; Gensyms are uninterned, so have no home package.\n      (symbol-package (gensym)) =>  NIL\n      (make-package 'pk1) =>  #<PACKAGE \"PK1\">\n      (intern \"SAMPLE1\" \"PK1\") =>  PK1::SAMPLE1, NIL\n      (export (find-symbol \"SAMPLE1\" \"PK1\") \"PK1\") =>  T\n      (make-package 'pk2 :use '(pk1)) =>  #<PACKAGE \"PK2\">\n      (find-symbol \"SAMPLE1\" \"PK2\") =>  PK1:SAMPLE1, :INHERITED\n      (symbol-package 'pk1::sample1) =>  #<PACKAGE \"PK1\">\n      (symbol-package 'pk2::sample1) =>  #<PACKAGE \"PK1\">\n      (symbol-package 'pk1::sample2) =>  #<PACKAGE \"PK1\">\n      (symbol-package 'pk2::sample2) =>  #<PACKAGE \"PK2\">\n      ;; The next several forms create a scenario in which a symbol\n      ;; is not really uninterned, but is \"apparently uninterned\",\n      ;; and so SYMBOL-PACKAGE still returns NIL.\n      (setq s3 'pk1::sample3) =>  PK1::SAMPLE3\n      (import s3 'pk2) =>  T\n      (unintern s3 'pk1) =>  T\n      (symbol-package s3) =>  NIL\n      (eq s3 'pk2::sample3) =>  T\n\nAffected By::\n.............\n\nimport, intern, unintern\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if symbol is not a symbol.\n\nSee Also::\n..........\n\n*Note intern::\n\n"
}