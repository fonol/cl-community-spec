{
    "name": "random",
    "prev": "make-random-state",
    "next": "random-state-p",
    "up": "Numbers Dictionary",
    "header": {
        "type": "Function",
        "text": "random"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "random",
                    "text": " limit &optional random-state =>  random-number\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "limit",
                    "desc": "a positive integer, or a positive float."
                },
                {
                    "name": "random-state",
                    "desc": "a random state.  The default is the current random state."
                },
                {
                    "name": "random-number",
                    "desc": "a non-negative number less than limit and of the same type"
                }
            ]
        },
        {
            "type": "Description",
            "text": "Returns a pseudo-random number that is a non-negative number less than\nlimit and of the same type as limit.\nThe random-state, which is modified by this function, encodes the internal\nstate maintained by the random number generator.\nAn approximately uniform choice distribution is used.  If limit is an\ninteger, each of the possible results occurs with (approximate)\nprobability 1/limit.\n"
        },
        {
            "type": "Examples",
            "text": "      (<= 0 (random 1000) 1000) =>  true\n      (let ((state1 (make-random-state))\n            (state2 (make-random-state)))\n        (= (random 1000 state1) (random 1000 state2))) =>  true\n"
        },
        {
            "type": "Side Effects",
            "text": "The random-state is modified.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if limit is not a positive\ninteger or a positive real.\n"
        },
        {
            "type": "See Also",
            "text": "*Note make-random-state:: , *Note random-state::\n"
        },
        {
            "type": "Notes",
            "text": "See Common Lisp: The Language for information about generating random\nnumbers.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: random,  Next: random-state-p,  Prev: make-random-state,  Up: Numbers Dictionary\n\nrandom                                                           [Function]\n---------------------------------------------------------------------------\n\n`random'  limit &optional random-state =>  random-number\n\nArguments and Values::\n......................\n\nlimit--a positive integer, or a positive float.\n\nrandom-state--a random state.  The default is the current random state.\n\nrandom-number--a non-negative number less than limit and of the same type\nas limit.\n\nDescription::\n.............\n\nReturns a pseudo-random number that is a non-negative number less than\nlimit and of the same type as limit.\n\nThe random-state, which is modified by this function, encodes the internal\nstate maintained by the random number generator.\n\nAn approximately uniform choice distribution is used.  If limit is an\ninteger, each of the possible results occurs with (approximate)\nprobability 1/limit.\n\nExamples::\n..........\n\n      (<= 0 (random 1000) 1000) =>  true\n      (let ((state1 (make-random-state))\n            (state2 (make-random-state)))\n        (= (random 1000 state1) (random 1000 state2))) =>  true\n\nSide Effects::\n..............\n\nThe random-state is modified.\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if limit is not a positive\ninteger or a positive real.\n\nSee Also::\n..........\n\n*Note make-random-state:: , *Note random-state::\n\nNotes::\n.......\n\nSee Common Lisp: The Language for information about generating random\nnumbers.\n\n"
}