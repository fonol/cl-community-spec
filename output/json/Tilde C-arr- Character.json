{
    "name": "Tilde C-> Character",
    "prev": "FORMAT Basic Output",
    "next": "Tilde Percent-> Newline",
    "up": "FORMAT Basic Output",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Tilde C: Character",
            "text": "The next arg should be a character; it is printed according to the\nmodifier flags.\n~C prints the character as if by using write-char if it is a simple\ncharacter.  Characters that are not simple are not necessarily printed as\nif by write-char, but are displayed in an implementation-defined,\nabbreviated format.  For example,\n      (format nil \"~C\" #\\A) =>  \"A\"\n      (format nil \"~C\" #\\Space) =>  \" \"\n~:C is the same as ~C for printing characters, but other characters are\n\"spelled out.\"  The intent is that this is a \"pretty\" format for printing\ncharacters.  For simple characters that are not printing, what is spelled\nout is the name of the character (see char-name).  For characters that are\nnot simple and not printing, what is spelled out is implementation-defined.\nFor example,\n      (format nil \"~:C\" #\\A) =>  \"A\"\n      (format nil \"~:C\" #\\Space) =>  \"Space\"\n     ;; This next example assumes an implementation-defined \"Control\" attribute.\n      (format nil \"~:C\" #\\Control-Space)\n     =>  \"Control-Space\"\n     OR=> \"c-Space\"\n~:@C prints what ~:C would, and then if the character requires unusual\nshift keys on the keyboard to type it, this fact is mentioned.  For\nexample,\n      (format nil \"~:@C\" #\\Control-Partial) =>  \"Control-\\partial (Top-F)\"\nThis is the format used for telling the user about a key he is expected to\ntype, in prompts, for instance.  The precise output may depend not only on\nthe implementation, but on the particular I/O devices in use.\n~@C prints the character in a way that the Lisp reader can understand,\nusing #\\ syntax.\n~@C  binds *print-escape* to t.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Tilde C-> Character,  Next: Tilde Percent-> Newline,  Prev: FORMAT Basic Output,  Up: FORMAT Basic Output\n\nTilde C: Character\n..................\n\nThe next arg should be a character; it is printed according to the\nmodifier flags.\n\n~C prints the character as if by using write-char if it is a simple\ncharacter.  Characters that are not simple are not necessarily printed as\nif by write-char, but are displayed in an implementation-defined,\nabbreviated format.  For example,\n\n      (format nil \"~C\" #\\A) =>  \"A\"\n      (format nil \"~C\" #\\Space) =>  \" \"\n\n~:C is the same as ~C for printing characters, but other characters are\n\"spelled out.\"  The intent is that this is a \"pretty\" format for printing\ncharacters.  For simple characters that are not printing, what is spelled\nout is the name of the character (see char-name).  For characters that are\nnot simple and not printing, what is spelled out is implementation-defined.\nFor example,\n\n      (format nil \"~:C\" #\\A) =>  \"A\"\n      (format nil \"~:C\" #\\Space) =>  \"Space\"\n     ;; This next example assumes an implementation-defined \"Control\" attribute.\n      (format nil \"~:C\" #\\Control-Space)\n     =>  \"Control-Space\"\n     OR=> \"c-Space\"\n\n~:@C prints what ~:C would, and then if the character requires unusual\nshift keys on the keyboard to type it, this fact is mentioned.  For\nexample,\n\n      (format nil \"~:@C\" #\\Control-Partial) =>  \"Control-\\partial (Top-F)\"\n\nThis is the format used for telling the user about a key he is expected to\ntype, in prompts, for instance.  The precise output may depend not only on\nthe implementation, but on the particular I/O devices in use.\n\n~@C prints the character in a way that the Lisp reader can understand,\nusing #\\ syntax.\n\n~@C  binds *print-escape* to t.\n\n"
}