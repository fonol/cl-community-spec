{
    "name": "if",
    "prev": "cond",
    "next": "or",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "if"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "if",
                    "text": " test-form then-form [else-form] =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "Test-form",
                    "desc": "a form."
                },
                {
                    "name": "Then-form",
                    "desc": "a form."
                },
                {
                    "name": "Else-form",
                    "desc": "a form.  The default is nil."
                },
                {
                    "name": "results",
                    "desc": "if the test-form yielded true, the values returned by the"
                }
            ]
        },
        {
            "type": "Description",
            "text": "if allows the execution of a form to be dependent on a single test-form.\nFirst test-form is evaluated.  If the result is true, then then-form is\nselected; otherwise else-form is selected.  Whichever form is selected is\nthen evaluated.\n"
        },
        {
            "type": "Examples",
            "text": "      (if t 1) =>  1\n      (if nil 1 2) =>  2\n      (defun test ()\n        (dolist (truth-value '(t nil 1 (a b c)))\n          (if truth-value (print 'true) (print 'false))\n          (prin1 truth-value))) =>  TEST\n      (test)\n      |>  TRUE T\n      |>  FALSE NIL\n      |>  TRUE 1\n      |>  TRUE (A B C)\n     =>  NIL\n"
        },
        {
            "type": "See Also",
            "text": "*Note cond:: , unless, *Note when; unless::\n"
        },
        {
            "type": "Notes",
            "text": "      (if test-form then-form else-form)\n      == (cond (test-form then-form) (t else-form))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: if,  Next: or,  Prev: cond,  Up: Data and Control Flow Dictionary\n\nif                                                       [Special Operator]\n---------------------------------------------------------------------------\n\n`if'  test-form then-form [else-form] =>  {result}*\n\nArguments and Values::\n......................\n\nTest-form--a form.\n\nThen-form--a form.\n\nElse-form--a form.  The default is nil.\n\nresults--if the test-form yielded true, the values returned by the\nthen-form; otherwise, the values returned by the else-form.\n\nDescription::\n.............\n\nif allows the execution of a form to be dependent on a single test-form.\n\nFirst test-form is evaluated.  If the result is true, then then-form is\nselected; otherwise else-form is selected.  Whichever form is selected is\nthen evaluated.\n\nExamples::\n..........\n\n      (if t 1) =>  1\n      (if nil 1 2) =>  2\n      (defun test ()\n        (dolist (truth-value '(t nil 1 (a b c)))\n          (if truth-value (print 'true) (print 'false))\n          (prin1 truth-value))) =>  TEST\n      (test)\n      |>  TRUE T\n      |>  FALSE NIL\n      |>  TRUE 1\n      |>  TRUE (A B C)\n     =>  NIL\n\nSee Also::\n..........\n\n*Note cond:: , unless, *Note when; unless::\n\nNotes::\n.......\n\n      (if test-form then-form else-form)\n      == (cond (test-form then-form) (t else-form))\n\n"
}