{
    "name": "Signaling",
    "prev": "Signaling and Handling Conditions",
    "next": "Resignaling a Condition",
    "up": "Signaling and Handling Conditions",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Signaling",
            "text": "When a condition is signaled, the most recent applicable active handler is\ninvoked.  Sometimes a handler will decline by simply returning without a\ntransfer of control.  In such cases, the next most recent applicable\nactive handler is invoked.\nIf there are no applicable handlers for a condition that has been\nsignaled, or if all applicable handlers decline, the condition is\nunhandled.\nThe functions cerror and error invoke the interactive condition handler\n(the debugger) rather than return if the condition being signaled,\nregardless of its type, is unhandled.  In contrast, signal returns nil if\nthe condition being signaled, regardless of its type, is unhandled.\nThe variable *break-on-signals* can be used to cause the debugger to be\nentered before the signaling process begins.\nFigure 9-5 shows defined names relating to the signaling of conditions.\n  *break-on-signals*  error   warn     cerror              signal        \n  Figure 9-5: Defined names relating to signaling conditions.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Signaling,  Next: Resignaling a Condition,  Prev: Signaling and Handling Conditions,  Up: Signaling and Handling Conditions\n\nSignaling\n.........\n\nWhen a condition is signaled, the most recent applicable active handler is\ninvoked.  Sometimes a handler will decline by simply returning without a\ntransfer of control.  In such cases, the next most recent applicable\nactive handler is invoked.\n\nIf there are no applicable handlers for a condition that has been\nsignaled, or if all applicable handlers decline, the condition is\nunhandled.\n\nThe functions cerror and error invoke the interactive condition handler\n(the debugger) rather than return if the condition being signaled,\nregardless of its type, is unhandled.  In contrast, signal returns nil if\nthe condition being signaled, regardless of its type, is unhandled.\n\nThe variable *break-on-signals* can be used to cause the debugger to be\nentered before the signaling process begins.\n\nFigure 9-5 shows defined names relating to the signaling of conditions.\n\n  *break-on-signals*  error   warn     cerror              signal        \n\n  Figure 9-5: Defined names relating to signaling conditions.\n\n\n"
}