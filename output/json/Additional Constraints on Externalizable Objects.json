{
    "name": "Additional Constraints on Externalizable Objects",
    "prev": "Extensions to Similarity Rules",
    "next": null,
    "up": "Literal Objects in Compiled Files",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Additional Constraints on Externalizable Objects",
            "text": "If two literal objects appearing in the source code for a single file\nprocessed with the file compiler are the identical, the corresponding\nobjects in the compiled code must also be the identical.\nWith the exception of symbols and packages, any two literal objects in\ncode being processed by the file compiler may be coalesced if and only if\nthey are similar; if they are either both symbols or both packages, they\nmay only be coalesced if and only if they are identical.\nObjects containing circular references can be externalizable objects.  The\nfile compiler is required to preserve eqlness of substructures within a\nfile.  Preserving eqlness means that subobjects that are the same in the\nsource code must be the same in the corresponding compiled code.\nIn addition, the following are constraints on the handling of literal\nobjects by the file compiler:\n     array: If an array in the source code is a simple array, then the\n     corresponding array in the compiled code will also be a simple array.\n     If an array in the source code is displaced, has a fill pointer, or\n     is actually adjustable, the corresponding array in the compiled code\n     might lack any or all of these qualities. If an array in the source\n     code has a fill pointer, then the corresponding array in the compiled\n     code might be only the size implied by the fill pointer.\n     packages: The loader is required to find the corresponding package\n     object as if by calling find-package with the package name as an\n     argument.  An error of type package-error is signaled if no package\n     of that name exists at load time.\n     random-state: A constant random state object cannot be used as the\n     state argument to the function random because random modifies this\n     data structure.\n     structure, standard-object: Objects of type structure-object and\n     standard-object may appear in compiled constants if there is an\n     appropriate make-load-form method defined for that type.\n     The file compiler calls make-load-form on any object that is\n     referenced as a literal object if the object is a generalized\n     instance of standard-object, structure-object, condition, or any of a\n     (possibly empty) implementation-dependent set of other classes.  The\n     file compiler only calls make-load-form once for any given object\n     within a single file.\n     symbol: In order to guarantee that compiled files can be loaded\n     correctly, users must ensure that the packages referenced in those\n     files are defined consistently at compile time and load time.\n     Conforming programs must satisfy the following requirements:\n    1.\n          The current package when a top level form in the file is\n          processed by compile-file must be the same as the current package\n          when the code corresponding to that top level form in the\n          compiled file is executed by load.  In particular:\n         a.\n               Any top level form in a file that alters the current\n               package must change it to a package of the same name both\n               at compile time and at load time.\n         b.\n               If the first non-atomic top level form in the file is not\n               an in-package form, then the current package at the time\n               load is called must be a package with the same name as the\n               package that was the current package at the time\n               compile-file was called.\n    2.\n          For all symbols appearing lexically within a top level form that\n          were accessible in the package that was the current package\n          during processing of that top level form at compile time, but\n          whose home package was another package, at load time there must\n          be a symbol with the same name that is accessible in both the\n          load-time current package and in the package with the same name\n          as the compile-time home package.\n    3.\n          For all symbols represented in the compiled file that were\n          external symbols in their home package at compile time, there\n          must be a symbol with the same name that is an external symbol\n          in the package with the same name at load time.\n     If any of these conditions do not hold, the package in which the\n     loader looks for the affected symbols is unspecified.\n     Implementations are permitted to signal an error or to define this\n     behavior.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Additional Constraints on Externalizable Objects,  Prev: Extensions to Similarity Rules,  Up: Literal Objects in Compiled Files\n\nAdditional Constraints on Externalizable Objects\n................................................\n\nIf two literal objects appearing in the source code for a single file\nprocessed with the file compiler are the identical, the corresponding\nobjects in the compiled code must also be the identical.\n\nWith the exception of symbols and packages, any two literal objects in\ncode being processed by the file compiler may be coalesced if and only if\nthey are similar; if they are either both symbols or both packages, they\nmay only be coalesced if and only if they are identical.\n\nObjects containing circular references can be externalizable objects.  The\nfile compiler is required to preserve eqlness of substructures within a\nfile.  Preserving eqlness means that subobjects that are the same in the\nsource code must be the same in the corresponding compiled code.\n\nIn addition, the following are constraints on the handling of literal\nobjects by the file compiler:\n\n\n     array: If an array in the source code is a simple array, then the\n     corresponding array in the compiled code will also be a simple array.\n     If an array in the source code is displaced, has a fill pointer, or\n     is actually adjustable, the corresponding array in the compiled code\n     might lack any or all of these qualities. If an array in the source\n     code has a fill pointer, then the corresponding array in the compiled\n     code might be only the size implied by the fill pointer.\n\n\n     packages: The loader is required to find the corresponding package\n     object as if by calling find-package with the package name as an\n     argument.  An error of type package-error is signaled if no package\n     of that name exists at load time.\n\n\n     random-state: A constant random state object cannot be used as the\n     state argument to the function random because random modifies this\n     data structure.\n\n\n     structure, standard-object: Objects of type structure-object and\n     standard-object may appear in compiled constants if there is an\n     appropriate make-load-form method defined for that type.\n\n     The file compiler calls make-load-form on any object that is\n     referenced as a literal object if the object is a generalized\n     instance of standard-object, structure-object, condition, or any of a\n     (possibly empty) implementation-dependent set of other classes.  The\n     file compiler only calls make-load-form once for any given object\n     within a single file.\n\n\n     symbol: In order to guarantee that compiled files can be loaded\n     correctly, users must ensure that the packages referenced in those\n     files are defined consistently at compile time and load time.\n     Conforming programs must satisfy the following requirements:\n\n    1.\n          The current package when a top level form in the file is\n          processed by compile-file must be the same as the current package\n          when the code corresponding to that top level form in the\n          compiled file is executed by load.  In particular:\n\n         a.\n               Any top level form in a file that alters the current\n               package must change it to a package of the same name both\n               at compile time and at load time.\n\n         b.\n               If the first non-atomic top level form in the file is not\n               an in-package form, then the current package at the time\n               load is called must be a package with the same name as the\n               package that was the current package at the time\n               compile-file was called.\n\n    2.\n          For all symbols appearing lexically within a top level form that\n          were accessible in the package that was the current package\n          during processing of that top level form at compile time, but\n          whose home package was another package, at load time there must\n          be a symbol with the same name that is accessible in both the\n          load-time current package and in the package with the same name\n          as the compile-time home package.\n\n    3.\n          For all symbols represented in the compiled file that were\n          external symbols in their home package at compile time, there\n          must be a symbol with the same name that is an external symbol\n          in the package with the same name at load time.\n\n     If any of these conditions do not hold, the package in which the\n     loader looks for the affected symbols is unspecified.\n     Implementations are permitted to signal an error or to define this\n     behavior.\n\n"
}