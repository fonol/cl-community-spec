{
    "name": "Notes about the Implementation of Compiler Macros",
    "prev": "When Compiler Macros Are Used",
    "next": "Minimal Compilation",
    "up": "Compilation Semantics",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Notes about the Implementation of Compiler Macros",
            "text": "Although it is technically permissible, as described above, for eval to\ntreat compiler macros in the same situations as compiler might, this is\nnot necessarily a good idea in interpreted implementations.\nCompiler macros exist for the purpose of trading compile-time speed for\nrun-time speed.  Programmers who write compiler macros tend to assume that\nthe compiler macros can take more time than normal functions and macros in\norder to produce code which is especially optimal for use at run time.\nSince eval in an interpreted implementation might perform semantic\nanalysis of the same form multiple times, it might be inefficient in\ngeneral for the implementation to choose to call compiler macros on every\nsuch evaluation.\nNevertheless, the decision about what to do in these situations is left to\neach implementation.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Notes about the Implementation of Compiler Macros,  Next: Minimal Compilation,  Prev: When Compiler Macros Are Used,  Up: Compilation Semantics\n\nNotes about the Implementation of Compiler Macros\n.................................................\n\nAlthough it is technically permissible, as described above, for eval to\ntreat compiler macros in the same situations as compiler might, this is\nnot necessarily a good idea in interpreted implementations.\n\nCompiler macros exist for the purpose of trading compile-time speed for\nrun-time speed.  Programmers who write compiler macros tend to assume that\nthe compiler macros can take more time than normal functions and macros in\norder to produce code which is especially optimal for use at run time.\nSince eval in an interpreted implementation might perform semantic\nanalysis of the same form multiple times, it might be inefficient in\ngeneral for the implementation to choose to call compiler macros on every\nsuch evaluation.\n\nNevertheless, the decision about what to do in these situations is left to\neach implementation.\n\n"
}