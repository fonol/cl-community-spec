{
    "name": "char-upcase",
    "prev": "standard-char-p",
    "next": "upper-case-p",
    "up": "Characters Dictionary",
    "header": {
        "type": "Function",
        "text": "char-upcase, char-downcase"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "char-upcase",
                    "text": " character =>  corresponding-character\n"
                },
                {
                    "name": "char-downcase",
                    "text": " character =>  corresponding-character\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "character, corresponding-character",
                    "desc": "a character."
                }
            ]
        },
        {
            "type": "Description",
            "text": "If character is a lowercase character, char-upcase returns the\ncorresponding uppercase character.  Otherwise, char-upcase just returns\nthe given character.\nIf character is an uppercase character, char-downcase returns the\ncorresponding lowercase character.  Otherwise, char-downcase just returns\nthe given character.\nThe result only ever differs from character in its code attribute; all\nimplementation-defined attributes are preserved.\n"
        },
        {
            "type": "Examples",
            "text": "      (char-upcase #\\a) =>  #\\A\n      (char-upcase #\\A) =>  #\\A\n      (char-downcase #\\a) =>  #\\a\n      (char-downcase #\\A) =>  #\\a\n      (char-upcase #\\9) =>  #\\9\n      (char-downcase #\\9) =>  #\\9\n      (char-upcase #\\@) =>  #\\@\n      (char-downcase #\\@) =>  #\\@\n      ;; Note that this next example might run for a very long time in\n      ;; some implementations if CHAR-CODE-LIMIT happens to be very large\n      ;; for that implementation.\n      (dotimes (code char-code-limit)\n        (let ((char (code-char code)))\n          (when char\n            (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))\n                          ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))\n                          (t (and (char= (char-upcase (char-downcase char)) char)\n                                  (char= (char-downcase (char-upcase char)) char))))\n              (return char)))))\n     =>  NIL\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if character is not a character.\n"
        },
        {
            "type": "See Also",
            "text": "*Note upper-case-p; lower-case-p; both-case-p:: , *Note alpha-char-p:: ,\n*Note Characters With Case::, *Note Documentation of\nImplementation-Defined Scripts::\n"
        },
        {
            "type": "Notes",
            "text": "If the corresponding-char is different than character, then both the\ncharacter and the corresponding-char have case.\nSince char-equal ignores the case of the characters it compares, the\ncorresponding-character is always the same as character under char-equal.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: char-upcase,  Next: upper-case-p,  Prev: standard-char-p,  Up: Characters Dictionary\n\nchar-upcase, char-downcase                                       [Function]\n---------------------------------------------------------------------------\n\n`char-upcase'  character =>  corresponding-character\n\n`char-downcase'  character =>  corresponding-character\n\nArguments and Values::\n......................\n\ncharacter, corresponding-character--a character.\n\nDescription::\n.............\n\nIf character is a lowercase character, char-upcase returns the\ncorresponding uppercase character.  Otherwise, char-upcase just returns\nthe given character.\n\nIf character is an uppercase character, char-downcase returns the\ncorresponding lowercase character.  Otherwise, char-downcase just returns\nthe given character.\n\nThe result only ever differs from character in its code attribute; all\nimplementation-defined attributes are preserved.\n\nExamples::\n..........\n\n      (char-upcase #\\a) =>  #\\A\n      (char-upcase #\\A) =>  #\\A\n      (char-downcase #\\a) =>  #\\a\n      (char-downcase #\\A) =>  #\\a\n      (char-upcase #\\9) =>  #\\9\n      (char-downcase #\\9) =>  #\\9\n      (char-upcase #\\@) =>  #\\@\n      (char-downcase #\\@) =>  #\\@\n      ;; Note that this next example might run for a very long time in\n      ;; some implementations if CHAR-CODE-LIMIT happens to be very large\n      ;; for that implementation.\n      (dotimes (code char-code-limit)\n        (let ((char (code-char code)))\n          (when char\n            (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))\n                          ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))\n                          (t (and (char= (char-upcase (char-downcase char)) char)\n                                  (char= (char-downcase (char-upcase char)) char))))\n              (return char)))))\n     =>  NIL\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if character is not a character.\n\nSee Also::\n..........\n\n*Note upper-case-p; lower-case-p; both-case-p:: , *Note alpha-char-p:: ,\n*Note Characters With Case::, *Note Documentation of\nImplementation-Defined Scripts::\n\nNotes::\n.......\n\nIf the corresponding-char is different than character, then both the\ncharacter and the corresponding-char have case.\n\nSince char-equal ignores the case of the characters it compares, the\ncorresponding-character is always the same as character under char-equal.\n\n"
}