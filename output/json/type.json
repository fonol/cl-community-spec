{
    "name": "type",
    "prev": "dynamic-extent",
    "next": "inline",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Declaration",
        "text": "type"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "text": "(type typespec {var}*)\n(typespec {var}*)\n"
        },
        {
            "type": "Arguments",
            "text": "typespec--a type specifier.\nvar--a variable name.\n"
        },
        {
            "type": "Valid Context",
            "text": "declaration or proclamation\n"
        },
        {
            "type": "Binding Types Affected",
            "text": "variable\n"
        },
        {
            "type": "Description",
            "text": "Affects only variable bindings and specifies that the vars take on values\nonly of the specified typespec.  In particular, values assigned to the\nvariables by setq, as well as the initial values of the vars must be of\nthe specified typespec.  type declarations never apply to function\nbindings (see ftype).\nA type declaration of a symbol defined by symbol-macrolet is equivalent to\nwrapping a the expression around the expansion of that symbol,\nalthough the symbol's macro expansion is not actually affected.\nThe meaning of a type declaration is equivalent to changing each reference\nto a variable (var) within the scope of the declaration to (the typespec\nvar), changing each expression assigned to the variable (new-value) within\nthe scope of the declaration to (the typespec new-value), and executing\n(the typespec var) at the moment the scope of the declaration is entered.\nA type declaration is valid in all declarations. The interpretation of a\ntype declaration is as follows:\n1.\n     During the execution of any reference to the declared variable within\n     the scope of the declaration, the consequences are undefined if the\n     value of the declared variable is not of the declared type.\n2.\n     During the execution of any setq of the declared variable within the\n     scope of the declaration, the consequences are undefined if the newly\n     assigned value of the declared variable is not of the declared type.\n3.\n     At the moment the scope of the declaration is entered, the\n     consequences are undefined if the value of the declared variable is\n     not of the declared type.\nA type declaration affects only variable references within its scope.\nIf nested type declarations refer to the same variable, then the value of\nthe variable must be a member of the intersection of the declared types.\nIf there is a local type declaration for a dynamic variable, and there is\nalso a global type proclamation for that same variable, then the value of\nthe variable within the scope of the local declaration must be a member of\nthe intersection of the two declared types.\ntype declarations can  be free declarations or bound declarations.\nA symbol cannot be both the name of a type and the name of a declaration.\nDefining a symbol as the name of a class, structure, condition, or type,\nwhen the symbol has been declared as a declaration name, or vice versa,\nsignals an error.\nWithin the lexical scope of an array type declaration, all references to\narray elements are assumed to satisfy the expressed array element type (as\nopposed to the upgraded array element type).  A compiler can treat the\ncode within the scope of the array type declaration as if each access of\nan array element were surrounded by an appropriate the form.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun f (x y)\n        (declare (type fixnum x y))\n        (let ((z (+ x y)))\n          (declare (type fixnum z))\n          z)) =>  F\n      (f 1 2) =>  3\n      ;; The previous definition of F is equivalent to\n      (defun f (x y)\n        ;; This declaration is a shorthand form of the TYPE declaration\n        (declare (fixnum x y))\n        ;; To declare the type of a return value, it's not necessary to\n        ;; create a named variable.  A THE special form can be used instead.\n        (the fixnum (+ x y))) =>  F\n      (f 1 2) =>  3\n      (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))\n      (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))\n      (defun frob (an-array)\n        (declare (type (array (signed-byte 5) 1) an-array))\n        (setf (aref an-array 1) 31)\n        (setf (aref an-array 2) 127)\n        (setf (aref an-array 3) (* 2 (aref an-array 3)))\n        (let ((foo 0))\n          (declare (type (signed-byte 5) foo))\n          (setf foo (aref an-array 0))))\n      (frob *one-array*)\n      (frob *another-array*)\nThe above definition of frob is equivalent to:\n      (defun frob (an-array)\n        (setf (the (signed-byte 5) (aref an-array 1)) 31)\n        (setf (the (signed-byte 5) (aref an-array 2)) 127)\n        (setf (the (signed-byte 5) (aref an-array 3))\n              (* 2 (the (signed-byte 5) (aref an-array 3))))\n        (let ((foo 0))\n          (declare (type (signed-byte 5) foo))\n          (setf foo (the (signed-byte 5) (aref an-array 0)))))\nGiven an implementation in which fixnums are 29 bits but fixnum arrays are\nupgraded to signed 32-bit arrays, the following could be compiled with all\nfixnum arithmetic:\n      (defun bump-counters (counters)\n        (declare (type (array fixnum *) bump-counters))\n        (dotimes (i (length counters))\n          (incf (aref counters i))))\n"
        },
        {
            "type": "See Also",
            "text": "declare, *Note declaim:: , *Note proclaim::\n"
        },
        {
            "type": "Notes",
            "text": "(typespec {var}*) is an abbreviation for (type typespec {var}*).\nA type declaration for the arguments to a function does not necessarily\nimply anything about the type of the result.  The following function is\nnot permitted to be compiled using implementation-dependent fixnum-only\narithmetic:\n      (defun f (x y) (declare (fixnum x y)) (+ x y))\nTo see why, consider (f most-positive-fixnum 1).  Common Lisp defines that\nF must return a bignum here, rather than signal an error or produce a\nmathematically incorrect result.  If you have special knowledge such\n\"fixnum overflow\" cases will not come up, you can declare the result value\nto be in the fixnum range, enabling some compilers to use more efficient\narithmetic:\n      (defun f (x y)\n        (declare (fixnum x y))\n        (the fixnum (+ x y)))\nNote, however, that in the three-argument case, because of the possibility\nof an implicit intermediate value growing too large, the following will not\ncause implementation-dependent fixnum-only arithmetic to be used:\n      (defun f (x y)\n        (declare (fixnum x y z))\n        (the fixnum (+ x y z)))\nTo see why, consider (f most-positive-fixnum 1 -1).  Although the\narguments and the result are all fixnums, an intermediate value is not a\nfixnum.  If it is important that implementation-dependent fixnum-only\narithmetic be selected in implementations that provide it, consider\nwriting something like this instead:\n      (defun f (x y)\n        (declare (fixnum x y z))\n        (the fixnum (+ (the fixnum (+ x y)) z)))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: type,  Next: inline,  Prev: dynamic-extent,  Up: Evaluation and Compilation Dictionary\n\ntype                                                          [Declaration]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n(type typespec {var}*)\n\n(typespec {var}*)\n\nArguments::\n...........\n\ntypespec--a type specifier.\n\nvar--a variable name.\n\nValid Context::\n...............\n\ndeclaration or proclamation\n\nBinding Types Affected::\n........................\n\nvariable\n\nDescription::\n.............\n\nAffects only variable bindings and specifies that the vars take on values\nonly of the specified typespec.  In particular, values assigned to the\nvariables by setq, as well as the initial values of the vars must be of\nthe specified typespec.  type declarations never apply to function\nbindings (see ftype).\n\nA type declaration of a symbol defined by symbol-macrolet is equivalent to\nwrapping a the expression around the expansion of that symbol,\n\nalthough the symbol's macro expansion is not actually affected.\n\nThe meaning of a type declaration is equivalent to changing each reference\nto a variable (var) within the scope of the declaration to (the typespec\nvar), changing each expression assigned to the variable (new-value) within\nthe scope of the declaration to (the typespec new-value), and executing\n(the typespec var) at the moment the scope of the declaration is entered.\n\nA type declaration is valid in all declarations. The interpretation of a\ntype declaration is as follows:\n1.\n     During the execution of any reference to the declared variable within\n     the scope of the declaration, the consequences are undefined if the\n     value of the declared variable is not of the declared type.\n\n2.\n     During the execution of any setq of the declared variable within the\n     scope of the declaration, the consequences are undefined if the newly\n     assigned value of the declared variable is not of the declared type.\n\n3.\n     At the moment the scope of the declaration is entered, the\n     consequences are undefined if the value of the declared variable is\n     not of the declared type.\n\nA type declaration affects only variable references within its scope.\n\nIf nested type declarations refer to the same variable, then the value of\nthe variable must be a member of the intersection of the declared types.\n\nIf there is a local type declaration for a dynamic variable, and there is\nalso a global type proclamation for that same variable, then the value of\nthe variable within the scope of the local declaration must be a member of\nthe intersection of the two declared types.\n\ntype declarations can  be free declarations or bound declarations.\n\nA symbol cannot be both the name of a type and the name of a declaration.\nDefining a symbol as the name of a class, structure, condition, or type,\nwhen the symbol has been declared as a declaration name, or vice versa,\nsignals an error.\n\nWithin the lexical scope of an array type declaration, all references to\narray elements are assumed to satisfy the expressed array element type (as\nopposed to the upgraded array element type).  A compiler can treat the\ncode within the scope of the array type declaration as if each access of\nan array element were surrounded by an appropriate the form.\n\nExamples::\n..........\n\n      (defun f (x y)\n        (declare (type fixnum x y))\n        (let ((z (+ x y)))\n          (declare (type fixnum z))\n          z)) =>  F\n      (f 1 2) =>  3\n      ;; The previous definition of F is equivalent to\n      (defun f (x y)\n        ;; This declaration is a shorthand form of the TYPE declaration\n        (declare (fixnum x y))\n        ;; To declare the type of a return value, it's not necessary to\n        ;; create a named variable.  A THE special form can be used instead.\n        (the fixnum (+ x y))) =>  F\n      (f 1 2) =>  3\n\n      (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))\n      (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))\n     \n      (defun frob (an-array)\n        (declare (type (array (signed-byte 5) 1) an-array))\n        (setf (aref an-array 1) 31)\n        (setf (aref an-array 2) 127)\n        (setf (aref an-array 3) (* 2 (aref an-array 3)))\n        (let ((foo 0))\n          (declare (type (signed-byte 5) foo))\n          (setf foo (aref an-array 0))))\n     \n      (frob *one-array*)\n      (frob *another-array*)\n\nThe above definition of frob is equivalent to:\n\n      (defun frob (an-array)\n        (setf (the (signed-byte 5) (aref an-array 1)) 31)\n        (setf (the (signed-byte 5) (aref an-array 2)) 127)\n        (setf (the (signed-byte 5) (aref an-array 3))\n              (* 2 (the (signed-byte 5) (aref an-array 3))))\n        (let ((foo 0))\n          (declare (type (signed-byte 5) foo))\n          (setf foo (the (signed-byte 5) (aref an-array 0)))))\n\nGiven an implementation in which fixnums are 29 bits but fixnum arrays are\nupgraded to signed 32-bit arrays, the following could be compiled with all\nfixnum arithmetic:\n\n      (defun bump-counters (counters)\n        (declare (type (array fixnum *) bump-counters))\n        (dotimes (i (length counters))\n          (incf (aref counters i))))\n\nSee Also::\n..........\n\ndeclare, *Note declaim:: , *Note proclaim::\n\nNotes::\n.......\n\n(typespec {var}*) is an abbreviation for (type typespec {var}*).\n\nA type declaration for the arguments to a function does not necessarily\nimply anything about the type of the result.  The following function is\nnot permitted to be compiled using implementation-dependent fixnum-only\narithmetic:\n\n      (defun f (x y) (declare (fixnum x y)) (+ x y))\n\nTo see why, consider (f most-positive-fixnum 1).  Common Lisp defines that\nF must return a bignum here, rather than signal an error or produce a\nmathematically incorrect result.  If you have special knowledge such\n\"fixnum overflow\" cases will not come up, you can declare the result value\nto be in the fixnum range, enabling some compilers to use more efficient\narithmetic:\n\n      (defun f (x y)\n        (declare (fixnum x y))\n        (the fixnum (+ x y)))\n\nNote, however, that in the three-argument case, because of the possibility\nof an implicit intermediate value growing too large, the following will not\ncause implementation-dependent fixnum-only arithmetic to be used:\n\n      (defun f (x y)\n        (declare (fixnum x y z))\n        (the fixnum (+ x y z)))\n\nTo see why, consider (f most-positive-fixnum 1 -1).  Although the\narguments and the result are all fixnums, an intermediate value is not a\nfixnum.  If it is important that implementation-dependent fixnum-only\narithmetic be selected in implementations that provide it, consider\nwriting something like this instead:\n\n      (defun f (x y)\n        (declare (fixnum x y z))\n        (the fixnum (+ (the fixnum (+ x y)) z)))\n\n"
}