{
    "name": "Evaluation of Subforms to Places",
    "prev": "Overview of Places and Generalized Reference",
    "next": "Examples of Evaluation of Subforms to Places",
    "up": "Overview of Places and Generalized Reference",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Evaluation of Subforms to Places",
            "text": "The following rules apply to the evaluation of subforms in a place:\n1.\n     The evaluation ordering of subforms within a place is determined by\n     the order specified by the second value returned by\n     get-setf-expansion.\n     For all places defined by this specification (e.g., getf, ldb, ...),\n     this order of evaluation is left-to-right.\n     When a place is derived from a macro expansion, this rule is applied\n     after the macro is expanded to find the appropriate place.\n     Places defined by using defmacro or\n     define-setf-expander\n     use the evaluation order defined by those definitions.  For example,\n     consider the following:\n           (defmacro wrong-order (x y) `(getf ,y ,x))\n     This following form evaluates place2 first and then place1 because\n     that is the order they are evaluated in the macro expansion:\n           (push value (wrong-order place1 place2))\n2.\n     For the macros that manipulate places (push, pushnew, remf, incf,\n     decf, shiftf, rotatef, psetf, setf, pop, and those defined by\n     define-modify-macro) the subforms of the macro call are evaluated\n     exactly once in left-to-right order, with the subforms of the places\n     evaluated in the order specified in (1).\n     push, pushnew, remf, incf, decf, shiftf, rotatef, psetf, pop evaluate\n     all subforms before modifying any of the place locations.  setf (in\n     the case when setf has more than two arguments) performs its\n     operation on each pair in sequence. For example, in\n           (setf place1 value1 place2 value2 ...)\n     the subforms of place1 and value1 are evaluated, the location\n     specified by place1 is modified to contain the value returned by\n     value1, and then the rest of the setf form is processed in a like\n     manner.\n3.\n     For check-type, ctypecase, and ccase, subforms of the place are\n     evaluated once as in (1), but might be evaluated again if the type\n     check fails in the case of check-type or none of the cases hold in\n     ctypecase and ccase.\n4.\n     For assert, the order of evaluation of the generalized references is\n     not specified.\nRules 2, 3 and 4 cover all standardized macros that manipulate places.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Evaluation of Subforms to Places,  Next: Examples of Evaluation of Subforms to Places,  Prev: Overview of Places and Generalized Reference,  Up: Overview of Places and Generalized Reference\n\nEvaluation of Subforms to Places\n................................\n\nThe following rules apply to the evaluation of subforms in a place:\n\n1.\n     The evaluation ordering of subforms within a place is determined by\n     the order specified by the second value returned by\n\n     get-setf-expansion.\n\n     For all places defined by this specification (e.g., getf, ldb, ...),\n     this order of evaluation is left-to-right.\n\n     When a place is derived from a macro expansion, this rule is applied\n     after the macro is expanded to find the appropriate place.\n\n     Places defined by using defmacro or\n\n     define-setf-expander\n\n     use the evaluation order defined by those definitions.  For example,\n     consider the following:\n\n           (defmacro wrong-order (x y) `(getf ,y ,x))\n\n     This following form evaluates place2 first and then place1 because\n     that is the order they are evaluated in the macro expansion:\n\n           (push value (wrong-order place1 place2))\n\n2.\n     For the macros that manipulate places (push, pushnew, remf, incf,\n     decf, shiftf, rotatef, psetf, setf, pop, and those defined by\n     define-modify-macro) the subforms of the macro call are evaluated\n     exactly once in left-to-right order, with the subforms of the places\n     evaluated in the order specified in (1).\n\n     push, pushnew, remf, incf, decf, shiftf, rotatef, psetf, pop evaluate\n     all subforms before modifying any of the place locations.  setf (in\n     the case when setf has more than two arguments) performs its\n     operation on each pair in sequence. For example, in\n\n           (setf place1 value1 place2 value2 ...)\n\n     the subforms of place1 and value1 are evaluated, the location\n     specified by place1 is modified to contain the value returned by\n     value1, and then the rest of the setf form is processed in a like\n     manner.\n\n3.\n     For check-type, ctypecase, and ccase, subforms of the place are\n     evaluated once as in (1), but might be evaluated again if the type\n     check fails in the case of check-type or none of the cases hold in\n     ctypecase and ccase.\n\n4.\n     For assert, the order of evaluation of the generalized references is\n     not specified.\n\nRules 2, 3 and 4 cover all standardized macros that manipulate places.\n\n"
}