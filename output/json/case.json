{
    "name": "case",
    "prev": "when",
    "next": "typecase",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "case, ccase, ecase"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "case",
                    "text": " keyform  {!normal-clause}* [!otherwise-clause] =>  {result}*\n"
                },
                {
                    "name": "ccase",
                    "text": " keyplace {!normal-clause}* =>  {result}*\n\n"
                },
                {
                    "name": "ecase",
                    "text": " keyform  {!normal-clause}* =>  {result}*\n\nnormal-clause ::=(keys {form}*)\n\notherwise-clause ::=({otherwise | t} {form}*)\n\nclause ::=normal-clause | otherwise-clause\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "keyform",
                    "desc": "a form; evaluated to produce a test-key."
                },
                {
                    "name": "keyplace",
                    "desc": "a form; evaluated initially to produce a test-key.  Possibly"
                },
                {
                    "name": "keyplace",
                    "desc": "a form; evaluated initially to produce a test-key.  Possiblyalso used later as a place if no keys match.\n"
                },
                {
                    "name": "test-key",
                    "desc": "an object produced by evaluating keyform or keyplace."
                },
                {
                    "name": "keys",
                    "desc": "a designator for a list of objects.  In the case of case, thesymbols t and otherwise may not be used as the keys designator.  To refer\nto these symbols by themselves as keys, the designators (t) and\n(otherwise), respectively, must be used instead.\n"
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the forms in the matching clause."
                }
            ]
        },
        {
            "type": "Description",
            "text": "These macros allow the conditional execution of a body of forms in a\nclause that is selected by matching the test-key on the basis of its\nidentity.\nThe keyform or keyplace is evaluated to produce the test-key.\nEach of the normal-clauses is then considered in turn.  If the test-key is\nthe same as any key for that clause, the forms in that clause are\nevaluated as an implicit progn, and the values it returns are returned as\nthe value of the case, ccase, or ecase form.\nThese macros differ only in their behavior when no normal-clause matches;\nspecifically:\ncase\n     If no normal-clause matches, and there is an otherwise-clause, then\n     that otherwise-clause automatically matches; the forms in that clause\n     are evaluated as an implicit progn, and the values it returns are\n     returned as the value of the case.\n     If there is no otherwise-clause, case returns nil.\nccase\n     If no normal-clause matches, a correctable error of type type-error\n     is signaled.  The offending datum is the test-key and the expected\n     type is type equivalent to (member key1 key2 ...).  The store-value\n     restart can be used to correct the error.\n     If the store-value restart is invoked, its argument becomes the new\n     test-key, and is stored in keyplace as if by (setf keyplace test-key).\n     Then ccase starts over, considering each clause anew.\n     [Reviewer Note by Barmar: Will it prompt for multiple values if\n     keyplace is a VALUES general ref?]\n     The subforms of keyplace might be evaluated again if none of the\n     cases holds.\necase\n     If no normal-clause matches, a non-correctable error of type\n     type-error is signaled.  The offending datum is the test-key and the\n     expected type is type equivalent to (member key1 key2 ...).\n     Note that in contrast with ccase, the caller of ecase may rely on the\n     fact that ecase does not return if a normal-clause does not match.\n"
        },
        {
            "type": "Examples",
            "text": "      (dolist (k '(1 2 3 :four #\\v () t 'other))\n         (format t \"~S \"\n            (case k ((1 2) 'clause1)\n                    (3 'clause2)\n                    (nil 'no-keys-so-never-seen)\n                    ((nil) 'nilslot)\n                    ((:four #\\v) 'clause4)\n                    ((t) 'tslot)\n                    (otherwise 'others))))\n      |>  CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS\n     =>  NIL\n      (defun add-em (x) (apply #'+ (mapcar #'decode x)))\n     =>  ADD-EM\n      (defun decode (x)\n        (ccase x\n          ((i uno) 1)\n          ((ii dos) 2)\n          ((iii tres) 3)\n          ((iv cuatro) 4)))\n     =>  DECODE\n      (add-em '(uno iii)) =>  4\n      (add-em '(uno iiii))\n      |>  Error: The value of X, IIII, is not I, UNO, II, DOS, III,\n      |>         TRES, IV, or CUATRO.\n      |>   1: Supply a value to use instead.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Value to evaluate and use for X: |>>'IV<<|\n     =>  5\n"
        },
        {
            "type": "Side Effects",
            "text": "The debugger might be entered.  If the store-value restart is invoked, the\nvalue of keyplace might be changed.\n"
        },
        {
            "type": "Affected By",
            "text": "ccase and ecase, since they might signal an error, are potentially\naffected by existing handlers and *debug-io*.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "ccase and ecase signal an error of type type-error if no normal-clause\nmatches.\n"
        },
        {
            "type": "See Also",
            "text": "*Note cond:: , *Note typecase; ctypecase; etypecase:: , *Note setf; psetf::\n, *Note Generalized Reference::\n"
        },
        {
            "type": "Notes",
            "text": "     (case test-key\n       {(({key}*) {form}*)}*)\n     ==\n     (let ((#1=#:g0001 test-key))\n       (cond {((member #1# '({key}*)) {form}*)}*))\nThe specific error message used by ecase and ccase can vary between\nimplementations.  In situations where control of the specific wording of\nthe error message is important, it is better to use case with an\notherwise-clause that explicitly signals an error with an appropriate\nmessage.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: case,  Next: typecase,  Prev: when,  Up: Data and Control Flow Dictionary\n\ncase, ccase, ecase                                                  [Macro]\n---------------------------------------------------------------------------\n\n`case'  keyform  {!normal-clause}* [!otherwise-clause] =>  {result}*\n\n`ccase'  keyplace {!normal-clause}* =>  {result}*\n\n`ecase'  keyform  {!normal-clause}* =>  {result}*\n\nnormal-clause ::=(keys {form}*)\n\notherwise-clause ::=({otherwise | t} {form}*)\n\nclause ::=normal-clause | otherwise-clause\n\nArguments and Values::\n......................\n\nkeyform--a form; evaluated to produce a test-key.\n\nkeyplace--a form; evaluated initially to produce a test-key.  Possibly\nalso used later as a place if no keys match.\n\ntest-key--an object produced by evaluating keyform or keyplace.\n\nkeys--a designator for a list of objects.  In the case of case, the\nsymbols t and otherwise may not be used as the keys designator.  To refer\nto these symbols by themselves as keys, the designators (t) and\n(otherwise), respectively, must be used instead.\n\nforms--an implicit progn.\n\nresults--the values returned by the forms in the matching clause.\n\nDescription::\n.............\n\nThese macros allow the conditional execution of a body of forms in a\nclause that is selected by matching the test-key on the basis of its\nidentity.\n\nThe keyform or keyplace is evaluated to produce the test-key.\n\nEach of the normal-clauses is then considered in turn.  If the test-key is\nthe same as any key for that clause, the forms in that clause are\nevaluated as an implicit progn, and the values it returns are returned as\nthe value of the case, ccase, or ecase form.\n\nThese macros differ only in their behavior when no normal-clause matches;\nspecifically:\n\ncase\n     If no normal-clause matches, and there is an otherwise-clause, then\n     that otherwise-clause automatically matches; the forms in that clause\n     are evaluated as an implicit progn, and the values it returns are\n     returned as the value of the case.\n\n     If there is no otherwise-clause, case returns nil.\n\nccase\n     If no normal-clause matches, a correctable error of type type-error\n     is signaled.  The offending datum is the test-key and the expected\n     type is type equivalent to (member key1 key2 ...).  The store-value\n     restart can be used to correct the error.\n\n     If the store-value restart is invoked, its argument becomes the new\n     test-key, and is stored in keyplace as if by (setf keyplace test-key).\n     Then ccase starts over, considering each clause anew.\n\n     [Reviewer Note by Barmar: Will it prompt for multiple values if\n     keyplace is a VALUES general ref?]\n\n     The subforms of keyplace might be evaluated again if none of the\n     cases holds.\n\necase\n     If no normal-clause matches, a non-correctable error of type\n     type-error is signaled.  The offending datum is the test-key and the\n     expected type is type equivalent to (member key1 key2 ...).\n\n     Note that in contrast with ccase, the caller of ecase may rely on the\n     fact that ecase does not return if a normal-clause does not match.\n\nExamples::\n..........\n\n      (dolist (k '(1 2 3 :four #\\v () t 'other))\n         (format t \"~S \"\n            (case k ((1 2) 'clause1)\n                    (3 'clause2)\n                    (nil 'no-keys-so-never-seen)\n                    ((nil) 'nilslot)\n                    ((:four #\\v) 'clause4)\n                    ((t) 'tslot)\n                    (otherwise 'others))))\n      |>  CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS\n     =>  NIL\n      (defun add-em (x) (apply #'+ (mapcar #'decode x)))\n     =>  ADD-EM\n      (defun decode (x)\n        (ccase x\n          ((i uno) 1)\n          ((ii dos) 2)\n          ((iii tres) 3)\n          ((iv cuatro) 4)))\n     =>  DECODE\n      (add-em '(uno iii)) =>  4\n      (add-em '(uno iiii))\n      |>  Error: The value of X, IIII, is not I, UNO, II, DOS, III,\n      |>         TRES, IV, or CUATRO.\n      |>   1: Supply a value to use instead.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Value to evaluate and use for X: |>>'IV<<|\n     =>  5\n\nSide Effects::\n..............\n\nThe debugger might be entered.  If the store-value restart is invoked, the\nvalue of keyplace might be changed.\n\nAffected By::\n.............\n\nccase and ecase, since they might signal an error, are potentially\naffected by existing handlers and *debug-io*.\n\nExceptional Situations::\n........................\n\nccase and ecase signal an error of type type-error if no normal-clause\nmatches.\n\nSee Also::\n..........\n\n*Note cond:: , *Note typecase; ctypecase; etypecase:: , *Note setf; psetf::\n, *Note Generalized Reference::\n\nNotes::\n.......\n\n     (case test-key\n       {(({key}*) {form}*)}*)\n     ==\n     (let ((#1=#:g0001 test-key))\n       (cond {((member #1# '({key}*)) {form}*)}*))\n\nThe specific error message used by ecase and ccase can vary between\nimplementations.  In situations where control of the specific wording of\nthe error message is important, it is better to use case with an\notherwise-clause that explicitly signals an error with an appropriate\nmessage.\n\n"
}