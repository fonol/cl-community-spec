{
    "name": "make-load-form",
    "prev": "make-instances-obsolete",
    "next": "make-load-form-saving-slots",
    "up": "Objects Dictionary",
    "header": {
        "type": "Standard Generic Function",
        "text": "make-load-form"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "make-load-form",
                    "text": " object &optional environment =>  creation-form[,initialization-form]\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "make-load-form",
                    "text": " (object standard-object)  &optional environment\n"
                },
                {
                    "name": "make-load-form",
                    "text": " (object structure-object) &optional environment\n\n"
                },
                {
                    "name": "make-load-form",
                    "text": " (object condition)        &optional environment\n\n"
                },
                {
                    "name": "make-load-form",
                    "text": " (object class)            &optional environment\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "object",
                    "desc": "an object."
                },
                {
                    "name": "environment",
                    "desc": "an environment object."
                },
                {
                    "name": "creation-form",
                    "desc": "a form."
                },
                {
                    "name": "initialization-form",
                    "desc": "a form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The generic function make-load-form creates and returns one or two forms,\na creation-form and an initialization-form, that enable load to construct\nan object equivalent to object.  Environment is an environment object\ncorresponding to the lexical environment in which the forms will be\nprocessed.\nThe file compiler calls make-load-form to process certain classes of\nliteral objects; see *Note Additional Constraints on Externalizable\nObjects::.\nConforming programs may call make-load-form directly, providing object is\na generalized instance of standard-object, structure-object, or condition.\nThe creation form is a form that, when evaluated at load time, should\nreturn an object that is equivalent to object.  The exact meaning of\nequivalent depends on the type of object and is up to the programmer who\ndefines a method for make-load-form; see *Note Literal Objects in Compiled\nFiles::.\nThe initialization form is a form that, when evaluated at load time,\nshould perform further initialization of the object.  The value returned\nby the initialization form is ignored.  If make-load-form returns only one\nvalue, the initialization form is nil, which has no effect.  If object\nappears as a constant in the initialization form, at load time it will be\nreplaced by the equivalent object constructed by the creation form; this\nis how the further initialization gains access to the object.\nBoth the creation-form and the initialization-form may contain references\nto any externalizable object.  However, there must not be any circular\ndependencies in creation forms.  An example of a circular dependency is\nwhen the creation form for the object X contains a reference to the object\nY, and the creation form for the object Y contains a reference to the\nobject X.  Initialization forms are not subject to any restriction against\ncircular dependencies, which is the reason that initialization forms exist;\nsee the example of circular data structures below.\nThe creation form for an object is always evaluated before the\ninitialization form for that object.  When either the creation form or the\ninitialization form references other objects that have not been referenced\nearlier in the file being compiled, the compiler ensures that all of the\nreferenced objects have been created before evaluating the referencing\nform.  When the referenced object is of a type which the file compiler\nprocesses using make-load-form, this involves evaluating the creation form\nreturned for it.  (This is the reason for the prohibition against circular\nreferences among creation forms).\nEach initialization form is evaluated as soon as possible after its\nassociated creation form, as determined by data flow.  If the\ninitialization form for an object does not reference any other objects not\nreferenced earlier in the file and processed by the file compiler using\nmake-load-form, the initialization form is evaluated immediately after the\ncreation form.  If a creation or initialization form F does contain\nreferences to such objects, the creation forms for those other objects are\nevaluated before F, and the initialization forms for those other objects\nare also evaluated before F whenever they do not depend on the object\ncreated or initialized by F.  Where these rules do not uniquely determine\nan order of evaluation between two creation/initialization forms, the\norder of evaluation is unspecified.\nWhile these creation and initialization forms are being evaluated, the\nobjects are possibly in an uninitialized state, analogous to the state of\nan object between the time it has been created by allocate-instance and it\nhas been processed fully by initialize-instance.  Programmers writing\nmethods for make-load-form must take care in manipulating objects not to\ndepend on slots that have not yet been initialized.\nIt is implementation-dependent whether load calls eval on the forms or\ndoes some other operation that has an equivalent effect.  For example, the\nforms might be translated into different but equivalent forms and then\nevaluated, they might be compiled and the resulting functions called by\nload, or they might be interpreted by a special-purpose function different\nfrom eval.  All that is required is that the effect be equivalent to\nevaluating the forms.\nThe method specialized on class returns a creation form using the name of\nthe class if the class has a proper name in environment, signaling an\nerror of type error if it does not have a proper name.  Evaluation of the\ncreation form uses the name to find the class with that name, as if by\ncalling find-class.  If a class with that name has not been defined, then\na class may be computed in an implementation-defined manner.  If a class\ncannot be returned as the result of evaluating the creation form, then an\nerror of type error is signaled.\nBoth conforming implementations and conforming programs may further\nspecialize make-load-form.\n"
        },
        {
            "type": "Examples",
            "text": "      (defclass obj ()\n         ((x :initarg :x :reader obj-x)\n          (y :initarg :y :reader obj-y)\n          (dist :accessor obj-dist)))\n     =>  #<STANDARD-CLASS OBJ 250020030>\n      (defmethod shared-initialize :after ((self obj) slot-names &rest keys)\n        (declare (ignore slot-names keys))\n        (unless (slot-boundp self 'dist)\n          (setf (obj-dist self)\n                (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))\n     =>  #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>\n      (defmethod make-load-form ((self obj) &optional environment)\n        (declare (ignore environment))\n        ;; Note that this definition only works because X and Y do not\n        ;; contain information which refers back to the object itself.\n        ;; For a more general solution to this problem, see revised example below.\n        `(make-instance ',(class-of self)\n                        :x ',(obj-x self) :y ',(obj-y self)))\n     =>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>\n      (setq obj1 (make-instance 'obj :x 3.0 :y 4.0)) =>  #<OBJ 26274136>\n      (obj-dist obj1) =>  5.0\n      (make-load-form obj1) =>  (MAKE-INSTANCE 'OBJ :X '3.0 :Y '4.0)\nIn the above example, an equivalent instance of obj is reconstructed by\nusing the values of two of its slots.  The value of the third slot is\nderived from those two values.\nAnother way to write the make-load-form method in that example is to use\nmake-load-form-saving-slots.  The code it generates might yield a slightly\ndifferent result from the make-load-form method shown above, but the\noperational effect will be the same.  For example:\n      ;; Redefine method defined above.\n      (defmethod make-load-form ((self obj) &optional environment)\n         (make-load-form-saving-slots self\n                                      :slot-names '(x y)\n                                      :environment environment))\n     =>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>\n      ;; Try MAKE-LOAD-FORM on object created above.\n      (make-load-form obj1)\n     =>  (ALLOCATE-INSTANCE '#<STANDARD-CLASS OBJ 250020030>),\n         (PROGN\n           (SETF (SLOT-VALUE '#<OBJ 26274136> 'X) '3.0)\n           (SETF (SLOT-VALUE '#<OBJ 26274136> 'Y) '4.0)\n           (INITIALIZE-INSTANCE '#<OBJ 26274136>))\nIn the following example, instances of my-frob are \"interned\" in some way.\nAn equivalent instance is reconstructed by using the value of the name\nslot as a key for searching existing objects.  In this case the programmer\nhas chosen to create a new object if no existing object is found;\nalternatively an error could have been signaled in that case.\n      (defclass my-frob ()\n         ((name :initarg :name :reader my-name)))\n      (defmethod make-load-form ((self my-frob) &optional environment)\n        (declare (ignore environment))\n        `(find-my-frob ',(my-name self) :if-does-not-exist :create))\nIn the following example, the data structure to be dumped is circular,\nbecause each parent has a list of its children and each child has a\nreference back to its parent.  If make-load-form is called on one object\nin such a structure,  the creation form creates an equivalent object and\nfills in the children slot, which forces creation of equivalent objects\nfor all of its children, grandchildren, etc.  At this point none of the\nparent slots have been filled in.  The initialization form fills in the\nparent slot, which forces creation of an equivalent object for the parent\nif it was not already created.  Thus the entire tree is recreated at load\ntime.  At compile time, make-load-form is called once for each object in\nthe tree.  All of the creation forms are evaluated, in\nimplementation-dependent order, and then all of the initialization forms\nare evaluated, also in implementation-dependent order.\n      (defclass tree-with-parent () ((parent :accessor tree-parent)\n                                     (children :initarg :children)))\n      (defmethod make-load-form ((x tree-with-parent) &optional environment)\n        (declare (ignore environment))\n        (values\n          ;; creation form\n          `(make-instance ',(class-of x) :children ',(slot-value x 'children))\n          ;; initialization form\n          `(setf (tree-parent ',x) ',(slot-value x 'parent))))\nIn the following example, the data structure to be dumped has no special\nproperties and an equivalent structure can be reconstructed simply by\nreconstructing the slots' contents.\n      (defstruct my-struct a b c)\n      (defmethod make-load-form ((s my-struct) &optional environment)\n         (make-load-form-saving-slots s :environment environment))\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "The methods specialized on standard-object, structure-object, and condition\nall signal an error of type error.\nIt is implementation-dependent whether calling make-load-form on a\ngeneralized instance of a system class signals an error or returns\ncreation and initialization forms.\n"
        },
        {
            "type": "See Also",
            "text": "*Note compile-file:: , *Note make-load-form-saving-slots:: , *Note\nAdditional Constraints on Externalizable Objects:: *Note Evaluation::,\n*Note Compilation::\n"
        },
        {
            "type": "Notes",
            "text": "The file compiler calls make-load-form in specific circumstances detailed\nin *Note Additional Constraints on Externalizable Objects::.\nSome implementations may provide facilities for defining new subclasses of\nclasses which are specified as system classes.  (Some likely candidates\ninclude generic-function, method, and stream).  Such implementations\nshould document how the file compiler processes instances of such classes\nwhen encountered as literal objects, and should document any relevant\nmethods for make-load-form.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: make-load-form,  Next: make-load-form-saving-slots,  Prev: make-instances-obsolete,  Up: Objects Dictionary\n\nmake-load-form                                  [Standard Generic Function]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n`make-load-form'  object &optional environment =>  creation-form[,\ninitialization-form]\n\nMethod Signatures::\n...................\n\n`make-load-form'  (object standard-object)  &optional environment\n\n`make-load-form'  (object structure-object) &optional environment\n\n`make-load-form'  (object condition)        &optional environment\n\n`make-load-form'  (object class)            &optional environment\n\nArguments and Values::\n......................\n\nobject--an object.\n\nenvironment--an environment object.\n\ncreation-form--a form.\n\ninitialization-form--a form.\n\nDescription::\n.............\n\nThe generic function make-load-form creates and returns one or two forms,\na creation-form and an initialization-form, that enable load to construct\nan object equivalent to object.  Environment is an environment object\ncorresponding to the lexical environment in which the forms will be\nprocessed.\n\nThe file compiler calls make-load-form to process certain classes of\nliteral objects; see *Note Additional Constraints on Externalizable\nObjects::.\n\nConforming programs may call make-load-form directly, providing object is\na generalized instance of standard-object, structure-object, or condition.\n\nThe creation form is a form that, when evaluated at load time, should\nreturn an object that is equivalent to object.  The exact meaning of\nequivalent depends on the type of object and is up to the programmer who\ndefines a method for make-load-form; see *Note Literal Objects in Compiled\nFiles::.\n\nThe initialization form is a form that, when evaluated at load time,\nshould perform further initialization of the object.  The value returned\nby the initialization form is ignored.  If make-load-form returns only one\nvalue, the initialization form is nil, which has no effect.  If object\nappears as a constant in the initialization form, at load time it will be\nreplaced by the equivalent object constructed by the creation form; this\nis how the further initialization gains access to the object.\n\nBoth the creation-form and the initialization-form may contain references\nto any externalizable object.  However, there must not be any circular\ndependencies in creation forms.  An example of a circular dependency is\nwhen the creation form for the object X contains a reference to the object\nY, and the creation form for the object Y contains a reference to the\nobject X.  Initialization forms are not subject to any restriction against\ncircular dependencies, which is the reason that initialization forms exist;\nsee the example of circular data structures below.\n\nThe creation form for an object is always evaluated before the\ninitialization form for that object.  When either the creation form or the\ninitialization form references other objects that have not been referenced\nearlier in the file being compiled, the compiler ensures that all of the\nreferenced objects have been created before evaluating the referencing\nform.  When the referenced object is of a type which the file compiler\nprocesses using make-load-form, this involves evaluating the creation form\nreturned for it.  (This is the reason for the prohibition against circular\nreferences among creation forms).\n\nEach initialization form is evaluated as soon as possible after its\nassociated creation form, as determined by data flow.  If the\ninitialization form for an object does not reference any other objects not\nreferenced earlier in the file and processed by the file compiler using\nmake-load-form, the initialization form is evaluated immediately after the\ncreation form.  If a creation or initialization form F does contain\nreferences to such objects, the creation forms for those other objects are\nevaluated before F, and the initialization forms for those other objects\nare also evaluated before F whenever they do not depend on the object\ncreated or initialized by F.  Where these rules do not uniquely determine\nan order of evaluation between two creation/initialization forms, the\norder of evaluation is unspecified.\n\nWhile these creation and initialization forms are being evaluated, the\nobjects are possibly in an uninitialized state, analogous to the state of\nan object between the time it has been created by allocate-instance and it\nhas been processed fully by initialize-instance.  Programmers writing\nmethods for make-load-form must take care in manipulating objects not to\ndepend on slots that have not yet been initialized.\n\nIt is implementation-dependent whether load calls eval on the forms or\ndoes some other operation that has an equivalent effect.  For example, the\nforms might be translated into different but equivalent forms and then\nevaluated, they might be compiled and the resulting functions called by\nload, or they might be interpreted by a special-purpose function different\nfrom eval.  All that is required is that the effect be equivalent to\nevaluating the forms.\n\nThe method specialized on class returns a creation form using the name of\nthe class if the class has a proper name in environment, signaling an\nerror of type error if it does not have a proper name.  Evaluation of the\ncreation form uses the name to find the class with that name, as if by\ncalling find-class.  If a class with that name has not been defined, then\na class may be computed in an implementation-defined manner.  If a class\ncannot be returned as the result of evaluating the creation form, then an\nerror of type error is signaled.\n\nBoth conforming implementations and conforming programs may further\nspecialize make-load-form.\n\nExamples::\n..........\n\n      (defclass obj ()\n         ((x :initarg :x :reader obj-x)\n          (y :initarg :y :reader obj-y)\n          (dist :accessor obj-dist)))\n     =>  #<STANDARD-CLASS OBJ 250020030>\n      (defmethod shared-initialize :after ((self obj) slot-names &rest keys)\n        (declare (ignore slot-names keys))\n        (unless (slot-boundp self 'dist)\n          (setf (obj-dist self)\n                (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))\n     =>  #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>\n      (defmethod make-load-form ((self obj) &optional environment)\n        (declare (ignore environment))\n        ;; Note that this definition only works because X and Y do not\n        ;; contain information which refers back to the object itself.\n        ;; For a more general solution to this problem, see revised example below.\n        `(make-instance ',(class-of self)\n                        :x ',(obj-x self) :y ',(obj-y self)))\n     =>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>\n      (setq obj1 (make-instance 'obj :x 3.0 :y 4.0)) =>  #<OBJ 26274136>\n      (obj-dist obj1) =>  5.0\n      (make-load-form obj1) =>  (MAKE-INSTANCE 'OBJ :X '3.0 :Y '4.0)\n\nIn the above example, an equivalent instance of obj is reconstructed by\nusing the values of two of its slots.  The value of the third slot is\nderived from those two values.\n\nAnother way to write the make-load-form method in that example is to use\nmake-load-form-saving-slots.  The code it generates might yield a slightly\ndifferent result from the make-load-form method shown above, but the\noperational effect will be the same.  For example:\n\n      ;; Redefine method defined above.\n      (defmethod make-load-form ((self obj) &optional environment)\n         (make-load-form-saving-slots self\n                                      :slot-names '(x y)\n                                      :environment environment))\n     =>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>\n      ;; Try MAKE-LOAD-FORM on object created above.\n      (make-load-form obj1)\n     =>  (ALLOCATE-INSTANCE '#<STANDARD-CLASS OBJ 250020030>),\n         (PROGN\n           (SETF (SLOT-VALUE '#<OBJ 26274136> 'X) '3.0)\n           (SETF (SLOT-VALUE '#<OBJ 26274136> 'Y) '4.0)\n           (INITIALIZE-INSTANCE '#<OBJ 26274136>))\n\nIn the following example, instances of my-frob are \"interned\" in some way.\nAn equivalent instance is reconstructed by using the value of the name\nslot as a key for searching existing objects.  In this case the programmer\nhas chosen to create a new object if no existing object is found;\nalternatively an error could have been signaled in that case.\n\n      (defclass my-frob ()\n         ((name :initarg :name :reader my-name)))\n      (defmethod make-load-form ((self my-frob) &optional environment)\n        (declare (ignore environment))\n        `(find-my-frob ',(my-name self) :if-does-not-exist :create))\n\nIn the following example, the data structure to be dumped is circular,\nbecause each parent has a list of its children and each child has a\nreference back to its parent.  If make-load-form is called on one object\nin such a structure,  the creation form creates an equivalent object and\nfills in the children slot, which forces creation of equivalent objects\nfor all of its children, grandchildren, etc.  At this point none of the\nparent slots have been filled in.  The initialization form fills in the\nparent slot, which forces creation of an equivalent object for the parent\nif it was not already created.  Thus the entire tree is recreated at load\ntime.  At compile time, make-load-form is called once for each object in\nthe tree.  All of the creation forms are evaluated, in\nimplementation-dependent order, and then all of the initialization forms\nare evaluated, also in implementation-dependent order.\n\n      (defclass tree-with-parent () ((parent :accessor tree-parent)\n                                     (children :initarg :children)))\n      (defmethod make-load-form ((x tree-with-parent) &optional environment)\n        (declare (ignore environment))\n        (values\n          ;; creation form\n          `(make-instance ',(class-of x) :children ',(slot-value x 'children))\n          ;; initialization form\n          `(setf (tree-parent ',x) ',(slot-value x 'parent))))\n\nIn the following example, the data structure to be dumped has no special\nproperties and an equivalent structure can be reconstructed simply by\nreconstructing the slots' contents.\n\n      (defstruct my-struct a b c)\n      (defmethod make-load-form ((s my-struct) &optional environment)\n         (make-load-form-saving-slots s :environment environment))\n\nExceptional Situations::\n........................\n\nThe methods specialized on standard-object, structure-object, and condition\nall signal an error of type error.\n\nIt is implementation-dependent whether calling make-load-form on a\ngeneralized instance of a system class signals an error or returns\ncreation and initialization forms.\n\nSee Also::\n..........\n\n*Note compile-file:: , *Note make-load-form-saving-slots:: , *Note\nAdditional Constraints on Externalizable Objects:: *Note Evaluation::,\n*Note Compilation::\n\nNotes::\n.......\n\nThe file compiler calls make-load-form in specific circumstances detailed\nin *Note Additional Constraints on Externalizable Objects::.\n\nSome implementations may provide facilities for defining new subclasses of\nclasses which are specified as system classes.  (Some likely candidates\ninclude generic-function, method, and stream).  Such implementations\nshould document how the file compiler processes instances of such classes\nwhen encountered as literal objects, and should document any relevant\nmethods for make-load-form.\n\n"
}