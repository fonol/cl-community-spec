{
    "name": "union",
    "prev": "subsetp",
    "next": null,
    "up": "Conses Dictionary",
    "header": {
        "type": "Function",
        "text": "union, nunion"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "union",
                    "text": " list-1 list-2 &key key test test-not =>  result-list\n"
                },
                {
                    "name": "nunion",
                    "text": " list-1 list-2 &key key test test-not =>  result-list\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "list-1",
                    "desc": "a proper list."
                },
                {
                    "name": "list-2",
                    "desc": "a proper list."
                },
                {
                    "name": "test",
                    "desc": "a designator for a function of two arguments that returns a"
                },
                {
                    "name": "test",
                    "desc": "a designator for a function of two arguments that returns ageneralized boolean.\n"
                },
                {
                    "name": "test-not",
                    "desc": "a designator for a function of two arguments that returns a"
                },
                {
                    "name": "test-not",
                    "desc": "a designator for a function of two arguments that returns ageneralized boolean.\n"
                },
                {
                    "name": "key",
                    "desc": "a designator for a function of one argument, or nil."
                },
                {
                    "name": "result-list",
                    "desc": "a list."
                }
            ]
        },
        {
            "type": "Description",
            "text": "union and nunion return a list that contains every element that occurs in\neither list-1 or list-2.\nFor all possible ordered pairs consisting of one element from list-1 and\none element from list-2, :test or  :test-not is used to determine whether\nthey satisfy the test.  The first argument to the :test or :test-not\nfunction is the part of the element of list-1 extracted by the :key\nfunction (if supplied); the second argument is the part of the element of\nlist-2 extracted by the :key function (if supplied).\nThe argument to the :key function is an element of list-1 or list-2; the\nreturn value is part of the supplied element.  If :key is not supplied or\nnil, the element of list-1 or list-2 itself is supplied to the :test or\n:test-not function.\nFor every matching pair, one of the two elements of the pair will be in\nthe result.  Any element from either list-1 or list-2 that matches no\nelement of the other will appear in the result.\nIf there is a duplication between list-1 and list-2, only one of the\nduplicate instances will be in the result.  If either list-1 or list-2 has\nduplicate entries within it, the redundant entries might or might not\nappear in the result.\nThe order of elements in the result do not have to reflect the ordering of\nlist-1 or list-2 in any way.  The result list may be eq to either list-1\nor list-2 if appropriate.\n"
        },
        {
            "type": "Examples",
            "text": "      (union '(a b c) '(f a d))\n     =>  (A B C F D)\n     OR=> (B C F A D)\n     OR=> (D F A B C)\n      (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)\n     =>  ((X 5) (Y 6) (Z 2))\n     OR=> ((X 4) (Y 6) (Z 2))\n      (setq lst1 (list 1 2 '(1 2) \"a\" \"b\")\n            lst2 (list 2 3 '(2 3) \"B\" \"C\"))\n     =>  (2 3 (2 3) \"B\" \"C\")\n      (nunion lst1 lst2)\n     =>  (1 (1 2) \"a\" \"b\" 2 3 (2 3) \"B\" \"C\")\n     OR=> (1 2 (1 2) \"a\" \"b\" \"C\" \"B\" (2 3) 3)\n"
        },
        {
            "type": "Side Effects",
            "text": "nunion is permitted to modify any part, car or cdr, of the list structure\nof list-1 or list-2.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should be prepared to signal an error of type type-error if list-1 and\nlist-2 are not proper lists.\n"
        },
        {
            "type": "See Also",
            "text": "*Note intersection; nintersection:: ,\n*Note Compiler Terminology::,\n*Note Traversal Rules and Side Effects::\n"
        },
        {
            "type": "Notes",
            "text": "The :test-not parameter is deprecated.\nSince the nunion side effect is not required, it should not be used in\nfor-effect-only positions in portable code.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: union,  Prev: subsetp,  Up: Conses Dictionary\n\nunion, nunion                                                    [Function]\n---------------------------------------------------------------------------\n\n`union'  list-1 list-2 &key key test test-not =>  result-list\n\n`nunion'  list-1 list-2 &key key test test-not =>  result-list\n\nArguments and Values::\n......................\n\nlist-1--a proper list.\n\nlist-2--a proper list.\n\ntest--a designator for a function of two arguments that returns a\ngeneralized boolean.\n\ntest-not--a designator for a function of two arguments that returns a\ngeneralized boolean.\n\nkey--a designator for a function of one argument, or nil.\n\nresult-list--a list.\n\nDescription::\n.............\n\nunion and nunion return a list that contains every element that occurs in\neither list-1 or list-2.\n\nFor all possible ordered pairs consisting of one element from list-1 and\none element from list-2, :test or  :test-not is used to determine whether\nthey satisfy the test.  The first argument to the :test or :test-not\nfunction is the part of the element of list-1 extracted by the :key\nfunction (if supplied); the second argument is the part of the element of\nlist-2 extracted by the :key function (if supplied).\n\nThe argument to the :key function is an element of list-1 or list-2; the\nreturn value is part of the supplied element.  If :key is not supplied or\nnil, the element of list-1 or list-2 itself is supplied to the :test or\n:test-not function.\n\nFor every matching pair, one of the two elements of the pair will be in\nthe result.  Any element from either list-1 or list-2 that matches no\nelement of the other will appear in the result.\n\nIf there is a duplication between list-1 and list-2, only one of the\nduplicate instances will be in the result.  If either list-1 or list-2 has\nduplicate entries within it, the redundant entries might or might not\nappear in the result.\n\nThe order of elements in the result do not have to reflect the ordering of\nlist-1 or list-2 in any way.  The result list may be eq to either list-1\nor list-2 if appropriate.\n\nExamples::\n..........\n\n      (union '(a b c) '(f a d))\n     =>  (A B C F D)\n     OR=> (B C F A D)\n     OR=> (D F A B C)\n      (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)\n     =>  ((X 5) (Y 6) (Z 2))\n     OR=> ((X 4) (Y 6) (Z 2))\n     \n      (setq lst1 (list 1 2 '(1 2) \"a\" \"b\")\n            lst2 (list 2 3 '(2 3) \"B\" \"C\"))\n     =>  (2 3 (2 3) \"B\" \"C\")\n      (nunion lst1 lst2)\n     =>  (1 (1 2) \"a\" \"b\" 2 3 (2 3) \"B\" \"C\")\n     OR=> (1 2 (1 2) \"a\" \"b\" \"C\" \"B\" (2 3) 3)\n\nSide Effects::\n..............\n\nnunion is permitted to modify any part, car or cdr, of the list structure\nof list-1 or list-2.\n\nExceptional Situations::\n........................\n\nShould be prepared to signal an error of type type-error if list-1 and\nlist-2 are not proper lists.\n\nSee Also::\n..........\n\n*Note intersection; nintersection:: ,\n\n*Note Compiler Terminology::,\n\n*Note Traversal Rules and Side Effects::\n\nNotes::\n.......\n\nThe :test-not parameter is deprecated.\n\nSince the nunion side effect is not required, it should not be used in\nfor-effect-only positions in portable code.\n\n"
}