{
    "name": "every",
    "prev": "constantly",
    "next": "and",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Function",
        "text": "every, some, notevery, notany"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "every",
                    "text": " predicate &rest sequences^+ =>  generalized-boolean\n"
                },
                {
                    "name": "some",
                    "text": " predicate &rest sequences^+ =>  result\n\n"
                },
                {
                    "name": "notevery",
                    "text": " predicate &rest sequences^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "notany",
                    "text": " predicate &rest sequences^+ =>  generalized-boolean\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "predicate",
                    "desc": "a designator for a function of as many arguments as there are"
                },
                {
                    "name": "predicate",
                    "desc": "a designator for a function of as many arguments as there aresequences.\n"
                },
                {
                    "name": "sequence",
                    "desc": "a sequence."
                },
                {
                    "name": "result",
                    "desc": "an object."
                },
                {
                    "name": "generalized-boolean",
                    "desc": "a generalized boolean."
                }
            ]
        },
        {
            "type": "Description",
            "text": "every, some, notevery, and notany test elements of sequences for\nsatisfaction of a given predicate.  The first argument to predicate is an\nelement of the first sequence; each succeeding argument is an element of a\nsucceeding sequence.\nPredicate is first applied to the elements with index 0 in each of the\nsequences, and possibly then to the elements with index 1, and so on,\nuntil a termination criterion is met or the end of the shortest of the\nsequences is reached.\nevery returns false as soon as any invocation of predicate returns false.\nIf the end of a sequence is reached, every returns true.  Thus, every\nreturns true if and only if every invocation of predicate returns true.\nsome returns the first non-nil value which is returned by an invocation of\npredicate.  If the end of a sequence is reached without any invocation of\nthe predicate returning true, some returns false.  Thus, some returns true\nif and only if some invocation of predicate returns true.\nnotany returns false as soon as any invocation of predicate returns true.\nIf the end of a sequence is reached, notany returns true.  Thus, notany\nreturns true if and only if it is not the case that any invocation of\npredicate returns true.\nnotevery returns true as soon as any invocation of predicate returns false.\nIf the end of a sequence is reached, notevery returns false.  Thus,\nnotevery returns true if and only if it is not the case that every\ninvocation of predicate returns true.\n"
        },
        {
            "type": "Examples",
            "text": "      (every #'characterp \"abc\") =>  true\n      (some #'= '(1 2 3 4 5) '(5 4 3 2 1)) =>  true\n      (notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  false\n      (notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  true\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal type-error if its first argument is neither a symbol nor a\nfunction or if any subsequent argument is not a proper sequence.\nOther exceptional situations are possible, depending on the nature of the\npredicate.\n"
        },
        {
            "type": "See Also",
            "text": "*Note and:: , *Note or:: ,\n*Note Traversal Rules and Side Effects::\n"
        },
        {
            "type": "Notes",
            "text": "      (notany predicate {sequence}*) == (not (some predicate {sequence}*))\n      (notevery predicate {sequence}*) == (not (every predicate {sequence}*))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: every,  Next: and,  Prev: constantly,  Up: Data and Control Flow Dictionary\n\nevery, some, notevery, notany                                    [Function]\n---------------------------------------------------------------------------\n\n`every'  predicate &rest sequences^+ =>  generalized-boolean\n\n`some'  predicate &rest sequences^+ =>  result\n\n`notevery'  predicate &rest sequences^+ =>  generalized-boolean\n\n`notany'  predicate &rest sequences^+ =>  generalized-boolean\n\nArguments and Values::\n......................\n\npredicate--a designator for a function of as many arguments as there are\nsequences.\n\nsequence--a sequence.\n\nresult--an object.\n\ngeneralized-boolean--a generalized boolean.\n\nDescription::\n.............\n\nevery, some, notevery, and notany test elements of sequences for\nsatisfaction of a given predicate.  The first argument to predicate is an\nelement of the first sequence; each succeeding argument is an element of a\nsucceeding sequence.\n\nPredicate is first applied to the elements with index 0 in each of the\nsequences, and possibly then to the elements with index 1, and so on,\nuntil a termination criterion is met or the end of the shortest of the\nsequences is reached.\n\nevery returns false as soon as any invocation of predicate returns false.\nIf the end of a sequence is reached, every returns true.  Thus, every\nreturns true if and only if every invocation of predicate returns true.\n\nsome returns the first non-nil value which is returned by an invocation of\npredicate.  If the end of a sequence is reached without any invocation of\nthe predicate returning true, some returns false.  Thus, some returns true\nif and only if some invocation of predicate returns true.\n\nnotany returns false as soon as any invocation of predicate returns true.\nIf the end of a sequence is reached, notany returns true.  Thus, notany\nreturns true if and only if it is not the case that any invocation of\npredicate returns true.\n\nnotevery returns true as soon as any invocation of predicate returns false.\nIf the end of a sequence is reached, notevery returns false.  Thus,\nnotevery returns true if and only if it is not the case that every\ninvocation of predicate returns true.\n\nExamples::\n..........\n\n      (every #'characterp \"abc\") =>  true\n      (some #'= '(1 2 3 4 5) '(5 4 3 2 1)) =>  true\n      (notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  false\n      (notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  true\n\nExceptional Situations::\n........................\n\nShould signal type-error if its first argument is neither a symbol nor a\nfunction or if any subsequent argument is not a proper sequence.\n\nOther exceptional situations are possible, depending on the nature of the\npredicate.\n\nSee Also::\n..........\n\n*Note and:: , *Note or:: ,\n\n*Note Traversal Rules and Side Effects::\n\nNotes::\n.......\n\n      (notany predicate {sequence}*) == (not (some predicate {sequence}*))\n      (notevery predicate {sequence}*) == (not (every predicate {sequence}*))\n\n"
}