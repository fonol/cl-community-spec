{
    "name": "Termination Test Clauses",
    "prev": "Value Accumulation Clauses",
    "next": "Unconditional Execution Clauses",
    "up": "The LOOP Facility",
    "header": {
        "type": null,
        "text": "Termination Test Clauses"
    },
    "sections": [
        {
            "type": "",
            "text": "The repeat construct causes iteration to terminate after a specified\nnumber of times.  The loop body executes n times, where n is the value of\nthe expression form.  The form argument is evaluated one time in the loop\nprologue.  If the expression evaluates to 0 or to a negative number, the\nloop body is not evaluated.\nThe constructs always, never, thereis, while, until, and the macro\nloop-finish allow conditional termination of iteration within a loop.\nThe constructs always, never, and thereis provide specific values to be\nreturned when a loop terminates.  Using always, never, or thereis in a\nloop with value accumulation clauses that are not into causes an error of\ntype program-error to be signaled (at macro expansion time).  Since\nalways, never, and thereis use\nthe return-from special operator\nto terminate iteration, any finally clause that is supplied is not\nevaluated when exit occurs due to any of these constructs.  In all other\nrespects these constructs behave like the while and until constructs.\nThe always construct takes one form and terminates the loop if the form\never evaluates to nil; in this case, it returns nil.  Otherwise, it\nprovides a default return value of t.  If the value of the supplied form\nis never nil, some other construct can terminate the iteration.\nThe never construct terminates iteration the first time that the value of\nthe supplied form is non-nil; the loop returns nil.  If the value of the\nsupplied form is always  nil, some other construct can terminate the\niteration.  Unless some other clause contributes a return value, the\ndefault value returned is t.\nThe thereis construct terminates iteration the first time that the value\nof the supplied form is non-nil; the loop returns the value of the\nsupplied form.  If the value of the supplied form is always  nil, some\nother construct can terminate the iteration.  Unless some other clause\ncontributes a return value, the default value returned is nil.\nThere are two differences between the thereis and until constructs:\n*\n     The until construct does not return a value or nil based on the value\n     of the supplied form.\n*\n     The until construct executes any finally clause.  Since thereis uses\n     the return-from special operator\n     to terminate iteration, any finally clause that is supplied is not\n     evaluated when exit occurs due to thereis.\nThe while construct allows iteration to continue until the supplied form\nevaluates to false.  The supplied form is reevaluated at the location of\nthe while clause.\nThe until construct is equivalent to while (not form)\\dots.  If the value\nof the supplied form is non-nil, iteration terminates.\nTermination-test control constructs can be used anywhere within the loop\nbody.  The termination tests are used in the order in which they appear.\nIf an until or while clause causes termination, any clauses that precede\nit in the source are still evaluated.  If the until and while constructs\ncause termination, control is passed to the loop epilogue, where any\nfinally clauses will be executed.\nThere are two differences between the never and until constructs:\n*\n     The until construct does not return t or nil based on the value of\n     the supplied form.\n*\n     The until construct does not bypass any finally clauses.  Since never\n     uses\n     the return-from special operator\n     to terminate iteration, any finally clause that is supplied is not\n     evaluated when exit occurs due to never.\nIn most cases it is not necessary to use loop-finish because other loop\ncontrol clauses terminate the loop.  The macro loop-finish is used to\nprovide a normal exit from a nested conditional inside a loop.  Since\nloop-finish transfers control to the loop epilogue, using loop-finish\nwithin a finally expression can cause infinite looping.\n* Menu:\n* Examples of REPEAT clause::\n* Examples of ALWAYS::\n* Examples of WHILE and UNTIL clauses::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Termination Test Clauses,  Next: Unconditional Execution Clauses,  Prev: Value Accumulation Clauses,  Up: The LOOP Facility\n\nTermination Test Clauses\n------------------------\n\nThe repeat construct causes iteration to terminate after a specified\nnumber of times.  The loop body executes n times, where n is the value of\nthe expression form.  The form argument is evaluated one time in the loop\nprologue.  If the expression evaluates to 0 or to a negative number, the\nloop body is not evaluated.\n\nThe constructs always, never, thereis, while, until, and the macro\nloop-finish allow conditional termination of iteration within a loop.\n\nThe constructs always, never, and thereis provide specific values to be\nreturned when a loop terminates.  Using always, never, or thereis in a\nloop with value accumulation clauses that are not into causes an error of\ntype program-error to be signaled (at macro expansion time).  Since\nalways, never, and thereis use\n\nthe return-from special operator\n\nto terminate iteration, any finally clause that is supplied is not\nevaluated when exit occurs due to any of these constructs.  In all other\nrespects these constructs behave like the while and until constructs.\n\nThe always construct takes one form and terminates the loop if the form\never evaluates to nil; in this case, it returns nil.  Otherwise, it\nprovides a default return value of t.  If the value of the supplied form\nis never nil, some other construct can terminate the iteration.\n\nThe never construct terminates iteration the first time that the value of\nthe supplied form is non-nil; the loop returns nil.  If the value of the\nsupplied form is always  nil, some other construct can terminate the\niteration.  Unless some other clause contributes a return value, the\ndefault value returned is t.\n\nThe thereis construct terminates iteration the first time that the value\nof the supplied form is non-nil; the loop returns the value of the\nsupplied form.  If the value of the supplied form is always  nil, some\nother construct can terminate the iteration.  Unless some other clause\ncontributes a return value, the default value returned is nil.\n\nThere are two differences between the thereis and until constructs:\n\n*\n     The until construct does not return a value or nil based on the value\n     of the supplied form.\n\n*\n     The until construct executes any finally clause.  Since thereis uses\n\n     the return-from special operator\n\n     to terminate iteration, any finally clause that is supplied is not\n     evaluated when exit occurs due to thereis.\n\nThe while construct allows iteration to continue until the supplied form\nevaluates to false.  The supplied form is reevaluated at the location of\nthe while clause.\n\nThe until construct is equivalent to while (not form)\\dots.  If the value\nof the supplied form is non-nil, iteration terminates.\n\nTermination-test control constructs can be used anywhere within the loop\nbody.  The termination tests are used in the order in which they appear.\nIf an until or while clause causes termination, any clauses that precede\nit in the source are still evaluated.  If the until and while constructs\ncause termination, control is passed to the loop epilogue, where any\nfinally clauses will be executed.\n\nThere are two differences between the never and until constructs:\n\n*\n     The until construct does not return t or nil based on the value of\n     the supplied form.\n\n*\n     The until construct does not bypass any finally clauses.  Since never\n     uses\n\n     the return-from special operator\n\n     to terminate iteration, any finally clause that is supplied is not\n     evaluated when exit occurs due to never.\n\nIn most cases it is not necessary to use loop-finish because other loop\ncontrol clauses terminate the loop.  The macro loop-finish is used to\nprovide a normal exit from a nested conditional inside a loop.  Since\nloop-finish transfers control to the loop epilogue, using loop-finish\nwithin a finally expression can cause infinite looping.\n\n* Menu:\n\n* Examples of REPEAT clause::\n* Examples of ALWAYS::\n* Examples of WHILE and UNTIL clauses::\n\n"
}