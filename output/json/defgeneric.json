{
    "name": "defgeneric",
    "prev": "defclass",
    "next": "defmethod",
    "up": "Objects Dictionary",
    "header": {
        "type": "Macro",
        "text": "defgeneric"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "defgeneric",
                    "text": " function-name gf-lambda-list [[!option |{!method-description}*]]\n=>  new-generic\n\noption ::=(:argument-precedence-order {parameter-name}^+) |\n           (declare {gf-declaration}^+) |\n           (:documentation gf-documentation) |\n           (:method-combination method-combination {method-combination-argument}*) |\n           (:generic-function-class generic-function-class) |\n           (:method-class method-class)\n\nmethod-description ::=(:method {method-qualifier}* specialized-lambda-list [[{declaration}* | documentation]] {form}*)\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "function-name",
                    "desc": "a function name."
                },
                {
                    "name": "generic-function-class",
                    "desc": "a non-nil symbol naming a class."
                },
                {
                    "name": "gf-declaration",
                    "desc": "an optimize declaration specifier; other declaration"
                },
                {
                    "name": "gf-declaration",
                    "desc": "an optimize declaration specifier; other declarationspecifiers are not permitted.\n"
                },
                {
                    "name": "gf-documentation",
                    "desc": "a string; not evaluated."
                },
                {
                    "name": "gf-lambda-list",
                    "desc": "a generic function lambda list."
                },
                {
                    "name": "method-class",
                    "desc": "a non-nil symbol naming a class."
                },
                {
                    "name": "method-combination-argument",
                    "desc": "an object."
                },
                {
                    "name": "method-combination-name",
                    "desc": "a symbol naming a method combination type.method-qualifiers, specialized-lambda-list, declarations, documentation,\n"
                },
                {
                    "name": "forms",
                    "desc": "as per defmethod."
                },
                {
                    "name": "new-generic",
                    "desc": "the generic function object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The macro defgeneric is used to define a generic function or to specify\noptions and declarations that pertain to a generic function as a whole.\nIf function-name is a list it must be of the form (setf symbol).  If\n(fboundp function-name) is false, a new generic function is created.\nIf (fdefinition function-name) is a generic function, that\ngeneric function is modified.  If function-name names an ordinary function,\na macro, or a special operator, an error is signaled.\nThe effect of the defgeneric macro is as if the following three steps were\nperformed: first, methods defined by previous defgeneric forms are removed;\n[Reviewer Note by Barmar: Shouldn't this (second) be first?] second,\nensure-generic-function is called; and finally, methods specified by the\ncurrent defgeneric form are added to the generic function.\nEach method-description defines a method on the generic function.  The\nlambda list of each method must be congruent with the lambda list\nspecified by the gf-lambda-list option.  If no method descriptions are\nspecified and a generic function of the same name does not already exist,\na generic function with no methods is created.\nThe gf-lambda-list argument of defgeneric specifies the shape of lambda\nlists for the methods on this generic function.  All methods on the\nresulting generic function must have lambda lists that are congruent with\nthis shape.  If a defgeneric form is evaluated and some methods for that\ngeneric function have lambda lists that are not congruent with that given\nin the defgeneric form, an error is signaled.  For further details on\nmethod congruence, see *Note Congruent Lambda-lists for all Methods of a\nGeneric Function::.\nThe generic function passes to the method all the argument values passed to\nit, and only those; default values are not supported.  Note that optional\nand keyword arguments in method definitions, however, can have default\ninitial value forms and can use supplied-p parameters.\nThe following options are provided.\nExcept as otherwise noted,\na given option may occur only once.\n*\n     The :argument-precedence-order option is used to specify the order in\n     which the required arguments in a call to the generic function are\n     tested for specificity when selecting a particular method. Each\n     required argument, as specified in the gf-lambda-list argument, must\n     be included exactly once as a parameter-name so that the full and\n     unambiguous precedence order is supplied.  If this condition is not\n     met, an error is signaled.\n     [Reviewer Note by Barmar: What is the default order?]\n*\n     The declare option is used to specify declarations that pertain to\n     the generic function.\n     An optimize declaration specifier is allowed.  It specifies whether\n     method selection should be optimized for speed or space, but it has\n     no effect on methods.  To control how a method is optimized, an\n     optimize declaration must be placed directly in the defmethod form or\n     method description.  The optimization qualities speed and space are\n     the only qualities this standard requires, but an implementation can\n     extend the object system to recognize other qualities.  A simple\n     implementation that has only one method selection technique and\n     ignores optimize declaration specifiers is valid.\n     The special, ftype, function, inline, notinline, and declaration\n     declarations are not permitted.  Individual implementations can\n     extend the declare option to support additional declarations.\n     [Editorial Note by KMP: Does \"additional\" mean including special,\n     ftype, etc.?  Or only other things that are not mentioned here?] If\n     an implementation notices a declaration specifier that it does not\n     support and that has not been proclaimed as a non-standard\n     declaration identifier name in a declaration proclamation, it should\n     issue a warning.  [Editorial Note by KMP: The wording of this\n     previous sentence, particularly the word \"and\" suggests to me that\n     you can `proclaim declaration' of an unsupported declaration (e.g.,\n     ftype) in order to suppress the warning.  That seems wrong.  Perhaps\n     it instead means to say \"does not support or is both undefined and\n     not proclaimed declaration.\"]\n     The declare option may be specified more than once.  The effect is\n     the same as if the lists of declaration specifiers had been appended\n     together into a single list and specified as a single declare option.\n*\n     The :documentation argument is a documentation string to be attached\n     to the generic function object, and to be attached with kind function\n     to the function-name.\n*\n     The :generic-function-class option may be used to specify that the\n     generic function is to have a different class than the default\n     provided by the system (the class standard-generic-function).  The\n     class-name argument is the name of a class that can be the class of a\n     generic function.  If function-name specifies an existing generic\n     function that has a different value for the :generic-function-class\n     argument and the new generic function class is compatible with the\n     old, change-class is called to change the class of the generic\n     function; otherwise an error is signaled.\n*\n     The :method-class option is used to specify that all methods on this\n     generic function are to have a different class from the default\n     provided by the system (the class standard-method).  The class-name\n     argument is the name of a class that is capable of being the class of\n     a method.\n     [Reviewer Note by Barmar: Is change-class called on existing methods?]\n*\n     The :method-combination option is followed by a symbol that names a\n     type of method combination.  The arguments (if any) that follow that\n     symbol depend on the type of method combination.  Note that the\n     standard method combination type does not support any arguments.\n     However, all types of method combination defined by the short form of\n     define-method-combination accept an optional argument named order,\n     defaulting to :most-specific-first, where a value of\n     :most-specific-last reverses the order of the primary methods without\n     affecting the order of the auxiliary methods.\nThe method-description arguments define methods that will be associated\nwith the generic function.  The method-qualifier and\nspecialized-lambda-list arguments in a method description are the same as\nfor defmethod.\nThe form arguments specify the method body.  The body of the method is\nenclosed in an implicit block.  If function-name is a symbol, this block\nbears the same name as the generic function.  If function-name is a list\nof the form (setf symbol), the name of the block is symbol.\nImplementations can extend defgeneric to include other options.  It is\nrequired that an implementation signal an error if it observes an option\nthat is not implemented locally.\ndefgeneric is not required to perform any compile-time side effects.  In\nparticular, the methods are not installed for invocation during\ncompilation.  An implementation may choose to store information about the\ngeneric function for the purposes of compile-time error-checking (such as\nchecking the number of arguments on calls, or noting that a definition for\nthe function name has been seen).\n"
        },
        {
            "type": "Examples",
            "text": ""
        },
        {
            "type": "Exceptional Situations",
            "text": "If function-name names an ordinary function, a macro, or a special\noperator, an error of type program-error is signaled.\nEach required argument, as specified in the gf-lambda-list argument, must\nbe included exactly once as a parameter-name, or an error of type\nprogram-error is signaled.\nThe lambda list of each method specified by a method-description must be\ncongruent with the lambda list specified by the gf-lambda-list option, or\nan error of type error is signaled.\nIf a defgeneric form is evaluated and some methods for that generic\nfunction have lambda lists that are not congruent with that given in the\ndefgeneric form, an error of type error is signaled.\nA given option may occur only once, or an error of type program-error is\nsignaled.\n[Reviewer Note by Barmar: This says that an error is signaled if you\nspecify the same generic function class as it already has!] If\nfunction-name specifies an existing generic function that has a different\nvalue for the :generic-function-class argument and the new generic\nfunction class is compatible with the old, change-class is called to\nchange the class of the generic function; otherwise an error of type error\nis signaled.\nImplementations can extend defgeneric to include other options.  It is\nrequired that an implementation signal an error of type program-error if\nit observes an option that is not implemented locally.\n"
        },
        {
            "type": "See Also",
            "text": "*Note defmethod:: , *Note documentation; (setf documentation):: , *Note\nensure-generic-function:: ,\ngeneric-function,\n*Note Congruent Lambda-lists for all Methods of a Generic Function::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: defgeneric,  Next: defmethod,  Prev: defclass,  Up: Objects Dictionary\n\ndefgeneric                                                          [Macro]\n---------------------------------------------------------------------------\n\n`defgeneric'  function-name gf-lambda-list [[!option |\n{!method-description}*]]\n=>  new-generic\n\noption ::=(:argument-precedence-order {parameter-name}^+) |\n           (declare {gf-declaration}^+) |\n           (:documentation gf-documentation) |\n           (:method-combination method-combination {method-combination-argument}*) |\n           (:generic-function-class generic-function-class) |\n           (:method-class method-class)\n\nmethod-description ::=(:method {method-qualifier}* specialized-lambda-list [[{declaration}* | documentation]] {form}*)\n\nArguments and Values::\n......................\n\nfunction-name--a function name.\n\ngeneric-function-class--a non-nil symbol naming a class.\n\ngf-declaration--an optimize declaration specifier; other declaration\nspecifiers are not permitted.\n\ngf-documentation--a string; not evaluated.\n\ngf-lambda-list--a generic function lambda list.\n\nmethod-class--a non-nil symbol naming a class.\n\nmethod-combination-argument--an object.\n\nmethod-combination-name--a symbol naming a method combination type.\n\nmethod-qualifiers, specialized-lambda-list, declarations, documentation,\nforms--as per defmethod.\n\nnew-generic--the generic function object.\n\nparameter-name--a symbol that names a required parameter in the\nlambda-list.  (If the :argument-precedence-order option is specified, each\nrequired parameter in the lambda-list must be used exactly once as a\nparameter-name.)\n\nDescription::\n.............\n\nThe macro defgeneric is used to define a generic function or to specify\noptions and declarations that pertain to a generic function as a whole.\n\nIf function-name is a list it must be of the form (setf symbol).  If\n(fboundp function-name) is false, a new generic function is created.\n\nIf (fdefinition function-name) is a generic function, that\n\ngeneric function is modified.  If function-name names an ordinary function,\na macro, or a special operator, an error is signaled.\n\nThe effect of the defgeneric macro is as if the following three steps were\nperformed: first, methods defined by previous defgeneric forms are removed;\n\n[Reviewer Note by Barmar: Shouldn't this (second) be first?] second,\nensure-generic-function is called; and finally, methods specified by the\ncurrent defgeneric form are added to the generic function.\n\nEach method-description defines a method on the generic function.  The\nlambda list of each method must be congruent with the lambda list\nspecified by the gf-lambda-list option.  If no method descriptions are\nspecified and a generic function of the same name does not already exist,\na generic function with no methods is created.\n\nThe gf-lambda-list argument of defgeneric specifies the shape of lambda\nlists for the methods on this generic function.  All methods on the\nresulting generic function must have lambda lists that are congruent with\nthis shape.  If a defgeneric form is evaluated and some methods for that\ngeneric function have lambda lists that are not congruent with that given\nin the defgeneric form, an error is signaled.  For further details on\nmethod congruence, see *Note Congruent Lambda-lists for all Methods of a\nGeneric Function::.\n\nThe generic function passes to the method all the argument values passed to\nit, and only those; default values are not supported.  Note that optional\nand keyword arguments in method definitions, however, can have default\ninitial value forms and can use supplied-p parameters.\n\nThe following options are provided.\n\nExcept as otherwise noted,\n\na given option may occur only once.\n\n*\n     The :argument-precedence-order option is used to specify the order in\n     which the required arguments in a call to the generic function are\n     tested for specificity when selecting a particular method. Each\n     required argument, as specified in the gf-lambda-list argument, must\n     be included exactly once as a parameter-name so that the full and\n     unambiguous precedence order is supplied.  If this condition is not\n     met, an error is signaled.\n\n     [Reviewer Note by Barmar: What is the default order?]\n\n*\n     The declare option is used to specify declarations that pertain to\n     the generic function.\n\n     An optimize declaration specifier is allowed.  It specifies whether\n     method selection should be optimized for speed or space, but it has\n     no effect on methods.  To control how a method is optimized, an\n     optimize declaration must be placed directly in the defmethod form or\n     method description.  The optimization qualities speed and space are\n     the only qualities this standard requires, but an implementation can\n     extend the object system to recognize other qualities.  A simple\n     implementation that has only one method selection technique and\n     ignores optimize declaration specifiers is valid.\n\n     The special, ftype, function, inline, notinline, and declaration\n     declarations are not permitted.  Individual implementations can\n     extend the declare option to support additional declarations.\n\n     [Editorial Note by KMP: Does \"additional\" mean including special,\n     ftype, etc.?  Or only other things that are not mentioned here?] If\n     an implementation notices a declaration specifier that it does not\n     support and that has not been proclaimed as a non-standard\n     declaration identifier name in a declaration proclamation, it should\n     issue a warning.  [Editorial Note by KMP: The wording of this\n     previous sentence, particularly the word \"and\" suggests to me that\n     you can `proclaim declaration' of an unsupported declaration (e.g.,\n     ftype) in order to suppress the warning.  That seems wrong.  Perhaps\n     it instead means to say \"does not support or is both undefined and\n     not proclaimed declaration.\"]\n\n     The declare option may be specified more than once.  The effect is\n     the same as if the lists of declaration specifiers had been appended\n     together into a single list and specified as a single declare option.\n\n*\n     The :documentation argument is a documentation string to be attached\n     to the generic function object, and to be attached with kind function\n     to the function-name.\n\n*\n     The :generic-function-class option may be used to specify that the\n     generic function is to have a different class than the default\n     provided by the system (the class standard-generic-function).  The\n     class-name argument is the name of a class that can be the class of a\n     generic function.  If function-name specifies an existing generic\n     function that has a different value for the :generic-function-class\n     argument and the new generic function class is compatible with the\n     old, change-class is called to change the class of the generic\n     function; otherwise an error is signaled.\n\n*\n     The :method-class option is used to specify that all methods on this\n     generic function are to have a different class from the default\n     provided by the system (the class standard-method).  The class-name\n     argument is the name of a class that is capable of being the class of\n     a method.\n\n     [Reviewer Note by Barmar: Is change-class called on existing methods?]\n\n*\n     The :method-combination option is followed by a symbol that names a\n     type of method combination.  The arguments (if any) that follow that\n     symbol depend on the type of method combination.  Note that the\n     standard method combination type does not support any arguments.\n     However, all types of method combination defined by the short form of\n     define-method-combination accept an optional argument named order,\n     defaulting to :most-specific-first, where a value of\n     :most-specific-last reverses the order of the primary methods without\n     affecting the order of the auxiliary methods.\n\nThe method-description arguments define methods that will be associated\nwith the generic function.  The method-qualifier and\nspecialized-lambda-list arguments in a method description are the same as\nfor defmethod.\n\nThe form arguments specify the method body.  The body of the method is\nenclosed in an implicit block.  If function-name is a symbol, this block\nbears the same name as the generic function.  If function-name is a list\nof the form (setf symbol), the name of the block is symbol.\n\nImplementations can extend defgeneric to include other options.  It is\nrequired that an implementation signal an error if it observes an option\nthat is not implemented locally.\n\ndefgeneric is not required to perform any compile-time side effects.  In\nparticular, the methods are not installed for invocation during\ncompilation.  An implementation may choose to store information about the\ngeneric function for the purposes of compile-time error-checking (such as\nchecking the number of arguments on calls, or noting that a definition for\nthe function name has been seen).\n\nExamples::\n..........\n\nExceptional Situations::\n........................\n\nIf function-name names an ordinary function, a macro, or a special\noperator, an error of type program-error is signaled.\n\nEach required argument, as specified in the gf-lambda-list argument, must\nbe included exactly once as a parameter-name, or an error of type\nprogram-error is signaled.\n\nThe lambda list of each method specified by a method-description must be\ncongruent with the lambda list specified by the gf-lambda-list option, or\nan error of type error is signaled.\n\nIf a defgeneric form is evaluated and some methods for that generic\nfunction have lambda lists that are not congruent with that given in the\ndefgeneric form, an error of type error is signaled.\n\nA given option may occur only once, or an error of type program-error is\nsignaled.\n\n[Reviewer Note by Barmar: This says that an error is signaled if you\nspecify the same generic function class as it already has!] If\nfunction-name specifies an existing generic function that has a different\nvalue for the :generic-function-class argument and the new generic\nfunction class is compatible with the old, change-class is called to\nchange the class of the generic function; otherwise an error of type error\nis signaled.\n\nImplementations can extend defgeneric to include other options.  It is\nrequired that an implementation signal an error of type program-error if\nit observes an option that is not implemented locally.\n\nSee Also::\n..........\n\n*Note defmethod:: , *Note documentation; (setf documentation):: , *Note\nensure-generic-function:: ,\n\ngeneric-function,\n\n*Note Congruent Lambda-lists for all Methods of a Generic Function::\n\n"
}