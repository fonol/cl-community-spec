{
    "name": "substitute",
    "prev": "replace",
    "next": "concatenate",
    "up": "Sequences Dictionary",
    "header": {
        "type": null,
        "text": "nsubstitute, nsubstitute-if, nsubstitute-if-not"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "substitute",
                    "text": " newitem  olditem  sequence &key from-end test test-not startend count key\n=>  result-sequence\n\n"
                },
                {
                    "name": "substitute-if",
                    "text": " newitem predicate sequence &key from-end start end count\nkey\n=>  result-sequence\n\n"
                },
                {
                    "name": "substitute-if-not",
                    "text": " newitem predicate sequence &key from-end start end\ncount key\n=>  result-sequence\n\n"
                },
                {
                    "name": "nsubstitute",
                    "text": " newitem  olditem  sequence &key from-end test test-not\nstart end count key\n=>  sequence\n\n"
                },
                {
                    "name": "nsubstitute-if",
                    "text": " newitem predicate sequence &key from-end start end count\nkey\n=>  sequence\n\n"
                },
                {
                    "name": "nsubstitute-if-not",
                    "text": " newitem predicate sequence &key from-end start end\ncount key\n=>  sequence\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "newitem",
                    "desc": "an object."
                },
                {
                    "name": "olditem",
                    "desc": "an object."
                },
                {
                    "name": "sequence",
                    "desc": "a proper sequence."
                },
                {
                    "name": "predicate",
                    "desc": "a designator for a function of one argument that returns a"
                },
                {
                    "name": "predicate",
                    "desc": "a designator for a function of one argument that returns ageneralized boolean.\n"
                },
                {
                    "name": "from-end",
                    "desc": "a generalized boolean.  The default is false."
                },
                {
                    "name": "test",
                    "desc": "a designator for a function of two arguments that returns a"
                },
                {
                    "name": "test",
                    "desc": "a designator for a function of two arguments that returns ageneralized boolean.\n"
                },
                {
                    "name": "test-not",
                    "desc": "a designator for a function of two arguments that returns a"
                },
                {
                    "name": "test-not",
                    "desc": "a designator for a function of two arguments that returns ageneralized boolean.\n"
                },
                {
                    "name": "start, end",
                    "desc": "bounding index designators of sequence.  The defaults for"
                },
                {
                    "name": "start, end",
                    "desc": "bounding index designators of sequence.  The defaults forstart and end are 0 and nil, respectively.\n"
                },
                {
                    "name": "count",
                    "desc": "an integer or nil.The default is nil.\n"
                },
                {
                    "name": "key",
                    "desc": "a designator for a function of one argument, or nil."
                },
                {
                    "name": "result-sequence",
                    "desc": "a sequence."
                }
            ]
        },
        {
            "type": "Description",
            "text": "substitute, substitute-if, and substitute-if-not return a copy of sequence\nin which each element that satisfies the test has been replaced with\nnewitem.\nnsubstitute, nsubstitute-if, and nsubstitute-if-not are like substitute,\nsubstitute-if, and substitute-if-not respectively, but they may modify\nsequence.\nIf sequence is a vector, the result is a vector that has the same actual\narray element type as sequence.  The result might or might not be simple,\nand might or might not be identical to sequence.  If sequence is a list,\nthe result is a list.\nCount, if supplied, limits the number of elements altered; if more than\ncount elements satisfy the test, then of these elements only the leftmost\nor rightmost, depending on from-end, are replaced, as many as specified by\ncount.\nIf count is supplied and negative, the behavior is as if zero had been\nsupplied instead.\nIf count is nil, all matching items are affected.\nSupplying a from-end of true matters only when the count is provided (and\nnon-nil); in that case, only the rightmost count elements satisfying the\ntest are removed (instead of the leftmost).\npredicate, test, and test-not might be called more than once for each\nsequence element, and their side effects can happen in any order.\nThe result of all these functions is a sequence of the same type as\nsequence that has the same elements except that those in the subsequence\nbounded by start and end and satisfying the test have been replaced by\nnewitem.\nsubstitute, substitute-if, and substitute-if-not return a sequence which\ncan share with sequence or may be identical to the input sequence if no\nelements need to be changed.\nnsubstitute and  nsubstitute-if are required to setf any car (if sequence\nis a list) or aref (if sequence is a vector) of sequence that is required\nto be replaced with newitem.  If sequence is a list, none of the cdrs of\nthe top-level list can be modified.\n"
        },
        {
            "type": "Examples",
            "text": "      (substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\"\n      (substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)\n      (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)\n      (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)\n     =>  (1 2 4 1 3 9 5)\n      (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)\n      (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)\n     =>  ((1) (2) (3) 0)\n      (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)\n      (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)\n     =>  (1 2 4 1 3 9 5)\n      (setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)\n      (nsubstitute-if \"function was here\" #'fboundp some-things\n                      :count 1 :from-end t) =>  (A CAR B \"function was here\" C)\n      some-things =>  (A CAR B \"function was here\" C)\n      (setq alpha-tester (copy-seq \"ab \")) =>  \"ab \"\n      (nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\"\n      alpha-tester =>  \"abz\"\n"
        },
        {
            "type": "Side Effects",
            "text": "nsubstitute, nsubstitute-if, and nsubstitute-if-not modify sequence.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should be prepared to signal an error of type type-error if sequence is\nnot a proper sequence.\n"
        },
        {
            "type": "See Also",
            "text": "*Note subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not:: ,\nnsubst,\n*Note Compiler Terminology::,\n*Note Traversal Rules and Side Effects::\n"
        },
        {
            "type": "Notes",
            "text": "The :test-not argument is deprecated.\nThe functions substitute-if-not and nsubstitute-if-not are deprecated.\nnsubstitute and nsubstitute-if can be used in for-effect-only positions in\ncode.\nBecause the side-effecting variants (e.g., nsubstitute) potentially change\nthe path that is being traversed, their effects in the presence of shared\nor circular structure may vary in surprising ways when compared to their\nnon-side-effecting alternatives.  To see this, consider the following\nside-effect behavior, which might be exhibited by some implementations:\n      (defun test-it (fn)\n        (let ((x (cons 'b nil)))\n          (rplacd x x)\n          (funcall fn 'a 'b x :count 1)))\n      (test-it #'substitute) =>  (A . #1=(B . #1#))\n      (test-it #'nsubstitute) =>  (A . #1#)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: substitute,  Next: concatenate,  Prev: replace,  Up: Sequences Dictionary\n\nsubstitute, substitute-if, substitute-if-not,\n---------------------------------------------\n\nnsubstitute, nsubstitute-if, nsubstitute-if-not\n-----------------------------------------------\n\n                                                                [Function]\n\n`substitute'  newitem  olditem  sequence &key from-end test test-not start\nend count key\n=>  result-sequence\n\n`substitute-if'  newitem predicate sequence &key from-end start end count\nkey\n=>  result-sequence\n\n`substitute-if-not'  newitem predicate sequence &key from-end start end\ncount key\n=>  result-sequence\n\n`nsubstitute'  newitem  olditem  sequence &key from-end test test-not\nstart end count key\n=>  sequence\n\n`nsubstitute-if'  newitem predicate sequence &key from-end start end count\nkey\n=>  sequence\n\n`nsubstitute-if-not'  newitem predicate sequence &key from-end start end\ncount key\n=>  sequence\n\nArguments and Values::\n......................\n\nnewitem--an object.\n\nolditem--an object.\n\nsequence--a proper sequence.\n\npredicate--a designator for a function of one argument that returns a\ngeneralized boolean.\n\nfrom-end--a generalized boolean.  The default is false.\n\ntest--a designator for a function of two arguments that returns a\ngeneralized boolean.\n\ntest-not--a designator for a function of two arguments that returns a\ngeneralized boolean.\n\nstart, end--bounding index designators of sequence.  The defaults for\nstart and end are 0 and nil, respectively.\n\ncount--an integer or nil.\n\nThe default is nil.\n\nkey--a designator for a function of one argument, or nil.\n\nresult-sequence--a sequence.\n\nDescription::\n.............\n\nsubstitute, substitute-if, and substitute-if-not return a copy of sequence\nin which each element that satisfies the test has been replaced with\nnewitem.\n\nnsubstitute, nsubstitute-if, and nsubstitute-if-not are like substitute,\nsubstitute-if, and substitute-if-not respectively, but they may modify\nsequence.\n\nIf sequence is a vector, the result is a vector that has the same actual\narray element type as sequence.  The result might or might not be simple,\nand might or might not be identical to sequence.  If sequence is a list,\nthe result is a list.\n\nCount, if supplied, limits the number of elements altered; if more than\ncount elements satisfy the test, then of these elements only the leftmost\nor rightmost, depending on from-end, are replaced, as many as specified by\ncount.\n\nIf count is supplied and negative, the behavior is as if zero had been\nsupplied instead.\n\nIf count is nil, all matching items are affected.\n\nSupplying a from-end of true matters only when the count is provided (and\nnon-nil); in that case, only the rightmost count elements satisfying the\ntest are removed (instead of the leftmost).\n\npredicate, test, and test-not might be called more than once for each\nsequence element, and their side effects can happen in any order.\n\nThe result of all these functions is a sequence of the same type as\nsequence that has the same elements except that those in the subsequence\nbounded by start and end and satisfying the test have been replaced by\nnewitem.\n\nsubstitute, substitute-if, and substitute-if-not return a sequence which\ncan share with sequence or may be identical to the input sequence if no\nelements need to be changed.\n\nnsubstitute and  nsubstitute-if are required to setf any car (if sequence\nis a list) or aref (if sequence is a vector) of sequence that is required\nto be replaced with newitem.  If sequence is a list, none of the cdrs of\nthe top-level list can be modified.\n\nExamples::\n..........\n\n      (substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\"\n      (substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)\n      (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)\n      (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)\n     =>  (1 2 4 1 3 9 5)\n      (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)\n     \n      (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)\n     =>  ((1) (2) (3) 0)\n      (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)\n      (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)\n     =>  (1 2 4 1 3 9 5)\n     \n      (setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)\n      (nsubstitute-if \"function was here\" #'fboundp some-things\n                      :count 1 :from-end t) =>  (A CAR B \"function was here\" C)\n      some-things =>  (A CAR B \"function was here\" C)\n      (setq alpha-tester (copy-seq \"ab \")) =>  \"ab \"\n      (nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\"\n      alpha-tester =>  \"abz\"\n\nSide Effects::\n..............\n\nnsubstitute, nsubstitute-if, and nsubstitute-if-not modify sequence.\n\nExceptional Situations::\n........................\n\nShould be prepared to signal an error of type type-error if sequence is\nnot a proper sequence.\n\nSee Also::\n..........\n\n*Note subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not:: ,\nnsubst,\n\n*Note Compiler Terminology::,\n\n*Note Traversal Rules and Side Effects::\n\nNotes::\n.......\n\nThe :test-not argument is deprecated.\n\nThe functions substitute-if-not and nsubstitute-if-not are deprecated.\n\nnsubstitute and nsubstitute-if can be used in for-effect-only positions in\ncode.\n\nBecause the side-effecting variants (e.g., nsubstitute) potentially change\nthe path that is being traversed, their effects in the presence of shared\nor circular structure may vary in surprising ways when compared to their\nnon-side-effecting alternatives.  To see this, consider the following\nside-effect behavior, which might be exhibited by some implementations:\n\n      (defun test-it (fn)\n        (let ((x (cons 'b nil)))\n          (rplacd x x)\n          (funcall fn 'a 'b x :count 1)))\n      (test-it #'substitute) =>  (A . #1=(B . #1#))\n      (test-it #'nsubstitute) =>  (A . #1#)\n\n"
}