{
    "name": "defstruct",
    "prev": "Structures Dictionary",
    "next": "copy-structure",
    "up": "Structures Dictionary",
    "header": {
        "type": "Macro",
        "text": "defstruct"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "defstruct",
                    "text": " name-and-options [documentation] {!slot-description}*=>  structure-name\n\nname-and-options ::=structure-name | (structure-name [[!options]])\n\noptions ::=!conc-name-option |             {!constructor-option}* |\n            !copier-option |             !include-option |\n            !initial-offset-option |             !named-option |\n            !predicate-option |             !printer-option |\n            !type-option\n\nconc-name-option ::=:conc-name | (:conc-name) | (:conc-name conc-name)\n\nconstructor-option ::=:constructor |\n                       (:constructor) |\n                       (:constructor constructor-name) |\n                       (:constructor constructor-name constructor-arglist)\n\ncopier-option ::=:copier | (:copier) | (:copier copier-name)\n\npredicate-option ::=:predicate | (:predicate) | (:predicate predicate-name)\n\ninclude-option ::=(:include included-structure-name {!slot-description}*)\n\nprinter-option ::=!print-object-option | !print-function-option\n\nprint-object-option ::=(:print-object printer-name) | (:print-object)\n\nprint-function-option ::=(:print-function printer-name) | (:print-function)\n\ntype-option ::=(:type type)\n\nnamed-option ::=:named\n\ninitial-offset-option ::=(:initial-offset initial-offset)\n\nslot-description ::=slot-name | \n                     (slot-name [slot-initform [[!slot-option]]])\n\nslot-option ::=:type slot-type | \n                :read-only slot-read-only-p\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "conc-name",
                    "desc": "a string designator."
                },
                {
                    "name": "constructor-arglist",
                    "desc": "a boa lambda list."
                },
                {
                    "name": "constructor-name",
                    "desc": "a symbol."
                },
                {
                    "name": "copier-name",
                    "desc": "a symbol."
                },
                {
                    "name": "included-structure-name",
                    "desc": "an already-defined structure name.Note that a derived type is not permissible, even if it would expand into\na structure name.\n"
                },
                {
                    "name": "initial-offset",
                    "desc": "a non-negative integer."
                },
                {
                    "name": "predicate-name",
                    "desc": "a symbol."
                },
                {
                    "name": "printer-name",
                    "desc": "a function name or a lambda expression."
                },
                {
                    "name": "slot-name",
                    "desc": "a symbol."
                },
                {
                    "name": "slot-initform",
                    "desc": "a form."
                },
                {
                    "name": "slot-read-only-p",
                    "desc": "a generalized boolean."
                },
                {
                    "name": "structure-name",
                    "desc": "a symbol."
                },
                {
                    "name": "type",
                    "desc": "one of the type specifiers list, vector, or (vector size), or some"
                },
                {
                    "name": "type",
                    "desc": "one of the type specifiers list, vector, or (vector size), or someother type specifier defined by the implementation to be appropriate.\n"
                },
                {
                    "name": "documentation",
                    "desc": "a string; not evaluated."
                }
            ]
        },
        {
            "type": "Description",
            "text": "defstruct defines a structured type, named structure-type, with named\nslots as specified by the slot-options.\ndefstruct defines readers for the slots and arranges for setf to work\nproperly on such reader functions.  Also, unless overridden, it defines a\npredicate named name-p, defines a constructor function named\nmake-constructor-name, and defines a copier function named\ncopy-constructor-name.  All names of automatically created functions might\nautomatically be declared inline (at the discretion of the implementation).\nIf documentation is supplied, it is attached to structure-name as a\ndocumentation string of kind structure,\nand unless :type is used, the documentation is also attached to\nstructure-name as a documentation string of kind type and as a\ndocumentation string to the class object for the class named\nstructure-name.\ndefstruct defines a constructor function that is used to create instances\nof the structure created by defstruct.  The default name is\nmake-structure-name.  A different name can be supplied by giving the name\nas the argument to the constructor option.  nil indicates that no\nconstructor function will be created.\nAfter a new structure type has been defined, instances of that type\nnormally can be created by using the constructor function for the type.  A\ncall to a constructor function is of the following form:\n (constructor-function-name\n  slot-keyword-1 form-1\n  slot-keyword-2 form-2\n  ...)\nThe arguments to the constructor function are all keyword arguments.  Each\nslot keyword argument must  be a keyword whose name corresponds to the\nname of a structure slot.  All the keywords and forms are evaluated.  If a\nslot is not initialized in this way, it is initialized by evaluating\nslot-initform in the slot description\nat the time the constructor function is called.\nIf no slot-initform is supplied, the consequences are undefined if an\nattempt is later made to read the slot's value before a value is\nexplicitly assigned.\nEach slot-initform supplied for a defstruct component, when used by the\nconstructor function for an otherwise unsupplied component, is\nre-evaluated on every call to the constructor function.\nThe slot-initform is not evaluated unless it is needed in the creation of\na particular structure instance.  If it is never needed, there can be no\ntype-mismatch error, even if the type of the slot is specified; no warning\nshould be issued in this case.\nFor example, in the following sequence, only the last call is an error.\n      (defstruct person (name 007 :type string))\n      (make-person :name \"James\")\n      (make-person)\nIt is as if the slot-initforms were used as initialization forms for the\nkeyword parameters of the constructor function.\nThe symbols which name the slots must not be used by the implementation as\nthe names for the lambda variables in the constructor function, since one\nor more of those symbols might have been proclaimed special or might be\ndefined as the name of a constant variable.  The slot default init forms\nare evaluated in the lexical environment in which the defstruct form\nitself appears and in the dynamic environment in which the call to the\nconstructor function appears.\nFor example, if the form (gensym) were used as an initialization form,\neither in the constructor-function call or as the default initialization\nform in defstruct, then every call to the constructor function would call\ngensym once to generate a new symbol.\nEach slot-description in defstruct can specify zero or more slot-options.\nA slot-option consists of a pair of a keyword and a value (which is not a\nform to be evaluated, but the value itself).  For example:\n      (defstruct ship\n        (x-position 0.0 :type short-float)\n        (y-position 0.0 :type short-float)\n        (x-velocity 0.0 :type short-float)\n        (y-velocity 0.0 :type short-float)\n        (mass *default-ship-mass* :type short-float :read-only t))\nThis specifies that each slot always contains a short float, and that the\nlast slot cannot be altered once a ship is constructed.\nThe available slot-options are:\n:type type\n     This specifies that the contents of the slot is always of type type.\n     This is entirely analogous to the declaration of a variable or\n     function; it effectively declares the result type of the reader\n     function.  It is implementation-dependent whether the type is checked\n     when initializing a slot or when assigning to it.  Type is not\n     evaluated; it must be a valid type specifier.\n:read-only x\n     When x is true, this specifies that this slot cannot be altered; it\n     will always contain the value supplied at construction time.  setf\n     will not accept the reader function for this slot.  If x is false,\n     this slot-option has no effect.  X is not evaluated.\n     When this option is false or unsupplied, it is\n     implementation-dependent whether the ability to write the slot is\n     implemented by a setf function or a setf expander.\nThe following keyword options are available for use with defstruct.  A\ndefstruct option can be either a keyword or a list of a keyword and\narguments for that keyword; specifying the keyword by itself is equivalent\nto specifying a list consisting of the keyword and no arguments.  The\nsyntax for defstruct options differs from the pair syntax used for\nslot-options.  No part of any of these options is evaluated.\n:conc-name\n     This provides for automatic prefixing of names of reader (or access)\n     functions.  The default behavior is to begin the names of all the\n     reader functions of a structure with the name of the structure\n     followed by a hyphen.\n     :conc-name supplies an alternate prefix to be used.  If a hyphen is\n     to be used as a separator, it must be supplied as part of the prefix.\n     If :conc-name is nil or no argument is supplied, then no prefix is\n     used; then the names of the reader functions are the same as the slot\n     names.  If a non-nil prefix is given, the name of the reader function\n     for each slot is constructed by concatenating that prefix and the\n     name of the slot, and interning the resulting symbol in the package\n     that is current at the time the defstruct form is expanded.\n     Note that no matter what is supplied for :conc-name, slot keywords\n     that match the slot names with no prefix attached are used with a\n     constructor function.  The reader function name is used in\n     conjunction with setf.  Here is an example:\n           (defstruct (door (:conc-name dr-)) knob-color width material) =>  DOOR\n           (setq my-door (make-door :knob-color 'red :width 5.0))\n          =>  #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)\n           (dr-width my-door) =>  5.0\n           (setf (dr-width my-door) 43.7) =>  43.7\n           (dr-width my-door) =>  43.7\n     Whether or not the :conc-name option is explicitly supplied, the\n     following rule governs name conflicts of generated reader (or\n     accessor) names: For any structure type S_1 having a reader function\n     named R for a slot named X_1 that is inherited by another structure\n     type S_2 that would have a reader function with the same name R for a\n     slot named X_2, no definition for R is generated by the definition of\n     S_2; instead, the definition of R is inherited from the definition of\n     S_1.  (In such a case, if X_1 and X_2 are different slots, the\n     implementation might signal a style warning.)\n:constructor\n     This option takes zero, one, or two arguments.  If at least one\n     argument is supplied and the first argument is not nil, then that\n     argument is a symbol which specifies the name of the constructor\n     function.  If the argument is not supplied (or if the option itself\n     is not supplied), the name of the constructor is produced by\n     concatenating the string \"MAKE-\" and the name of the structure,\n     interning the name in whatever package is current at the time\n     defstruct is expanded.  If the argument is provided and is nil, no\n     constructor function is defined.\n     If :constructor is given as (:constructor name arglist), then instead\n     of making a keyword driven constructor function, defstruct defines a\n     \"positional\" constructor function, taking arguments whose meaning is\n     determined by the argument's position and possibly by keywords.\n     Arglist is used to describe what the arguments to the constructor\n     will be. In the simplest case something like (:constructor make-foo\n     (a b c)) defines make-foo to be a three-argument constructor function\n     whose arguments are used to initialize the slots named a, b, and c.\n     Because a constructor of this type operates \"By Order of Arguments,\"\n     it is sometimes known as a \"boa constructor.\"\n     For information on how the arglist for a \"boa constructor\" is\n     processed, see *Note Boa Lambda Lists::.\n     It is permissible to use the :constructor option more than once, so\n     that you can define several different constructor functions, each\n     taking different parameters.\n     [Reviewer Note by Barmar: What about (:constructor) and (:constructor\n     nil).  Should we worry about it?]\n     defstruct creates the default-named keyword constructor function only\n     if no explicit :constructor options are specified, or if the\n     :constructor option is specified without a name argument.\n     (:constructor nil) is meaningful only when there are no other\n     :constructor options specified.  It prevents defstruct from\n     generating any constructors at all.\n     Otherwise, defstruct creates a constructor function corresponding to\n     each supplied :constructor option.  It is permissible to specify\n     multiple keyword constructor functions as well as multiple \"boa\n     constructors\".\n:copier\n     This option takes one argument, a symbol, which specifies the name of\n     the copier function.  If the argument is not provided or if the\n     option itself is not provided, the name of the copier is produced by\n     concatenating the string \"COPY-\" and the name of the structure,\n     interning the name in whatever package is current at the time\n     defstruct is expanded.  If the argument is provided and is nil, no\n     copier function is defined.\n     The automatically defined copier function is a function of one\n     argument,\n     which must be of the structure type being defined.\n     The copier function creates a fresh structure that has the same type\n     as its argument, and that has the same component values as the\n     original structure; that is, the component values are not copied\n     recursively.\n     If the defstruct :type option was not used, the following equivalence\n     applies:\n           (copier-name x) = (copy-structure (the structure-name x))\n:include\n     This option is used for building a new structure definition as an\n     extension of another structure definition.  For example:\n           (defstruct person name age sex)\n     To make a new structure to represent an astronaut that has the\n     attributes of name, age, and sex, and functions that operate on\n     person structures, astronaut is defined with :include as follows:\n           (defstruct (astronaut (:include person)\n                                 (:conc-name astro-))\n              helmet-size\n              (favorite-beverage 'tang))\n     :include causes the structure being defined to have the same slots as\n     the included structure.  This is done in such a way that the reader\n     functions for the included structure also work on the structure being\n     defined.  In this example, an astronaut therefore has five slots: the\n     three defined in person and the two defined in astronaut itself.  The\n     reader functions defined by the person structure can be applied to\n     instances of the astronaut structure, and they work correctly.\n     Moreover, astronaut has its own reader functions for components\n     defined by the person structure.  The following examples illustrate\n     the use of astronaut structures:\n           (setq x (make-astronaut :name 'buzz\n                                   :age 45.\n                                   :sex t\n                                   :helmet-size 17.5))\n           (person-name x) =>  BUZZ\n           (astro-name x) =>  BUZZ\n           (astro-favorite-beverage x) =>  TANG\n           (reduce #'+ astros :key #'person-age) ; obtains the total of the ages\n                                                 ; of the possibly empty\n                                                 ; sequence of astros\n     The difference between the reader functions person-name and astro-name\n     is that person-name can be correctly applied to any person, including\n     an astronaut, while astro-name can be correctly applied only to an\n     astronaut.  An implementation might check for incorrect use of reader\n     functions.\n     At most one :include can be supplied in a single defstruct.  The\n     argument to :include is required and must be the name of some\n     previously defined structure.  If the structure being defined has no\n     :type option, then the included structure must also have had no :type\n     option supplied for it.  If the structure being defined has a :type\n     option, then the included structure must have been declared with a\n     :type option specifying the same representation type.\n     If no :type option is involved, then the structure name of the\n     including structure definition becomes the name of a data type, and\n     therefore a valid type specifier recognizable by typep; it becomes a\n     subtype of the included structure.  In the above example, astronaut\n     is a subtype of person; hence\n           (typep (make-astronaut) 'person) =>  true\n     indicating that all operations on persons also work on astronauts.\n     The structure using :include can specify default values or\n     slot-options for the included slots different from those the included\n     structure specifies, by giving the :include option as:\n           (:include included-structure-name {slot-description}*)\n     Each slot-description must have a slot-name that is the same as that\n     of some slot in the included structure.  If a slot-description has no\n     slot-initform, then in the new structure the slot has no initial\n     value.  Otherwise its initial value form is replaced by the\n     slot-initform in the slot-description.  A normally writable slot can\n     be made read-only.  If a slot is read-only in the included structure,\n     then it must also be so in the including structure.  If a type is\n     supplied for a slot, it must be a subtype of the type specified in\n     the included structure.\n     For example, if the default age for an astronaut is 45, then\n           (defstruct (astronaut (:include person (age 45)))\n              helmet-size\n              (favorite-beverage 'tang))\n     If :include is used with the :type option, then the effect is first\n     to skip over as many representation elements as needed to represent\n     the included structure, then to skip over any additional elements\n     supplied by the :initial-offset option, and then to begin allocation\n     of elements from that point.  For example:\n           (defstruct (binop (:type list) :named (:initial-offset 2))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n           (defstruct (annotated-binop (:type list)\n                                       (:initial-offset 3)\n                                       (:include binop))\n            commutative associative identity) =>  ANNOTATED-BINOP\n           (make-annotated-binop :operator '*\n                                 :operand-1 'x\n                                 :operand-2 5\n                                 :commutative t\n                                 :associative t\n                                 :identity 1)\n             =>  (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)\n     The first two nil elements stem from the :initial-offset of 2 in the\n     definition of binop.  The next four elements contain the structure\n     name and three slots for binop.  The next three nil elements stem\n     from the :initial-offset of 3 in the definition of annotated-binop.\n     The last three list elements contain the additional slots for an\n     annotated-binop.\n:initial-offset\n     :initial-offset instructs defstruct to skip over a certain number of\n     slots before it starts allocating the slots described in the body.\n     This option's argument is the number of slots defstruct should skip.\n     :initial-offset can be used only if :type is also supplied.\n     [Reviewer Note by Barmar: What are initial values of the skipped\n     slots?]\n     :initial-offset allows slots to be allocated beginning at a\n     representational element other than the first.  For example, the form\n           (defstruct (binop (:type list) (:initial-offset 2))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n     would result in the following behavior for make-binop:\n           (make-binop :operator '+ :operand-1 'x :operand-2 5)\n          =>  (NIL NIL + X 5)\n           (make-binop :operand-2 4 :operator '*)\n          =>  (NIL NIL * NIL 4)\n     The selector functions binop-operator, binop-operand-1, and\n     binop-operand-2 would be essentially equivalent to third, fourth, and\n     fifth, respectively.  Similarly, the form\n           (defstruct (binop (:type list) :named (:initial-offset 2))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n     would result in the following behavior for make-binop:\n           (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (NIL NIL BINOP + X 5)\n           (make-binop :operand-2 4 :operator '*) =>  (NIL NIL BINOP * NIL 4)\n     The first two nil elements stem from the :initial-offset of 2 in the\n     definition of binop.  The next four elements contain the structure\n     name and three slots for binop.\n:named\n     :named specifies that the structure is named.  If no :type is\n     supplied, then the structure is always named.\n     For example:\n           (defstruct (binop (:type list))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n     This defines a constructor function make-binop and three selector\n     functions, namely binop-operator, binop-operand-1, and\n     binop-operand-2.  (It does not, however, define a predicate binop-p,\n     for reasons explained below.)\n     The effect of make-binop is simply to construct a list of length\n     three:\n           (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (+ X 5)\n           (make-binop :operand-2 4 :operator '*) =>  (* NIL 4)\n     It is just like the function list except that it takes keyword\n     arguments and performs slot defaulting appropriate to the binop\n     conceptual data type.  Similarly, the selector functions\n     binop-operator, binop-operand-1, and binop-operand-2 are essentially\n     equivalent to car, cadr, and caddr, respectively.  They might not be\n     completely equivalent because, for example, an implementation would\n     be justified in adding error-checking code to ensure that the\n     argument to each selector function is a length-3 list.\n     binop is a conceptual data type in that it is not made a part of the\n     Common Lisp type system.  typep does not recognize binop as a type\n     specifier, and type-of returns list when given a binop structure.\n     There is no way to distinguish a data structure constructed by\n     make-binop from any other list that happens to have the correct\n     structure.\n     There is not any way to recover the structure name binop from a\n     structure created by make-binop.  This can only be done if the\n     structure is named.  A named structure has the property that, given\n     an instance of the structure, the structure name (that names the\n     type) can be reliably recovered.  For structures defined with no\n     :type option, the structure name actually becomes part of the Common\n     Lisp data-type system.  type-of, when applied to such a structure,\n     returns the structure name as the type of the object; typep recognizes\n     the structure name as a valid type specifier.\n     For structures defined with a :type option, type-of returns a type\n     specifier such as list or (vector t), depending on the type supplied\n     to the :type option.  The structure name does not become a valid type\n     specifier.  However, if the :named option is also supplied, then the\n     first component of the structure (as created by a defstruct\n     constructor function) always contains the structure name.  This\n     allows the structure name to be recovered from an instance of the\n     structure and allows a reasonable predicate for the conceptual type\n     to be defined: the automatically defined name-p predicate for the\n     structure operates by first checking that its argument is of the\n     proper type (list, (vector t), or whatever) and then checking whether\n     the first component contains the appropriate type name.\n     Consider the binop example shown above, modified only to include the\n     :named option:\n           (defstruct (binop (:type list) :named)\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n     As before, this defines a constructor function make-binop and three\n     selector functions binop-operator, binop-operand-1, and\n     binop-operand-2.  It also defines a predicate binop-p.  The effect of\n     make-binop is now to construct a list of length four:\n           (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (BINOP + X 5)\n           (make-binop :operand-2 4 :operator '*) =>  (BINOP * NIL 4)\n     The structure has the same layout as before except that the structure\n     name binop is included as the first list element.  The selector\n     functions binop-operator, binop-operand-1, and binop-operand-2 are\n     essentially equivalent to cadr, caddr, and cadddr, respectively.  The\n     predicate binop-p is more or less equivalent to this definition:\n           (defun binop-p (x)\n             (and (consp x) (eq (car x) 'binop))) =>  BINOP-P\n     The name binop is still not a valid type specifier recognizable to\n     typep, but at least there is a way of distinguishing binop structures\n     from other similarly defined structures.\n:predicate\n     This option takes one argument, which specifies the name of the type\n     predicate.  If the argument is not supplied or if the option itself\n     is not supplied, the name of the predicate is made by concatenating\n     the name of the structure to the string \"-P\", interning the name in\n     whatever package is current at the time defstruct is expanded.  If\n     the argument is provided and is nil, no predicate is defined.  A\n     predicate can be defined only if the structure is named; if :type is\n     supplied and :named is not supplied, then :predicate must either be\n     unsupplied or have the value nil.\n:print-function, :print-object\n     The :print-function and :print-object options specify that a\n     print-object method for structures of type structure-name should be\n     generated.  These options are not synonyms, but do perform a similar\n     service; the choice of which option (:print-function or\n     :print-object) is used affects how the function named printer-name is\n     called.  Only one of these options may be used, and these options may\n     be used only if :type is not supplied.\n     If the :print-function option is used, then when a structure of type\n     structure-name is to be printed, the designated printer function is\n     called on three arguments:\n    -\n          the structure to be printed (a generalized instance of\n          structure-name).\n    -\n          a stream to print to.\n    -\n          an integer indicating the current depth.  The magnitude of this\n          integer may vary between implementations; however, it can\n          reliably be compared against *print-level* to determine whether\n          depth abbreviation is appropriate.\n     Specifying (:print-function printer-name) is approximately equivalent\n     to specifying:\n           (defmethod print-object ((object structure-name) stream)\n             (funcall (function printer-name) object stream <<current-print-depth>>))\n     where the <<current-print-depth>> represents the printer's belief of\n     how deep it is currently printing.  It is implementation-dependent\n     whether <<current-print-depth>> is always 0 and *print-level*, if\n     non-nil, is re-bound to successively smaller values as printing\n     descends recursively, or whether current-print-depth varies in value\n     as printing descends recursively and *print-level* remains constant\n     during the same traversal.\n     If the :print-object option is used, then when a structure of type\n     structure-name is to be printed, the designated printer function is\n     called on two arguments:\n    -\n          the structure to be printed.\n    -\n          the stream to print to.\n     Specifying (:print-object printer-name) is equivalent to specifying:\n           (defmethod print-object ((object structure-name) stream)\n             (funcall (function printer-name) object stream))\n     If no :type option is supplied, and if either a :print-function or a\n     :print-object option is supplied, and if no printer-name is supplied,\n     then a print-object method specialized for structure-name is\n     generated that calls a function that implements the default printing\n     behavior for structures using #S notation; see *Note Printing\n     Structures::.\n     If neither a :print-function nor a :print-object option is supplied,\n     then defstruct does not generate a print-object method specialized\n     for structure-name and some default behavior is inherited either from\n     a structure named in an :include option or from the default behavior\n     for printing structures; see the function print-object and *Note\n     Printing Structures::.\n     When *print-circle* is true, a user-defined print function can print\n     objects to the supplied stream using write, prin1, princ, or format\n     and expect circularities to be detected and printed using the #n#\n     syntax.  This applies to methods on print-object in addition to\n     :print-function options.  If a user-defined print function prints to\n     a stream other than the one that was supplied, then circularity\n     detection starts over for that stream.  See the variable\n     *print-circle*.\n:type\n     :type explicitly specifies the representation to be used for the\n     structure.  Its argument must be one of these types:\n    vector\n          This produces the same result as specifying (vector t).  The\n          structure is represented as a general vector, storing components\n          as vector elements.  The first component is vector element 1 if\n          the structure is :named, and element 0 otherwise.\n          [Reviewer Note by Barmar: Do any implementations create\n          non-simple vectors?]\n    (vector element-type)\n          The structure is represented as a (possibly specialized) vector,\n          storing components as vector elements.  Every component must be\n          of a type that can be stored in a vector of the type specified.\n          The first component is vector element 1 if the structure is\n          :named, and element 0 otherwise.  The structure can be :named\n          only if the type symbol is a subtype of the supplied\n          element-type.\n    list\n          The structure is represented as a list.  The first component is\n          the cadr if the structure is :named, and the car if it is not\n          :named.\n     Specifying this option has the effect of forcing a specific\n     representation and of forcing the components to be stored in the\n     order specified in defstruct in corresponding successive elements of\n     the specified representation.  It also prevents the structure name\n     from becoming a valid type specifier recognizable by typep.\n     For example:\n           (defstruct (quux (:type list) :named) x y)\n     should make a constructor that builds a list exactly like the one\n     that list produces, with quux as its car.\n     If this type is defined:\n           (deftype quux () '(satisfies quux-p))\n     then this form\n           (typep (make-quux) 'quux)\n     should return precisely what this one does\n           (typep (list 'quux nil nil) 'quux)\n     If :type is not supplied, the structure is represented as an object\n     of type structure-object.\n     defstruct without a :type option defines a class with the structure\n     name as its name. The metaclass of structure instances is\n     structure-class.\nThe consequences of redefining a defstruct structure are undefined.\nIn the case where no defstruct options have been supplied, the following\nfunctions are automatically defined to operate on instances of the new\nstructure:\nPredicate\n     A predicate with the name structure-name-p is defined to test\n     membership in the structure type.  The predicate (structure-name-p\n     object) is true if an object is of this type; otherwise it is false.\n     typep can also be used with the name of the new type to test whether\n     an object belongs to the type.  Such a function call has the form\n     (typep object 'structure-name).\nComponent reader functions\n     Reader functions are defined to read the components of the structure.\n     For each slot name, there is a corresponding reader function with\n     the name structure-name-slot-name.  This function reads the contents\n     of that slot.  Each reader function takes one argument, which is an\n     instance of the structure type.  setf can be used with any of these\n     reader functions to alter the slot contents.\nConstructor function\n     A constructor function with the name make-structure-name is defined.\n     This function creates and returns new instances of the structure type.\nCopier function\n     A copier function with the name copy-structure-name is defined.  The\n     copier function takes an object of the structure type and creates a\n     new object of the same  type that is a copy of the first.  The copier\n     function creates a new structure with the same component entries as\n     the original.  Corresponding components of the two structure instances\n     are eql.\nIf a defstruct form appears as a top level form, the compiler must make\nthe structure type name recognized as a valid type name in subsequent\ndeclarations (as for deftype) and make the structure slot readers known to\nsetf.  In addition, the compiler must save enough information about the\nstructure type so that further defstruct definitions can use :include in a\nsubsequent deftype in the same file to refer to the structure type name.\nThe functions which defstruct generates are not defined in the compile\ntime environment, although the compiler may save enough information about\nthe functions to code subsequent calls inline.  The #S reader macro might\nor might not recognize the newly defined structure type name at compile\ntime.\n"
        },
        {
            "type": "Examples",
            "text": "An example of a structure definition follows:\n      (defstruct ship\n        x-position\n        y-position\n        x-velocity\n        y-velocity\n        mass)\nThis declares that every ship is an object with five named components.\nThe evaluation of this form does the following:\n1.\n     It defines ship-x-position to be a function of one argument, a ship,\n     that returns the x-position of the ship; ship-y-position and the\n     other components are given similar function definitions.  These\n     functions are called the access functions, as they are used to access\n     elements of the structure.\n2.\n     ship becomes the name of a type of which instances of ships are\n     elements.  ship becomes acceptable to typep, for example; (typep x\n     'ship) is true if x is a ship and false if x is any object other than\n     a ship.\n3.\n     A function named ship-p of one argument is defined; it is a predicate\n     that is true if its argument is a ship and is false otherwise.\n4.\n     A function called make-ship is defined that, when invoked, creates a\n     data structure with five components, suitable for use with the access\n     functions.  Thus executing\n           (setq ship2 (make-ship))\n     sets ship2 to a newly created ship object.  One can supply the\n     initial values of any desired component in the call to make-ship by\n     using keyword arguments in this way:\n           (setq ship2 (make-ship :mass *default-ship-mass*\n                                  :x-position 0\n                                  :y-position 0))\n     This constructs a new ship and initializes three of its components.\n     This function is called the \"constructor function\" because it\n     constructs a new structure.\n5.\n     A function called copy-ship of one argument is defined that, when\n     given a ship object, creates a new ship object that is a copy of the\n     given one.  This function is called the \"copier function.\"\nsetf can be used to alter the components of a ship:\n      (setf (ship-x-position ship2) 100)\nThis alters the x-position of ship2 to be 100.  This works because\ndefstruct behaves as if it generates an appropriate defsetf for each\naccess function.\n     ;;;\n     ;;; Example 1\n     ;;; define town structure type\n     ;;; area, watertowers, firetrucks, population, elevation are its components\n     ;;;\n      (defstruct town\n                  area\n                  watertowers\n                  (firetrucks 1 :type fixnum)    ;an initialized slot\n                  population\n                  (elevation 5128 :read-only t)) ;a slot that can't be changed\n     =>  TOWN\n     ;create a town instance\n      (setq town1 (make-town :area 0 :watertowers 0)) =>  #S(TOWN...)\n     ;town's predicate recognizes the new instance\n      (town-p town1) =>  true\n     ;new town's area is as specified by make-town\n      (town-area town1) =>  0\n     ;new town's elevation has initial value\n      (town-elevation town1) =>  5128\n     ;setf recognizes reader function\n      (setf (town-population town1) 99) =>  99\n      (town-population town1) =>  99\n     ;copier function makes a copy of town1\n      (setq town2 (copy-town town1)) =>  #S(TOWN...)\n      (= (town-population town1) (town-population town2))  =>  true\n     ;since elevation is a read-only slot, its value can be set only\n     ;when the structure is created\n      (setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))\n     =>  #S(TOWN...)\n     ;;;\n     ;;; Example 2\n     ;;; define clown structure type\n     ;;; this structure uses a nonstandard prefix\n     ;;;\n      (defstruct (clown (:conc-name bozo-))\n                  (nose-color 'red)\n                  frizzy-hair-p polkadots) =>  CLOWN\n      (setq funny-clown (make-clown)) =>  #S(CLOWN)\n     ;use non-default reader name\n      (bozo-nose-color funny-clown) =>  RED\n      (defstruct (klown (:constructor make-up-klown) ;similar def using other\n                  (:copier clone-klown)              ;customizing keywords\n                  (:predicate is-a-bozo-p))\n                  nose-color frizzy-hair-p polkadots) =>  klown\n     ;custom constructor now exists\n      (fboundp 'make-up-klown) =>  true\n     ;;;\n     ;;; Example 3\n     ;;; define a vehicle structure type\n     ;;; then define a truck structure type that includes\n     ;;; the vehicle structure\n     ;;;\n      (defstruct vehicle name year (diesel t :read-only t)) =>  VEHICLE\n      (defstruct (truck (:include vehicle (year 79)))\n                  load-limit\n                  (axles 6)) =>  TRUCK\n      (setq x (make-truck :name 'mac :diesel t :load-limit 17))\n     =>  #S(TRUCK...)\n     ;vehicle readers work on trucks\n      (vehicle-name x)\n     =>  MAC\n     ;default taken from :include clause\n      (vehicle-year x)\n     =>  79\n      (defstruct (pickup (:include truck))     ;pickup type includes truck\n                  camper long-bed four-wheel-drive) =>  PICKUP\n      (setq x (make-pickup :name 'king :long-bed t)) =>  #S(PICKUP...)\n     ;:include default inherited\n      (pickup-year x) =>  79\n     ;;;\n     ;;; Example 4\n     ;;; use of BOA constructors\n     ;;;\n      (defstruct (dfs-boa                      ;BOA constructors\n                    (:constructor make-dfs-boa (a b c))\n                    (:constructor create-dfs-boa\n                      (a &optional b (c 'cc) &rest d &aux e (f 'ff))))\n                  a b c d e f) =>  DFS-BOA\n     ;a, b, and c set by position, and the rest are uninitialized\n      (setq x (make-dfs-boa 1 2 3)) =>  #(DFS-BOA...)\n      (dfs-boa-a x) =>  1\n     ;a and b set, c and f defaulted\n      (setq x (create-dfs-boa 1 2)) =>  #(DFS-BOA...)\n      (dfs-boa-b x) =>  2\n      (eq (dfs-boa-c x) 'cc) =>  true\n     ;a, b, and c set, and the rest are collected into d\n      (setq x (create-dfs-boa 1 2 3 4 5 6)) =>  #(DFS-BOA...)\n      (dfs-boa-d x) =>  (4 5 6)\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If any two slot names (whether present directly or inherited by the\n:include option) are the same under string=, defstruct should signal an\nerror of type program-error.\nThe consequences are undefined if the included-structure-name does not\nname a structure type.\n"
        },
        {
            "type": "See Also",
            "text": "*Note documentation; (setf documentation):: , *Note print-object:: , *Note\nsetf; psetf:: , *Note subtypep:: , *Note type-of:: , *Note typep:: , *Note\nCompilation::\n"
        },
        {
            "type": "Notes",
            "text": "The printer-name should observe the values of such printer-control\nvariables as *print-escape*.\nThe restriction against issuing a warning for type mismatches between a\nslot-initform and the corresponding slot's :type option is necessary\nbecause a slot-initform must be specified in order to specify slot\noptions; in some cases, no suitable default may exist.\nThe mechanism by which defstruct arranges for slot accessors to be usable\nwith setf is implementation-dependent; for example, it may use setf\nfunctions, setf expanders, or some other implementation-dependent\nmechanism known to that implementation's code for setf.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: defstruct,  Next: copy-structure,  Prev: Structures Dictionary,  Up: Structures Dictionary\n\ndefstruct                                                           [Macro]\n---------------------------------------------------------------------------\n\n`defstruct'  name-and-options [documentation] {!slot-description}*\n=>  structure-name\n\nname-and-options ::=structure-name | (structure-name [[!options]])\n\noptions ::=!conc-name-option |             {!constructor-option}* |\n            !copier-option |             !include-option |\n            !initial-offset-option |             !named-option |\n            !predicate-option |             !printer-option |\n            !type-option\n\nconc-name-option ::=:conc-name | (:conc-name) | (:conc-name conc-name)\n\nconstructor-option ::=:constructor |\n                       (:constructor) |\n                       (:constructor constructor-name) |\n                       (:constructor constructor-name constructor-arglist)\n\ncopier-option ::=:copier | (:copier) | (:copier copier-name)\n\npredicate-option ::=:predicate | (:predicate) | (:predicate predicate-name)\n\ninclude-option ::=(:include included-structure-name {!slot-description}*)\n\nprinter-option ::=!print-object-option | !print-function-option\n\nprint-object-option ::=(:print-object printer-name) | (:print-object)\n\nprint-function-option ::=(:print-function printer-name) | (:print-function)\n\ntype-option ::=(:type type)\n\nnamed-option ::=:named\n\ninitial-offset-option ::=(:initial-offset initial-offset)\n\nslot-description ::=slot-name | \n                     (slot-name [slot-initform [[!slot-option]]])\n\nslot-option ::=:type slot-type | \n                :read-only slot-read-only-p\n\nArguments and Values::\n......................\n\nconc-name--a string designator.\n\nconstructor-arglist--a boa lambda list.\n\nconstructor-name--a symbol.\n\ncopier-name--a symbol.\n\nincluded-structure-name--an already-defined structure name.\n\nNote that a derived type is not permissible, even if it would expand into\na structure name.\n\ninitial-offset--a non-negative integer.\n\npredicate-name--a symbol.\n\nprinter-name--a function name or a lambda expression.\n\nslot-name--a symbol.\n\nslot-initform--a form.\n\nslot-read-only-p--a generalized boolean.\n\nstructure-name--a symbol.\n\ntype--one of the type specifiers list, vector, or (vector size), or some\nother type specifier defined by the implementation to be appropriate.\n\ndocumentation--a string; not evaluated.\n\nDescription::\n.............\n\ndefstruct defines a structured type, named structure-type, with named\nslots as specified by the slot-options.\n\ndefstruct defines readers for the slots and arranges for setf to work\nproperly on such reader functions.  Also, unless overridden, it defines a\npredicate named name-p, defines a constructor function named\nmake-constructor-name, and defines a copier function named\ncopy-constructor-name.  All names of automatically created functions might\nautomatically be declared inline (at the discretion of the implementation).\n\nIf documentation is supplied, it is attached to structure-name as a\ndocumentation string of kind structure,\n\nand unless :type is used, the documentation is also attached to\nstructure-name as a documentation string of kind type and as a\ndocumentation string to the class object for the class named\nstructure-name.\n\ndefstruct defines a constructor function that is used to create instances\nof the structure created by defstruct.  The default name is\nmake-structure-name.  A different name can be supplied by giving the name\nas the argument to the constructor option.  nil indicates that no\nconstructor function will be created.\n\nAfter a new structure type has been defined, instances of that type\nnormally can be created by using the constructor function for the type.  A\ncall to a constructor function is of the following form:\n\n (constructor-function-name\n  slot-keyword-1 form-1\n  slot-keyword-2 form-2\n  ...)\nThe arguments to the constructor function are all keyword arguments.  Each\nslot keyword argument must  be a keyword whose name corresponds to the\nname of a structure slot.  All the keywords and forms are evaluated.  If a\nslot is not initialized in this way, it is initialized by evaluating\nslot-initform in the slot description\n\nat the time the constructor function is called.\n\nIf no slot-initform is supplied, the consequences are undefined if an\nattempt is later made to read the slot's value before a value is\nexplicitly assigned.\n\nEach slot-initform supplied for a defstruct component, when used by the\nconstructor function for an otherwise unsupplied component, is\nre-evaluated on every call to the constructor function.\n\nThe slot-initform is not evaluated unless it is needed in the creation of\na particular structure instance.  If it is never needed, there can be no\ntype-mismatch error, even if the type of the slot is specified; no warning\nshould be issued in this case.\n\nFor example, in the following sequence, only the last call is an error.\n\n      (defstruct person (name 007 :type string))\n      (make-person :name \"James\")\n      (make-person)\n\nIt is as if the slot-initforms were used as initialization forms for the\nkeyword parameters of the constructor function.\n\nThe symbols which name the slots must not be used by the implementation as\nthe names for the lambda variables in the constructor function, since one\nor more of those symbols might have been proclaimed special or might be\ndefined as the name of a constant variable.  The slot default init forms\nare evaluated in the lexical environment in which the defstruct form\nitself appears and in the dynamic environment in which the call to the\nconstructor function appears.\n\nFor example, if the form (gensym) were used as an initialization form,\neither in the constructor-function call or as the default initialization\nform in defstruct, then every call to the constructor function would call\ngensym once to generate a new symbol.\n\nEach slot-description in defstruct can specify zero or more slot-options.\n\nA slot-option consists of a pair of a keyword and a value (which is not a\nform to be evaluated, but the value itself).  For example:\n\n      (defstruct ship\n        (x-position 0.0 :type short-float)\n        (y-position 0.0 :type short-float)\n        (x-velocity 0.0 :type short-float)\n        (y-velocity 0.0 :type short-float)\n        (mass *default-ship-mass* :type short-float :read-only t))\n\nThis specifies that each slot always contains a short float, and that the\nlast slot cannot be altered once a ship is constructed.\n\nThe available slot-options are:\n:type type\n     This specifies that the contents of the slot is always of type type.\n     This is entirely analogous to the declaration of a variable or\n     function; it effectively declares the result type of the reader\n     function.  It is implementation-dependent whether the type is checked\n     when initializing a slot or when assigning to it.  Type is not\n     evaluated; it must be a valid type specifier.\n\n:read-only x\n     When x is true, this specifies that this slot cannot be altered; it\n     will always contain the value supplied at construction time.  setf\n     will not accept the reader function for this slot.  If x is false,\n     this slot-option has no effect.  X is not evaluated.\n\n     When this option is false or unsupplied, it is\n     implementation-dependent whether the ability to write the slot is\n     implemented by a setf function or a setf expander.\n\nThe following keyword options are available for use with defstruct.  A\ndefstruct option can be either a keyword or a list of a keyword and\narguments for that keyword; specifying the keyword by itself is equivalent\nto specifying a list consisting of the keyword and no arguments.  The\nsyntax for defstruct options differs from the pair syntax used for\nslot-options.  No part of any of these options is evaluated.\n:conc-name\n     This provides for automatic prefixing of names of reader (or access)\n     functions.  The default behavior is to begin the names of all the\n     reader functions of a structure with the name of the structure\n     followed by a hyphen.\n\n     :conc-name supplies an alternate prefix to be used.  If a hyphen is\n     to be used as a separator, it must be supplied as part of the prefix.\n     If :conc-name is nil or no argument is supplied, then no prefix is\n     used; then the names of the reader functions are the same as the slot\n     names.  If a non-nil prefix is given, the name of the reader function\n     for each slot is constructed by concatenating that prefix and the\n     name of the slot, and interning the resulting symbol in the package\n     that is current at the time the defstruct form is expanded.\n\n     Note that no matter what is supplied for :conc-name, slot keywords\n     that match the slot names with no prefix attached are used with a\n     constructor function.  The reader function name is used in\n     conjunction with setf.  Here is an example:\n\n           (defstruct (door (:conc-name dr-)) knob-color width material) =>  DOOR\n           (setq my-door (make-door :knob-color 'red :width 5.0))\n          =>  #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)\n           (dr-width my-door) =>  5.0\n           (setf (dr-width my-door) 43.7) =>  43.7\n           (dr-width my-door) =>  43.7\n\n     Whether or not the :conc-name option is explicitly supplied, the\n     following rule governs name conflicts of generated reader (or\n     accessor) names: For any structure type S_1 having a reader function\n     named R for a slot named X_1 that is inherited by another structure\n     type S_2 that would have a reader function with the same name R for a\n     slot named X_2, no definition for R is generated by the definition of\n     S_2; instead, the definition of R is inherited from the definition of\n     S_1.  (In such a case, if X_1 and X_2 are different slots, the\n     implementation might signal a style warning.)\n\n:constructor\n     This option takes zero, one, or two arguments.  If at least one\n     argument is supplied and the first argument is not nil, then that\n     argument is a symbol which specifies the name of the constructor\n     function.  If the argument is not supplied (or if the option itself\n     is not supplied), the name of the constructor is produced by\n     concatenating the string \"MAKE-\" and the name of the structure,\n     interning the name in whatever package is current at the time\n     defstruct is expanded.  If the argument is provided and is nil, no\n     constructor function is defined.\n\n     If :constructor is given as (:constructor name arglist), then instead\n     of making a keyword driven constructor function, defstruct defines a\n     \"positional\" constructor function, taking arguments whose meaning is\n     determined by the argument's position and possibly by keywords.\n     Arglist is used to describe what the arguments to the constructor\n     will be. In the simplest case something like (:constructor make-foo\n     (a b c)) defines make-foo to be a three-argument constructor function\n     whose arguments are used to initialize the slots named a, b, and c.\n\n     Because a constructor of this type operates \"By Order of Arguments,\"\n     it is sometimes known as a \"boa constructor.\"\n\n     For information on how the arglist for a \"boa constructor\" is\n     processed, see *Note Boa Lambda Lists::.\n\n     It is permissible to use the :constructor option more than once, so\n     that you can define several different constructor functions, each\n     taking different parameters.\n\n     [Reviewer Note by Barmar: What about (:constructor) and (:constructor\n     nil).  Should we worry about it?]\n\n     defstruct creates the default-named keyword constructor function only\n     if no explicit :constructor options are specified, or if the\n     :constructor option is specified without a name argument.\n\n     (:constructor nil) is meaningful only when there are no other\n     :constructor options specified.  It prevents defstruct from\n     generating any constructors at all.\n\n     Otherwise, defstruct creates a constructor function corresponding to\n     each supplied :constructor option.  It is permissible to specify\n     multiple keyword constructor functions as well as multiple \"boa\n     constructors\".\n\n:copier\n     This option takes one argument, a symbol, which specifies the name of\n     the copier function.  If the argument is not provided or if the\n     option itself is not provided, the name of the copier is produced by\n     concatenating the string \"COPY-\" and the name of the structure,\n     interning the name in whatever package is current at the time\n     defstruct is expanded.  If the argument is provided and is nil, no\n     copier function is defined.\n\n     The automatically defined copier function is a function of one\n     argument,\n\n     which must be of the structure type being defined.\n\n     The copier function creates a fresh structure that has the same type\n     as its argument, and that has the same component values as the\n     original structure; that is, the component values are not copied\n     recursively.\n\n     If the defstruct :type option was not used, the following equivalence\n     applies:\n\n           (copier-name x) = (copy-structure (the structure-name x))\n\n:include\n     This option is used for building a new structure definition as an\n     extension of another structure definition.  For example:\n\n           (defstruct person name age sex)\n\n     To make a new structure to represent an astronaut that has the\n     attributes of name, age, and sex, and functions that operate on\n     person structures, astronaut is defined with :include as follows:\n\n           (defstruct (astronaut (:include person)\n                                 (:conc-name astro-))\n              helmet-size\n              (favorite-beverage 'tang))\n\n     :include causes the structure being defined to have the same slots as\n     the included structure.  This is done in such a way that the reader\n     functions for the included structure also work on the structure being\n     defined.  In this example, an astronaut therefore has five slots: the\n     three defined in person and the two defined in astronaut itself.  The\n     reader functions defined by the person structure can be applied to\n     instances of the astronaut structure, and they work correctly.\n     Moreover, astronaut has its own reader functions for components\n     defined by the person structure.  The following examples illustrate\n     the use of astronaut structures:\n\n           (setq x (make-astronaut :name 'buzz\n                                   :age 45.\n                                   :sex t\n                                   :helmet-size 17.5))\n           (person-name x) =>  BUZZ\n           (astro-name x) =>  BUZZ\n           (astro-favorite-beverage x) =>  TANG\n\n           (reduce #'+ astros :key #'person-age) ; obtains the total of the ages\n                                                 ; of the possibly empty\n                                                 ; sequence of astros\n\n     The difference between the reader functions person-name and astro-name\n     is that person-name can be correctly applied to any person, including\n     an astronaut, while astro-name can be correctly applied only to an\n     astronaut.  An implementation might check for incorrect use of reader\n     functions.\n\n     At most one :include can be supplied in a single defstruct.  The\n     argument to :include is required and must be the name of some\n     previously defined structure.  If the structure being defined has no\n     :type option, then the included structure must also have had no :type\n     option supplied for it.  If the structure being defined has a :type\n     option, then the included structure must have been declared with a\n     :type option specifying the same representation type.\n\n     If no :type option is involved, then the structure name of the\n     including structure definition becomes the name of a data type, and\n     therefore a valid type specifier recognizable by typep; it becomes a\n     subtype of the included structure.  In the above example, astronaut\n     is a subtype of person; hence\n\n           (typep (make-astronaut) 'person) =>  true\n\n     indicating that all operations on persons also work on astronauts.\n\n     The structure using :include can specify default values or\n     slot-options for the included slots different from those the included\n     structure specifies, by giving the :include option as:\n\n           (:include included-structure-name {slot-description}*)\n\n     Each slot-description must have a slot-name that is the same as that\n     of some slot in the included structure.  If a slot-description has no\n     slot-initform, then in the new structure the slot has no initial\n     value.  Otherwise its initial value form is replaced by the\n     slot-initform in the slot-description.  A normally writable slot can\n     be made read-only.  If a slot is read-only in the included structure,\n     then it must also be so in the including structure.  If a type is\n     supplied for a slot, it must be a subtype of the type specified in\n     the included structure.\n\n     For example, if the default age for an astronaut is 45, then\n\n           (defstruct (astronaut (:include person (age 45)))\n              helmet-size\n              (favorite-beverage 'tang))\n\n     If :include is used with the :type option, then the effect is first\n     to skip over as many representation elements as needed to represent\n     the included structure, then to skip over any additional elements\n     supplied by the :initial-offset option, and then to begin allocation\n     of elements from that point.  For example:\n\n           (defstruct (binop (:type list) :named (:initial-offset 2))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n           (defstruct (annotated-binop (:type list)\n                                       (:initial-offset 3)\n                                       (:include binop))\n            commutative associative identity) =>  ANNOTATED-BINOP\n           (make-annotated-binop :operator '*\n                                 :operand-1 'x\n                                 :operand-2 5\n                                 :commutative t\n                                 :associative t\n                                 :identity 1)\n             =>  (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)\n\n     The first two nil elements stem from the :initial-offset of 2 in the\n     definition of binop.  The next four elements contain the structure\n     name and three slots for binop.  The next three nil elements stem\n     from the :initial-offset of 3 in the definition of annotated-binop.\n     The last three list elements contain the additional slots for an\n     annotated-binop.\n\n:initial-offset\n     :initial-offset instructs defstruct to skip over a certain number of\n     slots before it starts allocating the slots described in the body.\n     This option's argument is the number of slots defstruct should skip.\n     :initial-offset can be used only if :type is also supplied.\n\n     [Reviewer Note by Barmar: What are initial values of the skipped\n     slots?]\n\n     :initial-offset allows slots to be allocated beginning at a\n     representational element other than the first.  For example, the form\n\n           (defstruct (binop (:type list) (:initial-offset 2))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n\n     would result in the following behavior for make-binop:\n\n           (make-binop :operator '+ :operand-1 'x :operand-2 5)\n          =>  (NIL NIL + X 5)\n           (make-binop :operand-2 4 :operator '*)\n          =>  (NIL NIL * NIL 4)\n\n     The selector functions binop-operator, binop-operand-1, and\n     binop-operand-2 would be essentially equivalent to third, fourth, and\n     fifth, respectively.  Similarly, the form\n\n           (defstruct (binop (:type list) :named (:initial-offset 2))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n\n     would result in the following behavior for make-binop:\n\n           (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (NIL NIL BINOP + X 5)\n           (make-binop :operand-2 4 :operator '*) =>  (NIL NIL BINOP * NIL 4)\n\n     The first two nil elements stem from the :initial-offset of 2 in the\n     definition of binop.  The next four elements contain the structure\n     name and three slots for binop.\n\n:named\n     :named specifies that the structure is named.  If no :type is\n     supplied, then the structure is always named.\n\n     For example:\n\n           (defstruct (binop (:type list))\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n\n     This defines a constructor function make-binop and three selector\n     functions, namely binop-operator, binop-operand-1, and\n     binop-operand-2.  (It does not, however, define a predicate binop-p,\n     for reasons explained below.)\n\n     The effect of make-binop is simply to construct a list of length\n     three:\n\n           (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (+ X 5)\n           (make-binop :operand-2 4 :operator '*) =>  (* NIL 4)\n\n     It is just like the function list except that it takes keyword\n     arguments and performs slot defaulting appropriate to the binop\n     conceptual data type.  Similarly, the selector functions\n     binop-operator, binop-operand-1, and binop-operand-2 are essentially\n     equivalent to car, cadr, and caddr, respectively.  They might not be\n     completely equivalent because, for example, an implementation would\n     be justified in adding error-checking code to ensure that the\n     argument to each selector function is a length-3 list.\n\n     binop is a conceptual data type in that it is not made a part of the\n     Common Lisp type system.  typep does not recognize binop as a type\n     specifier, and type-of returns list when given a binop structure.\n     There is no way to distinguish a data structure constructed by\n     make-binop from any other list that happens to have the correct\n     structure.\n\n     There is not any way to recover the structure name binop from a\n     structure created by make-binop.  This can only be done if the\n     structure is named.  A named structure has the property that, given\n     an instance of the structure, the structure name (that names the\n     type) can be reliably recovered.  For structures defined with no\n     :type option, the structure name actually becomes part of the Common\n     Lisp data-type system.  type-of, when applied to such a structure,\n     returns the structure name as the type of the object; typep recognizes\n     the structure name as a valid type specifier.\n\n     For structures defined with a :type option, type-of returns a type\n     specifier such as list or (vector t), depending on the type supplied\n     to the :type option.  The structure name does not become a valid type\n     specifier.  However, if the :named option is also supplied, then the\n     first component of the structure (as created by a defstruct\n     constructor function) always contains the structure name.  This\n     allows the structure name to be recovered from an instance of the\n     structure and allows a reasonable predicate for the conceptual type\n     to be defined: the automatically defined name-p predicate for the\n     structure operates by first checking that its argument is of the\n     proper type (list, (vector t), or whatever) and then checking whether\n     the first component contains the appropriate type name.\n\n     Consider the binop example shown above, modified only to include the\n     :named option:\n\n           (defstruct (binop (:type list) :named)\n             (operator '? :type symbol)\n             operand-1\n             operand-2) =>  BINOP\n\n     As before, this defines a constructor function make-binop and three\n     selector functions binop-operator, binop-operand-1, and\n     binop-operand-2.  It also defines a predicate binop-p.  The effect of\n     make-binop is now to construct a list of length four:\n\n           (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (BINOP + X 5)\n           (make-binop :operand-2 4 :operator '*) =>  (BINOP * NIL 4)\n\n     The structure has the same layout as before except that the structure\n     name binop is included as the first list element.  The selector\n     functions binop-operator, binop-operand-1, and binop-operand-2 are\n     essentially equivalent to cadr, caddr, and cadddr, respectively.  The\n     predicate binop-p is more or less equivalent to this definition:\n\n           (defun binop-p (x)\n             (and (consp x) (eq (car x) 'binop))) =>  BINOP-P\n\n     The name binop is still not a valid type specifier recognizable to\n     typep, but at least there is a way of distinguishing binop structures\n     from other similarly defined structures.\n\n:predicate\n     This option takes one argument, which specifies the name of the type\n     predicate.  If the argument is not supplied or if the option itself\n     is not supplied, the name of the predicate is made by concatenating\n     the name of the structure to the string \"-P\", interning the name in\n     whatever package is current at the time defstruct is expanded.  If\n     the argument is provided and is nil, no predicate is defined.  A\n     predicate can be defined only if the structure is named; if :type is\n     supplied and :named is not supplied, then :predicate must either be\n     unsupplied or have the value nil.\n\n:print-function, :print-object\n     The :print-function and :print-object options specify that a\n     print-object method for structures of type structure-name should be\n     generated.  These options are not synonyms, but do perform a similar\n     service; the choice of which option (:print-function or\n     :print-object) is used affects how the function named printer-name is\n     called.  Only one of these options may be used, and these options may\n     be used only if :type is not supplied.\n\n     If the :print-function option is used, then when a structure of type\n     structure-name is to be printed, the designated printer function is\n     called on three arguments:\n\n    -\n          the structure to be printed (a generalized instance of\n          structure-name).\n\n    -\n          a stream to print to.\n\n    -\n          an integer indicating the current depth.  The magnitude of this\n          integer may vary between implementations; however, it can\n          reliably be compared against *print-level* to determine whether\n          depth abbreviation is appropriate.\n\n     Specifying (:print-function printer-name) is approximately equivalent\n     to specifying:\n\n           (defmethod print-object ((object structure-name) stream)\n             (funcall (function printer-name) object stream <<current-print-depth>>))\n\n     where the <<current-print-depth>> represents the printer's belief of\n     how deep it is currently printing.  It is implementation-dependent\n     whether <<current-print-depth>> is always 0 and *print-level*, if\n     non-nil, is re-bound to successively smaller values as printing\n     descends recursively, or whether current-print-depth varies in value\n     as printing descends recursively and *print-level* remains constant\n     during the same traversal.\n\n     If the :print-object option is used, then when a structure of type\n     structure-name is to be printed, the designated printer function is\n     called on two arguments:\n\n    -\n          the structure to be printed.\n\n    -\n          the stream to print to.\n\n     Specifying (:print-object printer-name) is equivalent to specifying:\n\n           (defmethod print-object ((object structure-name) stream)\n             (funcall (function printer-name) object stream))\n\n     If no :type option is supplied, and if either a :print-function or a\n     :print-object option is supplied, and if no printer-name is supplied,\n     then a print-object method specialized for structure-name is\n     generated that calls a function that implements the default printing\n     behavior for structures using #S notation; see *Note Printing\n     Structures::.\n\n     If neither a :print-function nor a :print-object option is supplied,\n     then defstruct does not generate a print-object method specialized\n     for structure-name and some default behavior is inherited either from\n     a structure named in an :include option or from the default behavior\n     for printing structures; see the function print-object and *Note\n     Printing Structures::.\n\n     When *print-circle* is true, a user-defined print function can print\n     objects to the supplied stream using write, prin1, princ, or format\n     and expect circularities to be detected and printed using the #n#\n     syntax.  This applies to methods on print-object in addition to\n     :print-function options.  If a user-defined print function prints to\n     a stream other than the one that was supplied, then circularity\n     detection starts over for that stream.  See the variable\n     *print-circle*.\n\n:type\n     :type explicitly specifies the representation to be used for the\n     structure.  Its argument must be one of these types:\n\n    vector\n          This produces the same result as specifying (vector t).  The\n          structure is represented as a general vector, storing components\n          as vector elements.  The first component is vector element 1 if\n          the structure is :named, and element 0 otherwise.\n\n          [Reviewer Note by Barmar: Do any implementations create\n          non-simple vectors?]\n\n    (vector element-type)\n          The structure is represented as a (possibly specialized) vector,\n          storing components as vector elements.  Every component must be\n          of a type that can be stored in a vector of the type specified.\n          The first component is vector element 1 if the structure is\n          :named, and element 0 otherwise.  The structure can be :named\n          only if the type symbol is a subtype of the supplied\n          element-type.\n\n    list\n          The structure is represented as a list.  The first component is\n          the cadr if the structure is :named, and the car if it is not\n          :named.\n\n     Specifying this option has the effect of forcing a specific\n     representation and of forcing the components to be stored in the\n     order specified in defstruct in corresponding successive elements of\n     the specified representation.  It also prevents the structure name\n     from becoming a valid type specifier recognizable by typep.\n\n     For example:\n\n           (defstruct (quux (:type list) :named) x y)\n\n     should make a constructor that builds a list exactly like the one\n     that list produces, with quux as its car.\n\n     If this type is defined:\n\n           (deftype quux () '(satisfies quux-p))\n\n     then this form\n\n           (typep (make-quux) 'quux)\n\n     should return precisely what this one does\n\n           (typep (list 'quux nil nil) 'quux)\n\n     If :type is not supplied, the structure is represented as an object\n     of type structure-object.\n\n     defstruct without a :type option defines a class with the structure\n     name as its name. The metaclass of structure instances is\n     structure-class.\n\nThe consequences of redefining a defstruct structure are undefined.\n\nIn the case where no defstruct options have been supplied, the following\nfunctions are automatically defined to operate on instances of the new\nstructure:\n\nPredicate\n     A predicate with the name structure-name-p is defined to test\n     membership in the structure type.  The predicate (structure-name-p\n     object) is true if an object is of this type; otherwise it is false.\n     typep can also be used with the name of the new type to test whether\n     an object belongs to the type.  Such a function call has the form\n     (typep object 'structure-name).\n\nComponent reader functions\n     Reader functions are defined to read the components of the structure.\n     For each slot name, there is a corresponding reader function with\n     the name structure-name-slot-name.  This function reads the contents\n     of that slot.  Each reader function takes one argument, which is an\n     instance of the structure type.  setf can be used with any of these\n     reader functions to alter the slot contents.\n\nConstructor function\n     A constructor function with the name make-structure-name is defined.\n     This function creates and returns new instances of the structure type.\n\nCopier function\n     A copier function with the name copy-structure-name is defined.  The\n     copier function takes an object of the structure type and creates a\n     new object of the same  type that is a copy of the first.  The copier\n     function creates a new structure with the same component entries as\n     the original.  Corresponding components of the two structure instances\n     are eql.\n\nIf a defstruct form appears as a top level form, the compiler must make\nthe structure type name recognized as a valid type name in subsequent\ndeclarations (as for deftype) and make the structure slot readers known to\nsetf.  In addition, the compiler must save enough information about the\nstructure type so that further defstruct definitions can use :include in a\nsubsequent deftype in the same file to refer to the structure type name.\nThe functions which defstruct generates are not defined in the compile\ntime environment, although the compiler may save enough information about\nthe functions to code subsequent calls inline.  The #S reader macro might\nor might not recognize the newly defined structure type name at compile\ntime.\n\nExamples::\n..........\n\nAn example of a structure definition follows:\n\n      (defstruct ship\n        x-position\n        y-position\n        x-velocity\n        y-velocity\n        mass)\n\nThis declares that every ship is an object with five named components.\nThe evaluation of this form does the following:\n\n1.\n     It defines ship-x-position to be a function of one argument, a ship,\n     that returns the x-position of the ship; ship-y-position and the\n     other components are given similar function definitions.  These\n     functions are called the access functions, as they are used to access\n     elements of the structure.\n\n2.\n     ship becomes the name of a type of which instances of ships are\n     elements.  ship becomes acceptable to typep, for example; (typep x\n     'ship) is true if x is a ship and false if x is any object other than\n     a ship.\n\n3.\n     A function named ship-p of one argument is defined; it is a predicate\n     that is true if its argument is a ship and is false otherwise.\n\n4.\n     A function called make-ship is defined that, when invoked, creates a\n     data structure with five components, suitable for use with the access\n     functions.  Thus executing\n\n           (setq ship2 (make-ship))\n\n     sets ship2 to a newly created ship object.  One can supply the\n     initial values of any desired component in the call to make-ship by\n     using keyword arguments in this way:\n\n           (setq ship2 (make-ship :mass *default-ship-mass*\n                                  :x-position 0\n                                  :y-position 0))\n\n     This constructs a new ship and initializes three of its components.\n     This function is called the \"constructor function\" because it\n     constructs a new structure.\n\n5.\n     A function called copy-ship of one argument is defined that, when\n     given a ship object, creates a new ship object that is a copy of the\n     given one.  This function is called the \"copier function.\"\n\nsetf can be used to alter the components of a ship:\n\n      (setf (ship-x-position ship2) 100)\n\nThis alters the x-position of ship2 to be 100.  This works because\ndefstruct behaves as if it generates an appropriate defsetf for each\naccess function.\n\n     ;;;\n     ;;; Example 1\n     ;;; define town structure type\n     ;;; area, watertowers, firetrucks, population, elevation are its components\n     ;;;\n      (defstruct town\n                  area\n                  watertowers\n                  (firetrucks 1 :type fixnum)    ;an initialized slot\n                  population\n                  (elevation 5128 :read-only t)) ;a slot that can't be changed\n     =>  TOWN\n     ;create a town instance\n      (setq town1 (make-town :area 0 :watertowers 0)) =>  #S(TOWN...)\n     ;town's predicate recognizes the new instance\n      (town-p town1) =>  true\n     ;new town's area is as specified by make-town\n      (town-area town1) =>  0\n     ;new town's elevation has initial value\n      (town-elevation town1) =>  5128\n     ;setf recognizes reader function\n      (setf (town-population town1) 99) =>  99\n      (town-population town1) =>  99\n     ;copier function makes a copy of town1\n      (setq town2 (copy-town town1)) =>  #S(TOWN...)\n      (= (town-population town1) (town-population town2))  =>  true\n     ;since elevation is a read-only slot, its value can be set only\n     ;when the structure is created\n      (setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))\n     =>  #S(TOWN...)\n     ;;;\n     ;;; Example 2\n     ;;; define clown structure type\n     ;;; this structure uses a nonstandard prefix\n     ;;;\n      (defstruct (clown (:conc-name bozo-))\n                  (nose-color 'red)\n                  frizzy-hair-p polkadots) =>  CLOWN\n      (setq funny-clown (make-clown)) =>  #S(CLOWN)\n     ;use non-default reader name\n      (bozo-nose-color funny-clown) =>  RED\n      (defstruct (klown (:constructor make-up-klown) ;similar def using other\n                  (:copier clone-klown)              ;customizing keywords\n                  (:predicate is-a-bozo-p))\n                  nose-color frizzy-hair-p polkadots) =>  klown\n     ;custom constructor now exists\n      (fboundp 'make-up-klown) =>  true\n     ;;;\n     ;;; Example 3\n     ;;; define a vehicle structure type\n     ;;; then define a truck structure type that includes\n     ;;; the vehicle structure\n     ;;;\n      (defstruct vehicle name year (diesel t :read-only t)) =>  VEHICLE\n      (defstruct (truck (:include vehicle (year 79)))\n                  load-limit\n                  (axles 6)) =>  TRUCK\n      (setq x (make-truck :name 'mac :diesel t :load-limit 17))\n     =>  #S(TRUCK...)\n     ;vehicle readers work on trucks\n      (vehicle-name x)\n     =>  MAC\n     ;default taken from :include clause\n      (vehicle-year x)\n     =>  79\n      (defstruct (pickup (:include truck))     ;pickup type includes truck\n                  camper long-bed four-wheel-drive) =>  PICKUP\n      (setq x (make-pickup :name 'king :long-bed t)) =>  #S(PICKUP...)\n     ;:include default inherited\n      (pickup-year x) =>  79\n     ;;;\n     ;;; Example 4\n     ;;; use of BOA constructors\n     ;;;\n      (defstruct (dfs-boa                      ;BOA constructors\n                    (:constructor make-dfs-boa (a b c))\n                    (:constructor create-dfs-boa\n                      (a &optional b (c 'cc) &rest d &aux e (f 'ff))))\n                  a b c d e f) =>  DFS-BOA\n     ;a, b, and c set by position, and the rest are uninitialized\n      (setq x (make-dfs-boa 1 2 3)) =>  #(DFS-BOA...)\n      (dfs-boa-a x) =>  1\n     ;a and b set, c and f defaulted\n      (setq x (create-dfs-boa 1 2)) =>  #(DFS-BOA...)\n      (dfs-boa-b x) =>  2\n      (eq (dfs-boa-c x) 'cc) =>  true\n     ;a, b, and c set, and the rest are collected into d\n      (setq x (create-dfs-boa 1 2 3 4 5 6)) =>  #(DFS-BOA...)\n      (dfs-boa-d x) =>  (4 5 6)\n\nExceptional Situations::\n........................\n\nIf any two slot names (whether present directly or inherited by the\n:include option) are the same under string=, defstruct should signal an\nerror of type program-error.\n\nThe consequences are undefined if the included-structure-name does not\nname a structure type.\n\nSee Also::\n..........\n\n*Note documentation; (setf documentation):: , *Note print-object:: , *Note\nsetf; psetf:: , *Note subtypep:: , *Note type-of:: , *Note typep:: , *Note\nCompilation::\n\nNotes::\n.......\n\nThe printer-name should observe the values of such printer-control\nvariables as *print-escape*.\n\nThe restriction against issuing a warning for type mismatches between a\nslot-initform and the corresponding slot's :type option is necessary\nbecause a slot-initform must be specified in order to specify slot\noptions; in some cases, no suitable default may exist.\n\nThe mechanism by which defstruct arranges for slot accessors to be usable\nwith setf is implementation-dependent; for example, it may use setf\nfunctions, setf expanders, or some other implementation-dependent\nmechanism known to that implementation's code for setf.\n\n"
}