{
    "name": "Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs",
    "prev": "Constraints on the COMMON-LISP Package for Conforming Programs",
    "next": "The COMMON-LISP-USER Package",
    "up": "Standardized Packages",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs",
            "text": "If an external symbol of the COMMON-LISP package is not globally defined\nas a standardized dynamic variable or constant variable, it is allowed to\nlexically bind it and to declare the type of that binding, and it is\nallowed to locally establish it as a symbol macro (e.g., with\nsymbol-macrolet).\nUnless explicitly specified otherwise, if an external symbol of the\nCOMMON-LISP package is globally defined as a standardized dynamic variable,\nit is permitted to bind or assign that dynamic variable provided that the\n\"Value Type\" constraints on the dynamic variable are maintained, and that\nthe new value of the variable is consistent with the stated purpose of the\nvariable.\nIf an external symbol of the COMMON-LISP package is not defined as a\nstandardized function, macro, or special operator, it is allowed to\nlexically bind it as a function (e.g., with flet), to declare the ftype of\nthat binding, and (in implementations which provide the ability to do so)\nto trace that binding.\nIf an external symbol of the COMMON-LISP package is not defined as a\nstandardized function, macro, or special operator, it is allowed to\nlexically bind it as a macro (e.g., with macrolet).\nIf an external symbol of the COMMON-LISP package is not defined as a\nstandardized function, macro, or special operator, it is allowed to\nlexically bind its setf function name as a function, and to declare the\nftype of that binding.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs,  Next: The COMMON-LISP-USER Package,  Prev: Constraints on the COMMON-LISP Package for Conforming Programs,  Up: Standardized Packages\n\nSome Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs\n.................................................................................\n\nIf an external symbol of the COMMON-LISP package is not globally defined\nas a standardized dynamic variable or constant variable, it is allowed to\nlexically bind it and to declare the type of that binding, and it is\nallowed to locally establish it as a symbol macro (e.g., with\nsymbol-macrolet).\n\nUnless explicitly specified otherwise, if an external symbol of the\nCOMMON-LISP package is globally defined as a standardized dynamic variable,\nit is permitted to bind or assign that dynamic variable provided that the\n\"Value Type\" constraints on the dynamic variable are maintained, and that\nthe new value of the variable is consistent with the stated purpose of the\nvariable.\n\nIf an external symbol of the COMMON-LISP package is not defined as a\nstandardized function, macro, or special operator, it is allowed to\nlexically bind it as a function (e.g., with flet), to declare the ftype of\nthat binding, and (in implementations which provide the ability to do so)\nto trace that binding.\n\nIf an external symbol of the COMMON-LISP package is not defined as a\nstandardized function, macro, or special operator, it is allowed to\nlexically bind it as a macro (e.g., with macrolet).\n\nIf an external symbol of the COMMON-LISP package is not defined as a\nstandardized function, macro, or special operator, it is allowed to\nlexically bind its setf function name as a function, and to declare the\nftype of that binding.\n\n"
}