{
    "name": "Backquote",
    "prev": "Double-Quote",
    "next": "Comma",
    "up": "Standard Macro Characters",
    "header": {
        "type": null,
        "text": "Backquote"
    },
    "sections": [
        {
            "type": "",
            "text": "The backquote introduces a template of a data structure to be built.  For\nexample, writing\n      `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))\nis roughly equivalent to writing\n      (list 'cond\n            (cons (list 'numberp x) y)\n            (list* 't (list 'print x) y))\nWhere a comma occurs in the template, the expression following the comma\nis to be evaluated to produce an object to be inserted at that point.\nAssume b has the value 3, for example, then evaluating the form denoted by\n`(a b ,b ,(+ b 1) b) produces the result (a b 3 4 b).\nIf a comma is immediately followed by an at-sign, then the form following\nthe at-sign is evaluated to produce a list of objects.  These objects are\nthen \"spliced\" into place in the template.  For example, if x has the\nvalue (a b c), then\n      `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))\n     =>  (x (a b c) a b c foo b bar (b c) baz b c)\nThe backquote syntax can be summarized formally as follows.\n*\n     `basic is the same as 'basic, that is, (quote basic), for any\n     expression basic that is not a list or a general vector.\n*\n     `,form is the same as form, for any form, provided that the\n     representation of form does not begin with at-sign or dot.  (A\n     similar caveat holds for all occurrences of a form after a comma.)\n*\n     `,@form has undefined consequences.\n*\n     `(x1 x2 x3 ... xn . atom) may be interpreted to mean\n           (append [ x1] [ x2] [ x3] ... [ xn] (quote atom))\n     where the brackets are used to indicate a transformation of an xj as\n     follows:\n    -\n          [form] is interpreted as (list `form), which contains a\n          backquoted form that must then be further interpreted.\n    -\n          [,form] is interpreted as (list form).\n    -\n          [,@form] is interpreted as form.\n*\n     `(x1 x2 x3 ... xn) may be interpreted to mean the same as the\n     backquoted form `(x1 x2 x3 ... xn . nil), thereby reducing it to the\n     previous case.\n*\n     `(x1 x2 x3 ... xn . ,form) may be interpreted to mean\n           (append [ x1] [ x2] [ x3] ... [ xn] form)\n     where the brackets indicate a transformation of an xj as described\n     above.\n*\n     `(x1 x2 x3 ... xn . ,@form) has undefined consequences.\n*\n     `#(x1 x2 x3 ... xn) may be interpreted to mean (apply #'vector `(x1\n     x2 x3 ... xn)).\nAnywhere \",@\" may be used, the syntax \",.\" may be used instead to indicate\nthat it is permissible to operate destructively on the list structure\nproduced by the form following the \",.\" (in effect, to use nconc instead\nof append).\nIf the backquote syntax is nested, the innermost backquoted form should be\nexpanded first.  This means that if several commas occur in a row, the\nleftmost one belongs to the innermost backquote.\nAn implementation is free to interpret a backquoted form F_1 as any form\nF_2 that, when evaluated, will produce a result that is the same under\nequal as the result implied by the above definition, provided that the\nside-effect behavior of the substitute form F_2 is also consistent with\nthe description given above.  The constructed copy of the template might\nor might not share list structure with the template itself.  As an\nexample, the above definition implies that\n      `((,a b) ,c ,@d)\nwill be interpreted as if it were\n      (append (list (append (list a) (list 'b) 'nil)) (list c) d 'nil)\nbut it could also be legitimately interpreted to mean any of the following:\n      (append (list (append (list a) (list 'b))) (list c) d)\n      (append (list (append (list a) '(b))) (list c) d)\n      (list* (cons a '(b)) c d)\n      (list* (cons a (list 'b)) c d)\n      (append (list (cons a '(b))) (list c) d)\n      (list* (cons a '(b)) c (copy-list d))\n* Menu:\n* Notes about Backquote::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Backquote,  Next: Comma,  Prev: Double-Quote,  Up: Standard Macro Characters\n\nBackquote\n---------\n\nThe backquote introduces a template of a data structure to be built.  For\nexample, writing\n\n      `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))\n\nis roughly equivalent to writing\n\n      (list 'cond\n            (cons (list 'numberp x) y)\n            (list* 't (list 'print x) y))\n\nWhere a comma occurs in the template, the expression following the comma\nis to be evaluated to produce an object to be inserted at that point.\nAssume b has the value 3, for example, then evaluating the form denoted by\n`(a b ,b ,(+ b 1) b) produces the result (a b 3 4 b).\n\nIf a comma is immediately followed by an at-sign, then the form following\nthe at-sign is evaluated to produce a list of objects.  These objects are\nthen \"spliced\" into place in the template.  For example, if x has the\nvalue (a b c), then\n\n      `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))\n     =>  (x (a b c) a b c foo b bar (b c) baz b c)\n\nThe backquote syntax can be summarized formally as follows.\n\n*\n     `basic is the same as 'basic, that is, (quote basic), for any\n     expression basic that is not a list or a general vector.\n\n*\n     `,form is the same as form, for any form, provided that the\n     representation of form does not begin with at-sign or dot.  (A\n     similar caveat holds for all occurrences of a form after a comma.)\n\n*\n     `,@form has undefined consequences.\n\n*\n     `(x1 x2 x3 ... xn . atom) may be interpreted to mean\n\n           (append [ x1] [ x2] [ x3] ... [ xn] (quote atom))\n\n     where the brackets are used to indicate a transformation of an xj as\n     follows:\n\n    -\n          [form] is interpreted as (list `form), which contains a\n          backquoted form that must then be further interpreted.\n\n    -\n          [,form] is interpreted as (list form).\n\n    -\n          [,@form] is interpreted as form.\n\n*\n     `(x1 x2 x3 ... xn) may be interpreted to mean the same as the\n     backquoted form `(x1 x2 x3 ... xn . nil), thereby reducing it to the\n     previous case.\n\n*\n     `(x1 x2 x3 ... xn . ,form) may be interpreted to mean\n\n           (append [ x1] [ x2] [ x3] ... [ xn] form)\n\n     where the brackets indicate a transformation of an xj as described\n     above.\n\n*\n     `(x1 x2 x3 ... xn . ,@form) has undefined consequences.\n\n*\n     `#(x1 x2 x3 ... xn) may be interpreted to mean (apply #'vector `(x1\n     x2 x3 ... xn)).\n\nAnywhere \",@\" may be used, the syntax \",.\" may be used instead to indicate\nthat it is permissible to operate destructively on the list structure\nproduced by the form following the \",.\" (in effect, to use nconc instead\nof append).\n\nIf the backquote syntax is nested, the innermost backquoted form should be\nexpanded first.  This means that if several commas occur in a row, the\nleftmost one belongs to the innermost backquote.\n\nAn implementation is free to interpret a backquoted form F_1 as any form\nF_2 that, when evaluated, will produce a result that is the same under\nequal as the result implied by the above definition, provided that the\nside-effect behavior of the substitute form F_2 is also consistent with\nthe description given above.  The constructed copy of the template might\nor might not share list structure with the template itself.  As an\nexample, the above definition implies that\n\n      `((,a b) ,c ,@d)\n\nwill be interpreted as if it were\n\n      (append (list (append (list a) (list 'b) 'nil)) (list c) d 'nil)\n\nbut it could also be legitimately interpreted to mean any of the following:\n\n      (append (list (append (list a) (list 'b))) (list c) d)\n      (append (list (append (list a) '(b))) (list c) d)\n      (list* (cons a '(b)) c d)\n      (list* (cons a (list 'b)) c d)\n      (append (list (cons a '(b))) (list c) d)\n      (list* (cons a '(b)) c (copy-list d))\n\n* Menu:\n\n* Notes about Backquote::\n\n"
}