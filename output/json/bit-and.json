{
    "name": "bit-and",
    "prev": "bit",
    "next": "bit-vector-p",
    "up": "Arrays Dictionary",
    "header": {
        "type": null,
        "text": "bit-ior, bit-nand, bit-nor, bit-not, bit-orc1, bit-orc2, bit-xor"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "bit-and",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n"
                },
                {
                    "name": "bit-andc1",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>\nresulting-bit-array\n\n"
                },
                {
                    "name": "bit-andc2",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>\nresulting-bit-array\n\n"
                },
                {
                    "name": "bit-eqv",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n"
                },
                {
                    "name": "bit-ior",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n"
                },
                {
                    "name": "bit-nand",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n"
                },
                {
                    "name": "bit-nor",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n"
                },
                {
                    "name": "bit-orc1",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n"
                },
                {
                    "name": "bit-orc2",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n"
                },
                {
                    "name": "bit-xor",
                    "text": " bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n"
                },
                {
                    "name": "bit-not",
                    "text": " bit-array &optional opt-arg =>  resulting-bit-array\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "bit-array, bit-array1, bit-array2",
                    "desc": "a bit array."
                },
                {
                    "name": "Opt-arg",
                    "desc": "a bit array, or t, or nil.  The default is nil.Bit-array, bit-array1, bit-array2, and opt-arg (if an array) must all be\nof the same rank and dimensions.\n"
                },
                {
                    "name": "resulting-bit-array",
                    "desc": "a bit array."
                }
            ]
        },
        {
            "type": "Description",
            "text": "These functions perform bit-wise logical operations on bit-array1 and\nbit-array2 and return an array of matching rank and dimensions, such that\nany given bit of the result is produced by operating on corresponding bits\nfrom each of the arguments.\nIn the case of bit-not, an array of rank and dimensions matching bit-array\nis returned that contains a copy of bit-array with all the bits inverted.\nIf opt-arg is of type (array bit) the contents of the result are\ndestructively placed into opt-arg.  If opt-arg is the symbol t, bit-array\nor bit-array1 is replaced with the result; if opt-arg is nil or omitted, a\nnew array is created to contain the result.\nFigure 15-4 indicates the logical operation performed by each of the\nfunctions.\n2\nFunction                                                   Operation                                   \n_______________________________________________________________________________________________________\nbit-and                                                    and                                         \nbit-eqv                                                    equivalence (exclusive nor)                 \nbit-not                                                    complement                                  \nbit-ior                                                    inclusive or                                \nbit-xor                                                    exclusive or                                \nbit-nand                                                   complement of bit-array1 and bit-array2     \nbit-nor                                                    complement of bit-array1 or bit-array2      \nbit-andc1                                                  and complement of bit-array1 with bit-array2\nbit-andc2                                                  and bit-array1 with complement of bit-array2\nbit-orc1                                                   or complement of bit-array1 with bit-array2 \nbit-orc2                                                   or bit-array1 with complement of bit-array2 \n  Figure 15-3: Bit-wise Logical Operations on Bit Arrays \n"
        },
        {
            "type": "Examples",
            "text": "      (bit-and (setq ba #*11101010) #*01101011) =>  #*01101010\n      (bit-and #*1100 #*1010) =>  #*1000\n      (bit-andc1 #*1100 #*1010) =>  #*0010\n      (setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000\n      (eq rba ba) =>  true\n      (bit-not (setq ba #*11101010)) =>  #*00010101\n      (setq rba (bit-not ba\n                          (setq tba (make-array 8\n                                                :element-type 'bit))))\n     =>  #*00010101\n      (equal rba tba) =>  true\n      (bit-xor #*1100 #*1010) =>  #*0110\n"
        },
        {
            "type": "See Also",
            "text": "lognot, *Note logand; logandc1; logandc2; logeqv; logior; lognand; lognor;\nlognot; logorc1; logorc2; logxor::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: bit-and,  Next: bit-vector-p,  Prev: bit,  Up: Arrays Dictionary\n\nbit-and, bit-andc1, bit-andc2, bit-eqv,\n---------------------------------------\n\nbit-ior, bit-nand, bit-nor, bit-not, bit-orc1, bit-orc2, bit-xor\n----------------------------------------------------------------\n\n                                                                [Function]\n\n`bit-and'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-andc1'  bit-array1 bit-array2 &optional opt-arg =>\nresulting-bit-array\n\n`bit-andc2'  bit-array1 bit-array2 &optional opt-arg =>\nresulting-bit-array\n\n`bit-eqv'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-ior'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-nand'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-nor'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-orc1'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-orc2'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-xor'  bit-array1 bit-array2 &optional opt-arg =>  resulting-bit-array\n\n`bit-not'  bit-array &optional opt-arg =>  resulting-bit-array\n\nArguments and Values::\n......................\n\nbit-array, bit-array1, bit-array2--a bit array.\n\nOpt-arg--a bit array, or t, or nil.  The default is nil.\n\nBit-array, bit-array1, bit-array2, and opt-arg (if an array) must all be\nof the same rank and dimensions.\n\nresulting-bit-array--a bit array.\n\nDescription::\n.............\n\nThese functions perform bit-wise logical operations on bit-array1 and\nbit-array2 and return an array of matching rank and dimensions, such that\nany given bit of the result is produced by operating on corresponding bits\nfrom each of the arguments.\n\nIn the case of bit-not, an array of rank and dimensions matching bit-array\nis returned that contains a copy of bit-array with all the bits inverted.\n\nIf opt-arg is of type (array bit) the contents of the result are\ndestructively placed into opt-arg.  If opt-arg is the symbol t, bit-array\nor bit-array1 is replaced with the result; if opt-arg is nil or omitted, a\nnew array is created to contain the result.\n\nFigure 15-4 indicates the logical operation performed by each of the\nfunctions.\n\n2\nFunction                                                   Operation                                   \n_______________________________________________________________________________________________________\n                                                           \nbit-and                                                    and                                         \nbit-eqv                                                    equivalence (exclusive nor)                 \nbit-not                                                    complement                                  \nbit-ior                                                    inclusive or                                \nbit-xor                                                    exclusive or                                \nbit-nand                                                   complement of bit-array1 and bit-array2     \nbit-nor                                                    complement of bit-array1 or bit-array2      \nbit-andc1                                                  and complement of bit-array1 with bit-array2\nbit-andc2                                                  and bit-array1 with complement of bit-array2\nbit-orc1                                                   or complement of bit-array1 with bit-array2 \nbit-orc2                                                   or bit-array1 with complement of bit-array2 \n  Figure 15-3: Bit-wise Logical Operations on Bit Arrays \n\nExamples::\n..........\n\n      (bit-and (setq ba #*11101010) #*01101011) =>  #*01101010\n      (bit-and #*1100 #*1010) =>  #*1000\n      (bit-andc1 #*1100 #*1010) =>  #*0010\n      (setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000\n      (eq rba ba) =>  true\n      (bit-not (setq ba #*11101010)) =>  #*00010101\n      (setq rba (bit-not ba\n                          (setq tba (make-array 8\n                                                :element-type 'bit))))\n     =>  #*00010101\n      (equal rba tba) =>  true\n      (bit-xor #*1100 #*1010) =>  #*0110\n\nSee Also::\n..........\n\nlognot, *Note logand; logandc1; logandc2; logeqv; logior; lognand; lognor;\nlognot; logorc1; logorc2; logxor::\n\n"
}