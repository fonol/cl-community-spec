{
    "name": "handler-bind",
    "prev": "*break-on-signals*",
    "next": "handler-case",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Macro",
        "text": "handler-bind"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "handler-bind",
                    "text": " ({!binding}*) {form}* =>  {result}*\nbinding ::=(type handler)\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "type",
                    "desc": "a type specifier."
                },
                {
                    "name": "handler",
                    "desc": "a form; evaluated to produce a handler-function."
                },
                {
                    "name": "handler-function",
                    "desc": "a designator for a function of one argument."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Executes forms in a dynamic environment where the indicated handler\nbindings are in effect.\nEach handler should evaluate to a handler-function, which is used to\nhandle conditions of the given type during execution of the forms.  This\nfunction should take a single argument, the condition being signaled.\nIf more than one handler binding is supplied, the handler bindings are\nsearched sequentially from top to bottom in search of a match (by visual\nanalogy with typecase).  If an appropriate type is found, the associated\nhandler is run in a dynamic environment where none of these handler\nbindings are visible (to avoid recursive errors).  If the handler\ndeclines, the search continues for another handler.\nIf no appropriate handler is found, other handlers are sought from\ndynamically enclosing contours.  If no handler is found outside, then\nsignal returns or error enters the debugger.\n"
        },
        {
            "type": "Examples",
            "text": "In the following code, if an unbound variable error is signaled in the\nbody (and not handled by an intervening handler), the first function is\ncalled.\n      (handler-bind ((unbound-variable #'(lambda ...))\n                     (error #'(lambda ...)))\n        ...)\nIf any other kind of error is signaled, the second function is called.  In\neither case, neither handler is active while executing the code in the\nassociated function.\n      (defun trap-error-handler (condition)\n        (format *error-output* \"~&~A~&\" condition)\n        (throw 'trap-errors nil))\n      (defmacro trap-errors (&rest forms)\n        `(catch 'trap-errors\n           (handler-bind ((error #'trap-error-handler))\n             ,@forms)))\n      (list (trap-errors (signal \"Foo.\") 1)\n            (trap-errors (error  \"Bar.\") 2)\n            (+ 1 2))\n      |>  Bar.\n     =>  (1 NIL 3)\nNote that \"Foo.\" is not printed because the condition made by signal is a\nsimple condition, which is not of type error, so it doesn't trigger the\nhandler for error set up by trap-errors.\n"
        },
        {
            "type": "See Also",
            "text": "*Note handler-case::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: handler-bind,  Next: handler-case,  Prev: *break-on-signals*,  Up: Conditions Dictionary\n\nhandler-bind                                                        [Macro]\n---------------------------------------------------------------------------\n\n`handler-bind'  ({!binding}*) {form}* =>  {result}*\n\nbinding ::=(type handler)\n\nArguments and Values::\n......................\n\ntype--a type specifier.\n\nhandler--a form; evaluated to produce a handler-function.\n\nhandler-function--a designator for a function of one argument.\n\nforms--an implicit progn.\n\nresults--the values returned by the forms.\n\nDescription::\n.............\n\nExecutes forms in a dynamic environment where the indicated handler\nbindings are in effect.\n\nEach handler should evaluate to a handler-function, which is used to\nhandle conditions of the given type during execution of the forms.  This\nfunction should take a single argument, the condition being signaled.\n\nIf more than one handler binding is supplied, the handler bindings are\nsearched sequentially from top to bottom in search of a match (by visual\nanalogy with typecase).  If an appropriate type is found, the associated\nhandler is run in a dynamic environment where none of these handler\nbindings are visible (to avoid recursive errors).  If the handler\ndeclines, the search continues for another handler.\n\nIf no appropriate handler is found, other handlers are sought from\ndynamically enclosing contours.  If no handler is found outside, then\nsignal returns or error enters the debugger.\n\nExamples::\n..........\n\nIn the following code, if an unbound variable error is signaled in the\nbody (and not handled by an intervening handler), the first function is\ncalled.\n\n      (handler-bind ((unbound-variable #'(lambda ...))\n                     (error #'(lambda ...)))\n        ...)\n\nIf any other kind of error is signaled, the second function is called.  In\neither case, neither handler is active while executing the code in the\nassociated function.\n\n      (defun trap-error-handler (condition)\n        (format *error-output* \"~&~A~&\" condition)\n        (throw 'trap-errors nil))\n     \n      (defmacro trap-errors (&rest forms)\n        `(catch 'trap-errors\n           (handler-bind ((error #'trap-error-handler))\n             ,@forms)))\n     \n      (list (trap-errors (signal \"Foo.\") 1)\n            (trap-errors (error  \"Bar.\") 2)\n            (+ 1 2))\n      |>  Bar.\n     =>  (1 NIL 3)\n\nNote that \"Foo.\" is not printed because the condition made by signal is a\nsimple condition, which is not of type error, so it doesn't trigger the\nhandler for error set up by trap-errors.\n\nSee Also::\n..........\n\n*Note handler-case::\n\n"
}