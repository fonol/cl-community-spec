{
    "name": "special",
    "prev": "optimize",
    "next": "locally",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Declaration",
        "text": "special"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "text": "(special {var}*)\n"
        },
        {
            "type": "Arguments",
            "text": "var--a symbol.\n"
        },
        {
            "type": "Valid Context",
            "text": "declaration or proclamation\n"
        },
        {
            "type": "Binding Types Affected",
            "text": "variable\n"
        },
        {
            "type": "Description",
            "text": "Specifies that all of the vars named are dynamic.  This specifier affects\nvariable bindings and affects references.  All variable bindings affected\nare made to be dynamic bindings, and affected variable references refer to\nthe current dynamic binding.  For example:\n      (defun hack (thing *mod*)    ;The binding of the parameter\n        (declare (special *mod*))  ; *mod* is visible to hack1,\n        (hack1 (car thing)))       ; but not that of thing.\n      (defun hack1 (arg)\n        (declare (special *mod*))  ;Declare references to *mod*\n                                   ;within hack1 to be special.\n        (if (atom arg) *mod*\n            (cons (hack1 (car arg)) (hack1 (cdr arg)))))\nA special declaration does not affect inner bindings of a var; the inner\nbindings implicitly shadow a special declaration and must be explicitly\nre-declared to be special.  special declarations never apply to function\nbindings.\nspecial declarations can be either bound declarations, affecting both a\nbinding and references, or free declarations, affecting only references,\ndepending on whether the declaration is attached to a variable binding.\nWhen used in a proclamation, a special declaration specifier applies to\nall bindings as well as to all references of the mentioned variables.  For\nexample, after\n      (declaim (special x))\nthen in a function definition such as\n      (defun example (x) ...)\nthe parameter x is bound as a dynamic variable rather than as a lexical\nvariable.\n"
        },
        {
            "type": "Examples",
            "text": "     (defun declare-eg (y)                 ;this y is special\n      (declare (special y))\n      (let ((y t))                         ;this y is lexical\n           (list y\n                 (locally (declare (special y)) y)))) ;this y refers to the\n                                                      ;special binding of y\n     =>  DECLARE-EG\n      (declare-eg nil) =>  (T NIL)\n     (setf (symbol-value 'x) 6)\n     (defun foo (x)                         ;a lexical binding of x\n       (print x)\n       (let ((x (1+ x)))                    ;a special binding of x\n         (declare (special x))              ;and a lexical reference\n         (bar))\n       (1+ x))\n     (defun bar ()\n       (print (locally (declare (special x))\n                x)))\n     (foo 10)\n      |>  10\n      |>  11\n     =>  11\n     (setf (symbol-value 'x) 6)\n     (defun bar (x y)            ;[1] 1st occurrence of x\n       (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence\n             (x y))              ;[3] 3rd occurrence of x\n         (declare (special x))\n         (list old-x x)))\n     (bar 'first 'second) =>  (FIRST SECOND)\n      (defun few (x &optional (y *foo*))\n        (declare (special *foo*))\n        ...)\nThe reference to *foo* in the first line of this example is not special\neven though there is a special declaration in the second line.\n      (declaim (special prosp)) =>  implementation-dependent\n      (setq prosp 1 reg 1) =>  1\n      (let ((prosp 2) (reg 2))         ;the binding of prosp is special\n         (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,\n         (list prosp reg))             ;whereas the variable reg is lexical\n     =>  (3 2)\n      (list prosp reg) =>  (1 3)\n      (declaim (special x))          ;x is always special.\n      (defun example (x y)\n        (declare (special y))\n        (let ((y 3) (x (* x 2)))\n          (print (+ y (locally (declare (special y)) y)))\n          (let ((y 4)) (declare (special y)) (foo x)))) =>  EXAMPLE\nIn the contorted code above, the outermost and innermost bindings of y are\ndynamic, but the middle binding is lexical. The two arguments to + are\ndifferent, one being the value, which is 3, of the lexical variable y, and\nthe other being the value of the dynamic variable named y (a binding of\nwhich happens, coincidentally, to lexically surround it at an outer\nlevel).  All the bindings of x and references to x are dynamic, however,\nbecause of the proclamation that x is always special.\n"
        },
        {
            "type": "See Also",
            "text": "*Note defparameter; defvar:: , defvar\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: special,  Next: locally,  Prev: optimize,  Up: Evaluation and Compilation Dictionary\n\nspecial                                                       [Declaration]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n(special {var}*)\n\nArguments::\n...........\n\nvar--a symbol.\n\nValid Context::\n...............\n\ndeclaration or proclamation\n\nBinding Types Affected::\n........................\n\nvariable\n\nDescription::\n.............\n\nSpecifies that all of the vars named are dynamic.  This specifier affects\nvariable bindings and affects references.  All variable bindings affected\nare made to be dynamic bindings, and affected variable references refer to\nthe current dynamic binding.  For example:\n\n      (defun hack (thing *mod*)    ;The binding of the parameter\n        (declare (special *mod*))  ; *mod* is visible to hack1,\n        (hack1 (car thing)))       ; but not that of thing.\n      (defun hack1 (arg)\n        (declare (special *mod*))  ;Declare references to *mod*\n                                   ;within hack1 to be special.\n        (if (atom arg) *mod*\n            (cons (hack1 (car arg)) (hack1 (cdr arg)))))\n\nA special declaration does not affect inner bindings of a var; the inner\nbindings implicitly shadow a special declaration and must be explicitly\nre-declared to be special.  special declarations never apply to function\nbindings.\n\nspecial declarations can be either bound declarations, affecting both a\nbinding and references, or free declarations, affecting only references,\ndepending on whether the declaration is attached to a variable binding.\n\nWhen used in a proclamation, a special declaration specifier applies to\nall bindings as well as to all references of the mentioned variables.  For\nexample, after\n\n      (declaim (special x))\n\nthen in a function definition such as\n\n      (defun example (x) ...)\n\nthe parameter x is bound as a dynamic variable rather than as a lexical\nvariable.\n\nExamples::\n..........\n\n     (defun declare-eg (y)                 ;this y is special\n      (declare (special y))\n      (let ((y t))                         ;this y is lexical\n           (list y\n                 (locally (declare (special y)) y)))) ;this y refers to the\n                                                      ;special binding of y\n     =>  DECLARE-EG\n      (declare-eg nil) =>  (T NIL)\n\n     (setf (symbol-value 'x) 6)\n     (defun foo (x)                         ;a lexical binding of x\n       (print x)\n       (let ((x (1+ x)))                    ;a special binding of x\n         (declare (special x))              ;and a lexical reference\n         (bar))\n       (1+ x))\n     (defun bar ()\n       (print (locally (declare (special x))\n                x)))\n     (foo 10)\n      |>  10\n      |>  11\n     =>  11\n\n     (setf (symbol-value 'x) 6)\n     (defun bar (x y)            ;[1] 1st occurrence of x\n       (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence\n             (x y))              ;[3] 3rd occurrence of x\n         (declare (special x))\n         (list old-x x)))\n     (bar 'first 'second) =>  (FIRST SECOND)\n\n      (defun few (x &optional (y *foo*))\n        (declare (special *foo*))\n        ...)\n\nThe reference to *foo* in the first line of this example is not special\neven though there is a special declaration in the second line.\n\n      (declaim (special prosp)) =>  implementation-dependent\n      (setq prosp 1 reg 1) =>  1\n      (let ((prosp 2) (reg 2))         ;the binding of prosp is special\n         (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,\n         (list prosp reg))             ;whereas the variable reg is lexical\n     =>  (3 2)\n      (list prosp reg) =>  (1 3)\n     \n      (declaim (special x))          ;x is always special.\n      (defun example (x y)\n        (declare (special y))\n        (let ((y 3) (x (* x 2)))\n          (print (+ y (locally (declare (special y)) y)))\n          (let ((y 4)) (declare (special y)) (foo x)))) =>  EXAMPLE\n\nIn the contorted code above, the outermost and innermost bindings of y are\ndynamic, but the middle binding is lexical. The two arguments to + are\ndifferent, one being the value, which is 3, of the lexical variable y, and\nthe other being the value of the dynamic variable named y (a binding of\nwhich happens, coincidentally, to lexically surround it at an outer\nlevel).  All the bindings of x and references to x are dynamic, however,\nbecause of the proclamation that x is always special.\n\nSee Also::\n..........\n\n*Note defparameter; defvar:: , defvar\n\n"
}