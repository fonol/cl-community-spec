{
    "name": "function (Special Operator)",
    "prev": "funcall",
    "next": "function-lambda-expression",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "function"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "function",
                    "text": " name =>  function\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a function name or lambda expression."
                },
                {
                    "name": "function",
                    "desc": "a function object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The value of function is the functional value of name in the current\nlexical environment.\nIf name is a function name, the functional definition of that name is that\nestablished by the innermost lexically enclosing flet, labels, or macrolet\nform, if there is one.  Otherwise the global functional definition of the\nfunction name is returned.\nIf name is a lambda expression, then a lexical closure is returned.  In\nsituations where a closure over the same set of bindings might be produced\nmore than once, the various resulting closures might or might not be eq.\nIt is an error to use function on a function name that does not denote a\nfunction in the lexical environment in which the function form appears.\nSpecifically, it is an error to use function on a symbol that denotes a\nmacro or special form.  An implementation may choose not to signal this\nerror for performance reasons, but implementations are forbidden from\ndefining the failure to signal an error as a useful behavior.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun adder (x) (function (lambda (y) (+ x y))))\nThe result of (adder 3) is a function that adds 3 to its argument:\n      (setq add3 (adder 3))\n      (funcall add3 5) =>  8\nThis works because function creates a closure of the lambda expression\nthat is able to refer to the value 3 of the variable x even after control\nhas returned from the function adder.\n"
        },
        {
            "type": "See Also",
            "text": "*Note defun:: , *Note fdefinition:: , *Note flet; labels; macrolet:: ,\nlabels, *Note symbol-function:: , *Note Symbols as Forms::, *Note\nSharpsign Single-Quote::, *Note Printing Other Objects::\n"
        },
        {
            "type": "Notes",
            "text": "The notation #'name may be used as an abbreviation for (function name).\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: function (Special Operator),  Next: function-lambda-expression,  Prev: funcall,  Up: Data and Control Flow Dictionary\n\nfunction                                                 [Special Operator]\n---------------------------------------------------------------------------\n\n`function'  name =>  function\n\nArguments and Values::\n......................\n\nname--a function name or lambda expression.\n\nfunction--a function object.\n\nDescription::\n.............\n\nThe value of function is the functional value of name in the current\nlexical environment.\n\nIf name is a function name, the functional definition of that name is that\nestablished by the innermost lexically enclosing flet, labels, or macrolet\nform, if there is one.  Otherwise the global functional definition of the\nfunction name is returned.\n\nIf name is a lambda expression, then a lexical closure is returned.  In\nsituations where a closure over the same set of bindings might be produced\nmore than once, the various resulting closures might or might not be eq.\n\nIt is an error to use function on a function name that does not denote a\nfunction in the lexical environment in which the function form appears.\nSpecifically, it is an error to use function on a symbol that denotes a\nmacro or special form.  An implementation may choose not to signal this\nerror for performance reasons, but implementations are forbidden from\ndefining the failure to signal an error as a useful behavior.\n\nExamples::\n..........\n\n      (defun adder (x) (function (lambda (y) (+ x y))))\n\nThe result of (adder 3) is a function that adds 3 to its argument:\n\n      (setq add3 (adder 3))\n      (funcall add3 5) =>  8\n\nThis works because function creates a closure of the lambda expression\nthat is able to refer to the value 3 of the variable x even after control\nhas returned from the function adder.\n\nSee Also::\n..........\n\n*Note defun:: , *Note fdefinition:: , *Note flet; labels; macrolet:: ,\nlabels, *Note symbol-function:: , *Note Symbols as Forms::, *Note\nSharpsign Single-Quote::, *Note Printing Other Objects::\n\nNotes::\n.......\n\nThe notation #'name may be used as an abbreviation for (function name).\n\n"
}