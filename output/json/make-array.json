{
    "name": "make-array",
    "prev": "simple-bit-vector",
    "next": "adjust-array",
    "up": "Arrays Dictionary",
    "header": {
        "type": "Function",
        "text": "make-array"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "make-array",
                    "text": " dimensions &key element-type initial-element initial-contentsadjustable fill-pointer displaced-to displaced-index-offset\n=>  new-array\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "dimensions",
                    "desc": "a designator for a list of valid array dimensions."
                },
                {
                    "name": "element-type",
                    "desc": "a type specifier.  The default is t."
                },
                {
                    "name": "initial-element",
                    "desc": "an object."
                },
                {
                    "name": "initial-contents",
                    "desc": "an object."
                },
                {
                    "name": "adjustable",
                    "desc": "a generalized boolean.  The default is nil."
                },
                {
                    "name": "fill-pointer",
                    "desc": "a valid fill pointer for the array to be created, or t or"
                },
                {
                    "name": "fill-pointer",
                    "desc": "a valid fill pointer for the array to be created, or t ornil.  The default is nil.\n"
                },
                {
                    "name": "displaced-to",
                    "desc": "an array or nil.  The default is nil.  This option must not"
                },
                {
                    "name": "displaced-to",
                    "desc": "an array or nil.  The default is nil.  This option must notbe supplied if either initial-element or initial-contents is supplied.\n"
                },
                {
                    "name": "displaced-index-offset",
                    "desc": "a valid array row-major index for displaced-to.The default is 0.  This option must not be supplied unless a non-nil\ndisplaced-to is supplied.\n"
                },
                {
                    "name": "new-array",
                    "desc": "an array."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Creates and returns an array constructed of the most specialized type that\ncan accommodate elements of type given by element-type.  If dimensions is\nnil then a zero-dimensional array is created.\nDimensions represents the dimensionality of the new array.\nelement-type indicates the type of the elements intended to be stored in\nthe new-array.  The new-array can actually store any objects of the type\nwhich results from upgrading element-type; see *Note Array Upgrading::.\nIf initial-element is supplied, it is used to initialize each element of\nnew-array.  If initial-element is supplied, it must be of the type given\nby element-type.  initial-element cannot be supplied if either the\n:initial-contents option is supplied or displaced-to is non-nil.  If\ninitial-element is not supplied,\nthe consequences of later reading an uninitialized element of new-array\nare undefined\nunless either initial-contents is supplied or displaced-to is non-nil.\ninitial-contents is used to initialize the contents of array.  For example:\n      (make-array '(4 2 3) :initial-contents\n                  '(((a b c) (1 2 3))\n                   ((d e f) (3 1 2))\n                   ((g h i) (2 3 1))\n                   ((j k l) (0 0 0))))\ninitial-contents is composed of a nested structure of sequences.  The\nnumbers of levels in the structure must equal the rank of array.  Each\nleaf of the nested structure must be of the type given by element-type.\nIf array is zero-dimensional, then initial-contents specifies the single\nelement.  Otherwise, initial-contents must be a sequence whose length is\nequal to the first dimension; each element must be a nested structure for\nan array whose dimensions are the remaining dimensions, and so on.\nInitial-contents cannot be supplied if either initial-element is supplied\nor displaced-to is non-nil.  If initial-contents is not supplied,\nthe consequences of later reading an uninitialized element of new-array\nare undefined\nunless either initial-element is supplied or displaced-to is non-nil.\nIf adjustable is non-nil, the array is expressly adjustable (and so\nactually adjustable); otherwise, the array is not expressly adjustable\n(and it is implementation-dependent whether the array is actually\nadjustable).\nIf fill-pointer is non-nil, the array must be one-dimensional; that is,\nthe array must be a vector.  If fill-pointer is t, the length of the\nvector is used to initialize the fill pointer.  If fill-pointer is an\ninteger, it becomes the initial fill pointer for the vector.\nIf displaced-to is non-nil, make-array will create a displaced array and\ndisplaced-to is the target of that displaced array.  In that case, the\nconsequences are undefined if the actual array element type of\ndisplaced-to is not type equivalent to the actual array element type of\nthe array being created.  If displaced-to is nil, the array is not a\ndisplaced array.\nThe displaced-index-offset is made to be the index offset of the array.\nWhen an array A is given as the :displaced-to argument to make-array when\ncreating array B, then array B is said to be displaced to array A.  The\ntotal number of elements in an array, called the total size of the array,\nis calculated as the product of all the dimensions.  It is required that\nthe total size of A be no smaller than the sum of the total size of B plus\nthe offset n supplied by the displaced-index-offset.  The effect of\ndisplacing is that array B does not have any elements of its own, but\ninstead maps accesses to itself into accesses to array A.  The mapping\ntreats both arrays as if they were one-dimensional by taking the elements\nin row-major order, and then maps an access to element k of array B to an\naccess to element k+n of array A.\nIf make-array is called with adjustable, fill-pointer, and displaced-to\neach nil, then the result is a simple array.\nIf make-array is called with one or more of adjustable, fill-pointer, or\ndisplaced-to being true, whether the resulting array is a simple array is\nimplementation-dependent.\nWhen an array A is given as the :displaced-to argument to make-array when\ncreating array B, then array B is said to be displaced to array A.  The\ntotal number of elements in an array, called the total size of the array,\nis calculated as the product of all the dimensions.  The consequences are\nunspecified if the total size of A is smaller than the sum of the total\nsize of B plus the offset n supplied by the displaced-index-offset.  The\neffect of displacing is that array B does not have any elements of its\nown, but instead maps accesses to itself into accesses to array A.  The\nmapping treats both arrays as if they were one-dimensional by taking the\nelements in row-major order, and then maps an access to element k of array\nB to an access to element k+n of array A.\n"
        },
        {
            "type": "Examples",
            "text": "      (make-array 5) ;; Creates a one-dimensional array of five elements.\n      (make-array '(3 4) :element-type '(mod 16)) ;; Creates a\n                     ;;two-dimensional array, 3 by 4, with four-bit elements.\n      (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.\n      (make-array nil :initial-element nil) =>  #0ANIL\n      (make-array 4 :initial-element nil) =>  #(NIL NIL NIL NIL)\n      (make-array '(2 4)\n                   :element-type '(unsigned-byte 2)\n                   :initial-contents '((0 1 2 3) (3 2 1 0)))\n     =>  #2A((0 1 2 3) (3 2 1 0))\n      (make-array 6\n                   :element-type 'character\n                   :initial-element #\\a\n                   :fill-pointer 3) =>  \"aaa\"\nThe following is an example of making a displaced array.\n      (setq a (make-array '(4 3)))\n     =>  #<ARRAY 4x3 simple 32546632>\n      (dotimes (i 4)\n        (dotimes (j 3)\n          (setf (aref a i j) (list i 'x j '= (* i j)))))\n     =>  NIL\n      (setq b (make-array 8 :displaced-to a\n                            :displaced-index-offset 2))\n     =>  #<ARRAY 8 indirect 32550757>\n      (dotimes (i 8)\n        (print (list i (aref b i))))\n      |>  (0 (0 X 2 = 0))\n      |>  (1 (1 X 0 = 0))\n      |>  (2 (1 X 1 = 1))\n      |>  (3 (1 X 2 = 2))\n      |>  (4 (2 X 0 = 0))\n      |>  (5 (2 X 1 = 2))\n      |>  (6 (2 X 2 = 4))\n      |>  (7 (3 X 0 = 0))\n     =>  NIL\nThe last example depends on the fact that arrays are, in effect, stored in\nrow-major order.\n      (setq a1 (make-array 50))\n     =>  #<ARRAY 50 simple 32562043>\n      (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))\n     =>  #<ARRAY 20 indirect 32563346>\n      (length b1) =>  20\n      (setq a2 (make-array 50 :fill-pointer 10))\n     =>  #<ARRAY 50 fill-pointer 10 46100216>\n      (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))\n     =>  #<ARRAY 20 indirect 46104010>\n      (length a2) =>  10\n      (length b2) =>  20\n      (setq a3 (make-array 50 :fill-pointer 10))\n     =>  #<ARRAY 50 fill-pointer 10 46105663>\n      (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10\n                              :fill-pointer 5))\n     =>  #<ARRAY 20 indirect, fill-pointer 5 46107432>\n      (length a3) =>  10\n      (length b3) =>  5\n"
        },
        {
            "type": "See Also",
            "text": "*Note adjustable-array-p:: , *Note aref:: , *Note arrayp:: , *Note\narray-element-type:: , *Note array-rank-limit:: , *Note\narray-dimension-limit:: , *Note fill-pointer:: , *Note\nupgraded-array-element-type::\n"
        },
        {
            "type": "Notes",
            "text": "There is no specified way to create an array for which adjustable-array-p\ndefinitely returns false.  There is no specified way to create an array\nthat is not a simple array.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: make-array,  Next: adjust-array,  Prev: simple-bit-vector,  Up: Arrays Dictionary\n\nmake-array                                                       [Function]\n---------------------------------------------------------------------------\n\n`make-array'  dimensions &key element-type initial-element initial-contents\nadjustable fill-pointer displaced-to displaced-index-offset\n=>  new-array\n\nArguments and Values::\n......................\n\ndimensions--a designator for a list of valid array dimensions.\n\nelement-type--a type specifier.  The default is t.\n\ninitial-element--an object.\n\ninitial-contents--an object.\n\nadjustable--a generalized boolean.  The default is nil.\n\nfill-pointer--a valid fill pointer for the array to be created, or t or\nnil.  The default is nil.\n\ndisplaced-to--an array or nil.  The default is nil.  This option must not\nbe supplied if either initial-element or initial-contents is supplied.\n\ndisplaced-index-offset--a valid array row-major index for displaced-to.\nThe default is 0.  This option must not be supplied unless a non-nil\ndisplaced-to is supplied.\n\nnew-array--an array.\n\nDescription::\n.............\n\nCreates and returns an array constructed of the most specialized type that\ncan accommodate elements of type given by element-type.  If dimensions is\nnil then a zero-dimensional array is created.\n\nDimensions represents the dimensionality of the new array.\n\nelement-type indicates the type of the elements intended to be stored in\nthe new-array.  The new-array can actually store any objects of the type\nwhich results from upgrading element-type; see *Note Array Upgrading::.\n\nIf initial-element is supplied, it is used to initialize each element of\nnew-array.  If initial-element is supplied, it must be of the type given\nby element-type.  initial-element cannot be supplied if either the\n:initial-contents option is supplied or displaced-to is non-nil.  If\ninitial-element is not supplied,\n\nthe consequences of later reading an uninitialized element of new-array\nare undefined\n\nunless either initial-contents is supplied or displaced-to is non-nil.\n\ninitial-contents is used to initialize the contents of array.  For example:\n\n      (make-array '(4 2 3) :initial-contents\n                  '(((a b c) (1 2 3))\n                   ((d e f) (3 1 2))\n                   ((g h i) (2 3 1))\n                   ((j k l) (0 0 0))))\n\ninitial-contents is composed of a nested structure of sequences.  The\nnumbers of levels in the structure must equal the rank of array.  Each\nleaf of the nested structure must be of the type given by element-type.\nIf array is zero-dimensional, then initial-contents specifies the single\nelement.  Otherwise, initial-contents must be a sequence whose length is\nequal to the first dimension; each element must be a nested structure for\nan array whose dimensions are the remaining dimensions, and so on.\nInitial-contents cannot be supplied if either initial-element is supplied\nor displaced-to is non-nil.  If initial-contents is not supplied,\n\nthe consequences of later reading an uninitialized element of new-array\nare undefined\n\nunless either initial-element is supplied or displaced-to is non-nil.\n\nIf adjustable is non-nil, the array is expressly adjustable (and so\nactually adjustable); otherwise, the array is not expressly adjustable\n(and it is implementation-dependent whether the array is actually\nadjustable).\n\nIf fill-pointer is non-nil, the array must be one-dimensional; that is,\nthe array must be a vector.  If fill-pointer is t, the length of the\nvector is used to initialize the fill pointer.  If fill-pointer is an\ninteger, it becomes the initial fill pointer for the vector.\n\nIf displaced-to is non-nil, make-array will create a displaced array and\ndisplaced-to is the target of that displaced array.  In that case, the\nconsequences are undefined if the actual array element type of\ndisplaced-to is not type equivalent to the actual array element type of\nthe array being created.  If displaced-to is nil, the array is not a\ndisplaced array.\n\nThe displaced-index-offset is made to be the index offset of the array.\nWhen an array A is given as the :displaced-to argument to make-array when\ncreating array B, then array B is said to be displaced to array A.  The\ntotal number of elements in an array, called the total size of the array,\nis calculated as the product of all the dimensions.  It is required that\nthe total size of A be no smaller than the sum of the total size of B plus\nthe offset n supplied by the displaced-index-offset.  The effect of\ndisplacing is that array B does not have any elements of its own, but\ninstead maps accesses to itself into accesses to array A.  The mapping\ntreats both arrays as if they were one-dimensional by taking the elements\nin row-major order, and then maps an access to element k of array B to an\naccess to element k+n of array A.\n\nIf make-array is called with adjustable, fill-pointer, and displaced-to\neach nil, then the result is a simple array.\n\nIf make-array is called with one or more of adjustable, fill-pointer, or\ndisplaced-to being true, whether the resulting array is a simple array is\nimplementation-dependent.\n\nWhen an array A is given as the :displaced-to argument to make-array when\ncreating array B, then array B is said to be displaced to array A.  The\ntotal number of elements in an array, called the total size of the array,\nis calculated as the product of all the dimensions.  The consequences are\nunspecified if the total size of A is smaller than the sum of the total\nsize of B plus the offset n supplied by the displaced-index-offset.  The\neffect of displacing is that array B does not have any elements of its\nown, but instead maps accesses to itself into accesses to array A.  The\nmapping treats both arrays as if they were one-dimensional by taking the\nelements in row-major order, and then maps an access to element k of array\nB to an access to element k+n of array A.\n\nExamples::\n..........\n\n\n      (make-array 5) ;; Creates a one-dimensional array of five elements.\n      (make-array '(3 4) :element-type '(mod 16)) ;; Creates a\n                     ;;two-dimensional array, 3 by 4, with four-bit elements.\n      (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.\n\n      (make-array nil :initial-element nil) =>  #0ANIL\n      (make-array 4 :initial-element nil) =>  #(NIL NIL NIL NIL)\n      (make-array '(2 4)\n                   :element-type '(unsigned-byte 2)\n                   :initial-contents '((0 1 2 3) (3 2 1 0)))\n     =>  #2A((0 1 2 3) (3 2 1 0))\n      (make-array 6\n                   :element-type 'character\n                   :initial-element #\\a\n                   :fill-pointer 3) =>  \"aaa\"\n\nThe following is an example of making a displaced array.\n\n      (setq a (make-array '(4 3)))\n     =>  #<ARRAY 4x3 simple 32546632>\n      (dotimes (i 4)\n        (dotimes (j 3)\n          (setf (aref a i j) (list i 'x j '= (* i j)))))\n     =>  NIL\n      (setq b (make-array 8 :displaced-to a\n                            :displaced-index-offset 2))\n     =>  #<ARRAY 8 indirect 32550757>\n      (dotimes (i 8)\n        (print (list i (aref b i))))\n      |>  (0 (0 X 2 = 0))\n      |>  (1 (1 X 0 = 0))\n      |>  (2 (1 X 1 = 1))\n      |>  (3 (1 X 2 = 2))\n      |>  (4 (2 X 0 = 0))\n      |>  (5 (2 X 1 = 2))\n      |>  (6 (2 X 2 = 4))\n      |>  (7 (3 X 0 = 0))\n     =>  NIL\n\nThe last example depends on the fact that arrays are, in effect, stored in\nrow-major order.\n\n      (setq a1 (make-array 50))\n     =>  #<ARRAY 50 simple 32562043>\n      (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))\n     =>  #<ARRAY 20 indirect 32563346>\n      (length b1) =>  20\n     \n      (setq a2 (make-array 50 :fill-pointer 10))\n     =>  #<ARRAY 50 fill-pointer 10 46100216>\n      (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))\n     =>  #<ARRAY 20 indirect 46104010>\n      (length a2) =>  10\n      (length b2) =>  20\n     \n      (setq a3 (make-array 50 :fill-pointer 10))\n     =>  #<ARRAY 50 fill-pointer 10 46105663>\n      (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10\n                              :fill-pointer 5))\n     =>  #<ARRAY 20 indirect, fill-pointer 5 46107432>\n      (length a3) =>  10\n      (length b3) =>  5\n\nSee Also::\n..........\n\n*Note adjustable-array-p:: , *Note aref:: , *Note arrayp:: , *Note\narray-element-type:: , *Note array-rank-limit:: , *Note\narray-dimension-limit:: , *Note fill-pointer:: , *Note\nupgraded-array-element-type::\n\nNotes::\n.......\n\nThere is no specified way to create an array for which adjustable-array-p\ndefinitely returns false.  There is no specified way to create an array\nthat is not a simple array.\n\n"
}