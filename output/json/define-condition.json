{
    "name": "define-condition",
    "prev": "ignore-errors",
    "next": "make-condition",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Macro",
        "text": "define-condition"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "define-condition",
                    "text": " name ({parent-type}*) ({!slot-spec}*) {option}*=>  name\n\nslot-spec ::=slot-name | (slot-name !slot-option)\n\nslot-option ::=[[ {:reader symbol}* | \n                {:writer !function-name}* | \n                {:accessor symbol}* | \n                {:allocation !allocation-type} | \n                {:initarg symbol}* |                  {:initform form} | \n                {:type type-specifier} ]]\n\noption ::=[[ (:default-initargs . initarg-list) | \n           (:documentation string) |             (:report report-name) ]]\n\nfunction-name ::={symbol | (setf symbol)}\n\nallocation-type ::=:instance | :class\n\nreport-name ::=string | symbol | lambda expression\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a symbol."
                },
                {
                    "name": "parent-type",
                    "desc": "a symbol naming a condition type.  If no parent-types are"
                },
                {
                    "name": "parent-type",
                    "desc": "a symbol naming a condition type.  If no parent-types aresupplied, the parent-types default to (condition).\n"
                }
            ]
        },
        {
            "type": "Description",
            "text": "define-condition defines a new condition type called name, which is a\nsubtype of\nthe type or types named by parent-type.  Each parent-type argument\nspecifies a direct supertype of the new condition. The new condition\ninherits slots and methods from each of its direct supertypes, and so on.\nIf a slot name/slot form pair is supplied, the slot form is a form that\ncan be evaluated by make-condition to produce a default value when an\nexplicit value is not provided.  If no slot form is supplied, the contents\nof the slot is initialized in an implementation-dependent way.\nIf the type being defined and some other type from which it inherits have\na slot by the same name, only one slot is allocated in the condition, but\nthe supplied slot form overrides any slot form that might otherwise have\nbeen inherited from a parent-type.  If no slot form is supplied, the\ninherited slot form (if any) is still visible.\nAccessors are created according to the same rules as used by defclass.\nA description of slot-options follows:\n:reader\n     The :reader slot option specifies that an unqualified method is to be\n     defined on the generic function named by the argument to :reader to\n     read the value of the given slot.\n*\n     The :initform slot option is used to provide a default initial value\n     form to be used in the initialization of the slot.  This form is\n     evaluated every time it is used to initialize the slot.  The lexical\n     environment in which this form is evaluated is the lexical\n     environment in which the define-condition form was evaluated.  Note\n     that the lexical environment refers both to variables and to\n     functions.  For local slots, the dynamic environment is the dynamic\n     environment in which make-condition was called; for shared slots, the\n     dynamic environment is the dynamic environment in which the\n     define-condition form was evaluated.\n     [Reviewer Note by Barmar: Issue CLOS-CONDITIONS doesn't say this.] No\n     implementation is permitted to extend the syntax of define-condition\n     to allow (slot-name form) as an abbreviation for (slot-name :initform\n     form).\n:initarg\n     The :initarg slot option declares an initialization argument named by\n     its symbol argument and specifies that this initialization argument\n     initializes the given slot.  If the initialization argument has a\n     value in the call to initialize-instance, the value is stored into\n     the given slot, and the slot's :initform slot option, if any, is not\n     evaluated.  If none of the initialization arguments specified for a\n     given slot has a value, the slot is initialized according to the\n     :initform slot option, if specified.\n:type\n     The :type slot option specifies that the contents of the slot is\n     always of the specified type.  It effectively declares the result\n     type of the reader generic function when applied to an object of this\n     condition type.  The consequences of attempting to store in a slot a\n     value that does not satisfy the type of the slot is undefined.\n:default-initargs\n     [Editorial Note by KMP: This is an option, not a slot option.]\n     This option is treated the same as it would be defclass.\n:documentation\n     [Editorial Note by KMP: This is both an option and a slot option.]\n     The :documentation slot option provides a documentation string for\n     the slot.\n:report\n     [Editorial Note by KMP: This is an option, not a slot option.]\n     Condition reporting is mediated through the print-object method for\n     the condition type in question, with *print-escape* always being nil.\n     Specifying (:report report-name) in the definition of a condition\n     type C is equivalent to:\n           (defmethod print-object ((x c) stream)\n             (if *print-escape* (call-next-method) (report-name x stream)))\n     If the value supplied by the argument to :report (report-name) is a\n     symbol or a lambda expression, it must be acceptable to function.\n     (function report-name) is evaluated in the current lexical\n     environment.  It should return a function of two arguments, a\n     condition and a stream, that prints on the stream a description of\n     the condition.  This function is called whenever the condition is\n     printed while *print-escape* is nil.\n     If report-name is a string, it is a shorthand for\n           (lambda (condition stream)\n             (declare (ignore condition))\n             (write-string report-name stream))\n     This option is processed after the new condition type has been\n     defined, so use of the slot accessors within the :report function is\n     permitted.  If this option is not supplied, information about how to\n     report this type of condition is inherited from the parent-type.\nThe consequences are unspecifed if an attempt is made to read a slot that\nhas not been explicitly initialized and that has not been given a default\nvalue.\nThe consequences are unspecified if an attempt is made to assign the slots\nby using setf.\nIf a define-condition form appears as a top level form, the compiler must\nmake name recognizable as a valid type name, and it must be possible to\nreference the condition type as the parent-type of another condition type\nin a subsequent define-condition form in the file being compiled.\n"
        },
        {
            "type": "Examples",
            "text": "The following form defines a condition of type peg/hole-mismatch which\ninherits from a condition type called blocks-world-error:\n     (define-condition peg/hole-mismatch\n                       (blocks-world-error)\n                       ((peg-shape  :initarg :peg-shape\n                                    :reader peg/hole-mismatch-peg-shape)\n                        (hole-shape :initarg :hole-shape\n                                    :reader peg/hole-mismatch-hole-shape))\n       (:report (lambda (condition stream)\n                  (format stream \"A ~A peg cannot go in a ~A hole.\"\n                          (peg/hole-mismatch-peg-shape  condition)\n                          (peg/hole-mismatch-hole-shape condition)))))\nThe new type has slots peg-shape and hole-shape, so make-condition accepts\n:peg-shape and :hole-shape keywords.  The readers\npeg/hole-mismatch-peg-shape and peg/hole-mismatch-hole-shape apply to\nobjects of this type, as illustrated in the :report information.\nThe following form defines a condition type named machine-error which\ninherits from error:\n     (define-condition machine-error\n                       (error)\n                       ((machine-name :initarg :machine-name\n                                      :reader machine-error-machine-name))\n       (:report (lambda (condition stream)\n                  (format stream \"There is a problem with ~A.\"\n                          (machine-error-machine-name condition)))))\nBuilding on this definition, a new error condition can be defined which is\na subtype of machine-error for use when machines are not available:\n     (define-condition machine-not-available-error (machine-error) ()\n       (:report (lambda (condition stream)\n                  (format stream \"The machine ~A is not available.\"\n                          (machine-error-machine-name condition)))))\nThis defines a still more specific condition, built upon\nmachine-not-available-error, which provides a slot initialization form for\nmachine-name but which does not provide any new slots or report\ninformation.  It just gives the machine-name slot a default initialization:\n     (define-condition my-favorite-machine-not-available-error\n                       (machine-not-available-error)\n       ((machine-name :initform \"mc.lcs.mit.edu\")))\nNote that since no :report clause was given, the information inherited\nfrom machine-not-available-error is used to report this type of condition.\n      (define-condition ate-too-much (error)\n          ((person :initarg :person :reader ate-too-much-person)\n           (weight :initarg :weight :reader ate-too-much-weight)\n           (kind-of-food :initarg :kind-of-food\n                         :reader :ate-too-much-kind-of-food)))\n     =>  ATE-TOO-MUCH\n      (define-condition ate-too-much-ice-cream (ate-too-much)\n        ((kind-of-food :initform 'ice-cream)\n         (flavor       :initarg :flavor\n                       :reader ate-too-much-ice-cream-flavor\n                       :initform 'vanilla ))\n        (:report (lambda (condition stream)\n                   (format stream \"~A ate too much ~A ice-cream\"\n                           (ate-too-much-person condition)\n                           (ate-too-much-ice-cream-flavor condition)))))\n     =>  ATE-TOO-MUCH-ICE-CREAM\n      (make-condition 'ate-too-much-ice-cream\n                      :person 'fred\n                      :weight 300\n                      :flavor 'chocolate)\n     =>  #<ATE-TOO-MUCH-ICE-CREAM 32236101>\n      (format t \"~A\" *)\n      |>  FRED ate too much CHOCOLATE ice-cream\n     =>  NIL\n"
        },
        {
            "type": "See Also",
            "text": "*Note make-condition:: , *Note defclass:: , *Note Condition System\nConcepts::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: define-condition,  Next: make-condition,  Prev: ignore-errors,  Up: Conditions Dictionary\n\ndefine-condition                                                    [Macro]\n---------------------------------------------------------------------------\n\n[Editorial Note by KMP: This syntax stuff is still very confused and needs\nlots of work.]\n\n`define-condition'  name ({parent-type}*) ({!slot-spec}*) {option}*\n=>  name\n\nslot-spec ::=slot-name | (slot-name !slot-option)\n\nslot-option ::=[[ {:reader symbol}* | \n                {:writer !function-name}* | \n                {:accessor symbol}* | \n                {:allocation !allocation-type} | \n                {:initarg symbol}* |                  {:initform form} | \n                {:type type-specifier} ]]\n\noption ::=[[ (:default-initargs . initarg-list) | \n           (:documentation string) |             (:report report-name) ]]\n\nfunction-name ::={symbol | (setf symbol)}\n\nallocation-type ::=:instance | :class\n\nreport-name ::=string | symbol | lambda expression\n\nArguments and Values::\n......................\n\nname--a symbol.\n\nparent-type--a symbol naming a condition type.  If no parent-types are\nsupplied, the parent-types default to (condition).\n\ndefault-initargs--a list of keyword/value pairs.\n\n[Editorial Note by KMP: This is all mixed up as to which is a slot option\nand which is a main option.  I'll sort that out.  Also, some of this is\nimplied by the bnf and needn't be stated explicitly.]\n\nSlot-spec - the name of a slot or a list consisting of the slot-name\nfollowed by zero or more slot-options.\n\nSlot-name - a slot name (a symbol), the list of a slot name, or the list\nof slot name/slot form pairs.\n\nOption - Any of the following:\n\n:reader\n     :reader can be supplied more than once for a given slot and cannot be\n     nil.\n\n:writer\n     :writer can be supplied more than once for a given slot and must name\n     a generic function.\n\n:accessor\n     :accessor can be supplied more than once for a given slot and cannot\n     be nil.\n\n:allocation\n     :allocation can be supplied once at most for a given slot.  The\n     default if :allocation is not supplied is :instance.\n\n:initarg\n     :initarg can be supplied more than once for a given slot.\n\n:initform\n     :initform can be supplied once at most for a given slot.\n\n:type\n     :type can be supplied once at most for a given slot.\n\n:documentation\n     :documentation can be supplied once at most for a given slot.\n\n:report\n     :report can be supplied once at most.\n\nDescription::\n.............\n\ndefine-condition defines a new condition type called name, which is a\nsubtype of\n\nthe type or types named by parent-type.  Each parent-type argument\nspecifies a direct supertype of the new condition. The new condition\ninherits slots and methods from each of its direct supertypes, and so on.\n\nIf a slot name/slot form pair is supplied, the slot form is a form that\ncan be evaluated by make-condition to produce a default value when an\nexplicit value is not provided.  If no slot form is supplied, the contents\nof the slot is initialized in an implementation-dependent way.\n\nIf the type being defined and some other type from which it inherits have\na slot by the same name, only one slot is allocated in the condition, but\nthe supplied slot form overrides any slot form that might otherwise have\nbeen inherited from a parent-type.  If no slot form is supplied, the\ninherited slot form (if any) is still visible.\n\nAccessors are created according to the same rules as used by defclass.\n\nA description of slot-options follows:\n\n:reader\n     The :reader slot option specifies that an unqualified method is to be\n     defined on the generic function named by the argument to :reader to\n     read the value of the given slot.\n\n*\n     The :initform slot option is used to provide a default initial value\n     form to be used in the initialization of the slot.  This form is\n     evaluated every time it is used to initialize the slot.  The lexical\n     environment in which this form is evaluated is the lexical\n     environment in which the define-condition form was evaluated.  Note\n     that the lexical environment refers both to variables and to\n     functions.  For local slots, the dynamic environment is the dynamic\n     environment in which make-condition was called; for shared slots, the\n     dynamic environment is the dynamic environment in which the\n     define-condition form was evaluated.\n\n     [Reviewer Note by Barmar: Issue CLOS-CONDITIONS doesn't say this.] No\n     implementation is permitted to extend the syntax of define-condition\n     to allow (slot-name form) as an abbreviation for (slot-name :initform\n     form).\n\n:initarg\n     The :initarg slot option declares an initialization argument named by\n     its symbol argument and specifies that this initialization argument\n     initializes the given slot.  If the initialization argument has a\n     value in the call to initialize-instance, the value is stored into\n     the given slot, and the slot's :initform slot option, if any, is not\n     evaluated.  If none of the initialization arguments specified for a\n     given slot has a value, the slot is initialized according to the\n     :initform slot option, if specified.\n\n:type\n     The :type slot option specifies that the contents of the slot is\n     always of the specified type.  It effectively declares the result\n     type of the reader generic function when applied to an object of this\n     condition type.  The consequences of attempting to store in a slot a\n     value that does not satisfy the type of the slot is undefined.\n\n:default-initargs\n     [Editorial Note by KMP: This is an option, not a slot option.]\n\n     This option is treated the same as it would be defclass.\n\n:documentation\n     [Editorial Note by KMP: This is both an option and a slot option.]\n\n     The :documentation slot option provides a documentation string for\n     the slot.\n\n:report\n     [Editorial Note by KMP: This is an option, not a slot option.]\n\n     Condition reporting is mediated through the print-object method for\n     the condition type in question, with *print-escape* always being nil.\n     Specifying (:report report-name) in the definition of a condition\n     type C is equivalent to:\n\n           (defmethod print-object ((x c) stream)\n             (if *print-escape* (call-next-method) (report-name x stream)))\n\n     If the value supplied by the argument to :report (report-name) is a\n     symbol or a lambda expression, it must be acceptable to function.\n     (function report-name) is evaluated in the current lexical\n     environment.  It should return a function of two arguments, a\n     condition and a stream, that prints on the stream a description of\n     the condition.  This function is called whenever the condition is\n     printed while *print-escape* is nil.\n\n     If report-name is a string, it is a shorthand for\n\n           (lambda (condition stream)\n             (declare (ignore condition))\n             (write-string report-name stream))\n\n     This option is processed after the new condition type has been\n     defined, so use of the slot accessors within the :report function is\n     permitted.  If this option is not supplied, information about how to\n     report this type of condition is inherited from the parent-type.\n\nThe consequences are unspecifed if an attempt is made to read a slot that\nhas not been explicitly initialized and that has not been given a default\nvalue.\n\nThe consequences are unspecified if an attempt is made to assign the slots\nby using setf.\n\nIf a define-condition form appears as a top level form, the compiler must\nmake name recognizable as a valid type name, and it must be possible to\nreference the condition type as the parent-type of another condition type\nin a subsequent define-condition form in the file being compiled.\n\nExamples::\n..........\n\nThe following form defines a condition of type peg/hole-mismatch which\ninherits from a condition type called blocks-world-error:\n\n     (define-condition peg/hole-mismatch\n                       (blocks-world-error)\n                       ((peg-shape  :initarg :peg-shape\n                                    :reader peg/hole-mismatch-peg-shape)\n                        (hole-shape :initarg :hole-shape\n                                    :reader peg/hole-mismatch-hole-shape))\n       (:report (lambda (condition stream)\n                  (format stream \"A ~A peg cannot go in a ~A hole.\"\n                          (peg/hole-mismatch-peg-shape  condition)\n                          (peg/hole-mismatch-hole-shape condition)))))\n\nThe new type has slots peg-shape and hole-shape, so make-condition accepts\n:peg-shape and :hole-shape keywords.  The readers\npeg/hole-mismatch-peg-shape and peg/hole-mismatch-hole-shape apply to\nobjects of this type, as illustrated in the :report information.\n\nThe following form defines a condition type named machine-error which\ninherits from error:\n\n     (define-condition machine-error\n                       (error)\n                       ((machine-name :initarg :machine-name\n                                      :reader machine-error-machine-name))\n       (:report (lambda (condition stream)\n                  (format stream \"There is a problem with ~A.\"\n                          (machine-error-machine-name condition)))))\n\nBuilding on this definition, a new error condition can be defined which is\na subtype of machine-error for use when machines are not available:\n\n     (define-condition machine-not-available-error (machine-error) ()\n       (:report (lambda (condition stream)\n                  (format stream \"The machine ~A is not available.\"\n                          (machine-error-machine-name condition)))))\n\nThis defines a still more specific condition, built upon\nmachine-not-available-error, which provides a slot initialization form for\nmachine-name but which does not provide any new slots or report\ninformation.  It just gives the machine-name slot a default initialization:\n\n     (define-condition my-favorite-machine-not-available-error\n                       (machine-not-available-error)\n       ((machine-name :initform \"mc.lcs.mit.edu\")))\n\nNote that since no :report clause was given, the information inherited\nfrom machine-not-available-error is used to report this type of condition.\n\n      (define-condition ate-too-much (error)\n          ((person :initarg :person :reader ate-too-much-person)\n           (weight :initarg :weight :reader ate-too-much-weight)\n           (kind-of-food :initarg :kind-of-food\n                         :reader :ate-too-much-kind-of-food)))\n     =>  ATE-TOO-MUCH\n      (define-condition ate-too-much-ice-cream (ate-too-much)\n        ((kind-of-food :initform 'ice-cream)\n         (flavor       :initarg :flavor\n                       :reader ate-too-much-ice-cream-flavor\n                       :initform 'vanilla ))\n        (:report (lambda (condition stream)\n                   (format stream \"~A ate too much ~A ice-cream\"\n                           (ate-too-much-person condition)\n                           (ate-too-much-ice-cream-flavor condition)))))\n     =>  ATE-TOO-MUCH-ICE-CREAM\n      (make-condition 'ate-too-much-ice-cream\n                      :person 'fred\n                      :weight 300\n                      :flavor 'chocolate)\n     =>  #<ATE-TOO-MUCH-ICE-CREAM 32236101>\n      (format t \"~A\" *)\n      |>  FRED ate too much CHOCOLATE ice-cream\n     =>  NIL\n\nSee Also::\n..........\n\n*Note make-condition:: , *Note defclass:: , *Note Condition System\nConcepts::\n\n"
}