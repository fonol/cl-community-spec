{
    "name": "subtypep",
    "prev": "deftype",
    "next": "type-of",
    "up": "Types and Classes Dictionary",
    "header": {
        "type": "Function",
        "text": "subtypep"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "subtypep",
                    "text": " type-1 type-2 &optional environment =>  subtype-p, valid-p\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "type-1",
                    "desc": "a type specifier."
                },
                {
                    "name": "type-2",
                    "desc": "a type specifier."
                },
                {
                    "name": "environment",
                    "desc": "an environment object.  The default is nil, denoting the null"
                },
                {
                    "name": "environment",
                    "desc": "an environment object.  The default is nil, denoting the nulllexical environment and the current global environment.\n"
                },
                {
                    "name": "subtype-p",
                    "desc": "a generalized boolean."
                },
                {
                    "name": "valid-p",
                    "desc": "a generalized boolean."
                }
            ]
        },
        {
            "type": "Description",
            "text": "If type-1 is a recognizable subtype of type-2, the first value is true.\nOtherwise, the first value is false, indicating that either type-1 is not\na subtype of type-2, or else type-1 is a subtype of type-2 but is not a\nrecognizable subtype.\nA second value is also returned indicating the `certainty' of the first\nvalue.  If this value is true, then the first value is an accurate\nindication of the subtype relationship.  (The second value is always true\nwhen the first value is true.)\nFigure 4-9 summarizes the possible combinations of values that might\nresult.\n  Value 1  Value 2  Meaning                                               \n  true     true     type-1 is definitely a subtype of type-2.             \n  false    true     type-1 is definitely not a subtype of type-2.         \n  false    false    subtypep could not determine the relationship,        \n                    so type-1 might or might not be a subtype of type-2.  \n               Figure 4-9: Result possibilities for subtypep             \nsubtypep is permitted to return the values false and false only when at\nleast one argument involves one of these type specifiers: and, eql, the\nlist form of function, member, not, or, satisfies, or values.  (A type\nspecifier `involves' such a symbol if, after being type expanded, it\ncontains that symbol in a position that would call for its meaning as a\ntype specifier to be used.) One consequence of this is that if neither\ntype-1 nor type-2 involves any of these type specifiers, then subtypep is\nobliged to determine the relationship accurately.  In particular, subtypep\nreturns the values true and true if the arguments are equal and do not\ninvolve any of these type specifiers.\nsubtypep never returns a second value of nil when both type-1 and type-2\ninvolve only the names in Figure~4-2, or names of types defined by\ndefstruct, define-condition, or defclass, or derived types that expand\ninto only those names.  While type specifiers listed in Figure~4-2 and\nnames of defclass and defstruct can in some cases be implemented as\nderived types, subtypep regards them as primitive.\nThe relationships between types reflected by subtypep are those specific\nto the particular implementation.  For example, if an implementation\nsupports only a single type of floating-point numbers, in that\nimplementation (subtypep 'float 'long-float) returns the values true and\ntrue (since the two types are identical).\nFor all T1 and T2 other than *, (array T1) and (array T2) are two\ndifferent type specifiers that always refer to the same sets of things if\nand only if they refer to arrays of exactly the same specialized\nrepresentation, i.e., if (upgraded-array-element-type 'T1)  and\n(upgraded-array-element-type 'T2) return two different type specifiers\nthat always refer to the same sets of objects.  This is another way of\nsaying that `(array type-specifier) and `(array\n,(upgraded-array-element-type 'type-specifier)) refer to the same set of\nspecialized array representations.  For all T1 and T2 other than *, the\nintersection of (array T1) and (array T2) is the empty set if and only if\nthey refer to arrays of different, distinct specialized representations.\nTherefore,\n      (subtypep '(array T1) '(array T2)) =>  true\nif and only if\n      (upgraded-array-element-type 'T1)  and\n      (upgraded-array-element-type 'T2)\nreturn two different type specifiers that always refer to the same sets of\nobjects.\nFor all type-specifiers T1 and T2 other than *,\n      (subtypep '(complex T1) '(complex T2)) =>  true, true\nif:\n1.\n     T1 is a subtype of T2, or\n2.\n     (upgraded-complex-part-type 'T1) and (upgraded-complex-part-type 'T2)\n     return two different type specifiers that always refer to the same\n     sets of objects; in this case, (complex T1) and (complex T2) both\n     refer to the same specialized representation.\nThe values are false and true otherwise.\nThe form\n      (subtypep '(complex single-float) '(complex float))\nmust return true in all implementations, but\n      (subtypep '(array single-float) '(array float))\nreturns true only in implementations that do not have a specialized array\nrepresentation for single floats distinct from that for other floats.\n"
        },
        {
            "type": "Examples",
            "text": "      (subtypep 'compiled-function 'function) =>  true, true\n      (subtypep 'null 'list) =>  true, true\n      (subtypep 'null 'symbol) =>  true, true\n      (subtypep 'integer 'string) =>  false, true\n      (subtypep '(satisfies dummy) nil) =>  false, implementation-dependent\n      (subtypep '(integer 1 3) '(integer 1 4)) =>  true, true\n      (subtypep '(integer (0) (0)) 'nil) =>  true, true\n      (subtypep 'nil '(integer (0) (0))) =>  true, true\n      (subtypep '(integer (0) (0)) '(member)) =>  true, true ;or false, false\n      (subtypep '(member) 'nil) =>  true, true ;or false, false\n      (subtypep 'nil '(member)) =>  true, true ;or false, false\nLet <aet-x> and <aet-y> be two distinct type specifiers that do not always\nrefer to the same sets of objects in a given implementation, but for which\nmake-array, will return an object of the same array type.\nThus, in each case,\n       (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))\n                 (array-element-type (make-array 0 :element-type '<aet-y>)))\n     =>  true, true\n       (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))\n                 (array-element-type (make-array 0 :element-type '<aet-x>)))\n     =>  true, true\nIf  (array <aet-x>) and (array <aet-y>) are different names for exactly\nthe same set of objects, these names should always refer to the same sets\nof objects.  That implies that the following set of tests are also true:\n      (subtypep '(array <aet-x>) '(array <aet-y>)) =>  true, true\n      (subtypep '(array <aet-y>) '(array <aet-x>)) =>  true, true\n"
        },
        {
            "type": "See Also",
            "text": "*Note Types::\n"
        },
        {
            "type": "Notes",
            "text": "The small differences between the subtypep specification for the array and\ncomplex types are necessary because there is no creation function for\ncomplexes which allows the specification of the resultant part type\nindependently of the actual types of the parts.  Thus in the case of the\ntype complex, the actual type of the parts is referred to, although a\nnumber can be a member of more than one type.  For example, 17 is of type\n(mod 18) as well as type (mod 256) and type integer; and 2.3f5 is of type\nsingle-float as well as type float.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: subtypep,  Next: type-of,  Prev: deftype,  Up: Types and Classes Dictionary\n\nsubtypep                                                         [Function]\n---------------------------------------------------------------------------\n\n`subtypep'  type-1 type-2 &optional environment =>  subtype-p, valid-p\n\nArguments and Values::\n......................\n\ntype-1--a type specifier.\n\ntype-2--a type specifier.\n\nenvironment--an environment object.  The default is nil, denoting the null\nlexical environment and the current global environment.\n\nsubtype-p--a generalized boolean.\n\nvalid-p--a generalized boolean.\n\nDescription::\n.............\n\nIf type-1 is a recognizable subtype of type-2, the first value is true.\nOtherwise, the first value is false, indicating that either type-1 is not\na subtype of type-2, or else type-1 is a subtype of type-2 but is not a\nrecognizable subtype.\n\nA second value is also returned indicating the `certainty' of the first\nvalue.  If this value is true, then the first value is an accurate\nindication of the subtype relationship.  (The second value is always true\nwhen the first value is true.)\n\nFigure 4-9 summarizes the possible combinations of values that might\nresult.\n\n  Value 1  Value 2  Meaning                                               \n  true     true     type-1 is definitely a subtype of type-2.             \n  false    true     type-1 is definitely not a subtype of type-2.         \n  false    false    subtypep could not determine the relationship,        \n                    so type-1 might or might not be a subtype of type-2.  \n\n               Figure 4-9: Result possibilities for subtypep             \n\n\nsubtypep is permitted to return the values false and false only when at\nleast one argument involves one of these type specifiers: and, eql, the\nlist form of function, member, not, or, satisfies, or values.  (A type\nspecifier `involves' such a symbol if, after being type expanded, it\ncontains that symbol in a position that would call for its meaning as a\ntype specifier to be used.) One consequence of this is that if neither\ntype-1 nor type-2 involves any of these type specifiers, then subtypep is\nobliged to determine the relationship accurately.  In particular, subtypep\nreturns the values true and true if the arguments are equal and do not\ninvolve any of these type specifiers.\n\nsubtypep never returns a second value of nil when both type-1 and type-2\ninvolve only the names in Figure~4-2, or names of types defined by\ndefstruct, define-condition, or defclass, or derived types that expand\ninto only those names.  While type specifiers listed in Figure~4-2 and\nnames of defclass and defstruct can in some cases be implemented as\nderived types, subtypep regards them as primitive.\n\nThe relationships between types reflected by subtypep are those specific\nto the particular implementation.  For example, if an implementation\nsupports only a single type of floating-point numbers, in that\nimplementation (subtypep 'float 'long-float) returns the values true and\ntrue (since the two types are identical).\n\nFor all T1 and T2 other than *, (array T1) and (array T2) are two\ndifferent type specifiers that always refer to the same sets of things if\nand only if they refer to arrays of exactly the same specialized\nrepresentation, i.e., if (upgraded-array-element-type 'T1)  and\n(upgraded-array-element-type 'T2) return two different type specifiers\nthat always refer to the same sets of objects.  This is another way of\nsaying that `(array type-specifier) and `(array\n,(upgraded-array-element-type 'type-specifier)) refer to the same set of\nspecialized array representations.  For all T1 and T2 other than *, the\nintersection of (array T1) and (array T2) is the empty set if and only if\nthey refer to arrays of different, distinct specialized representations.\n\nTherefore,\n\n      (subtypep '(array T1) '(array T2)) =>  true\n\nif and only if\n\n      (upgraded-array-element-type 'T1)  and\n      (upgraded-array-element-type 'T2)\n\nreturn two different type specifiers that always refer to the same sets of\nobjects.\n\nFor all type-specifiers T1 and T2 other than *,\n\n      (subtypep '(complex T1) '(complex T2)) =>  true, true\n\nif:\n1.\n     T1 is a subtype of T2, or\n\n2.\n     (upgraded-complex-part-type 'T1) and (upgraded-complex-part-type 'T2)\n     return two different type specifiers that always refer to the same\n     sets of objects; in this case, (complex T1) and (complex T2) both\n     refer to the same specialized representation.\n\nThe values are false and true otherwise.\n\nThe form\n\n      (subtypep '(complex single-float) '(complex float))\n\nmust return true in all implementations, but\n\n      (subtypep '(array single-float) '(array float))\n\nreturns true only in implementations that do not have a specialized array\nrepresentation for single floats distinct from that for other floats.\n\nExamples::\n..........\n\n      (subtypep 'compiled-function 'function) =>  true, true\n      (subtypep 'null 'list) =>  true, true\n      (subtypep 'null 'symbol) =>  true, true\n      (subtypep 'integer 'string) =>  false, true\n      (subtypep '(satisfies dummy) nil) =>  false, implementation-dependent\n      (subtypep '(integer 1 3) '(integer 1 4)) =>  true, true\n      (subtypep '(integer (0) (0)) 'nil) =>  true, true\n      (subtypep 'nil '(integer (0) (0))) =>  true, true\n      (subtypep '(integer (0) (0)) '(member)) =>  true, true ;or false, false\n      (subtypep '(member) 'nil) =>  true, true ;or false, false\n      (subtypep 'nil '(member)) =>  true, true ;or false, false\n\nLet <aet-x> and <aet-y> be two distinct type specifiers that do not always\nrefer to the same sets of objects in a given implementation, but for which\nmake-array, will return an object of the same array type.\n\nThus, in each case,\n\n       (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))\n                 (array-element-type (make-array 0 :element-type '<aet-y>)))\n     =>  true, true\n     \n       (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))\n                 (array-element-type (make-array 0 :element-type '<aet-x>)))\n     =>  true, true\n\nIf  (array <aet-x>) and (array <aet-y>) are different names for exactly\nthe same set of objects, these names should always refer to the same sets\nof objects.  That implies that the following set of tests are also true:\n\n      (subtypep '(array <aet-x>) '(array <aet-y>)) =>  true, true\n      (subtypep '(array <aet-y>) '(array <aet-x>)) =>  true, true\n\nSee Also::\n..........\n\n*Note Types::\n\nNotes::\n.......\n\nThe small differences between the subtypep specification for the array and\ncomplex types are necessary because there is no creation function for\ncomplexes which allows the specification of the resultant part type\nindependently of the actual types of the parts.  Thus in the case of the\ntype complex, the actual type of the parts is referred to, although a\nnumber can be a member of more than one type.  For example, 17 is of type\n(mod 18) as well as type (mod 256) and type integer; and 2.3f5 is of type\nsingle-float as well as type float.\n\n"
}