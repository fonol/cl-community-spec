{
    "name": "read-char-no-hang",
    "prev": "read-char",
    "next": "terpri",
    "up": "Streams Dictionary",
    "header": {
        "type": "Function",
        "text": "read-char-no-hang"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "read-char-no-hang",
                    "text": " &optional input-stream eof-error-p eof-valuerecursive-p =>  char\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "eof-error-p",
                    "desc": "a generalized boolean.  The default is true."
                },
                {
                    "name": "eof-value",
                    "desc": "an object.  The default is nil."
                },
                {
                    "name": "recursive-p",
                    "desc": "a generalized boolean.  The default is false."
                },
                {
                    "name": "char",
                    "desc": "a character or nil or the eof-value."
                }
            ]
        },
        {
            "type": "Description",
            "text": "read-char-no-hang returns a character from input-stream if such a\ncharacter is available.  If no character is available, read-char-no-hang\nreturns nil.\nIf recursive-p is true, this call is expected to be embedded in a\nhigher-level call to read or a similar function used by the Lisp reader.\nIf an end of file_2 occurs and eof-error-p is false, eof-value is returned.\n"
        },
        {
            "type": "Examples",
            "text": "     ;; This code assumes an implementation in which a newline is not\n     ;; required to terminate input from the console.\n      (defun test-it ()\n        (unread-char (read-char))\n        (list (read-char-no-hang)\n              (read-char-no-hang)\n              (read-char-no-hang)))\n     =>  TEST-IT\n     ;; Implementation A, where a Newline is not required to terminate\n     ;; interactive input on the console.\n      (test-it)\n      |>  |>>a<<|\n     =>  (#\\a NIL NIL)\n     ;; Implementation B, where a Newline is required to terminate\n     ;; interactive input on the console, and where that Newline remains\n     ;; on the input stream.\n      (test-it)\n      |>  |>>a[<--~]<<|\n     =>  (#\\a #\\Newline NIL)\n"
        },
        {
            "type": "Affected By",
            "text": "*standard-input*, *terminal-io*.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If an end of file_2 occurs when eof-error-p is true, an error of type\nend-of-file is signaled .\n"
        },
        {
            "type": "See Also",
            "text": "*Note listen::\n"
        },
        {
            "type": "Notes",
            "text": "read-char-no-hang is exactly like read-char, except that if it would be\nnecessary to wait in order to get a character (as from a keyboard), nil is\nimmediately returned without waiting.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: read-char-no-hang,  Next: terpri,  Prev: read-char,  Up: Streams Dictionary\n\nread-char-no-hang                                                [Function]\n---------------------------------------------------------------------------\n\n`read-char-no-hang'  &optional input-stream eof-error-p eof-value\nrecursive-p =>  char\n\nArguments and Values::\n......................\n\ninput-stream - an input stream designator.  The default is standard input.\n\neof-error-p--a generalized boolean.  The default is true.\n\neof-value--an object.  The default is nil.\n\nrecursive-p--a generalized boolean.  The default is false.\n\nchar--a character or nil or the eof-value.\n\nDescription::\n.............\n\nread-char-no-hang returns a character from input-stream if such a\ncharacter is available.  If no character is available, read-char-no-hang\nreturns nil.\n\nIf recursive-p is true, this call is expected to be embedded in a\nhigher-level call to read or a similar function used by the Lisp reader.\n\nIf an end of file_2 occurs and eof-error-p is false, eof-value is returned.\n\nExamples::\n..........\n\n     ;; This code assumes an implementation in which a newline is not\n     ;; required to terminate input from the console.\n      (defun test-it ()\n        (unread-char (read-char))\n        (list (read-char-no-hang)\n              (read-char-no-hang)\n              (read-char-no-hang)))\n     =>  TEST-IT\n     ;; Implementation A, where a Newline is not required to terminate\n     ;; interactive input on the console.\n      (test-it)\n      |>  |>>a<<|\n     =>  (#\\a NIL NIL)\n     ;; Implementation B, where a Newline is required to terminate\n     ;; interactive input on the console, and where that Newline remains\n     ;; on the input stream.\n      (test-it)\n      |>  |>>a[<--~]<<|\n     =>  (#\\a #\\Newline NIL)\n\nAffected By::\n.............\n\n*standard-input*, *terminal-io*.\n\nExceptional Situations::\n........................\n\nIf an end of file_2 occurs when eof-error-p is true, an error of type\nend-of-file is signaled .\n\nSee Also::\n..........\n\n*Note listen::\n\nNotes::\n.......\n\nread-char-no-hang is exactly like read-char, except that if it would be\nnecessary to wait in order to get a character (as from a keyboard), nil is\nimmediately returned without waiting.\n\n"
}