{
    "name": "Macro Characters",
    "prev": "Invalid Characters",
    "next": "Multiple Escape Characters",
    "up": "Character Syntax Types",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Macro Characters",
            "text": "When the Lisp reader encounters a macro character on an input stream,\nspecial parsing of subsequent characters on the input stream is performed.\nA macro character has an associated function called a reader macro function\nthat implements its specialized parsing behavior.  An association of this\nkind can be established or modified under control of a conforming program\nby using the functions set-macro-character and\nset-dispatch-macro-character.\nUpon encountering a macro character, the Lisp reader calls its reader\nmacro function, which parses one specially formatted object from the input\nstream.  The function either returns the parsed object, or else it returns\nno values to indicate that the characters scanned by the function are\nbeing ignored (e.g., in the case of a comment).  Examples of macro\ncharacters are backquote, single-quote, left-parenthesis, and\nright-parenthesis.\nA macro character is either terminating or non-terminating.  The\ndifference between terminating and non-terminating macro characters lies\nin what happens when such characters occur in the middle of a token.  If a\nnon-terminating macro character occurs in the middle of a token, the\nfunction associated with the non-terminating macro character is not called,\nand the non-terminating macro character does not terminate the token's\nname; it becomes part of the name as if the macro character were really a\nconstituent character.  A terminating macro character terminates any token,\nand its associated reader macro function is called no matter where the\ncharacter appears.  The only non-terminating macro character in standard\nsyntax is sharpsign.\nIf a character is a dispatching macro character C_1, its reader macro\nfunction is a function supplied by the implementation.  This function\nreads decimal digit characters until a non-digit C_2 is read.  If any\ndigits were read, they are converted into a corresponding integer infix\nparameter P; otherwise, the infix parameter P is nil.  The terminating\nnon-digit C_2 is a character (sometimes called a \"sub-character\" to\nemphasize its subordinate role in the dispatching) that is looked up in\nthe dispatch table associated with the dispatching macro character C_1.\nThe reader macro function associated with the sub-character C_2 is invoked\nwith three arguments: the stream, the sub-character C_2, and the infix\nparameter P.  For more information about dispatch characters, see the\nfunction set-dispatch-macro-character.\nFor information about the macro characters that are available in standard\nsyntax, see *Note Standard Macro Characters::.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Macro Characters,  Next: Multiple Escape Characters,  Prev: Invalid Characters,  Up: Character Syntax Types\n\nMacro Characters\n................\n\nWhen the Lisp reader encounters a macro character on an input stream,\nspecial parsing of subsequent characters on the input stream is performed.\n\nA macro character has an associated function called a reader macro function\nthat implements its specialized parsing behavior.  An association of this\nkind can be established or modified under control of a conforming program\nby using the functions set-macro-character and\nset-dispatch-macro-character.\n\nUpon encountering a macro character, the Lisp reader calls its reader\nmacro function, which parses one specially formatted object from the input\nstream.  The function either returns the parsed object, or else it returns\nno values to indicate that the characters scanned by the function are\nbeing ignored (e.g., in the case of a comment).  Examples of macro\ncharacters are backquote, single-quote, left-parenthesis, and\nright-parenthesis.\n\nA macro character is either terminating or non-terminating.  The\ndifference between terminating and non-terminating macro characters lies\nin what happens when such characters occur in the middle of a token.  If a\nnon-terminating macro character occurs in the middle of a token, the\nfunction associated with the non-terminating macro character is not called,\nand the non-terminating macro character does not terminate the token's\nname; it becomes part of the name as if the macro character were really a\nconstituent character.  A terminating macro character terminates any token,\nand its associated reader macro function is called no matter where the\ncharacter appears.  The only non-terminating macro character in standard\nsyntax is sharpsign.\n\nIf a character is a dispatching macro character C_1, its reader macro\nfunction is a function supplied by the implementation.  This function\nreads decimal digit characters until a non-digit C_2 is read.  If any\ndigits were read, they are converted into a corresponding integer infix\nparameter P; otherwise, the infix parameter P is nil.  The terminating\nnon-digit C_2 is a character (sometimes called a \"sub-character\" to\nemphasize its subordinate role in the dispatching) that is looked up in\nthe dispatch table associated with the dispatching macro character C_1.\nThe reader macro function associated with the sub-character C_2 is invoked\nwith three arguments: the stream, the sub-character C_2, and the infix\nparameter P.  For more information about dispatch characters, see the\nfunction set-dispatch-macro-character.\n\nFor information about the macro characters that are available in standard\nsyntax, see *Note Standard Macro Characters::.\n\n"
}