{
    "name": "define-method-combination",
    "prev": "compute-applicable-methods",
    "next": "find-method",
    "up": "Objects Dictionary",
    "header": {
        "type": "Macro",
        "text": "define-method-combination"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "define-method-combination",
                    "text": " name [[!short-form-option]]=>  name\n\n"
                },
                {
                    "name": "define-method-combination",
                    "text": " name lambda-list ({method-group-specifier}*)\n[(:arguments . args-lambda-list)] [(:generic-function\ngeneric-function-symbol)] [[{declaration}* | documentation]] {form}*\n=>  name\n\nshort-form-option ::=:documentation documentation | \n                      :identity-with-one-argument identity-with-one-argument |\n                      :operator operator\n\nmethod-group-specifier ::=(name {{qualifier-pattern}^+ | predicate} [[!long-form-option]])\n\nlong-form-option ::=:description description |\n                     :order order |\n                     :required required-p\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "args-lambda-list",
                    "desc": " a define-method-combination arguments lambda list."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "description",
                    "desc": "a format control."
                },
                {
                    "name": "documentation",
                    "desc": "a string; not evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn that must compute and return the form that"
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn that must compute and return the form thatspecifies how the methods are combined, that is, the effective method.\n"
                },
                {
                    "name": "generic-function-symbol",
                    "desc": "a symbol."
                },
                {
                    "name": "identity-with-one-argument",
                    "desc": "a generalized boolean."
                },
                {
                    "name": "lambda-list",
                    "desc": "ordinary lambda list."
                },
                {
                    "name": "name",
                    "desc": "a symbol.  Non-keyword, non-nil symbols are usually used."
                },
                {
                    "name": "operator",
                    "desc": "an operator.  Name and operator are often the same symbol.  This"
                },
                {
                    "name": "operator",
                    "desc": "an operator.  Name and operator are often the same symbol.  Thisis the default, but it is not required.\n"
                },
                {
                    "name": "order",
                    "desc": ":most-specific-first or :most-specific-last; evaluated."
                },
                {
                    "name": "predicate",
                    "desc": "a symbol that names a function of one argument that returns a"
                },
                {
                    "name": "predicate",
                    "desc": "a symbol that names a function of one argument that returns ageneralized boolean.\n"
                },
                {
                    "name": "qualifier-pattern",
                    "desc": "a list, or the symbol *."
                },
                {
                    "name": "required-p",
                    "desc": "a generalized boolean."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The macro define-method-combination is used to define new types of method\ncombination.\nThere are two forms of define-method-combination.  The short form is a\nsimple facility for the cases that are expected to be most commonly\nneeded.  The long form is more powerful but more verbose.  It resembles\ndefmacro in that the body is an expression, usually using backquote, that\ncomputes a form.  Thus arbitrary control structures can be implemented.\nThe long form also allows arbitrary processing of method qualifiers.\nShort Form\n     The short form syntax of define-method-combination is recognized when\n     the second subform is a non-nil symbol or is not present.  When the\n     short form is used, name is defined as a type of method combination\n     that produces a Lisp form (operator method-call method-call ...).\n     The operator is a symbol that can be the name of a function, macro,\n     or special operator.  The operator can be supplied by a keyword\n     option; it defaults to name.\n     Keyword options for the short form are the following:\n    *\n          The :documentation option is used to document the\n          method-combination type; see description of long form below.\n    *\n          The :identity-with-one-argument option enables an optimization\n          when its value is true (the default is false).  If there is\n          exactly one applicable method and it is a primary method, that\n          method serves as the effective method and operator is not called.\n          This optimization avoids the need to create a new effective\n          method and avoids the overhead of a function call.  This option\n          is designed to be used with operators such as progn, and, +, and\n          max.\n    *\n          The :operator option specifies the name of the operator.  The\n          operator argument is a symbol that can be the name of a function,\n          macro, or special form.\n     These types of method combination require exactly one qualifier per\n     method.  An error is signaled if there are applicable methods with no\n     qualifiers or with qualifiers that are not supported by the method\n     combination type.\n     A method combination procedure defined in this way recognizes two\n     roles for methods.  A method whose one qualifier is the symbol naming\n     this type of method combination is defined to be a primary method.  At\n     least one primary method must be applicable or an error is signaled.\n     A method with :around as its one qualifier is an auxiliary method\n     that behaves the same as an around method in standard method\n     combination.  The function call-next-method can only be used in\n     around methods; it cannot be used in primary methods defined by the\n     short form of the define-method-combination macro.\n     A method combination procedure defined in this way accepts an optional\n     argument named order, which defaults to :most-specific-first.  A\n     value of :most-specific-last reverses the order of the primary\n     methods without affecting the order of the auxiliary methods.\n     The short form automatically includes error checking and support for\n     around methods.\n     For a discussion of built-in method combination types, see *Note\n     Built-in Method Combination Types::.\nLong Form\n     The long form syntax of define-method-combination is recognized when\n     the second subform is a list.\n     The lambda-list receives any arguments provided after the name of the\n     method combination type in the :method-combination option to\n     defgeneric.\n     A list of method group specifiers follows.  Each specifier selects a\n     subset of the applicable methods to play a particular role, either by\n     matching their qualifiers against some patterns or by testing their\n     qualifiers with a predicate.  These method group specifiers define\n     all method qualifiers that can be used with this type of method\n     combination.\n     The car of each method-group-specifier is a symbol which names a\n     variable.  During the execution of the forms in the body of\n     define-method-combination, this variable is bound to a list of the\n     methods in the method group.  The methods in this list occur in the\n     order specified by the :order option.\n     If qualifier-pattern is a symbol it must be *.  A method matches a\n     qualifier-pattern if the method's list of qualifiers is equal to the\n     qualifier-pattern (except that the symbol * in a qualifier-pattern\n     matches anything).  Thus a qualifier-pattern can be one of the\n     following: the empty list, which matches unqualified methods; the\n     symbol *, which matches all methods; a true list, which matches\n     methods with the same number of qualifiers as the length of the list\n     when each qualifier matches the corresponding list element; or a\n     dotted list that ends in the symbol * (the * matches any number of\n     additional qualifiers).\n     Each applicable method is tested against the qualifier-patterns and\n     predicates in left-to-right order.  As soon as a qualifier-pattern\n     matches or a predicate returns true, the method becomes a member of\n     the corresponding method group and no further tests are made.  Thus\n     if a method could be a member of more than one method group, it joins\n     only the first such group.  If a method group has more than one\n     qualifier-pattern, a method need only satisfy one of the\n     qualifier-patterns to be a member of the group.\n     The name of a predicate function can appear instead of\n     qualifier-patterns in a method group specifier.  The predicate is\n     called for each method that has not been assigned to an earlier\n     method group; it is called with one argument, the method's qualifier\n     list.  The predicate should return true if the method is to be a\n     member of the method group.  A predicate can be distinguished from a\n     qualifier-pattern because it is a symbol other than nil or *.\n     If there is an applicable method that does not fall into any method\n     group, the function invalid-method-error is called.\n     Method group specifiers can have keyword options following the\n     qualifier patterns or predicate.  Keyword options can be\n     distinguished from additional qualifier patterns because they are\n     neither lists nor the symbol *.  The keyword options are as follows:\n    *\n          The :description option is used to provide a description of the\n          role of methods in the method group.  Programming environment\n          tools use (apply #'format stream format-control\n          (method-qualifiers method)) to print this description, which is\n          expected to be concise.  This keyword option allows the\n          description of a method qualifier to be defined in the same\n          module that defines the meaning of the method qualifier.  In\n          most cases, format-control will not contain any format\n          directives, but they are available for generality.  If\n          :description is not supplied, a default description is generated\n          based on the variable name and the qualifier patterns and on\n          whether this method group includes the unqualified methods.\n    *\n          The :order option specifies the order of methods.  The order\n          argument is a form that evaluates to :most-specific-first or\n          :most-specific-last.  If it evaluates to any other value, an\n          error is signaled.  If :order is not supplied, it defaults to\n          :most-specific-first.\n    *\n          The :required option specifies whether at least one method in\n          this method group is required.  If its value is true and the\n          method group is empty (that is, no applicable methods match the\n          qualifier patterns or satisfy the predicate), an error is\n          signaled.  If :required is not supplied, it defaults to nil.\n     The use of method group specifiers provides a convenient syntax to\n     select methods, to divide them among the possible roles, and to\n     perform the necessary error checking.  It is possible to perform\n     further filtering of methods in the body forms by using normal\n     list-processing operations and the functions method-qualifiers and\n     invalid-method-error.  It is permissible to use setq on the variables\n     named in the method group specifiers and to bind additional\n     variables.  It is also possible to bypass the method group specifier\n     mechanism and do everything in the body forms.  This is accomplished\n     by writing a single method group with * as its only qualifier-pattern;\n     the variable is then bound to a list of all of the applicable\n     methods, in most-specific-first order.\n     The body forms compute and return the form that specifies how the\n     methods are combined, that is, the effective method.  The effective\n     method is evaluated in the null lexical environment augmented with a\n     local macro definition for call-method and with bindings named by\n     symbols not accessible from the COMMON-LISP-USER package.  Given a\n     method object in one of the lists produced by the method group\n     specifiers and a list of next methods, call-method will invoke the\n     method such that call-next-method has available the next methods.\n     When an effective method has no effect other than to call a single\n     method, some implementations employ an optimization that uses the\n     single method directly as the effective method, thus avoiding the need\n     to create a new effective method.  This optimization is active when\n     the effective method form consists entirely of an invocation of the\n     call-method macro whose first subform is a method object and whose\n     second subform is nil or unsupplied.  Each define-method-combination\n     body is responsible for stripping off redundant invocations of progn,\n     and, multiple-value-prog1, and the like, if this optimization is\n     desired.\n     The list (:arguments . lambda-list) can appear before any\n     declarations or documentation string.  This form is useful when the\n     method combination type performs some specific behavior as part of\n     the combined method and that behavior needs access to the arguments to\n     the generic function.  Each parameter variable defined by lambda-list\n     is bound to a form that can be inserted into the effective method.\n     When this form is evaluated during execution of the effective method,\n     its value is the corresponding argument to the generic function; the\n     consequences of using such a form as the place in a setf form are\n     undefined.\n     Argument correspondence is computed by dividing the :arguments\n     lambda-list and the generic function lambda-list into three sections:\n     the required parameters, the optional parameters, and the keyword and\n     rest parameters.  The arguments supplied to the generic function for\n     a particular call are also divided into three sections; the required\n     arguments section contains as many arguments as the generic function\n     has required parameters, the optional arguments section contains as\n     many arguments as the generic function has optional parameters, and\n     the keyword/rest arguments section contains the remaining arguments.\n     Each parameter in the required and optional sections of the\n     :arguments lambda-list accesses the argument at the same position in\n     the corresponding section of the arguments.  If the section of the\n     :arguments lambda-list is shorter, extra arguments are ignored.  If\n     the section of the :arguments lambda-list is longer, excess required\n     parameters are bound to forms that evaluate to nil and excess\n     optional parameters are bound to their initforms.  The keyword\n     parameters and rest parameters in the :arguments lambda-list access\n     the keyword/rest section of the arguments.  If the :arguments\n     lambda-list contains &key, it behaves as if it also contained\n     &allow-other-keys.\n     In addition, &whole var can be placed first in the :arguments\n     lambda-list.  It causes var to be bound to a form that evaluates to a\n     list of all of the arguments supplied to the generic function.  This\n     is different from &rest because it accesses all of the arguments, not\n     just the keyword/rest arguments.\n     Erroneous conditions detected by the body should be reported with\n     method-combination-error or invalid-method-error; these functions add\n     any necessary contextual information to the error message and will\n     signal the appropriate error.\n     The body forms are evaluated inside of the bindings created by the\n     lambda list and method group specifiers.\n     [Reviewer Note by Barmar: Are they inside or outside the :ARGUMENTS\n     bindings?] Declarations at the head of the body are positioned\n     directly inside of bindings created by the lambda list and outside of\n     the bindings of the method group variables.  Thus method group\n     variables cannot be declared in this way.  locally may be used around\n     the body, however.\n     Within the body forms, generic-function-symbol is bound to the\n     generic function object.\n     Documentation is attached as a documentation string to name (as kind\n     method-combination) and to the method combination object.\n     Note that two methods with identical specializers, but with different\n     qualifiers, are not ordered by the algorithm described in Step 2 of\n     the method selection and combination process described in *Note\n     Method Selection and Combination::.  Normally the two methods play\n     different roles in the effective method because they have different\n     qualifiers, and no matter how they are ordered in the result of Step\n     2, the effective method is the same.  If the two methods play the same\n     role and their order matters,\n     [Reviewer Note by Barmar: How does the system know when the order\n     matters?] an error is signaled.  This happens as part of the\n     qualifier pattern matching in define-method-combination.\nIf a define-method-combination form appears as a top level form, the\ncompiler must make the method combination name be recognized as a valid\nmethod combination name in subsequent defgeneric forms.  However, the\nmethod combination is executed no earlier than when the\ndefine-method-combination form is executed, and possibly as late as the\ntime that generic functions that use the method combination are executed.\n"
        },
        {
            "type": "Examples",
            "text": "Most examples of the long form of define-method-combination also\nillustrate the use of the related functions that are provided as part of\nthe declarative method combination facility.\n     ;;; Examples of the short form of define-method-combination\n      (define-method-combination and :identity-with-one-argument t)\n      (defmethod func and ((x class1) y) ...)\n     ;;; The equivalent of this example in the long form is:\n      (define-method-combination and\n              (&optional (order :most-specific-first))\n              ((around (:around))\n               (primary (and) :order order :required t))\n        (let ((form (if (rest primary)\n                        `(and ,@(mapcar #'(lambda (method)\n                                            `(call-method ,method))\n                                        primary))\n                        `(call-method ,(first primary)))))\n          (if around\n              `(call-method ,(first around)\n                            (,@(rest around)\n                             (make-method ,form)))\n              form)))\n     ;;; Examples of the long form of define-method-combination\n     ;The default method-combination technique\n      (define-method-combination standard ()\n              ((around (:around))\n               (before (:before))\n               (primary () :required t)\n               (after (:after)))\n        (flet ((call-methods (methods)\n                 (mapcar #'(lambda (method)\n                             `(call-method ,method))\n                         methods)))\n          (let ((form (if (or before after (rest primary))\n                          `(multiple-value-prog1\n                             (progn ,@(call-methods before)\n                                    (call-method ,(first primary)\n                                                 ,(rest primary)))\n                             ,@(call-methods (reverse after)))\n                          `(call-method ,(first primary)))))\n            (if around\n                `(call-method ,(first around)\n                              (,@(rest around)\n                               (make-method ,form)))\n                form))))\n     ;A simple way to try several methods until one returns non-nil\n      (define-method-combination or ()\n              ((methods (or)))\n        `(or ,@(mapcar #'(lambda (method)\n                           `(call-method ,method))\n                       methods)))\n     ;A more complete version of the preceding\n      (define-method-combination or\n              (&optional (order ':most-specific-first))\n              ((around (:around))\n               (primary (or)))\n        ;; Process the order argument\n        (case order\n          (:most-specific-first)\n          (:most-specific-last (setq primary (reverse primary)))\n          (otherwise (method-combination-error \"~S is an invalid order.~@\n          :most-specific-first and :most-specific-last are the possible values.\"\n                                               order)))\n        ;; Must have a primary method\n        (unless primary\n          (method-combination-error \"A primary method is required.\"))\n        ;; Construct the form that calls the primary methods\n        (let ((form (if (rest primary)\n                        `(or ,@(mapcar #'(lambda (method)\n                                           `(call-method ,method))\n                                       primary))\n                        `(call-method ,(first primary)))))\n          ;; Wrap the around methods around that form\n          (if around\n              `(call-method ,(first around)\n                            (,@(rest around)\n                             (make-method ,form)))\n              form)))\n     ;The same thing, using the :order and :required keyword options\n      (define-method-combination or\n              (&optional (order ':most-specific-first))\n              ((around (:around))\n               (primary (or) :order order :required t))\n        (let ((form (if (rest primary)\n                        `(or ,@(mapcar #'(lambda (method)\n                                           `(call-method ,method))\n                                       primary))\n                        `(call-method ,(first primary)))))\n          (if around\n              `(call-method ,(first around)\n                            (,@(rest around)\n                             (make-method ,form)))\n              form)))\n     ;This short-form call is behaviorally identical to the preceding\n      (define-method-combination or :identity-with-one-argument t)\n     ;Order methods by positive integer qualifiers\n     ;:around methods are disallowed to keep the example small\n      (define-method-combination example-method-combination ()\n              ((methods positive-integer-qualifier-p))\n        `(progn ,@(mapcar #'(lambda (method)\n                              `(call-method ,method))\n                          (stable-sort methods #'<\n                            :key #'(lambda (method)\n                                     (first (method-qualifiers method)))))))\n      (defun positive-integer-qualifier-p (method-qualifiers)\n        (and (= (length method-qualifiers) 1)\n             (typep (first method-qualifiers) '(integer 0 *))))\n     ;;; Example of the use of :arguments\n      (define-method-combination progn-with-lock ()\n              ((methods ()))\n        (:arguments object)\n        `(unwind-protect\n             (progn (lock (object-lock ,object))\n                    ,@(mapcar #'(lambda (method)\n                                  `(call-method ,method))\n                              methods))\n           (unlock (object-lock ,object))))\n"
        },
        {
            "type": "Side Effects",
            "text": "The compiler is not required to perform any compile-time side-effects.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Method combination types defined with the short form require exactly one\nqualifier per method.  An error of type error is signaled if there are\napplicable methods with no qualifiers or with qualifiers that are not\nsupported by the method combination type.  At least one primary method\nmust be applicable or an error of type error is signaled.\nIf an applicable method does not fall into any method group, the system\nsignals an error of type error indicating that the method is invalid for\nthe kind of method combination in use.\nIf the value of the :required option is true and the method group is empty\n(that is, no applicable methods match the qualifier patterns or satisfy\nthe predicate), an error of type error is signaled.\nIf the :order option evaluates to a value other than :most-specific-first\nor :most-specific-last, an error of type error is signaled.\n"
        },
        {
            "type": "See Also",
            "text": "*Note call-method; make-method:: , *Note call-next-method:: , *Note\ndocumentation; (setf documentation):: , *Note method-qualifiers:: , *Note\nmethod-combination-error:: , *Note invalid-method-error:: , *Note\ndefgeneric:: , *Note Method Selection and Combination::, *Note Built-in\nMethod Combination Types::, *Note Syntactic Interaction of Documentation\nStrings and Declarations::\n"
        },
        {
            "type": "Notes",
            "text": "The :method-combination option of defgeneric is used to specify that a\ngeneric function should use a particular method combination type.  The\nfirst argument to the :method-combination option is the name of a method\ncombination type and the remaining arguments are options for that type.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: define-method-combination,  Next: find-method,  Prev: compute-applicable-methods,  Up: Objects Dictionary\n\ndefine-method-combination                                           [Macro]\n---------------------------------------------------------------------------\n\n`define-method-combination'  name [[!short-form-option]]\n=>  name\n\n`define-method-combination'  name lambda-list ({method-group-specifier}*)\n[(:arguments . args-lambda-list)] [(:generic-function\ngeneric-function-symbol)] [[{declaration}* | documentation]] {form}*\n=>  name\n\nshort-form-option ::=:documentation documentation | \n                      :identity-with-one-argument identity-with-one-argument |\n                      :operator operator\n\nmethod-group-specifier ::=(name {{qualifier-pattern}^+ | predicate} [[!long-form-option]])\n\nlong-form-option ::=:description description |\n                     :order order |\n                     :required required-p\n\nArguments and Values::\n......................\n\nargs-lambda-list-- a define-method-combination arguments lambda list.\n\ndeclaration--a declare expression; not evaluated.\n\ndescription--a format control.\n\ndocumentation--a string; not evaluated.\n\nforms--an implicit progn that must compute and return the form that\nspecifies how the methods are combined, that is, the effective method.\n\ngeneric-function-symbol--a symbol.\n\nidentity-with-one-argument--a generalized boolean.\n\nlambda-list--ordinary lambda list.\n\nname--a symbol.  Non-keyword, non-nil symbols are usually used.\n\noperator--an operator.  Name and operator are often the same symbol.  This\nis the default, but it is not required.\n\norder--:most-specific-first or :most-specific-last; evaluated.\n\npredicate--a symbol that names a function of one argument that returns a\ngeneralized boolean.\n\nqualifier-pattern--a list, or the symbol *.\n\nrequired-p--a generalized boolean.\n\nDescription::\n.............\n\nThe macro define-method-combination is used to define new types of method\ncombination.\n\nThere are two forms of define-method-combination.  The short form is a\nsimple facility for the cases that are expected to be most commonly\nneeded.  The long form is more powerful but more verbose.  It resembles\ndefmacro in that the body is an expression, usually using backquote, that\ncomputes a form.  Thus arbitrary control structures can be implemented.\nThe long form also allows arbitrary processing of method qualifiers.\n\nShort Form\n     The short form syntax of define-method-combination is recognized when\n     the second subform is a non-nil symbol or is not present.  When the\n     short form is used, name is defined as a type of method combination\n     that produces a Lisp form (operator method-call method-call ...).\n     The operator is a symbol that can be the name of a function, macro,\n     or special operator.  The operator can be supplied by a keyword\n     option; it defaults to name.\n\n     Keyword options for the short form are the following:\n\n    *\n          The :documentation option is used to document the\n          method-combination type; see description of long form below.\n\n    *\n          The :identity-with-one-argument option enables an optimization\n          when its value is true (the default is false).  If there is\n          exactly one applicable method and it is a primary method, that\n          method serves as the effective method and operator is not called.\n          This optimization avoids the need to create a new effective\n          method and avoids the overhead of a function call.  This option\n          is designed to be used with operators such as progn, and, +, and\n          max.\n\n    *\n          The :operator option specifies the name of the operator.  The\n          operator argument is a symbol that can be the name of a function,\n          macro, or special form.\n\n     These types of method combination require exactly one qualifier per\n     method.  An error is signaled if there are applicable methods with no\n     qualifiers or with qualifiers that are not supported by the method\n     combination type.\n\n     A method combination procedure defined in this way recognizes two\n     roles for methods.  A method whose one qualifier is the symbol naming\n     this type of method combination is defined to be a primary method.  At\n     least one primary method must be applicable or an error is signaled.\n     A method with :around as its one qualifier is an auxiliary method\n     that behaves the same as an around method in standard method\n     combination.  The function call-next-method can only be used in\n     around methods; it cannot be used in primary methods defined by the\n     short form of the define-method-combination macro.\n\n     A method combination procedure defined in this way accepts an optional\n     argument named order, which defaults to :most-specific-first.  A\n     value of :most-specific-last reverses the order of the primary\n     methods without affecting the order of the auxiliary methods.\n\n     The short form automatically includes error checking and support for\n     around methods.\n\n     For a discussion of built-in method combination types, see *Note\n     Built-in Method Combination Types::.\n\nLong Form\n     The long form syntax of define-method-combination is recognized when\n     the second subform is a list.\n\n     The lambda-list receives any arguments provided after the name of the\n     method combination type in the :method-combination option to\n     defgeneric.\n\n     A list of method group specifiers follows.  Each specifier selects a\n     subset of the applicable methods to play a particular role, either by\n     matching their qualifiers against some patterns or by testing their\n     qualifiers with a predicate.  These method group specifiers define\n     all method qualifiers that can be used with this type of method\n     combination.\n\n     The car of each method-group-specifier is a symbol which names a\n     variable.  During the execution of the forms in the body of\n     define-method-combination, this variable is bound to a list of the\n     methods in the method group.  The methods in this list occur in the\n     order specified by the :order option.\n\n     If qualifier-pattern is a symbol it must be *.  A method matches a\n     qualifier-pattern if the method's list of qualifiers is equal to the\n     qualifier-pattern (except that the symbol * in a qualifier-pattern\n     matches anything).  Thus a qualifier-pattern can be one of the\n     following: the empty list, which matches unqualified methods; the\n     symbol *, which matches all methods; a true list, which matches\n     methods with the same number of qualifiers as the length of the list\n     when each qualifier matches the corresponding list element; or a\n     dotted list that ends in the symbol * (the * matches any number of\n     additional qualifiers).\n\n     Each applicable method is tested against the qualifier-patterns and\n     predicates in left-to-right order.  As soon as a qualifier-pattern\n     matches or a predicate returns true, the method becomes a member of\n     the corresponding method group and no further tests are made.  Thus\n     if a method could be a member of more than one method group, it joins\n     only the first such group.  If a method group has more than one\n     qualifier-pattern, a method need only satisfy one of the\n     qualifier-patterns to be a member of the group.\n\n     The name of a predicate function can appear instead of\n     qualifier-patterns in a method group specifier.  The predicate is\n     called for each method that has not been assigned to an earlier\n     method group; it is called with one argument, the method's qualifier\n     list.  The predicate should return true if the method is to be a\n     member of the method group.  A predicate can be distinguished from a\n     qualifier-pattern because it is a symbol other than nil or *.\n\n     If there is an applicable method that does not fall into any method\n     group, the function invalid-method-error is called.\n\n     Method group specifiers can have keyword options following the\n     qualifier patterns or predicate.  Keyword options can be\n     distinguished from additional qualifier patterns because they are\n     neither lists nor the symbol *.  The keyword options are as follows:\n\n    *\n          The :description option is used to provide a description of the\n          role of methods in the method group.  Programming environment\n          tools use (apply #'format stream format-control\n          (method-qualifiers method)) to print this description, which is\n          expected to be concise.  This keyword option allows the\n          description of a method qualifier to be defined in the same\n          module that defines the meaning of the method qualifier.  In\n          most cases, format-control will not contain any format\n          directives, but they are available for generality.  If\n          :description is not supplied, a default description is generated\n          based on the variable name and the qualifier patterns and on\n          whether this method group includes the unqualified methods.\n\n    *\n          The :order option specifies the order of methods.  The order\n          argument is a form that evaluates to :most-specific-first or\n          :most-specific-last.  If it evaluates to any other value, an\n          error is signaled.  If :order is not supplied, it defaults to\n          :most-specific-first.\n\n    *\n          The :required option specifies whether at least one method in\n          this method group is required.  If its value is true and the\n          method group is empty (that is, no applicable methods match the\n          qualifier patterns or satisfy the predicate), an error is\n          signaled.  If :required is not supplied, it defaults to nil.\n\n     The use of method group specifiers provides a convenient syntax to\n     select methods, to divide them among the possible roles, and to\n     perform the necessary error checking.  It is possible to perform\n     further filtering of methods in the body forms by using normal\n     list-processing operations and the functions method-qualifiers and\n     invalid-method-error.  It is permissible to use setq on the variables\n     named in the method group specifiers and to bind additional\n     variables.  It is also possible to bypass the method group specifier\n     mechanism and do everything in the body forms.  This is accomplished\n     by writing a single method group with * as its only qualifier-pattern;\n     the variable is then bound to a list of all of the applicable\n     methods, in most-specific-first order.\n\n     The body forms compute and return the form that specifies how the\n     methods are combined, that is, the effective method.  The effective\n     method is evaluated in the null lexical environment augmented with a\n     local macro definition for call-method and with bindings named by\n     symbols not accessible from the COMMON-LISP-USER package.  Given a\n     method object in one of the lists produced by the method group\n     specifiers and a list of next methods, call-method will invoke the\n     method such that call-next-method has available the next methods.\n\n     When an effective method has no effect other than to call a single\n     method, some implementations employ an optimization that uses the\n     single method directly as the effective method, thus avoiding the need\n     to create a new effective method.  This optimization is active when\n     the effective method form consists entirely of an invocation of the\n     call-method macro whose first subform is a method object and whose\n     second subform is nil or unsupplied.  Each define-method-combination\n     body is responsible for stripping off redundant invocations of progn,\n     and, multiple-value-prog1, and the like, if this optimization is\n     desired.\n\n     The list (:arguments . lambda-list) can appear before any\n     declarations or documentation string.  This form is useful when the\n     method combination type performs some specific behavior as part of\n     the combined method and that behavior needs access to the arguments to\n     the generic function.  Each parameter variable defined by lambda-list\n     is bound to a form that can be inserted into the effective method.\n     When this form is evaluated during execution of the effective method,\n     its value is the corresponding argument to the generic function; the\n     consequences of using such a form as the place in a setf form are\n     undefined.\n\n     Argument correspondence is computed by dividing the :arguments\n     lambda-list and the generic function lambda-list into three sections:\n     the required parameters, the optional parameters, and the keyword and\n     rest parameters.  The arguments supplied to the generic function for\n     a particular call are also divided into three sections; the required\n     arguments section contains as many arguments as the generic function\n     has required parameters, the optional arguments section contains as\n     many arguments as the generic function has optional parameters, and\n     the keyword/rest arguments section contains the remaining arguments.\n     Each parameter in the required and optional sections of the\n     :arguments lambda-list accesses the argument at the same position in\n     the corresponding section of the arguments.  If the section of the\n     :arguments lambda-list is shorter, extra arguments are ignored.  If\n     the section of the :arguments lambda-list is longer, excess required\n     parameters are bound to forms that evaluate to nil and excess\n     optional parameters are bound to their initforms.  The keyword\n     parameters and rest parameters in the :arguments lambda-list access\n     the keyword/rest section of the arguments.  If the :arguments\n     lambda-list contains &key, it behaves as if it also contained\n     &allow-other-keys.\n\n     In addition, &whole var can be placed first in the :arguments\n     lambda-list.  It causes var to be bound to a form that evaluates to a\n     list of all of the arguments supplied to the generic function.  This\n     is different from &rest because it accesses all of the arguments, not\n     just the keyword/rest arguments.\n\n     Erroneous conditions detected by the body should be reported with\n     method-combination-error or invalid-method-error; these functions add\n     any necessary contextual information to the error message and will\n     signal the appropriate error.\n\n     The body forms are evaluated inside of the bindings created by the\n     lambda list and method group specifiers.\n\n     [Reviewer Note by Barmar: Are they inside or outside the :ARGUMENTS\n     bindings?] Declarations at the head of the body are positioned\n     directly inside of bindings created by the lambda list and outside of\n     the bindings of the method group variables.  Thus method group\n     variables cannot be declared in this way.  locally may be used around\n     the body, however.\n\n     Within the body forms, generic-function-symbol is bound to the\n     generic function object.\n\n     Documentation is attached as a documentation string to name (as kind\n     method-combination) and to the method combination object.\n\n     Note that two methods with identical specializers, but with different\n     qualifiers, are not ordered by the algorithm described in Step 2 of\n     the method selection and combination process described in *Note\n     Method Selection and Combination::.  Normally the two methods play\n     different roles in the effective method because they have different\n     qualifiers, and no matter how they are ordered in the result of Step\n     2, the effective method is the same.  If the two methods play the same\n     role and their order matters,\n\n     [Reviewer Note by Barmar: How does the system know when the order\n     matters?] an error is signaled.  This happens as part of the\n     qualifier pattern matching in define-method-combination.\n\nIf a define-method-combination form appears as a top level form, the\ncompiler must make the method combination name be recognized as a valid\nmethod combination name in subsequent defgeneric forms.  However, the\nmethod combination is executed no earlier than when the\ndefine-method-combination form is executed, and possibly as late as the\ntime that generic functions that use the method combination are executed.\n\nExamples::\n..........\n\nMost examples of the long form of define-method-combination also\nillustrate the use of the related functions that are provided as part of\nthe declarative method combination facility.\n\n     ;;; Examples of the short form of define-method-combination\n     \n      (define-method-combination and :identity-with-one-argument t)\n     \n      (defmethod func and ((x class1) y) ...)\n     \n     ;;; The equivalent of this example in the long form is:\n     \n      (define-method-combination and\n              (&optional (order :most-specific-first))\n              ((around (:around))\n               (primary (and) :order order :required t))\n        (let ((form (if (rest primary)\n                        `(and ,@(mapcar #'(lambda (method)\n                                            `(call-method ,method))\n                                        primary))\n                        `(call-method ,(first primary)))))\n          (if around\n              `(call-method ,(first around)\n                            (,@(rest around)\n                             (make-method ,form)))\n              form)))\n     \n     ;;; Examples of the long form of define-method-combination\n     \n     ;The default method-combination technique\n      (define-method-combination standard ()\n              ((around (:around))\n               (before (:before))\n               (primary () :required t)\n               (after (:after)))\n        (flet ((call-methods (methods)\n                 (mapcar #'(lambda (method)\n                             `(call-method ,method))\n                         methods)))\n          (let ((form (if (or before after (rest primary))\n                          `(multiple-value-prog1\n                             (progn ,@(call-methods before)\n                                    (call-method ,(first primary)\n                                                 ,(rest primary)))\n                             ,@(call-methods (reverse after)))\n                          `(call-method ,(first primary)))))\n            (if around\n                `(call-method ,(first around)\n                              (,@(rest around)\n                               (make-method ,form)))\n                form))))\n     \n     ;A simple way to try several methods until one returns non-nil\n      (define-method-combination or ()\n              ((methods (or)))\n        `(or ,@(mapcar #'(lambda (method)\n                           `(call-method ,method))\n                       methods)))\n     \n     ;A more complete version of the preceding\n      (define-method-combination or\n              (&optional (order ':most-specific-first))\n              ((around (:around))\n               (primary (or)))\n        ;; Process the order argument\n        (case order\n          (:most-specific-first)\n          (:most-specific-last (setq primary (reverse primary)))\n          (otherwise (method-combination-error \"~S is an invalid order.~@\n          :most-specific-first and :most-specific-last are the possible values.\"\n                                               order)))\n        ;; Must have a primary method\n        (unless primary\n          (method-combination-error \"A primary method is required.\"))\n        ;; Construct the form that calls the primary methods\n        (let ((form (if (rest primary)\n                        `(or ,@(mapcar #'(lambda (method)\n                                           `(call-method ,method))\n                                       primary))\n                        `(call-method ,(first primary)))))\n          ;; Wrap the around methods around that form\n          (if around\n              `(call-method ,(first around)\n                            (,@(rest around)\n                             (make-method ,form)))\n              form)))\n     \n     ;The same thing, using the :order and :required keyword options\n      (define-method-combination or\n              (&optional (order ':most-specific-first))\n              ((around (:around))\n               (primary (or) :order order :required t))\n        (let ((form (if (rest primary)\n                        `(or ,@(mapcar #'(lambda (method)\n                                           `(call-method ,method))\n                                       primary))\n                        `(call-method ,(first primary)))))\n          (if around\n              `(call-method ,(first around)\n                            (,@(rest around)\n                             (make-method ,form)))\n              form)))\n     \n     ;This short-form call is behaviorally identical to the preceding\n      (define-method-combination or :identity-with-one-argument t)\n     \n     ;Order methods by positive integer qualifiers\n     ;:around methods are disallowed to keep the example small\n      (define-method-combination example-method-combination ()\n              ((methods positive-integer-qualifier-p))\n        `(progn ,@(mapcar #'(lambda (method)\n                              `(call-method ,method))\n                          (stable-sort methods #'<\n                            :key #'(lambda (method)\n                                     (first (method-qualifiers method)))))))\n     \n      (defun positive-integer-qualifier-p (method-qualifiers)\n        (and (= (length method-qualifiers) 1)\n             (typep (first method-qualifiers) '(integer 0 *))))\n     \n     ;;; Example of the use of :arguments\n      (define-method-combination progn-with-lock ()\n              ((methods ()))\n        (:arguments object)\n        `(unwind-protect\n             (progn (lock (object-lock ,object))\n                    ,@(mapcar #'(lambda (method)\n                                  `(call-method ,method))\n                              methods))\n           (unlock (object-lock ,object))))\n\nSide Effects::\n..............\n\nThe compiler is not required to perform any compile-time side-effects.\n\nExceptional Situations::\n........................\n\nMethod combination types defined with the short form require exactly one\nqualifier per method.  An error of type error is signaled if there are\napplicable methods with no qualifiers or with qualifiers that are not\nsupported by the method combination type.  At least one primary method\nmust be applicable or an error of type error is signaled.\n\nIf an applicable method does not fall into any method group, the system\nsignals an error of type error indicating that the method is invalid for\nthe kind of method combination in use.\n\nIf the value of the :required option is true and the method group is empty\n(that is, no applicable methods match the qualifier patterns or satisfy\nthe predicate), an error of type error is signaled.\n\nIf the :order option evaluates to a value other than :most-specific-first\nor :most-specific-last, an error of type error is signaled.\n\nSee Also::\n..........\n\n*Note call-method; make-method:: , *Note call-next-method:: , *Note\ndocumentation; (setf documentation):: , *Note method-qualifiers:: , *Note\nmethod-combination-error:: , *Note invalid-method-error:: , *Note\ndefgeneric:: , *Note Method Selection and Combination::, *Note Built-in\nMethod Combination Types::, *Note Syntactic Interaction of Documentation\nStrings and Declarations::\n\nNotes::\n.......\n\nThe :method-combination option of defgeneric is used to specify that a\ngeneric function should use a particular method combination type.  The\nfirst argument to the :method-combination option is the name of a method\ncombination type and the remaining arguments are options for that type.\n\n"
}