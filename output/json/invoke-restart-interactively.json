{
    "name": "invoke-restart-interactively",
    "prev": "invoke-restart",
    "next": "restart-bind",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Function",
        "text": "invoke-restart-interactively"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "invoke-restart-interactively",
                    "text": " restart =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "restart",
                    "desc": "a restart designator."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the function associated with restart, if"
                }
            ]
        },
        {
            "type": "Description",
            "text": "invoke-restart-interactively calls the function associated with restart,\nprompting for any necessary arguments.  If restart is a name, it must be\nvalid in the current dynamic environment.\ninvoke-restart-interactively prompts for arguments by executing the code\nprovided in the :interactive keyword to restart-case or\n:interactive-function keyword to restart-bind.\nIf no such options have been supplied in the corresponding restart-bind or\nrestart-case, then the consequences are undefined if the restart takes\nrequired arguments.  If the arguments are optional, an argument list of\nnil is used.\nOnce the arguments have been determined, invoke-restart-interactively\nexecutes the following:\n      (apply #'invoke-restart restart arguments)\n"
        },
        {
            "type": "Examples",
            "text": "      (defun add3 (x) (check-type x number) (+ x 3))\n      (add3 'seven)\n      |>  Error: The value SEVEN was not of type NUMBER.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a different value to use.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>(invoke-restart-interactively 'store-value)<<|\n      |>  Type a form to evaluate and use: |>>7<<|\n     =>  10\n"
        },
        {
            "type": "Side Effects",
            "text": "If prompting for arguments is necesary, some typeout may occur (on query\nI/O).\nA non-local transfer of control might be done by the restart.\n"
        },
        {
            "type": "Affected By",
            "text": "*query-io*, active restarts\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If restart is not valid, an error of type control-error is signaled.\n"
        },
        {
            "type": "See Also",
            "text": "*Note find-restart:: , *Note invoke-restart:: , *Note restart-case:: ,\n*Note restart-bind::\n"
        },
        {
            "type": "Notes",
            "text": "invoke-restart-interactively is used internally by the debugger and may\nalso be useful in implementing other portable, interactive debugging tools.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: invoke-restart-interactively,  Next: restart-bind,  Prev: invoke-restart,  Up: Conditions Dictionary\n\ninvoke-restart-interactively                                     [Function]\n---------------------------------------------------------------------------\n\n`invoke-restart-interactively'  restart =>  {result}*\n\nArguments and Values::\n......................\n\nrestart--a restart designator.\n\nresults--the values returned by the function associated with restart, if\nthat function returns.\n\nDescription::\n.............\n\ninvoke-restart-interactively calls the function associated with restart,\nprompting for any necessary arguments.  If restart is a name, it must be\nvalid in the current dynamic environment.\n\ninvoke-restart-interactively prompts for arguments by executing the code\nprovided in the :interactive keyword to restart-case or\n:interactive-function keyword to restart-bind.\n\nIf no such options have been supplied in the corresponding restart-bind or\nrestart-case, then the consequences are undefined if the restart takes\nrequired arguments.  If the arguments are optional, an argument list of\nnil is used.\n\nOnce the arguments have been determined, invoke-restart-interactively\nexecutes the following:\n\n      (apply #'invoke-restart restart arguments)\n\nExamples::\n..........\n\n      (defun add3 (x) (check-type x number) (+ x 3))\n     \n      (add3 'seven)\n      |>  Error: The value SEVEN was not of type NUMBER.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a different value to use.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>(invoke-restart-interactively 'store-value)<<|\n      |>  Type a form to evaluate and use: |>>7<<|\n     =>  10\n\nSide Effects::\n..............\n\nIf prompting for arguments is necesary, some typeout may occur (on query\nI/O).\n\nA non-local transfer of control might be done by the restart.\n\nAffected By::\n.............\n\n*query-io*, active restarts\n\nExceptional Situations::\n........................\n\nIf restart is not valid, an error of type control-error is signaled.\n\nSee Also::\n..........\n\n*Note find-restart:: , *Note invoke-restart:: , *Note restart-case:: ,\n*Note restart-bind::\n\nNotes::\n.......\n\ninvoke-restart-interactively is used internally by the debugger and may\nalso be useful in implementing other portable, interactive debugging tools.\n\n"
}