{
    "name": "Designators",
    "prev": "NIL",
    "next": "Nonsense Words",
    "up": "Notational Conventions",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Designators",
            "text": "A designator is an object that denotes another object.\nWhere a parameter of an operator is described as a designator, the\ndescription of the operator is written in a way that assumes that the\nvalue of the parameter is the denoted object; that is, that the parameter\nis already of the denoted type.  (The specific nature of the object\ndenoted by a \"<<type>> designator\" or a \"designator for a <<type>>\" can be\nfound in the Glossary entry for \"<<type>> designator.\")\nFor example, \"nil\" and \"the value of *standard-output*\" are operationally\nindistinguishable as stream designators.  Similarly, the symbol foo and\nthe string \"FOO\" are operationally indistinguishable as string designators.\nExcept as otherwise noted, in a situation where the denoted object might\nbe used multiple times, it is implementation-dependent whether the object\nis coerced only once or whether the coercion occurs each time the object\nmust be used.\nFor example, mapcar receives a function designator as an argument, and its\ndescription is written as if this were simply a function.  In fact, it is\nimplementation-dependent whether the function designator is coerced right\naway or whether it is carried around internally in the form that it was\ngiven as an argument and re-coerced each time it is needed.  In most\ncases, conforming programs cannot detect the distinction, but there are\nsome pathological situations (particularly those involving self-redefining\nor mutually-redefining functions) which do conform and which can detect\nthis difference.  The following program is a conforming program, but might\nor might not have portably correct results, depending on whether its\ncorrectness depends on one or the other of the results:\n      (defun add-some (x)\n        (defun add-some (x) (+ x 2))\n        (+ x 1)) =>  ADD-SOME\n      (mapcar 'add-some '(1 2 3 4))\n     =>  (2 3 4 5)\n     OR=> (2 4 5 6)\nIn a few rare situations, there may be a need in a dictionary entry to\nrefer to the object that was the original designator for a parameter.\nSince naming the parameter would refer to the denoted object, the phrase\n\"the <<parameter-name>> designator\" can be used to refer to the designator\nwhich was the argument from which the value of <<parameter-name>> was\ncomputed.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Designators,  Next: Nonsense Words,  Prev: NIL,  Up: Notational Conventions\n\nDesignators\n...........\n\nA designator is an object that denotes another object.\n\nWhere a parameter of an operator is described as a designator, the\ndescription of the operator is written in a way that assumes that the\nvalue of the parameter is the denoted object; that is, that the parameter\nis already of the denoted type.  (The specific nature of the object\ndenoted by a \"<<type>> designator\" or a \"designator for a <<type>>\" can be\nfound in the Glossary entry for \"<<type>> designator.\")\n\nFor example, \"nil\" and \"the value of *standard-output*\" are operationally\nindistinguishable as stream designators.  Similarly, the symbol foo and\nthe string \"FOO\" are operationally indistinguishable as string designators.\n\nExcept as otherwise noted, in a situation where the denoted object might\nbe used multiple times, it is implementation-dependent whether the object\nis coerced only once or whether the coercion occurs each time the object\nmust be used.\n\nFor example, mapcar receives a function designator as an argument, and its\ndescription is written as if this were simply a function.  In fact, it is\nimplementation-dependent whether the function designator is coerced right\naway or whether it is carried around internally in the form that it was\ngiven as an argument and re-coerced each time it is needed.  In most\ncases, conforming programs cannot detect the distinction, but there are\nsome pathological situations (particularly those involving self-redefining\nor mutually-redefining functions) which do conform and which can detect\nthis difference.  The following program is a conforming program, but might\nor might not have portably correct results, depending on whether its\ncorrectness depends on one or the other of the results:\n\n      (defun add-some (x)\n        (defun add-some (x) (+ x 2))\n        (+ x 1)) =>  ADD-SOME\n      (mapcar 'add-some '(1 2 3 4))\n     =>  (2 3 4 5)\n     OR=> (2 4 5 6)\n\nIn a few rare situations, there may be a need in a dictionary entry to\nrefer to the object that was the original designator for a parameter.\nSince naming the parameter would refer to the denoted object, the phrase\n\"the <<parameter-name>> designator\" can be used to refer to the designator\nwhich was the argument from which the value of <<parameter-name>> was\ncomputed.\n\n"
}