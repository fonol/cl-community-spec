{
    "name": "apply",
    "prev": "Data and Control Flow Dictionary",
    "next": "defun",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Function",
        "text": "apply"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "apply",
                    "text": " function &rest args^+ =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "function",
                    "desc": "a function designator."
                },
                {
                    "name": "args",
                    "desc": "a spreadable argument list designator."
                },
                {
                    "name": "results",
                    "desc": "the values returned by function."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Applies the function to the args.\nWhen the function receives its arguments via &rest, it is permissible (but\nnot required) for the implementation to bind the rest parameter to an\nobject that shares structure with the last argument to apply.  Because a\nfunction can neither detect whether it was called via apply nor whether\n(if so) the last argument to apply was a constant, conforming programs\nmust neither rely on the list structure of a rest list to be freshly\nconsed, nor modify that list structure.\nsetf can be used with apply in certain circumstances; see *Note APPLY\nForms as Places::.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq f '+) =>  +\n      (apply f '(1 2)) =>  3\n      (setq f #'-) =>  #<FUNCTION ->\n      (apply f '(1 2)) =>  -1\n      (apply #'max 3 5 '(2 7 3)) =>  7\n      (apply 'cons '((+ 2 3) 4)) =>  ((+ 2 3) . 4)\n      (apply #'+ '()) =>  0\n      (defparameter *some-list* '(a b c))\n      (defun strange-test (&rest x) (eq x *some-list*))\n      (apply #'strange-test *some-list*) =>  implementation-dependent\n      (defun bad-boy (&rest x) (rplacd x 'y))\n      (bad-boy 'a 'b 'c) has undefined consequences.\n      (apply #'bad-boy *some-list*) has undefined consequences.\n      (defun foo (size &rest keys &key double &allow-other-keys)\n        (let ((v (apply #'make-array size :allow-other-keys t keys)))\n          (if double (concatenate (type-of v) v v) v)))\n      (foo 4 :initial-contents '(a b c d) :double t)\n         =>  #(A B C D A B C D)\n"
        },
        {
            "type": "See Also",
            "text": "*Note funcall:: , *Note fdefinition:: , function, *Note Evaluation::,\n*Note APPLY Forms as Places::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: apply,  Next: defun,  Prev: Data and Control Flow Dictionary,  Up: Data and Control Flow Dictionary\n\napply                                                            [Function]\n---------------------------------------------------------------------------\n\n`apply'  function &rest args^+ =>  {result}*\n\nArguments and Values::\n......................\n\nfunction--a function designator.\n\nargs--a spreadable argument list designator.\n\nresults--the values returned by function.\n\nDescription::\n.............\n\nApplies the function to the args.\n\nWhen the function receives its arguments via &rest, it is permissible (but\nnot required) for the implementation to bind the rest parameter to an\nobject that shares structure with the last argument to apply.  Because a\nfunction can neither detect whether it was called via apply nor whether\n(if so) the last argument to apply was a constant, conforming programs\nmust neither rely on the list structure of a rest list to be freshly\nconsed, nor modify that list structure.\n\nsetf can be used with apply in certain circumstances; see *Note APPLY\nForms as Places::.\n\nExamples::\n..........\n\n      (setq f '+) =>  +\n      (apply f '(1 2)) =>  3\n      (setq f #'-) =>  #<FUNCTION ->\n      (apply f '(1 2)) =>  -1\n      (apply #'max 3 5 '(2 7 3)) =>  7\n      (apply 'cons '((+ 2 3) 4)) =>  ((+ 2 3) . 4)\n      (apply #'+ '()) =>  0\n     \n      (defparameter *some-list* '(a b c))\n      (defun strange-test (&rest x) (eq x *some-list*))\n      (apply #'strange-test *some-list*) =>  implementation-dependent\n     \n      (defun bad-boy (&rest x) (rplacd x 'y))\n      (bad-boy 'a 'b 'c) has undefined consequences.\n      (apply #'bad-boy *some-list*) has undefined consequences.\n\n      (defun foo (size &rest keys &key double &allow-other-keys)\n        (let ((v (apply #'make-array size :allow-other-keys t keys)))\n          (if double (concatenate (type-of v) v v) v)))\n      (foo 4 :initial-contents '(a b c d) :double t)\n         =>  #(A B C D A B C D)\n\nSee Also::\n..........\n\n*Note funcall:: , *Note fdefinition:: , function, *Note Evaluation::,\n*Note APPLY Forms as Places::\n\n"
}