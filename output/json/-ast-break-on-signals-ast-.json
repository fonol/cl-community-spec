{
    "name": "*break-on-signals*",
    "prev": "*debugger-hook*",
    "next": "handler-bind",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Variable",
        "text": "*break-on-signals*"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Value Type",
            "text": "a type specifier.\n"
        },
        {
            "type": "Initial Value",
            "text": "nil.\n"
        },
        {
            "type": "Description",
            "text": "When (typep condition *break-on-signals*) returns true, calls to signal,\nand to other operators such as error that implicitly call signal, enter\nthe debugger prior to signaling the condition.\nThe continue restart can be used to continue with the normal signaling\nprocess when a break occurs process due to *break-on-signals*.\n"
        },
        {
            "type": "Examples",
            "text": "      *break-on-signals* =>  NIL\n      (ignore-errors (error 'simple-error :format-control \"Fooey!\"))\n     =>  NIL, #<SIMPLE-ERROR 32207172>\n      (let ((*break-on-signals* 'error))\n        (ignore-errors (error 'simple-error :format-control \"Fooey!\")))\n      |>  Break: Fooey!\n      |>  BREAK entered because of *BREAK-ON-SIGNALS*.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Continue to signal.\n      |>   2: Top level.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Continue to signal.\n     =>  NIL, #<SIMPLE-ERROR 32212257>\n      (let ((*break-on-signals* 'error))\n        (error 'simple-error :format-control \"Fooey!\"))\n      |>  Break: Fooey!\n      |>  BREAK entered because of *BREAK-ON-SIGNALS*.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Continue to signal.\n      |>   2: Top level.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Continue to signal.\n      |>  Error: Fooey!\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Top level.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Top level.\n"
        },
        {
            "type": "See Also",
            "text": "*Note break:: , *Note signal:: , *Note warn:: , *Note error:: , *Note\ntypep:: , *Note Condition System Concepts::\n"
        },
        {
            "type": "Notes",
            "text": "*break-on-signals* is intended primarily for use in debugging code that\ndoes signaling.   When setting *break-on-signals*, the user is encouraged\nto choose the most restrictive specification that suffices.  Setting\n*break-on-signals* effectively violates the modular handling of condition\nsignaling.  In practice, the complete effect of setting *break-on-signals*\nmight be unpredictable in some cases since the user might not be aware of\nthe variety or number of calls to signal that are used in code called only\nincidentally.\n*break-on-signals* enables an early entry to the debugger but such an\nentry does not preclude an additional entry to the debugger in the case of\noperations such as error and cerror.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: *break-on-signals*,  Next: handler-bind,  Prev: *debugger-hook*,  Up: Conditions Dictionary\n\n*break-on-signals*                                               [Variable]\n---------------------------------------------------------------------------\n\nValue Type::\n............\n\na type specifier.\n\nInitial Value::\n...............\n\nnil.\n\nDescription::\n.............\n\nWhen (typep condition *break-on-signals*) returns true, calls to signal,\nand to other operators such as error that implicitly call signal, enter\nthe debugger prior to signaling the condition.\n\nThe continue restart can be used to continue with the normal signaling\nprocess when a break occurs process due to *break-on-signals*.\n\nExamples::\n..........\n\n      *break-on-signals* =>  NIL\n      (ignore-errors (error 'simple-error :format-control \"Fooey!\"))\n     =>  NIL, #<SIMPLE-ERROR 32207172>\n     \n      (let ((*break-on-signals* 'error))\n        (ignore-errors (error 'simple-error :format-control \"Fooey!\")))\n      |>  Break: Fooey!\n      |>  BREAK entered because of *BREAK-ON-SIGNALS*.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Continue to signal.\n      |>   2: Top level.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Continue to signal.\n     =>  NIL, #<SIMPLE-ERROR 32212257>\n     \n      (let ((*break-on-signals* 'error))\n        (error 'simple-error :format-control \"Fooey!\"))\n      |>  Break: Fooey!\n      |>  BREAK entered because of *BREAK-ON-SIGNALS*.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Continue to signal.\n      |>   2: Top level.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Continue to signal.\n      |>  Error: Fooey!\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Top level.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Top level.\n\nSee Also::\n..........\n\n*Note break:: , *Note signal:: , *Note warn:: , *Note error:: , *Note\ntypep:: , *Note Condition System Concepts::\n\nNotes::\n.......\n\n*break-on-signals* is intended primarily for use in debugging code that\ndoes signaling.   When setting *break-on-signals*, the user is encouraged\nto choose the most restrictive specification that suffices.  Setting\n*break-on-signals* effectively violates the modular handling of condition\nsignaling.  In practice, the complete effect of setting *break-on-signals*\nmight be unpredictable in some cases since the user might not be aware of\nthe variety or number of calls to signal that are used in code called only\nincidentally.\n\n*break-on-signals* enables an early entry to the debugger but such an\nentry does not preclude an additional entry to the debugger in the case of\noperations such as error and cerror.\n\n"
}