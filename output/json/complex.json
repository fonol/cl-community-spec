{
    "name": "complex",
    "prev": "cis",
    "next": "complexp",
    "up": "Numbers Dictionary",
    "header": {
        "type": "Function",
        "text": "complex"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "complex",
                    "text": " realpart &optional imagpart =>  complex\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "realpart",
                    "desc": "a real."
                },
                {
                    "name": "imagpart",
                    "desc": "a real."
                },
                {
                    "name": "complex",
                    "desc": "a rational or a complex."
                }
            ]
        },
        {
            "type": "Description",
            "text": "complex returns a number whose real      part is realpart and whose\nimaginary part is imagpart.\nIf realpart is a rational and imagpart is the rational number zero, the\nresult of complex is realpart, a rational.  Otherwise, the result is a\ncomplex.\nIf either realpart or imagpart is a float, the non-float is converted to a\nfloat before the complex is created.  If imagpart is not supplied, the\nimaginary part is a zero of the same type as realpart; i.e., (coerce 0\n(type-of realpart)) is effectively used.\nType upgrading implies a movement upwards in the type hierarchy lattice.\nIn the case of complexes, the type-specifier\n[Reviewer Note by Barmar: What type specifier?] must be a subtype of\n(upgraded-complex-part-type type-specifier).  If type-specifier1 is a\nsubtype of type-specifier2, then (upgraded-complex-element-type\n'type-specifier1) must also be a subtype of (upgraded-complex-element-type\n'type-specifier2).  Two disjoint types can be upgraded into the same thing.\n"
        },
        {
            "type": "Examples",
            "text": "      (complex 0) =>  0\n      (complex 0.0) =>  #C(0.0 0.0)\n      (complex 1 1/2) =>  #C(1 1/2)\n      (complex 1 .99) =>  #C(1.0 0.99)\n      (complex 3/2 0.0) =>  #C(1.5 0.0)\n"
        },
        {
            "type": "See Also",
            "text": "*Note realpart; imagpart:: , imagpart\n"
        },
        {
            "type": "Notes",
            "text": "      #c(a b) == #.(complex a b)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: complex,  Next: complexp,  Prev: cis,  Up: Numbers Dictionary\n\ncomplex                                                          [Function]\n---------------------------------------------------------------------------\n\n`complex'  realpart &optional imagpart =>  complex\n\nArguments and Values::\n......................\n\nrealpart--a real.\n\nimagpart--a real.\n\ncomplex--a rational or a complex.\n\nDescription::\n.............\n\ncomplex returns a number whose real      part is realpart and whose\nimaginary part is imagpart.\n\nIf realpart is a rational and imagpart is the rational number zero, the\nresult of complex is realpart, a rational.  Otherwise, the result is a\ncomplex.\n\nIf either realpart or imagpart is a float, the non-float is converted to a\nfloat before the complex is created.  If imagpart is not supplied, the\nimaginary part is a zero of the same type as realpart; i.e., (coerce 0\n(type-of realpart)) is effectively used.\n\nType upgrading implies a movement upwards in the type hierarchy lattice.\nIn the case of complexes, the type-specifier\n\n[Reviewer Note by Barmar: What type specifier?] must be a subtype of\n(upgraded-complex-part-type type-specifier).  If type-specifier1 is a\nsubtype of type-specifier2, then (upgraded-complex-element-type\n'type-specifier1) must also be a subtype of (upgraded-complex-element-type\n'type-specifier2).  Two disjoint types can be upgraded into the same thing.\n\nExamples::\n..........\n\n      (complex 0) =>  0\n      (complex 0.0) =>  #C(0.0 0.0)\n      (complex 1 1/2) =>  #C(1 1/2)\n      (complex 1 .99) =>  #C(1.0 0.99)\n      (complex 3/2 0.0) =>  #C(1.5 0.0)\n\nSee Also::\n..........\n\n*Note realpart; imagpart:: , imagpart\n\nNotes::\n.......\n\n      #c(a b) == #.(complex a b)\n\n"
}