{
    "name": "function (System Class)",
    "prev": "boolean",
    "next": "compiled-function",
    "up": "Types and Classes Dictionary",
    "header": {
        "type": "System Class",
        "text": "function"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Class Precedence List",
            "text": "",
            "items": [
                {
                    "name": "function",
                    "link": null
                },
                {
                    "name": " t",
                    "link": null
                }
            ]
        },
        {
            "type": "Description",
            "text": "A function is an object that represents code to be executed when an\nappropriate number of arguments is supplied.  A function is produced by\nthe function special form, the function coerce,\nor the function compile.  A function can be directly invoked by using it\nas the first argument to funcall, apply, or multiple-value-call.\n"
        },
        {
            "type": "Compound Type Specifier Kind",
            "text": "Specializing.\n"
        },
        {
            "type": "Compound Type Specifier Syntax",
            "text": "(`function'{[arg-typespec [value-typespec]]})\narg-typespec ::=({typespec}*                    [&optional {typespec}*] \n                  [&rest typespec] \n                  [&key {(keyword typespec)}*])\n"
        },
        {
            "type": "Compound Type Specifier Arguments",
            "text": "typespec--a type specifier.\nvalue-typespec--a type specifier.\n"
        },
        {
            "type": "Compound Type Specifier Description",
            "text": "[Editorial Note by KMP: Isn't there some context info about ftype\ndeclarations to be merged here?]\n[Editorial Note by KMP: This could still use some cleaning up.]\n[Editorial Note by Sandra: Still need clarification about what happens if\nthe number of arguments doesn't match the FUNCTION type declaration.]\nThe list form of the function type-specifier can be used only for\ndeclaration and not for discrimination.  Every element of this type is a\nfunction that accepts arguments of the types specified by the  argj-types\nand returns values that are members of the types specified by value-type.\nThe &optional, &rest, &key,\nand &allow-other-keys\nmarkers can appear in the list of argument types.\nThe type specifier provided with &rest is the type of each actual\nargument, not the type of the corresponding variable.\nThe &key parameters should be supplied as lists of the form (keyword type).\nThe keyword must be a valid keyword-name symbol as must be supplied in the\nactual arguments of a call.\nThis is usually a symbol in the KEYWORD package but can be any symbol.\nWhen &key is given in a function type specifier lambda list, the keyword\nparameters given are exhaustive unless &allow-other-keys is also present.\n&allow-other-keys is an indication that other keyword arguments might\nactually be supplied and, if supplied, can be used.  For example, the type\nof the function make-list could be declared as follows:\n      (function ((integer 0) &key (:initial-element t)) list)\nThe value-type can be a values type specifier in order to indicate the\ntypes of multiple values.\nConsider a declaration of the following form:\n      (ftype (function (arg0-type arg1-type ...) val-type) f))\nAny form (f arg0 arg1 ...) within the scope of that declaration is\nequivalent to the following:\n      (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))\nThat is, the consequences are undefined if any of the arguments are not of\nthe specified types or the result is not of the specified type. In\nparticular, if any argument is not of the correct type, the result is not\nguaranteed to be of the specified type.\nThus, an ftype declaration for a function describes calls to the function,\nnot the actual definition of the function.\nConsider a declaration of the following form:\n      (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)\nThis declaration has the interpretation that, within the scope of the\ndeclaration, the consequences are unspecified if the value of\nfn-valued-variable is called with arguments not of the specified types;\nthe value resulting from a valid call will be of type val-type.\nAs with variable type declarations, nested declarations imply\nintersections of types, as follows:\n*\n     Consider the following two declarations of ftype:\n           (ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))\n     and\n           (ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))\n     If both these declarations are in effect, then within the shared\n     scope of the declarations, calls to f can be treated as if f were\n     declared as follows:\n           (ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)\n                            (and val-type1 val-type2))\n                  f))\n     It is permitted to ignore one or all of the ftype declarations in\n     force.\n*\n     If two (or more) type declarations are in effect for a variable, and\n     they are both function declarations, the declarations combine\n     similarly.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: function (System Class),  Next: compiled-function,  Prev: boolean,  Up: Types and Classes Dictionary\n\nfunction                                                     [System Class]\n---------------------------------------------------------------------------\n\nClass Precedence List::\n.......................\n\nfunction, t\n\nDescription::\n.............\n\nA function is an object that represents code to be executed when an\nappropriate number of arguments is supplied.  A function is produced by\nthe function special form, the function coerce,\n\nor the function compile.  A function can be directly invoked by using it\nas the first argument to funcall, apply, or multiple-value-call.\n\nCompound Type Specifier Kind::\n..............................\n\nSpecializing.\n\nCompound Type Specifier Syntax::\n................................\n\n(`function'{[arg-typespec [value-typespec]]})\n\narg-typespec ::=({typespec}*                    [&optional {typespec}*] \n                  [&rest typespec] \n                  [&key {(keyword typespec)}*])\n\nCompound Type Specifier Arguments::\n...................................\n\ntypespec--a type specifier.\n\nvalue-typespec--a type specifier.\n\nCompound Type Specifier Description::\n.....................................\n\n[Editorial Note by KMP: Isn't there some context info about ftype\ndeclarations to be merged here?]\n\n[Editorial Note by KMP: This could still use some cleaning up.]\n\n[Editorial Note by Sandra: Still need clarification about what happens if\nthe number of arguments doesn't match the FUNCTION type declaration.]\n\nThe list form of the function type-specifier can be used only for\ndeclaration and not for discrimination.  Every element of this type is a\nfunction that accepts arguments of the types specified by the  argj-types\nand returns values that are members of the types specified by value-type.\nThe &optional, &rest, &key,\n\nand &allow-other-keys\n\nmarkers can appear in the list of argument types.\n\nThe type specifier provided with &rest is the type of each actual\nargument, not the type of the corresponding variable.\n\nThe &key parameters should be supplied as lists of the form (keyword type).\nThe keyword must be a valid keyword-name symbol as must be supplied in the\nactual arguments of a call.\n\nThis is usually a symbol in the KEYWORD package but can be any symbol.\n\nWhen &key is given in a function type specifier lambda list, the keyword\nparameters given are exhaustive unless &allow-other-keys is also present.\n&allow-other-keys is an indication that other keyword arguments might\nactually be supplied and, if supplied, can be used.  For example, the type\nof the function make-list could be declared as follows:\n\n      (function ((integer 0) &key (:initial-element t)) list)\n\nThe value-type can be a values type specifier in order to indicate the\ntypes of multiple values.\n\nConsider a declaration of the following form:\n\n      (ftype (function (arg0-type arg1-type ...) val-type) f))\n\nAny form (f arg0 arg1 ...) within the scope of that declaration is\nequivalent to the following:\n\n      (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))\n\nThat is, the consequences are undefined if any of the arguments are not of\nthe specified types or the result is not of the specified type. In\nparticular, if any argument is not of the correct type, the result is not\nguaranteed to be of the specified type.\n\nThus, an ftype declaration for a function describes calls to the function,\nnot the actual definition of the function.\n\nConsider a declaration of the following form:\n\n      (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)\n\nThis declaration has the interpretation that, within the scope of the\ndeclaration, the consequences are unspecified if the value of\nfn-valued-variable is called with arguments not of the specified types;\nthe value resulting from a valid call will be of type val-type.\n\nAs with variable type declarations, nested declarations imply\nintersections of types, as follows:\n*\n     Consider the following two declarations of ftype:\n\n           (ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))\n\n     and\n\n           (ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))\n\n     If both these declarations are in effect, then within the shared\n     scope of the declarations, calls to f can be treated as if f were\n     declared as follows:\n\n           (ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)\n                            (and val-type1 val-type2))\n                  f))\n\n     It is permitted to ignore one or all of the ftype declarations in\n     force.\n\n*\n     If two (or more) type declarations are in effect for a variable, and\n     they are both function declarations, the declarations combine\n     similarly.\n\n"
}