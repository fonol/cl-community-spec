{
    "name": "check-type",
    "prev": "cerror",
    "next": "simple-error",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Macro",
        "text": "check-type"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "check-type",
                    "text": " place typespec [string] =>  nil\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "place",
                    "desc": "a place."
                },
                {
                    "name": "typespec",
                    "desc": "a type specifier."
                },
                {
                    "name": "string",
                    "desc": "a string; evaluated."
                }
            ]
        },
        {
            "type": "Description",
            "text": "check-type signals a correctable error of type type-error if the contents\nof place are not of the type typespec.\ncheck-type can return only if the store-value restart is invoked, either\nexplicitly from a handler or implicitly as one of the options offered by\nthe debugger.  If the store-value restart is invoked, check-type stores\nthe new value that is the argument to the restart invocation (or that is\nprompted for interactively by the debugger) in place and starts over,\nchecking the type of the new value and signaling another error if it is\nstill not of the desired type.\nThe first time place is evaluated, it is evaluated by normal evaluation\nrules.  It is later evaluated as a place if the type check fails and the\nstore-value restart is used; see *Note Evaluation of Subforms to Places::.\nstring should be an English description of the type, starting with an\nindefinite article (\"a\" or \"an\").  If string is not supplied, it is\ncomputed automatically from typespec.  The automatically generated message\nmentions place, its contents, and the desired type.  An implementation may\nchoose to generate a somewhat differently worded error message if it\nrecognizes that place is of a particular form, such as one of the\narguments to the function that called check-type.  string is allowed\nbecause some applications of check-type may require a more specific\ndescription of what is wanted than can be generated automatically from\ntypespec.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq aardvarks '(sam harry fred))\n     =>  (SAM HARRY FRED)\n      (check-type aardvarks (array * (3)))\n      |>  Error: The value of AARDVARKS, (SAM HARRY FRED),\n      |>         is not a 3-long array.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Use Value: |>>#(SAM FRED HARRY)<<|\n     =>  NIL\n      aardvarks\n     =>  #<ARRAY-T-3 13571>\n      (map 'list #'identity aardvarks)\n     =>  (SAM FRED HARRY)\n      (setq aardvark-count 'foo)\n     =>  FOO\n      (check-type aardvark-count (integer 0 *) \"A positive integer\")\n      |>  Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Top level.\n      |>  Debug> |>>:CONTINUE 2<<|\n      (defmacro define-adder (name amount)\n        (check-type name (and symbol (not null)) \"a name for an adder function\")\n        (check-type amount integer)\n        `(defun ,name (x) (+ x ,amount)))\n      (macroexpand '(define-adder add3 3))\n     =>  (defun add3 (x) (+ x 3))\n      (macroexpand '(define-adder 7 7))\n      |>  Error: The value of NAME, 7, is not a name for an adder function.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Top level.\n      |>  Debug> |>>:Continue 1<<|\n      |>  Specify a value to use instead.\n      |>  Type a form to be evaluated and used instead: |>>'ADD7<<|\n     =>  (defun add7 (x) (+ x 7))\n      (macroexpand '(define-adder add5 something))\n      |>  Error: The value of AMOUNT, SOMETHING, is not an integer.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Top level.\n      |>  Debug> |>>:Continue 1<<|\n      |>  Type a form to be evaluated and used instead: |>>5<<|\n     =>  (defun add5 (x) (+ x 5))\nControl is transferred to a handler.\n"
        },
        {
            "type": "Side Effects",
            "text": "The debugger might be entered.\n"
        },
        {
            "type": "Affected By",
            "text": "*break-on-signals*\nThe implementation.\n"
        },
        {
            "type": "See Also",
            "text": "*Note Condition System Concepts::\n"
        },
        {
            "type": "Notes",
            "text": "      (check-type place typespec)\n      == (assert (typep place 'typespec) (place)\n                 'type-error :datum place :expected-type 'typespec)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: check-type,  Next: simple-error,  Prev: cerror,  Up: Conditions Dictionary\n\ncheck-type                                                          [Macro]\n---------------------------------------------------------------------------\n\n`check-type'  place typespec [string] =>  nil\n\nArguments and Values::\n......................\n\nplace--a place.\n\ntypespec--a type specifier.\n\nstring--a string; evaluated.\n\nDescription::\n.............\n\ncheck-type signals a correctable error of type type-error if the contents\nof place are not of the type typespec.\n\ncheck-type can return only if the store-value restart is invoked, either\nexplicitly from a handler or implicitly as one of the options offered by\nthe debugger.  If the store-value restart is invoked, check-type stores\nthe new value that is the argument to the restart invocation (or that is\nprompted for interactively by the debugger) in place and starts over,\nchecking the type of the new value and signaling another error if it is\nstill not of the desired type.\n\nThe first time place is evaluated, it is evaluated by normal evaluation\nrules.  It is later evaluated as a place if the type check fails and the\nstore-value restart is used; see *Note Evaluation of Subforms to Places::.\n\nstring should be an English description of the type, starting with an\nindefinite article (\"a\" or \"an\").  If string is not supplied, it is\ncomputed automatically from typespec.  The automatically generated message\nmentions place, its contents, and the desired type.  An implementation may\nchoose to generate a somewhat differently worded error message if it\nrecognizes that place is of a particular form, such as one of the\narguments to the function that called check-type.  string is allowed\nbecause some applications of check-type may require a more specific\ndescription of what is wanted than can be generated automatically from\ntypespec.\n\nExamples::\n..........\n\n      (setq aardvarks '(sam harry fred))\n     =>  (SAM HARRY FRED)\n      (check-type aardvarks (array * (3)))\n      |>  Error: The value of AARDVARKS, (SAM HARRY FRED),\n      |>         is not a 3-long array.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>:CONTINUE 1<<|\n      |>  Use Value: |>>#(SAM FRED HARRY)<<|\n     =>  NIL\n      aardvarks\n     =>  #<ARRAY-T-3 13571>\n      (map 'list #'identity aardvarks)\n     =>  (SAM FRED HARRY)\n      (setq aardvark-count 'foo)\n     =>  FOO\n      (check-type aardvark-count (integer 0 *) \"A positive integer\")\n      |>  Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Top level.\n      |>  Debug> |>>:CONTINUE 2<<|\n\n      (defmacro define-adder (name amount)\n        (check-type name (and symbol (not null)) \"a name for an adder function\")\n        (check-type amount integer)\n        `(defun ,name (x) (+ x ,amount)))\n     \n      (macroexpand '(define-adder add3 3))\n     =>  (defun add3 (x) (+ x 3))\n     \n      (macroexpand '(define-adder 7 7))\n      |>  Error: The value of NAME, 7, is not a name for an adder function.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Top level.\n      |>  Debug> |>>:Continue 1<<|\n      |>  Specify a value to use instead.\n      |>  Type a form to be evaluated and used instead: |>>'ADD7<<|\n     =>  (defun add7 (x) (+ x 7))\n     \n      (macroexpand '(define-adder add5 something))\n      |>  Error: The value of AMOUNT, SOMETHING, is not an integer.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use instead.\n      |>   2: Top level.\n      |>  Debug> |>>:Continue 1<<|\n      |>  Type a form to be evaluated and used instead: |>>5<<|\n     =>  (defun add5 (x) (+ x 5))\n\nControl is transferred to a handler.\n\nSide Effects::\n..............\n\nThe debugger might be entered.\n\nAffected By::\n.............\n\n*break-on-signals*\n\nThe implementation.\n\nSee Also::\n..........\n\n*Note Condition System Concepts::\n\nNotes::\n.......\n\n      (check-type place typespec)\n      == (assert (typep place 'typespec) (place)\n                 'type-error :datum place :expected-type 'typespec)\n\n"
}