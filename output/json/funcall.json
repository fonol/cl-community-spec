{
    "name": "funcall",
    "prev": "flet",
    "next": "function (Special Operator)",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Function",
        "text": "funcall"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "funcall",
                    "text": " function &rest args =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "function",
                    "desc": "a function designator."
                },
                {
                    "name": "args",
                    "desc": "arguments to the function."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the function."
                }
            ]
        },
        {
            "type": "Description",
            "text": "funcall applies function to args.\nIf function is a symbol, it is coerced to a function as if by finding its\nfunctional value in the global environment.\n"
        },
        {
            "type": "Examples",
            "text": "      (funcall #'+ 1 2 3) =>  6\n      (funcall 'car '(1 2 3)) =>  1\n      (funcall 'position 1 '(1 2 3 2 1) :start 1) =>  4\n      (cons 1 2) =>  (1 . 2)\n      (flet ((cons (x y) `(kons ,x ,y)))\n        (let ((cons (symbol-function '+)))\n          (funcall #'cons\n                   (funcall 'cons 1 2)\n                   (funcall cons 1 2))))\n     =>  (KONS (1 . 2) 3)\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "An error of type undefined-function should be signaled if function is a\nsymbol that does not have a global definition as a function or that has a\nglobal definition as a macro or a special operator.\n"
        },
        {
            "type": "See Also",
            "text": "*Note apply:: , function, *Note Evaluation::\n"
        },
        {
            "type": "Notes",
            "text": "      (funcall function arg1 arg2 ...)\n      == (apply function arg1 arg2 ... nil)\n      == (apply function (list arg1 arg2 ...))\nThe difference between funcall and an ordinary function call is that in\nthe former case the function is obtained by ordinary evaluation of a form,\nand in the latter case it is obtained by the special interpretation of the\nfunction position that normally occurs.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: funcall,  Next: function (Special Operator),  Prev: flet,  Up: Data and Control Flow Dictionary\n\nfuncall                                                          [Function]\n---------------------------------------------------------------------------\n\n`funcall'  function &rest args =>  {result}*\n\nArguments and Values::\n......................\n\nfunction--a function designator.\n\nargs--arguments to the function.\n\nresults--the values returned by the function.\n\nDescription::\n.............\n\nfuncall applies function to args.\n\nIf function is a symbol, it is coerced to a function as if by finding its\nfunctional value in the global environment.\n\nExamples::\n..........\n\n      (funcall #'+ 1 2 3) =>  6\n      (funcall 'car '(1 2 3)) =>  1\n      (funcall 'position 1 '(1 2 3 2 1) :start 1) =>  4\n      (cons 1 2) =>  (1 . 2)\n      (flet ((cons (x y) `(kons ,x ,y)))\n        (let ((cons (symbol-function '+)))\n          (funcall #'cons\n                   (funcall 'cons 1 2)\n                   (funcall cons 1 2))))\n     =>  (KONS (1 . 2) 3)\n\nExceptional Situations::\n........................\n\nAn error of type undefined-function should be signaled if function is a\nsymbol that does not have a global definition as a function or that has a\nglobal definition as a macro or a special operator.\n\nSee Also::\n..........\n\n*Note apply:: , function, *Note Evaluation::\n\nNotes::\n.......\n\n      (funcall function arg1 arg2 ...)\n      == (apply function arg1 arg2 ... nil)\n      == (apply function (list arg1 arg2 ...))\n\nThe difference between funcall and an ordinary function call is that in\nthe former case the function is obtained by ordinary evaluation of a form,\nand in the latter case it is obtained by the special interpretation of the\nfunction position that normally occurs.\n\n"
}