{
    "name": "storage-condition",
    "prev": "parse-error",
    "next": "assert",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Condition Type",
        "text": "storage-condition"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Class Precedence List",
            "text": "",
            "items": [
                {
                    "name": "storage-condition",
                    "link": "storage-condition"
                },
                {
                    "name": " serious-condition",
                    "link": null
                },
                {
                    "name": " condition",
                    "link": null
                },
                {
                    "name": " t",
                    "link": null
                }
            ]
        },
        {
            "type": "Description",
            "text": "The type storage-condition consists of serious conditions that relate to\nproblems with memory management that are potentially due to\nimplementation-dependent limits rather than semantic errors in conforming\nprograms, and that typically warrant entry to the debugger if not handled.\nDepending on the details of the implementation, these might include such\nproblems as stack overflow, memory region overflow, and storage exhausted.\n"
        },
        {
            "type": "Notes",
            "text": "While some Common Lisp operations might signal storage-condition because\nthey are defined to create objects, it is unspecified whether operations\nthat are not defined to create objects create them anyway and so might\nalso signal storage-condition.  Likewise, the evaluator itself might\ncreate objects and so might signal storage-condition.  (The natural\nassumption might be that such object creation is naturally inefficient,\nbut even that is implementation-dependent.) In general, the entire\nquestion of how storage allocation is done is implementation-dependent,\nand so any operation might signal storage-condition at any time.  Because\nsuch a condition is indicative of a limitation of the implementation or of\nthe image rather than an error in a program, objects of type\nstorage-condition are not of type error.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: storage-condition,  Next: assert,  Prev: parse-error,  Up: Conditions Dictionary\n\nstorage-condition                                          [Condition Type]\n---------------------------------------------------------------------------\n\nClass Precedence List::\n.......................\n\nstorage-condition, serious-condition, condition, t\n\nDescription::\n.............\n\nThe type storage-condition consists of serious conditions that relate to\nproblems with memory management that are potentially due to\nimplementation-dependent limits rather than semantic errors in conforming\nprograms, and that typically warrant entry to the debugger if not handled.\nDepending on the details of the implementation, these might include such\nproblems as stack overflow, memory region overflow, and storage exhausted.\n\nNotes::\n.......\n\nWhile some Common Lisp operations might signal storage-condition because\nthey are defined to create objects, it is unspecified whether operations\nthat are not defined to create objects create them anyway and so might\nalso signal storage-condition.  Likewise, the evaluator itself might\ncreate objects and so might signal storage-condition.  (The natural\nassumption might be that such object creation is naturally inefficient,\nbut even that is implementation-dependent.) In general, the entire\nquestion of how storage allocation is done is implementation-dependent,\nand so any operation might signal storage-condition at any time.  Because\nsuch a condition is indicative of a limitation of the implementation or of\nthe image rather than an error in a program, objects of type\nstorage-condition are not of type error.\n\n"
}