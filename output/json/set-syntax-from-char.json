{
    "name": "set-syntax-from-char",
    "prev": "set-macro-character",
    "next": "with-standard-io-syntax",
    "up": "Reader Dictionary",
    "header": {
        "type": "Function",
        "text": "set-syntax-from-char"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "set-syntax-from-char",
                    "text": " to-char from-char &optional to-readtablefrom-readtable =>  t\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "to-char",
                    "desc": "a character."
                },
                {
                    "name": "from-char",
                    "desc": "a character."
                },
                {
                    "name": "to-readtable",
                    "desc": "a readtable.  The default is the current readtable."
                },
                {
                    "name": "from-readtable",
                    "desc": "a readtable designator.  The default is the standard"
                }
            ]
        },
        {
            "type": "Description",
            "text": "set-syntax-from-char makes the syntax of to-char   in to-readtable    be\nthe same as the syntax of from-char in from-readtable.\nset-syntax-from-char copies the syntax types of from-char.  If from-char\nis a macro character, its reader macro function is copied also.  If the\ncharacter is a dispatching macro character, its entire dispatch table of\nreader macro functions is copied.  The constituent traits of from-char are\nnot copied.\nA macro definition from a character such as \" can be copied to another\ncharacter; the standard definition for \" looks for another character that\nis the same as the character that invoked it.  The definition of ( can not\nbe meaningfully copied to {, on the other hand.  The result is that lists\nare of the form {a b c), not {a b c}, because the definition always looks\nfor a closing parenthesis, not a closing brace.\n"
        },
        {
            "type": "Examples",
            "text": "      (set-syntax-from-char #\\7 #\\;) =>  T\n      123579 =>  1235\n"
        },
        {
            "type": "Side Effects",
            "text": "The to-readtable is modified.\n"
        },
        {
            "type": "Affected By",
            "text": "The existing values in the from-readtable.\n"
        },
        {
            "type": "See Also",
            "text": "*Note set-macro-character; get-macro-character:: , *Note\nmake-dispatch-macro-character:: , *Note Character Syntax Types::\n"
        },
        {
            "type": "Notes",
            "text": "The constituent traits of a character are \"hard wired\" into the parser for\nextended tokens.  For example, if the definition of S is copied to *, then\n* will become a constituent that is alphabetic_2 but that cannot be used\nas a short float exponent marker.  For further information, see *Note\nConstituent Traits::.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: set-syntax-from-char,  Next: with-standard-io-syntax,  Prev: set-macro-character,  Up: Reader Dictionary\n\nset-syntax-from-char                                             [Function]\n---------------------------------------------------------------------------\n\n`set-syntax-from-char'  to-char from-char &optional to-readtable\nfrom-readtable =>  t\n\nArguments and Values::\n......................\n\nto-char--a character.\n\nfrom-char--a character.\n\nto-readtable--a readtable.  The default is the current readtable.\n\nfrom-readtable--a readtable designator.  The default is the standard\nreadtable.\n\nDescription::\n.............\n\nset-syntax-from-char makes the syntax of to-char   in to-readtable    be\nthe same as the syntax of from-char in from-readtable.\n\nset-syntax-from-char copies the syntax types of from-char.  If from-char\nis a macro character, its reader macro function is copied also.  If the\ncharacter is a dispatching macro character, its entire dispatch table of\nreader macro functions is copied.  The constituent traits of from-char are\nnot copied.\n\nA macro definition from a character such as \" can be copied to another\ncharacter; the standard definition for \" looks for another character that\nis the same as the character that invoked it.  The definition of ( can not\nbe meaningfully copied to {, on the other hand.  The result is that lists\nare of the form {a b c), not {a b c}, because the definition always looks\nfor a closing parenthesis, not a closing brace.\n\nExamples::\n..........\n\n      (set-syntax-from-char #\\7 #\\;) =>  T\n      123579 =>  1235\n\nSide Effects::\n..............\n\nThe to-readtable is modified.\n\nAffected By::\n.............\n\nThe existing values in the from-readtable.\n\nSee Also::\n..........\n\n*Note set-macro-character; get-macro-character:: , *Note\nmake-dispatch-macro-character:: , *Note Character Syntax Types::\n\nNotes::\n.......\n\nThe constituent traits of a character are \"hard wired\" into the parser for\nextended tokens.  For example, if the definition of S is copied to *, then\n* will become a constituent that is alphabetic_2 but that cannot be used\nas a short float exponent marker.  For further information, see *Note\nConstituent Traits::.\n\n"
}