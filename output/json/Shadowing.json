{
    "name": "Shadowing",
    "prev": "Closures and Lexical Binding",
    "next": "Extent",
    "up": "Evaluation",
    "header": {
        "type": null,
        "text": "Shadowing"
    },
    "sections": [
        {
            "type": "",
            "text": "If two forms that establish lexical bindings with the same name N are\ntextually nested, then references to N within the inner form refer to the\nbinding established by the inner form; the inner binding for N shadows the\nouter binding for N.  Outside the inner form but inside the outer one,\nreferences to N refer to the binding established by the outer form.  For\nexample:\n      (defun test (x z)\n        (let ((z (* x 2)))\n          (print z))\n        z)\nThe binding of the variable z by let shadows the parameter binding for the\nfunction test.  The reference to the variable z in the print form refers\nto the let binding.  The reference to z at the end of the function test\nrefers to the parameter named z.\nConstructs that are lexically scoped act as if new names were generated\nfor each object on each execution.  Therefore, dynamic shadowing cannot\noccur.  For example:\n      (defun contorted-example (f g x)\n        (if (= x 0)\n            (funcall f)\n            (block here\n               (+ 5 (contorted-example g\n                                       #'(lambda () (return-from here 4))\n                                       (- x 1))))))\nConsider the call (contorted-example nil nil 2).  This produces 4.  During\nthe course of execution, there are three calls to contorted-example,\ninterleaved with two blocks:\n      (contorted-example nil nil 2)\n        (block here_1 ...)\n          (contorted-example nil #'(lambda () (return-from here_1 4)) 1)\n            (block here_2 ...)\n              (contorted-example #'(lambda () (return-from here_1 4))\n                                 #'(lambda () (return-from here_2 4))\n                                 0)\n                  (funcall f)\n                         where f =>  #'(lambda () (return-from here_1 4))\n                      (return-from here_1 4)\nAt the time the funcall is executed there are two block exit points\noutstanding, each apparently named here.  The return-from form executed as\na result of the funcall operation refers to the outer outstanding exit\npoint (here_1), not the inner one (here_2).  It refers to that exit point\ntextually visible at the point of execution of function (here abbreviated\nby the #' syntax) that resulted in creation of the function object\nactually invoked by funcall.\nIf, in this example, one were to change the (funcall f) to (funcall g),\nthen the value of the call (contorted-example nil nil 2) would be 9.  The\nvalue would change because funcall would cause the execution of\n(return-from here_2 4), thereby causing a return from the inner exit point\n(here_2).  When that occurs, the value 4 is returned from the middle\ninvocation of contorted-example, 5 is added to that to get 9, and that\nvalue is returned from the outer block and the outermost call to\ncontorted-example.  The point is that the choice of exit point returned\nfrom has nothing to do with its being innermost or outermost; rather, it\ndepends on the lexical environment that is packaged up with a lambda\nexpression when function is executed.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Shadowing,  Next: Extent,  Prev: Closures and Lexical Binding,  Up: Evaluation\n\nShadowing\n---------\n\nIf two forms that establish lexical bindings with the same name N are\ntextually nested, then references to N within the inner form refer to the\nbinding established by the inner form; the inner binding for N shadows the\nouter binding for N.  Outside the inner form but inside the outer one,\nreferences to N refer to the binding established by the outer form.  For\nexample:\n\n      (defun test (x z)\n        (let ((z (* x 2)))\n          (print z))\n        z)\n\nThe binding of the variable z by let shadows the parameter binding for the\nfunction test.  The reference to the variable z in the print form refers\nto the let binding.  The reference to z at the end of the function test\nrefers to the parameter named z.\n\nConstructs that are lexically scoped act as if new names were generated\nfor each object on each execution.  Therefore, dynamic shadowing cannot\noccur.  For example:\n\n      (defun contorted-example (f g x)\n        (if (= x 0)\n            (funcall f)\n            (block here\n               (+ 5 (contorted-example g\n                                       #'(lambda () (return-from here 4))\n                                       (- x 1))))))\n\nConsider the call (contorted-example nil nil 2).  This produces 4.  During\nthe course of execution, there are three calls to contorted-example,\ninterleaved with two blocks:\n\n      (contorted-example nil nil 2)\n        (block here_1 ...)\n          (contorted-example nil #'(lambda () (return-from here_1 4)) 1)\n            (block here_2 ...)\n              (contorted-example #'(lambda () (return-from here_1 4))\n                                 #'(lambda () (return-from here_2 4))\n                                 0)\n                  (funcall f)\n                         where f =>  #'(lambda () (return-from here_1 4))\n                      (return-from here_1 4)\n\nAt the time the funcall is executed there are two block exit points\noutstanding, each apparently named here.  The return-from form executed as\na result of the funcall operation refers to the outer outstanding exit\npoint (here_1), not the inner one (here_2).  It refers to that exit point\ntextually visible at the point of execution of function (here abbreviated\nby the #' syntax) that resulted in creation of the function object\nactually invoked by funcall.\n\nIf, in this example, one were to change the (funcall f) to (funcall g),\nthen the value of the call (contorted-example nil nil 2) would be 9.  The\nvalue would change because funcall would cause the execution of\n(return-from here_2 4), thereby causing a return from the inner exit point\n(here_2).  When that occurs, the value 4 is returned from the middle\ninvocation of contorted-example, 5 is added to that to get 9, and that\nvalue is returned from the outer block and the outermost call to\ncontorted-example.  The point is that the choice of exit point returned\nfrom has nothing to do with its being innermost or outermost; rather, it\ndepends on the lexical environment that is packaged up with a lambda\nexpression when function is executed.\n\n"
}