{
    "name": "restart-case",
    "prev": "restart-bind",
    "next": "restart-name",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Macro",
        "text": "restart-case"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "restart-case",
                    "text": " restartable-form {!clause} =>  {result}*\nclause ::=( case-name lambda-list \n            [[:interactive interactive-expression | :report report-expression | :test test-expression]] \n            {declaration}* {form}*)\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "restartable-form",
                    "desc": "a form."
                },
                {
                    "name": "case-name",
                    "desc": "a symbol or nil."
                },
                {
                    "name": "lambda-list",
                    "desc": "an ordinary lambda list."
                },
                {
                    "name": "interactive-expression",
                    "desc": "a symbol or a lambda expression."
                },
                {
                    "name": "report-expression",
                    "desc": "a string, a symbol, or a lambda expression."
                },
                {
                    "name": "test-expression",
                    "desc": "a symbol or a lambda expression."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "form",
                    "desc": "a form."
                },
                {
                    "name": "results",
                    "desc": "the values resulting from the evaluation of restartable-form, or"
                }
            ]
        },
        {
            "type": "Description",
            "text": "restart-case evaluates restartable-form in a dynamic environment where the\nclauses have special meanings as points to which control may be\ntransferred.  If restartable-form finishes executing and returns any\nvalues, all values returned are returned by restart-case and processing\nhas completed. While restartable-form is executing, any code may transfer\ncontrol to one of the clauses (see invoke-restart).  If a transfer occurs,\nthe forms in the body of that clause is evaluated and any values returned\nby the last such form are returned by restart-case.  In this case, the\ndynamic state is unwound appropriately (so that the restarts established\naround the restartable-form are no longer active) prior to execution of the\nclause.\nIf there are no forms in a selected clause, restart-case returns nil.\nIf case-name is a symbol, it names this restart.\nIt is possible to have more than one clause use the same case-name.  In\nthis case, the first clause with that name is found by find-restart.  The\nother clauses are accessible using compute-restarts.\nEach arglist is an ordinary lambda list to be bound during the execution\nof its corresponding forms.  These parameters are used by the restart-case\nclause to receive any necessary data from a call to invoke-restart.\nBy default, invoke-restart-interactively passes no arguments and all\narguments must be optional in order to accomodate interactive restarting.\nHowever, the arguments need not be optional if the :interactive keyword\nhas been used to inform invoke-restart-interactively about how to compute\na proper argument list.\nKeyword options have the following meaning.\n:interactive\n     The value supplied by :interactive value must be a suitable argument\n     to function.  (function value) is evaluated in the current lexical\n     environment.  It should return a function of no arguments which\n     returns arguments to be used by invoke-restart-interactively when it\n     is invoked.  invoke-restart-interactively is called in the dynamic\n     environment available prior to any restart attempt, and uses query\n     I/O for user interaction.\n     If a restart is invoked interactively but no :interactive option was\n     supplied, the argument list used in the invocation is the empty list.\n:report\n     If the value supplied by :report value is a lambda expression or a\n     symbol, it must be acceptable to function.  (function value) is\n     evaluated in the current lexical environment.  It should return a\n     function of one argument, a stream, which prints on the stream a\n     description of the restart.  This function is called whenever the\n     restart is printed while *print-escape* is nil.\n     If value is a string, it is a shorthand for\n           (lambda (stream) (write-string value stream))\n     If a named restart is asked to report but no report information has\n     been supplied, the name of the restart is used in generating default\n     report text.\n     When *print-escape* is nil, the printer uses the report information\n     for a restart.  For example, a debugger might announce the action of\n     typing a \"continue\" command by:\n           (format t \"~&~S -- ~A~\n     which might then display as something like:\n           :CONTINUE -- Return to command level\n     The consequences are unspecified if an unnamed restart is specified\n     but no :report option is provided.\n:test\n     The value supplied by :test value must be a suitable argument to\n     function.  (function value) is evaluated in the current lexical\n     environment.  It should return a function of one argument, the\n     condition, that returns true if the restart is to be considered\n     visible.\n     The default for this option is equivalent to (lambda (c) (declare\n     (ignore c)) t).\nIf the restartable-form is a list whose car is any of the symbols signal,\nerror, cerror, or warn (or is a macro form which macroexpands into such a\nlist), then with-condition-restarts is used implicitly to associate the\nindicated restarts with the condition to be signaled.\n"
        },
        {
            "type": "Examples",
            "text": "      (restart-case\n          (handler-bind ((error #'(lambda (c)\n                                  (declare (ignore condition))\n                                  (invoke-restart 'my-restart 7))))\n            (error \"Foo.\"))\n        (my-restart (&optional v) v))\n     =>  7\n      (define-condition food-error (error) ())\n     =>  FOOD-ERROR\n      (define-condition bad-tasting-sundae (food-error)\n        ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)\n         (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)\n         (topping :initarg :topping :reader bad-tasting-sundae-topping))\n        (:report (lambda (condition stream)\n                   (format stream \"Bad tasting sundae with ~S, ~S, and ~S\"\n                           (bad-tasting-sundae-ice-cream condition)\n                           (bad-tasting-sundae-sauce condition)\n                           (bad-tasting-sundae-topping condition)))))\n     =>  BAD-TASTING-SUNDAE\n      (defun all-start-with-same-letter (symbol1 symbol2 symbol3)\n        (let ((first-letter (char (symbol-name symbol1) 0)))\n          (and (eql first-letter (char (symbol-name symbol2) 0))\n               (eql first-letter (char (symbol-name symbol3) 0)))))\n     =>  ALL-START-WITH-SAME-LETTER\n      (defun read-new-value ()\n        (format t \"Enter a new value: \")\n        (multiple-value-list (eval (read))))\n     =>  READ-NEW-VALUE\n      (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)\n        (do ()\n           ((all-start-with-same-letter ice-cream sauce topping))\n          (restart-case\n            (error 'bad-tasting-sundae\n                   :ice-cream ice-cream\n                   :sauce sauce\n                   :topping topping)\n            (use-new-ice-cream (new-ice-cream)\n              :report \"Use a new ice cream.\"\n              :interactive read-new-value\n              (setq ice-cream new-ice-cream))\n            (use-new-sauce (new-sauce)\n              :report \"Use a new sauce.\"\n              :interactive read-new-value\n              (setq sauce new-sauce))\n            (use-new-topping (new-topping)\n              :report \"Use a new topping.\"\n              :interactive read-new-value\n              (setq topping new-topping))))\n        (values ice-cream sauce topping))\n     =>  VERIFY-OR-FIX-PERFECT-SUNDAE\n      (verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)\n      |>  Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Use a new ice cream.\n      |>   2: Use a new sauce.\n      |>   3: Use a new topping.\n      |>   4: Return to Lisp Toplevel.\n      |>  Debug> |>>:continue 1<<|\n      |>  Use a new ice cream.\n      |>  Enter a new ice cream: |>>'chocolate<<|\n     =>  CHOCOLATE, CARAMEL, CHERRY\n"
        },
        {
            "type": "See Also",
            "text": "*Note restart-bind:: , *Note with-simple-restart:: .\n"
        },
        {
            "type": "Notes",
            "text": "      (restart-case expression\n         (name1 arglist1 ...options1... . body1)\n         (name2 arglist2 ...options2... . body2))\nis essentially equivalent to\n      (block #1=#:g0001\n        (let ((#2=#:g0002 nil))\n             (tagbody\n             (restart-bind ((name1 #'(lambda (&rest temp)\n                                     (setq #2# temp)\n                                     (go #3=#:g0003))\n                               ...slightly-transformed-options1...)\n                            (name2 #'(lambda (&rest temp)\n                                     (setq #2# temp)\n                                     (go #4=#:g0004))\n                               ...slightly-transformed-options2...))\n             (return-from #1# expression))\n               #3# (return-from #1#\n                       (apply #'(lambda arglist1 . body1) #2#))\n               #4# (return-from #1#\n                       (apply #'(lambda arglist2 . body2) #2#)))))\nUnnamed restarts are generally only useful interactively and an\ninteractive option which has no description is of little value.\nImplementations are encouraged to warn if an unnamed restart is used and\nno report information is provided at compilation    time.  At runtime,\nthis error might be noticed when entering the debugger.  Since signaling\nan error would probably cause recursive entry into the debugger (causing\nyet another recursive error, etc.) it is suggested that the debugger print\nsome indication of such problems when they occur but not actually signal\nerrors.\n      (restart-case (signal fred)\n        (a ...)\n        (b ...))\n      ==\n      (restart-case\n          (with-condition-restarts fred\n                                   (list (find-restart 'a)\n                                         (find-restart 'b))\n            (signal fred))\n        (a ...)\n        (b ...))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: restart-case,  Next: restart-name,  Prev: restart-bind,  Up: Conditions Dictionary\n\nrestart-case                                                        [Macro]\n---------------------------------------------------------------------------\n\n`restart-case'  restartable-form {!clause} =>  {result}*\n\nclause ::=( case-name lambda-list \n            [[:interactive interactive-expression | :report report-expression | :test test-expression]] \n            {declaration}* {form}*)\n\nArguments and Values::\n......................\n\nrestartable-form--a form.\n\ncase-name--a symbol or nil.\n\nlambda-list--an ordinary lambda list.\n\ninteractive-expression--a symbol or a lambda expression.\n\nreport-expression--a string, a symbol, or a lambda expression.\n\ntest-expression--a symbol or a lambda expression.\n\ndeclaration--a declare expression; not evaluated.\n\nform--a form.\n\nresults--the values resulting from the evaluation of restartable-form, or\nthe values returned by the last form executed in a chosen clause, or nil.\n\nDescription::\n.............\n\nrestart-case evaluates restartable-form in a dynamic environment where the\nclauses have special meanings as points to which control may be\ntransferred.  If restartable-form finishes executing and returns any\nvalues, all values returned are returned by restart-case and processing\nhas completed. While restartable-form is executing, any code may transfer\ncontrol to one of the clauses (see invoke-restart).  If a transfer occurs,\nthe forms in the body of that clause is evaluated and any values returned\nby the last such form are returned by restart-case.  In this case, the\ndynamic state is unwound appropriately (so that the restarts established\naround the restartable-form are no longer active) prior to execution of the\nclause.\n\nIf there are no forms in a selected clause, restart-case returns nil.\n\nIf case-name is a symbol, it names this restart.\n\nIt is possible to have more than one clause use the same case-name.  In\nthis case, the first clause with that name is found by find-restart.  The\nother clauses are accessible using compute-restarts.\n\nEach arglist is an ordinary lambda list to be bound during the execution\nof its corresponding forms.  These parameters are used by the restart-case\nclause to receive any necessary data from a call to invoke-restart.\n\nBy default, invoke-restart-interactively passes no arguments and all\narguments must be optional in order to accomodate interactive restarting.\nHowever, the arguments need not be optional if the :interactive keyword\nhas been used to inform invoke-restart-interactively about how to compute\na proper argument list.\n\nKeyword options have the following meaning.\n:interactive\n     The value supplied by :interactive value must be a suitable argument\n     to function.  (function value) is evaluated in the current lexical\n     environment.  It should return a function of no arguments which\n     returns arguments to be used by invoke-restart-interactively when it\n     is invoked.  invoke-restart-interactively is called in the dynamic\n     environment available prior to any restart attempt, and uses query\n     I/O for user interaction.\n\n     If a restart is invoked interactively but no :interactive option was\n     supplied, the argument list used in the invocation is the empty list.\n\n:report\n     If the value supplied by :report value is a lambda expression or a\n     symbol, it must be acceptable to function.  (function value) is\n     evaluated in the current lexical environment.  It should return a\n     function of one argument, a stream, which prints on the stream a\n     description of the restart.  This function is called whenever the\n     restart is printed while *print-escape* is nil.\n\n     If value is a string, it is a shorthand for\n\n           (lambda (stream) (write-string value stream))\n\n     If a named restart is asked to report but no report information has\n     been supplied, the name of the restart is used in generating default\n     report text.\n\n     When *print-escape* is nil, the printer uses the report information\n     for a restart.  For example, a debugger might announce the action of\n     typing a \"continue\" command by:\n\n           (format t \"~&~S -- ~A~\n\n     which might then display as something like:\n\n           :CONTINUE -- Return to command level\n\n     The consequences are unspecified if an unnamed restart is specified\n     but no :report option is provided.\n\n:test\n     The value supplied by :test value must be a suitable argument to\n     function.  (function value) is evaluated in the current lexical\n     environment.  It should return a function of one argument, the\n     condition, that returns true if the restart is to be considered\n     visible.\n\n     The default for this option is equivalent to (lambda (c) (declare\n     (ignore c)) t).\n\nIf the restartable-form is a list whose car is any of the symbols signal,\nerror, cerror, or warn (or is a macro form which macroexpands into such a\nlist), then with-condition-restarts is used implicitly to associate the\nindicated restarts with the condition to be signaled.\n\nExamples::\n..........\n\n      (restart-case\n          (handler-bind ((error #'(lambda (c)\n                                  (declare (ignore condition))\n                                  (invoke-restart 'my-restart 7))))\n            (error \"Foo.\"))\n        (my-restart (&optional v) v))\n     =>  7\n     \n      (define-condition food-error (error) ())\n     =>  FOOD-ERROR\n      (define-condition bad-tasting-sundae (food-error)\n        ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)\n         (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)\n         (topping :initarg :topping :reader bad-tasting-sundae-topping))\n        (:report (lambda (condition stream)\n                   (format stream \"Bad tasting sundae with ~S, ~S, and ~S\"\n                           (bad-tasting-sundae-ice-cream condition)\n                           (bad-tasting-sundae-sauce condition)\n                           (bad-tasting-sundae-topping condition)))))\n     =>  BAD-TASTING-SUNDAE\n      (defun all-start-with-same-letter (symbol1 symbol2 symbol3)\n        (let ((first-letter (char (symbol-name symbol1) 0)))\n          (and (eql first-letter (char (symbol-name symbol2) 0))\n               (eql first-letter (char (symbol-name symbol3) 0)))))\n     =>  ALL-START-WITH-SAME-LETTER\n      (defun read-new-value ()\n        (format t \"Enter a new value: \")\n        (multiple-value-list (eval (read))))\n     =>  READ-NEW-VALUE\n      (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)\n        (do ()\n           ((all-start-with-same-letter ice-cream sauce topping))\n          (restart-case\n            (error 'bad-tasting-sundae\n                   :ice-cream ice-cream\n                   :sauce sauce\n                   :topping topping)\n            (use-new-ice-cream (new-ice-cream)\n              :report \"Use a new ice cream.\"\n              :interactive read-new-value\n              (setq ice-cream new-ice-cream))\n            (use-new-sauce (new-sauce)\n              :report \"Use a new sauce.\"\n              :interactive read-new-value\n              (setq sauce new-sauce))\n            (use-new-topping (new-topping)\n              :report \"Use a new topping.\"\n              :interactive read-new-value\n              (setq topping new-topping))))\n        (values ice-cream sauce topping))\n     =>  VERIFY-OR-FIX-PERFECT-SUNDAE\n      (verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)\n      |>  Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Use a new ice cream.\n      |>   2: Use a new sauce.\n      |>   3: Use a new topping.\n      |>   4: Return to Lisp Toplevel.\n      |>  Debug> |>>:continue 1<<|\n      |>  Use a new ice cream.\n      |>  Enter a new ice cream: |>>'chocolate<<|\n     =>  CHOCOLATE, CARAMEL, CHERRY\n\nSee Also::\n..........\n\n*Note restart-bind:: , *Note with-simple-restart:: .\n\nNotes::\n.......\n\n      (restart-case expression\n         (name1 arglist1 ...options1... . body1)\n         (name2 arglist2 ...options2... . body2))\n\nis essentially equivalent to\n\n      (block #1=#:g0001\n        (let ((#2=#:g0002 nil))\n             (tagbody\n             (restart-bind ((name1 #'(lambda (&rest temp)\n                                     (setq #2# temp)\n                                     (go #3=#:g0003))\n                               ...slightly-transformed-options1...)\n                            (name2 #'(lambda (&rest temp)\n                                     (setq #2# temp)\n                                     (go #4=#:g0004))\n                               ...slightly-transformed-options2...))\n             (return-from #1# expression))\n               #3# (return-from #1#\n                       (apply #'(lambda arglist1 . body1) #2#))\n               #4# (return-from #1#\n                       (apply #'(lambda arglist2 . body2) #2#)))))\n\nUnnamed restarts are generally only useful interactively and an\ninteractive option which has no description is of little value.\nImplementations are encouraged to warn if an unnamed restart is used and\nno report information is provided at compilation    time.  At runtime,\nthis error might be noticed when entering the debugger.  Since signaling\nan error would probably cause recursive entry into the debugger (causing\nyet another recursive error, etc.) it is suggested that the debugger print\nsome indication of such problems when they occur but not actually signal\nerrors.\n\n      (restart-case (signal fred)\n        (a ...)\n        (b ...))\n      ==\n      (restart-case\n          (with-condition-restarts fred\n                                   (list (find-restart 'a)\n                                         (find-restart 'b))\n            (signal fred))\n        (a ...)\n        (b ...))\n\n"
}