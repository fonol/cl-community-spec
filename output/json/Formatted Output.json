{
    "name": "Formatted Output",
    "prev": "The Lisp Pretty Printer",
    "next": "Printer Dictionary",
    "up": "Printer",
    "header": {
        "type": null,
        "text": "Formatted Output"
    },
    "sections": [
        {
            "type": "",
            "text": "[Editorial Note by KMP: This is transplanted from FORMAT and will need a\nbit of work before it looks good standing alone. Bear with me.]\nformat is useful for producing nicely formatted text, producing\ngood-looking messages, and so on.  format can generate and return a string\nor output to destination.\nThe control-string argument to format is actually a format control.  That\nis, it can be either a format string or a function, for example a function\nreturned by the formatter macro.\nIf it is a function, the function is called with the appropriate output\nstream as its first argument and the data arguments to format as its\nremaining arguments.  The function should perform whatever output is\nnecessary and return the unused tail of the arguments (if any).\nThe compilation process performed by formatter produces a function that\nwould do with its arguments as the format interpreter would do with those\narguments.\nThe remainder of this section describes what happens if the control-string\nis a format string.\nControl-string is composed of simple text (characters) and embedded\ndirectives.\nformat writes the simple text as is; each embedded directive specifies\nfurther text output that is to appear at the corresponding point within\nthe simple text.  Most directives use one or more elements of args to\ncreate their output.\nA directive consists of a tilde, optional prefix parameters separated by\ncommas, optional colon and at-sign modifiers, and a single character\nindicating what kind of directive this is.\nThere is no required ordering between the at-sign and colon modifier.\nThe case of the directive character is ignored.  Prefix parameters are\nnotated as signed (sign is optional) decimal numbers, or as a single-quote\nfollowed by a character.  For example, ~5,'0d can be used to print an\ninteger in decimal radix in five columns with leading zeros, or ~5,'*d to\nget leading asterisks.\nIn place of a prefix parameter to a directive, V (or v) can be used.  In\nthis case, format takes an argument from args as a parameter to the\ndirective.  The argument should be an integer or character.  If the arg\nused by a V parameter is nil, the effect is as if the parameter had been\nomitted.  # can be used in place of a prefix parameter; it represents the\nnumber of args remaining to be processed.  When used within a recursive\nformat, in the context of ~? or ~{, the # prefix parameter represents the\nnumber of format arguments remaining within the recursive call.\nExamples of format strings:\n  \"~S\"        ;This is an S directive with no parameters or modifiers.  \n  \"~3,-4:@s\"  ;This is an S directive with two parameters, 3 and -4,    \n              ; and both the colon and at-sign flags.                   \n  \"~,+4S\"     ;Here the first prefix parameter is omitted and takes     \n              ; on its default value, while the second parameter is 4.  \n             Figure 22-5: Examples of format control strings           \nformat sends the output to destination.  If destination is nil, format\ncreates and returns a string containing the output from control-string.\nIf destination is non-nil, it must be a string with a fill pointer, a\nstream, or the symbol t.  If destination is a string with a fill pointer,\nthe output is added to the end of the string.  If destination is a stream,\nthe output is sent to that stream.  If destination is t, the output is\nsent to standard output.\nIn the description of the directives that follows, the term arg in general\nrefers to the next item of the set of args to be processed.  The word or\nphrase at the beginning of each description is a mnemonic for the\ndirective.\nformat directives do not bind any of the printer control variables\n(*print-...*) except as specified in the following descriptions.\nImplementations may specify the binding of new, implementation-specific\nprinter control variables for each format directive, but they may neither\nbind any standard printer control variables not specified in description\nof a format directive nor fail to bind any standard printer control\nvariables as specified in the description.\n* Menu:\n* FORMAT Basic Output::\n* FORMAT Radix Control::\n* FORMAT Floating-Point Printers::\n* FORMAT Printer Operations::\n* FORMAT Pretty Printer Operations::\n* FORMAT Layout Control::\n* FORMAT Control-Flow Operations::\n* FORMAT Miscellaneous Operations::\n* FORMAT Miscellaneous Pseudo-Operations::\n* Additional Information about FORMAT Operations::\n* Examples of FORMAT::\n* Notes about FORMAT::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Formatted Output,  Next: Printer Dictionary,  Prev: The Lisp Pretty Printer,  Up: Printer\n\nFormatted Output\n================\n\n[Editorial Note by KMP: This is transplanted from FORMAT and will need a\nbit of work before it looks good standing alone. Bear with me.]\n\nformat is useful for producing nicely formatted text, producing\ngood-looking messages, and so on.  format can generate and return a string\nor output to destination.\n\nThe control-string argument to format is actually a format control.  That\nis, it can be either a format string or a function, for example a function\nreturned by the formatter macro.\n\nIf it is a function, the function is called with the appropriate output\nstream as its first argument and the data arguments to format as its\nremaining arguments.  The function should perform whatever output is\nnecessary and return the unused tail of the arguments (if any).\n\nThe compilation process performed by formatter produces a function that\nwould do with its arguments as the format interpreter would do with those\narguments.\n\nThe remainder of this section describes what happens if the control-string\nis a format string.\n\nControl-string is composed of simple text (characters) and embedded\ndirectives.\n\nformat writes the simple text as is; each embedded directive specifies\nfurther text output that is to appear at the corresponding point within\nthe simple text.  Most directives use one or more elements of args to\ncreate their output.\n\nA directive consists of a tilde, optional prefix parameters separated by\ncommas, optional colon and at-sign modifiers, and a single character\nindicating what kind of directive this is.\n\nThere is no required ordering between the at-sign and colon modifier.\n\nThe case of the directive character is ignored.  Prefix parameters are\nnotated as signed (sign is optional) decimal numbers, or as a single-quote\nfollowed by a character.  For example, ~5,'0d can be used to print an\ninteger in decimal radix in five columns with leading zeros, or ~5,'*d to\nget leading asterisks.\n\nIn place of a prefix parameter to a directive, V (or v) can be used.  In\nthis case, format takes an argument from args as a parameter to the\ndirective.  The argument should be an integer or character.  If the arg\nused by a V parameter is nil, the effect is as if the parameter had been\nomitted.  # can be used in place of a prefix parameter; it represents the\nnumber of args remaining to be processed.  When used within a recursive\nformat, in the context of ~? or ~{, the # prefix parameter represents the\nnumber of format arguments remaining within the recursive call.\n\nExamples of format strings:\n\n  \"~S\"        ;This is an S directive with no parameters or modifiers.  \n  \"~3,-4:@s\"  ;This is an S directive with two parameters, 3 and -4,    \n              ; and both the colon and at-sign flags.                   \n  \"~,+4S\"     ;Here the first prefix parameter is omitted and takes     \n              ; on its default value, while the second parameter is 4.  \n\n             Figure 22-5: Examples of format control strings           \n\n\nformat sends the output to destination.  If destination is nil, format\ncreates and returns a string containing the output from control-string.\nIf destination is non-nil, it must be a string with a fill pointer, a\nstream, or the symbol t.  If destination is a string with a fill pointer,\nthe output is added to the end of the string.  If destination is a stream,\nthe output is sent to that stream.  If destination is t, the output is\nsent to standard output.\n\nIn the description of the directives that follows, the term arg in general\nrefers to the next item of the set of args to be processed.  The word or\nphrase at the beginning of each description is a mnemonic for the\ndirective.\n\nformat directives do not bind any of the printer control variables\n(*print-...*) except as specified in the following descriptions.\nImplementations may specify the binding of new, implementation-specific\nprinter control variables for each format directive, but they may neither\nbind any standard printer control variables not specified in description\nof a format directive nor fail to bind any standard printer control\nvariables as specified in the description.\n\n* Menu:\n\n* FORMAT Basic Output::\n* FORMAT Radix Control::\n* FORMAT Floating-Point Printers::\n* FORMAT Printer Operations::\n* FORMAT Pretty Printer Operations::\n* FORMAT Layout Control::\n* FORMAT Control-Flow Operations::\n* FORMAT Miscellaneous Operations::\n* FORMAT Miscellaneous Pseudo-Operations::\n* Additional Information about FORMAT Operations::\n* Examples of FORMAT::\n* Notes about FORMAT::\n\n"
}