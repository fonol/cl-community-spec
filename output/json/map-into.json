{
    "name": "map-into",
    "prev": "map",
    "next": "reduce",
    "up": "Sequences Dictionary",
    "header": {
        "type": "Function",
        "text": "map-into"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "map-into",
                    "text": " result-sequence function &rest sequences =>  result-sequence\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "result-sequence",
                    "desc": "a proper sequence."
                },
                {
                    "name": "function",
                    "desc": "a designator for a function of as many arguments as there are"
                },
                {
                    "name": "function",
                    "desc": "a designator for a function of as many arguments as there aresequences.\n"
                },
                {
                    "name": "sequence",
                    "desc": "a proper sequence."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Destructively modifies result-sequence to contain the results of applying\nfunction to each element in the argument sequences in turn.\nresult-sequence and each element of sequences can each be either a list or\na vector.  If result-sequence and each element of sequences are not all\nthe same length, the iteration terminates when the shortest sequence (of\nany of the sequences or the result-sequence) is exhausted.  If\nresult-sequence is a vector with a fill pointer, the fill pointer is\nignored when deciding how many iterations to perform, and afterwards the\nfill pointer is set to the number of times function was applied.  If\nresult-sequence is longer than the shortest element of sequences, extra\nelements at the end of result-sequence are left unchanged.  If\nresult-sequence is nil, map-into immediately returns nil, since nil is a\nsequence of length zero.\nIf function has side effects, it can count on being called first on all of\nthe elements with index 0, then on all of those numbered 1, and so on.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq a (list 1 2 3 4) b (list 10 10 10 10)) =>  (10 10 10 10)\n      (map-into a #'+ a b) =>  (11 12 13 14)\n      a =>  (11 12 13 14)\n      b =>  (10 10 10 10)\n      (setq k '(one two three)) =>  (ONE TWO THREE)\n      (map-into a #'cons k a) =>  ((ONE . 11) (TWO . 12) (THREE . 13) 14)\n      (map-into a #'gensym) =>  (#:G9090 #:G9091 #:G9092 #:G9093)\n      a =>  (#:G9090 #:G9091 #:G9092 #:G9093)\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should be prepared to signal an error of type type-error if\nresult-sequence is not a proper sequence.  Should be prepared to signal an\nerror of type type-error if sequence is not a proper sequence.\n"
        },
        {
            "type": "Notes",
            "text": "map-into differs from map in that it modifies an existing sequence rather\nthan creating a new one.  In addition, map-into can be called with only two\narguments, while map requires at least three arguments.\nmap-into could be defined by:\n      (defun map-into (result-sequence function &rest sequences)\n        (loop for index below (apply #'min\n                                     (length result-sequence)\n                                     (mapcar #'length sequences))\n              do (setf (elt result-sequence index)\n                       (apply function\n                              (mapcar #'(lambda (seq) (elt seq index))\n                                      sequences))))\n        result-sequence)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: map-into,  Next: reduce,  Prev: map,  Up: Sequences Dictionary\n\nmap-into                                                         [Function]\n---------------------------------------------------------------------------\n\n`map-into'  result-sequence function &rest sequences =>  result-sequence\n\nArguments and Values::\n......................\n\nresult-sequence--a proper sequence.\n\nfunction--a designator for a function of as many arguments as there are\nsequences.\n\nsequence--a proper sequence.\n\nDescription::\n.............\n\nDestructively modifies result-sequence to contain the results of applying\nfunction to each element in the argument sequences in turn.\n\nresult-sequence and each element of sequences can each be either a list or\na vector.  If result-sequence and each element of sequences are not all\nthe same length, the iteration terminates when the shortest sequence (of\nany of the sequences or the result-sequence) is exhausted.  If\nresult-sequence is a vector with a fill pointer, the fill pointer is\nignored when deciding how many iterations to perform, and afterwards the\nfill pointer is set to the number of times function was applied.  If\nresult-sequence is longer than the shortest element of sequences, extra\nelements at the end of result-sequence are left unchanged.  If\nresult-sequence is nil, map-into immediately returns nil, since nil is a\nsequence of length zero.\n\nIf function has side effects, it can count on being called first on all of\nthe elements with index 0, then on all of those numbered 1, and so on.\n\nExamples::\n..........\n\n      (setq a (list 1 2 3 4) b (list 10 10 10 10)) =>  (10 10 10 10)\n      (map-into a #'+ a b) =>  (11 12 13 14)\n      a =>  (11 12 13 14)\n      b =>  (10 10 10 10)\n      (setq k '(one two three)) =>  (ONE TWO THREE)\n      (map-into a #'cons k a) =>  ((ONE . 11) (TWO . 12) (THREE . 13) 14)\n      (map-into a #'gensym) =>  (#:G9090 #:G9091 #:G9092 #:G9093)\n      a =>  (#:G9090 #:G9091 #:G9092 #:G9093)\n\nExceptional Situations::\n........................\n\nShould be prepared to signal an error of type type-error if\nresult-sequence is not a proper sequence.  Should be prepared to signal an\nerror of type type-error if sequence is not a proper sequence.\n\nNotes::\n.......\n\nmap-into differs from map in that it modifies an existing sequence rather\nthan creating a new one.  In addition, map-into can be called with only two\narguments, while map requires at least three arguments.\n\nmap-into could be defined by:\n\n      (defun map-into (result-sequence function &rest sequences)\n        (loop for index below (apply #'min\n                                     (length result-sequence)\n                                     (mapcar #'length sequences))\n              do (setf (elt result-sequence index)\n                       (apply function\n                              (mapcar #'(lambda (seq) (elt seq index))\n                                      sequences))))\n        result-sequence)\n\n"
}