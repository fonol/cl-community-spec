{
    "name": "When Compiler Macros Are Used",
    "prev": "Naming of Compiler Macros",
    "next": "Notes about the Implementation of Compiler Macros",
    "up": "Compilation Semantics",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "When Compiler Macros Are Used",
            "text": "The presence of a compiler macro definition for a function or macro\nindicates that it is desirable for the compiler to use the expansion of\nthe compiler macro instead of the original function form or macro form.\nHowever, no language processor (compiler, evaluator, or other code walker)\nis ever required to actually invoke compiler macro functions, or to make\nuse of the resulting expansion if it does invoke a compiler macro function.\nWhen the compiler encounters a form during processing that represents a\ncall to a compiler macro name (that is not declared notinline), the\ncompiler might expand the compiler macro, and might use the expansion in\nplace of the original form.\nWhen eval encounters a form during processing that represents a call to a\ncompiler macro name (that is not declared notinline), eval might expand\nthe compiler macro, and might use the expansion in place of the original\nform.\nThere are two situations in which a compiler macro definition must not be\napplied by any language processor:\n*\n     The global function name binding associated with the compiler macro\n     is shadowed by a lexical binding of the function name.\n*\n     The function name has been declared or proclaimed notinline and the\n     call form appears within the scope of the declaration.\nIt is unspecified whether compiler macros are expanded or used in any other\nsituations.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: When Compiler Macros Are Used,  Next: Notes about the Implementation of Compiler Macros,  Prev: Naming of Compiler Macros,  Up: Compilation Semantics\n\nWhen Compiler Macros Are Used\n.............................\n\nThe presence of a compiler macro definition for a function or macro\nindicates that it is desirable for the compiler to use the expansion of\nthe compiler macro instead of the original function form or macro form.\nHowever, no language processor (compiler, evaluator, or other code walker)\nis ever required to actually invoke compiler macro functions, or to make\nuse of the resulting expansion if it does invoke a compiler macro function.\n\nWhen the compiler encounters a form during processing that represents a\ncall to a compiler macro name (that is not declared notinline), the\ncompiler might expand the compiler macro, and might use the expansion in\nplace of the original form.\n\nWhen eval encounters a form during processing that represents a call to a\ncompiler macro name (that is not declared notinline), eval might expand\nthe compiler macro, and might use the expansion in place of the original\nform.\n\nThere are two situations in which a compiler macro definition must not be\napplied by any language processor:\n\n*\n     The global function name binding associated with the compiler macro\n     is shadowed by a lexical binding of the function name.\n\n*\n     The function name has been declared or proclaimed notinline and the\n     call form appears within the scope of the declaration.\n\nIt is unspecified whether compiler macros are expanded or used in any other\nsituations.\n\n"
}