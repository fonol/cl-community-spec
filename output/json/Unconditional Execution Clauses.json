{
    "name": "Unconditional Execution Clauses",
    "prev": "Termination Test Clauses",
    "next": "Conditional Execution Clauses",
    "up": "The LOOP Facility",
    "header": {
        "type": null,
        "text": "Unconditional Execution Clauses"
    },
    "sections": [
        {
            "type": "",
            "text": "The do and doing constructs evaluate the supplied forms wherever they\noccur in the expanded form of loop.  The form argument can be any compound\nform.  Each form is evaluated in every iteration.  Because every loop\nclause must begin with a loop keyword, the keyword do is used when no\ncontrol action other than execution is required.\nThe return construct takes one form.  Any values returned by the form are\nimmediately returned by the loop form.  It is equivalent to the clause do\n(return-from block-name value), where block-name is the name specified in\na named clause, or nil if there is no named clause.\n* Menu:\n* Examples of unconditional execution::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Unconditional Execution Clauses,  Next: Conditional Execution Clauses,  Prev: Termination Test Clauses,  Up: The LOOP Facility\n\nUnconditional Execution Clauses\n-------------------------------\n\nThe do and doing constructs evaluate the supplied forms wherever they\noccur in the expanded form of loop.  The form argument can be any compound\nform.  Each form is evaluated in every iteration.  Because every loop\nclause must begin with a loop keyword, the keyword do is used when no\ncontrol action other than execution is required.\n\nThe return construct takes one form.  Any values returned by the form are\nimmediately returned by the loop form.  It is equivalent to the clause do\n(return-from block-name value), where block-name is the name specified in\na named clause, or nil if there is no named clause.\n\n* Menu:\n\n* Examples of unconditional execution::\n\n"
}