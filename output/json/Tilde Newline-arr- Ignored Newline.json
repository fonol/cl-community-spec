{
    "name": "Tilde Newline-> Ignored Newline",
    "prev": "Tilde Circumflex-> Escape Upward",
    "next": null,
    "up": "FORMAT Miscellaneous Pseudo-Operations",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Tilde Newline: Ignored Newline",
            "text": "Tilde immediately followed by a newline ignores the newline and any\nfollowing non-newline whitespace_1 characters.  With a :, the newline is\nignored, but any following whitespace_1 is left in place.  With an @, the\nnewline is left in place, but any following whitespace_1 is ignored.  For\nexample:\n      (defun type-clash-error (fn nargs argnum right-type wrong-type)\n        (format *error-output*\n                \"~&~S requires its ~:[~:R~;~*~]~\n                argument to be of type ~S,~\n                with an argument of type ~S.~\n                fn (eql nargs 1) argnum right-type wrong-type))\n      (type-clash-error 'aref nil 2 'integer 'vector)  prints:\n     AREF requires its second argument to be of type INTEGER,\n     but it was called with an argument of type VECTOR.\n     NIL\n      (type-clash-error 'car 1 1 'list 'short-float)  prints:\n     CAR requires its argument to be of type LIST,\n     but it was called with an argument of type SHORT-FLOAT.\n     NIL\nNote that in this example newlines appear in the output only as specified\nby the ~& and ~% directives; the actual newline characters in the control\nstring are suppressed because each is preceded by a tilde.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Tilde Newline-> Ignored Newline,  Prev: Tilde Circumflex-> Escape Upward,  Up: FORMAT Miscellaneous Pseudo-Operations\n\nTilde Newline: Ignored Newline\n..............................\n\nTilde immediately followed by a newline ignores the newline and any\nfollowing non-newline whitespace_1 characters.  With a :, the newline is\nignored, but any following whitespace_1 is left in place.  With an @, the\nnewline is left in place, but any following whitespace_1 is ignored.  For\nexample:\n\n      (defun type-clash-error (fn nargs argnum right-type wrong-type)\n        (format *error-output*\n                \"~&~S requires its ~:[~:R~;~*~]~\n                argument to be of type ~S,~\n                with an argument of type ~S.~\n                fn (eql nargs 1) argnum right-type wrong-type))\n      (type-clash-error 'aref nil 2 'integer 'vector)  prints:\n     AREF requires its second argument to be of type INTEGER,\n     but it was called with an argument of type VECTOR.\n     NIL\n      (type-clash-error 'car 1 1 'list 'short-float)  prints:\n     CAR requires its argument to be of type LIST,\n     but it was called with an argument of type SHORT-FLOAT.\n     NIL\n\nNote that in this example newlines appear in the output only as specified\nby the ~& and ~% directives; the actual newline characters in the control\nstring are suppressed because each is preceded by a tilde.\n\n"
}