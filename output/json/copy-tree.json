{
    "name": "copy-tree",
    "prev": "car",
    "next": "sublis",
    "up": "Conses Dictionary",
    "header": {
        "type": "Function",
        "text": "copy-tree"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "copy-tree",
                    "text": " tree =>  new-tree\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "tree",
                    "desc": "a tree."
                },
                {
                    "name": "new-tree",
                    "desc": "a tree."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Creates a copy of a tree of conses.\nIf tree is not a cons, it is returned; otherwise, the result is a new cons\nof the results of calling copy-tree on the car and cdr of tree.  In other\nwords, all conses in the tree represented by tree are copied recursively,\nstopping only when non-conses are encountered.\ncopy-tree does not preserve circularities and the sharing of substructure.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq object (list (cons 1 \"one\")\n                         (cons 2 (list 'a 'b 'c))))\n     =>  ((1 . \"one\") (2 A B C))\n      (setq object-too object) =>  ((1 . \"one\") (2 A B C))\n      (setq copy-as-list (copy-list object))\n      (setq copy-as-alist (copy-alist object))\n      (setq copy-as-tree (copy-tree object))\n      (eq object object-too) =>  true\n      (eq copy-as-tree object) =>  false\n      (eql copy-as-tree object) =>  false\n      (equal copy-as-tree object) =>  true\n      (setf (first (cdr (second object))) \"a\"\n            (car (second object)) \"two\"\n            (car object) '(one . 1)) =>  (ONE . 1)\n      object =>  ((ONE . 1) (\"two\" \"a\" B C))\n      object-too =>  ((ONE . 1) (\"two\" \"a\" B C))\n      copy-as-list =>  ((1 . \"one\") (\"two\" \"a\" B C))\n      copy-as-alist =>  ((1 . \"one\") (2 \"a\" B C))\n      copy-as-tree =>  ((1 . \"one\") (2 A B C))\n"
        },
        {
            "type": "See Also",
            "text": "*Note tree-equal::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: copy-tree,  Next: sublis,  Prev: car,  Up: Conses Dictionary\n\ncopy-tree                                                        [Function]\n---------------------------------------------------------------------------\n\n`copy-tree'  tree =>  new-tree\n\nArguments and Values::\n......................\n\ntree--a tree.\n\nnew-tree--a tree.\n\nDescription::\n.............\n\nCreates a copy of a tree of conses.\n\nIf tree is not a cons, it is returned; otherwise, the result is a new cons\nof the results of calling copy-tree on the car and cdr of tree.  In other\nwords, all conses in the tree represented by tree are copied recursively,\nstopping only when non-conses are encountered.\n\ncopy-tree does not preserve circularities and the sharing of substructure.\n\nExamples::\n..........\n\n      (setq object (list (cons 1 \"one\")\n                         (cons 2 (list 'a 'b 'c))))\n     =>  ((1 . \"one\") (2 A B C))\n      (setq object-too object) =>  ((1 . \"one\") (2 A B C))\n      (setq copy-as-list (copy-list object))\n      (setq copy-as-alist (copy-alist object))\n      (setq copy-as-tree (copy-tree object))\n      (eq object object-too) =>  true\n      (eq copy-as-tree object) =>  false\n      (eql copy-as-tree object) =>  false\n      (equal copy-as-tree object) =>  true\n      (setf (first (cdr (second object))) \"a\"\n            (car (second object)) \"two\"\n            (car object) '(one . 1)) =>  (ONE . 1)\n      object =>  ((ONE . 1) (\"two\" \"a\" B C))\n      object-too =>  ((ONE . 1) (\"two\" \"a\" B C))\n      copy-as-list =>  ((1 . \"one\") (\"two\" \"a\" B C))\n      copy-as-alist =>  ((1 . \"one\") (2 \"a\" B C))\n      copy-as-tree =>  ((1 . \"one\") (2 A B C))\n\nSee Also::\n..........\n\n*Note tree-equal::\n\n"
}