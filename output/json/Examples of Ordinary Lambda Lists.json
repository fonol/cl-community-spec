{
    "name": "Examples of Ordinary Lambda Lists",
    "prev": "Specifiers for @b{&aux} variables",
    "next": null,
    "up": "Ordinary Lambda Lists",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Examples of Ordinary Lambda Lists",
            "text": "Here are some examples involving optional parameters and rest parameters:\n      ((lambda (a b) (+ a (* b 3))) 4 5) =>  19\n      ((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) =>  19\n      ((lambda (a &optional (b 2)) (+ a (* b 3))) 4) =>  10\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))\n     =>  (2 NIL 3 NIL NIL)\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)\n     =>  (6 T 3 NIL NIL)\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)\n     =>  (6 T 3 T NIL)\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)\n     =>  (6 T 3 T (8))\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))\n       6 3 8 9 10 11)\n     =>  (6 t 3 t (8 9 10 11))\nHere are some examples involving keyword parameters:\n      ((lambda (a b &key c d) (list a b c d)) 1 2) =>  (1 2 NIL NIL)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) =>  (1 2 6 NIL)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) =>  (1 2 NIL 8)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) =>  (1 2 6 8)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) =>  (1 2 6 8)\n      ((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) =>  (:a 1 6 8)\n      ((lambda (a b &key c d) (list a b c d)) :a :b :c :d) =>  (:a :b :d NIL)\n      ((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) =>  (1 2 6 NIL)\n      ((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) =>  (1 2 6 NIL)\nHere are some examples involving optional parameters, rest parameters, and\nkeyword parameters together:\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1)\n     =>  (1 3 NIL 1 ())\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 2)\n     =>  (1 2 NIL 1 ())\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) :c 7)\n     =>  (:c 7 NIL :c ())\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 6 :c 7)\n     =>  (1 6 7 1 (:c 7))\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 6 :d 8)\n     =>  (1 6 NIL 8 (:d 8))\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 6 :d 8 :c 9 :d 10)\n     =>  (1 6 9 8 (:d 8 :c 9 :d 10))\nAs an example of the use of &allow-other-keys and :allow-other-keys,\nconsider a function that takes two named arguments of its own and also\naccepts additional named arguments to be passed to make-array:\n      (defun array-of-strings (str dims &rest named-pairs\n                               &key (start 0) end &allow-other-keys)\n        (apply #'make-array dims\n               :initial-element (subseq str start end)\n               :allow-other-keys t\n               named-pairs))\nThis function takes a string and dimensioning information and returns an\narray of the specified dimensions, each of whose elements is the specified\nstring.  However, :start and :end named arguments may be used to specify\nthat a substring of the given string should be used.  In addition, the\npresence of &allow-other-keys in the lambda list indicates that the caller\nmay supply additional named arguments; the rest parameter provides access\nto them.  These additional named arguments are passed to make-array.  The\nfunction make-array normally does not allow the named arguments :start and\n:end to be used, and an error should be signaled if such named arguments\nare supplied to make-array.  However, the presence in the call to\nmake-array of the named argument :allow-other-keys with a true value\ncauses any extraneous named arguments, including :start and :end, to be\nacceptable and ignored.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Examples of Ordinary Lambda Lists,  Prev: Specifiers for @b{&aux} variables,  Up: Ordinary Lambda Lists\n\nExamples of Ordinary Lambda Lists\n.................................\n\nHere are some examples involving optional parameters and rest parameters:\n\n      ((lambda (a b) (+ a (* b 3))) 4 5) =>  19\n      ((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) =>  19\n      ((lambda (a &optional (b 2)) (+ a (* b 3))) 4) =>  10\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))\n     =>  (2 NIL 3 NIL NIL)\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)\n     =>  (6 T 3 NIL NIL)\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)\n     =>  (6 T 3 T NIL)\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)\n     =>  (6 T 3 T (8))\n      ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))\n       6 3 8 9 10 11)\n     =>  (6 t 3 t (8 9 10 11))\n\nHere are some examples involving keyword parameters:\n\n      ((lambda (a b &key c d) (list a b c d)) 1 2) =>  (1 2 NIL NIL)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) =>  (1 2 6 NIL)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) =>  (1 2 NIL 8)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) =>  (1 2 6 8)\n      ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) =>  (1 2 6 8)\n      ((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) =>  (:a 1 6 8)\n      ((lambda (a b &key c d) (list a b c d)) :a :b :c :d) =>  (:a :b :d NIL)\n      ((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) =>  (1 2 6 NIL)\n      ((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) =>  (1 2 6 NIL)\n\nHere are some examples involving optional parameters, rest parameters, and\nkeyword parameters together:\n\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1)\n     =>  (1 3 NIL 1 ())\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 2)\n     =>  (1 2 NIL 1 ())\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) :c 7)\n     =>  (:c 7 NIL :c ())\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 6 :c 7)\n     =>  (1 6 7 1 (:c 7))\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 6 :d 8)\n     =>  (1 6 NIL 8 (:d 8))\n      ((lambda (a &optional (b 3) &rest x &key c (d a))\n         (list a b c d x)) 1 6 :d 8 :c 9 :d 10)\n     =>  (1 6 9 8 (:d 8 :c 9 :d 10))\n\nAs an example of the use of &allow-other-keys and :allow-other-keys,\nconsider a function that takes two named arguments of its own and also\naccepts additional named arguments to be passed to make-array:\n\n      (defun array-of-strings (str dims &rest named-pairs\n                               &key (start 0) end &allow-other-keys)\n        (apply #'make-array dims\n               :initial-element (subseq str start end)\n               :allow-other-keys t\n               named-pairs))\n\nThis function takes a string and dimensioning information and returns an\narray of the specified dimensions, each of whose elements is the specified\nstring.  However, :start and :end named arguments may be used to specify\nthat a substring of the given string should be used.  In addition, the\npresence of &allow-other-keys in the lambda list indicates that the caller\nmay supply additional named arguments; the rest parameter provides access\nto them.  These additional named arguments are passed to make-array.  The\nfunction make-array normally does not allow the named arguments :start and\n:end to be used, and an error should be signaled if such named arguments\nare supplied to make-array.  However, the presence in the call to\nmake-array of the named argument :allow-other-keys with a true value\ncauses any extraneous named arguments, including :start and :end, to be\nacceptable and ignored.\n\n"
}