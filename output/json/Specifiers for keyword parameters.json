{
    "name": "Specifiers for keyword parameters",
    "prev": "A specifier for a rest parameter",
    "next": "Suppressing Keyword Argument Checking",
    "up": "Ordinary Lambda Lists",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Specifiers for keyword parameters",
            "text": "If &key is present, all specifiers up to the next lambda list keyword or\nthe end of the list are keyword parameter specifiers.  When keyword\nparameters are processed, the same arguments are processed that would be\nmade into a list for a rest parameter.  It is permitted to specify both\n&rest and &key.  In this case the remaining arguments are used for both\npurposes; that is, all remaining arguments are made into a list for the\nrest parameter, and are also processed for the &key parameters.\nIf &key is specified, there must remain an even number of arguments; see\n*Note Odd Number of Keyword Arguments::.\nThese arguments are considered as pairs, the first argument in each pair\nbeing interpreted as a name and the second as the corresponding value.\nThe first object of each pair must be a symbol; see *Note Invalid Keyword\nArguments::.  The keyword parameter specifiers may optionally be followed\nby the lambda list keyword &allow-other-keys.\nIn each keyword parameter specifier must be a name var for the parameter\nvariable.\nIf the var appears alone or in a (var init-form) combination, the keyword\nname used when matching arguments to parameters is a symbol in the KEYWORD\npackage whose name is the same (under string=) as var's.  If the notation\n((keyword-name var) init-form) is used, then the keyword name used to\nmatch arguments to parameters is keyword-name, which may be a symbol in\nany package.  (Of course, if it is not a symbol in the KEYWORD package, it\ndoes not necessarily self-evaluate, so care must be taken when calling the\nfunction to make sure that normal evaluation still yields the keyword\nname.)\nThus\n      (defun foo (&key radix (type 'integer)) ...)\nmeans exactly the same as\n      (defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)\nThe keyword parameter specifiers are, like all parameter specifiers,\neffectively processed from left to right.  For each keyword parameter\nspecifier, if there is an argument pair whose name matches that\nspecifier's name (that is, the names are eq), then the parameter variable\nfor that specifier is bound to the second item (the value) of that\nargument pair.  If more than one such argument pair matches, the leftmost\nargument pair is used.  If no such argument pair exists, then the\ninit-form for that specifier is evaluated and the parameter variable is\nbound to that value (or to nil if no init-form was specified).\nsupplied-p-parameter is treated as for &optional parameters: it is bound\nto true if there was a matching argument pair, and to false otherwise.\nUnless keyword argument checking is suppressed, an argument pair must a\nname matched by a parameter specifier; see *Note Unrecognized Keyword\nArguments::.\nIf keyword argument checking is suppressed, then it is permitted for an\nargument pair to match no parameter specifier, and the argument pair is\nignored, but such an argument pair is accessible through the rest\nparameter if one was supplied.  The purpose of these mechanisms is to\nallow sharing of argument lists among several lambda expressions and to\nallow either the caller or the called lambda expression to specify that\nsuch sharing may be taking place.\nNote that if &key is present, a keyword argument of :allow-other-keys is\nalways permitted--regardless of whether the associated value is true or\nfalse.  However, if the value is false, other non-matching keywords are\nnot tolerated (unless &allow-other-keys was used).\nFurthermore, if the receiving argument list specifies a regular argument\nwhich would be flagged by :allow-other-keys, then :allow-other-keys has\nboth its special-cased meaning (identifying whether additional keywords\nare permitted) and its normal meaning (data flow into the function in\nquestion).\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Specifiers for keyword parameters,  Next: Suppressing Keyword Argument Checking,  Prev: A specifier for a rest parameter,  Up: Ordinary Lambda Lists\n\nSpecifiers for keyword parameters\n.................................\n\nIf &key is present, all specifiers up to the next lambda list keyword or\nthe end of the list are keyword parameter specifiers.  When keyword\nparameters are processed, the same arguments are processed that would be\nmade into a list for a rest parameter.  It is permitted to specify both\n&rest and &key.  In this case the remaining arguments are used for both\npurposes; that is, all remaining arguments are made into a list for the\nrest parameter, and are also processed for the &key parameters.\n\nIf &key is specified, there must remain an even number of arguments; see\n*Note Odd Number of Keyword Arguments::.\n\nThese arguments are considered as pairs, the first argument in each pair\nbeing interpreted as a name and the second as the corresponding value.\nThe first object of each pair must be a symbol; see *Note Invalid Keyword\nArguments::.  The keyword parameter specifiers may optionally be followed\nby the lambda list keyword &allow-other-keys.\n\nIn each keyword parameter specifier must be a name var for the parameter\nvariable.\n\nIf the var appears alone or in a (var init-form) combination, the keyword\nname used when matching arguments to parameters is a symbol in the KEYWORD\npackage whose name is the same (under string=) as var's.  If the notation\n((keyword-name var) init-form) is used, then the keyword name used to\nmatch arguments to parameters is keyword-name, which may be a symbol in\nany package.  (Of course, if it is not a symbol in the KEYWORD package, it\ndoes not necessarily self-evaluate, so care must be taken when calling the\nfunction to make sure that normal evaluation still yields the keyword\nname.)\n\nThus\n\n      (defun foo (&key radix (type 'integer)) ...)\n\nmeans exactly the same as\n\n      (defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)\n\nThe keyword parameter specifiers are, like all parameter specifiers,\neffectively processed from left to right.  For each keyword parameter\nspecifier, if there is an argument pair whose name matches that\nspecifier's name (that is, the names are eq), then the parameter variable\nfor that specifier is bound to the second item (the value) of that\nargument pair.  If more than one such argument pair matches, the leftmost\nargument pair is used.  If no such argument pair exists, then the\ninit-form for that specifier is evaluated and the parameter variable is\nbound to that value (or to nil if no init-form was specified).\nsupplied-p-parameter is treated as for &optional parameters: it is bound\nto true if there was a matching argument pair, and to false otherwise.\n\nUnless keyword argument checking is suppressed, an argument pair must a\nname matched by a parameter specifier; see *Note Unrecognized Keyword\nArguments::.\n\nIf keyword argument checking is suppressed, then it is permitted for an\nargument pair to match no parameter specifier, and the argument pair is\nignored, but such an argument pair is accessible through the rest\nparameter if one was supplied.  The purpose of these mechanisms is to\nallow sharing of argument lists among several lambda expressions and to\nallow either the caller or the called lambda expression to specify that\nsuch sharing may be taking place.\n\nNote that if &key is present, a keyword argument of :allow-other-keys is\nalways permitted--regardless of whether the associated value is true or\nfalse.  However, if the value is false, other non-matching keywords are\nnot tolerated (unless &allow-other-keys was used).\n\nFurthermore, if the receiving argument list specifies a regular argument\nwhich would be flagged by :allow-other-keys, then :allow-other-keys has\nboth its special-cased meaning (identifying whether additional keywords\nare permitted) and its normal meaning (data flow into the function in\nquestion).\n\n"
}