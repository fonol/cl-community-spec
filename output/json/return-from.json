{
    "name": "return-from",
    "prev": "go",
    "next": "return",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "return-from"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "return-from",
                    "text": " name [result] =>  #<NoValue>\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a block tag; not evaluated."
                },
                {
                    "name": "result",
                    "desc": "a form; evaluated.  The default is nil."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Returns control and multiple values_2 from a lexically enclosing block.\nA block form named name must lexically enclose the occurrence of\nreturn-from;  any values yielded by the evaluation of result are\nimmediately returned from the innermost such lexically enclosing block.\nThe transfer of control initiated by return-from is performed as described\nin *Note Transfer of Control to an Exit Point::.\n"
        },
        {
            "type": "Examples",
            "text": "      (block alpha (return-from alpha) 1) =>  NIL\n      (block alpha (return-from alpha 1) 2) =>  1\n      (block alpha (return-from alpha (values 1 2)) 3) =>  1, 2\n      (let ((a 0))\n         (dotimes (i 10) (incf a) (when (oddp i) (return)))\n         a) =>  2\n      (defun temp (x)\n         (if x (return-from temp 'dummy))\n         44) =>  TEMP\n      (temp nil) =>  44\n      (temp t) =>  DUMMY\n      (block out\n        (flet ((exit (n) (return-from out n)))\n          (block out (exit 1)))\n        2) =>  1\n      (block nil\n        (unwind-protect (return-from nil 1)\n          (return-from nil 2)))\n     =>  2\n      (dolist (flag '(nil t))\n        (block nil\n          (let ((x 5))\n            (declare (special x))\n            (unwind-protect (return-from nil)\n              (print x))))\n        (print 'here))\n      |>  5\n      |>  HERE\n      |>  5\n      |>  HERE\n     =>  NIL\n      (dolist (flag '(nil t))\n        (block nil\n          (let ((x 5))\n            (declare (special x))\n            (unwind-protect\n                (if flag (return-from nil))\n              (print x))))\n        (print 'here))\n      |>  5\n      |>  HERE\n      |>  5\n      |>  HERE\n     =>  NIL\nThe following has undefined consequences because the block form exits\nnormally before the return-from form is attempted.\n      (funcall (block nil #'(lambda () (return-from nil)))) is an error.\n"
        },
        {
            "type": "See Also",
            "text": "*Note block:: , *Note return:: , *Note Evaluation::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: return-from,  Next: return,  Prev: go,  Up: Data and Control Flow Dictionary\n\nreturn-from                                              [Special Operator]\n---------------------------------------------------------------------------\n\n`return-from'  name [result] =>  #<NoValue>\n\nArguments and Values::\n......................\n\nname--a block tag; not evaluated.\n\nresult--a form; evaluated.  The default is nil.\n\nDescription::\n.............\n\nReturns control and multiple values_2 from a lexically enclosing block.\n\nA block form named name must lexically enclose the occurrence of\nreturn-from;  any values yielded by the evaluation of result are\nimmediately returned from the innermost such lexically enclosing block.\n\nThe transfer of control initiated by return-from is performed as described\nin *Note Transfer of Control to an Exit Point::.\n\nExamples::\n..........\n\n      (block alpha (return-from alpha) 1) =>  NIL\n      (block alpha (return-from alpha 1) 2) =>  1\n      (block alpha (return-from alpha (values 1 2)) 3) =>  1, 2\n      (let ((a 0))\n         (dotimes (i 10) (incf a) (when (oddp i) (return)))\n         a) =>  2\n      (defun temp (x)\n         (if x (return-from temp 'dummy))\n         44) =>  TEMP\n      (temp nil) =>  44\n      (temp t) =>  DUMMY\n      (block out\n        (flet ((exit (n) (return-from out n)))\n          (block out (exit 1)))\n        2) =>  1\n      (block nil\n        (unwind-protect (return-from nil 1)\n          (return-from nil 2)))\n     =>  2\n      (dolist (flag '(nil t))\n        (block nil\n          (let ((x 5))\n            (declare (special x))\n            (unwind-protect (return-from nil)\n              (print x))))\n        (print 'here))\n      |>  5\n      |>  HERE\n      |>  5\n      |>  HERE\n     =>  NIL\n      (dolist (flag '(nil t))\n        (block nil\n          (let ((x 5))\n            (declare (special x))\n            (unwind-protect\n                (if flag (return-from nil))\n              (print x))))\n        (print 'here))\n      |>  5\n      |>  HERE\n      |>  5\n      |>  HERE\n     =>  NIL\n\nThe following has undefined consequences because the block form exits\nnormally before the return-from form is attempted.\n\n      (funcall (block nil #'(lambda () (return-from nil)))) is an error.\n\nSee Also::\n..........\n\n*Note block:: , *Note return:: , *Note Evaluation::\n\n"
}