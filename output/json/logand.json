{
    "name": "logand",
    "prev": "boole-1",
    "next": "logbitp",
    "up": "Numbers Dictionary",
    "header": {
        "type": null,
        "text": "logxor"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "logand",
                    "text": " &rest integers =>  result-integer\n"
                },
                {
                    "name": "logandc'  1 =>  integer-1 integer-2 result-integer `logandc",
                    "text": " 2 =>\ninteger-1 integer-2 result-integer `logeqv'  &rest integers =>\nresult-integer\n\n"
                },
                {
                    "name": "logior",
                    "text": " &rest integers =>  result-integer\n\n"
                },
                {
                    "name": "lognand",
                    "text": " integer-1 integer-2 =>  result-integer\n\n"
                },
                {
                    "name": "lognor",
                    "text": " integer-1 integer-2 =>  result-integer\n\n"
                },
                {
                    "name": "lognot",
                    "text": " integer =>  result-integer\n\n"
                },
                {
                    "name": "logorc'  1 =>  integer-1 integer-2 result-integer `logorc",
                    "text": " 2 =>\ninteger-1 integer-2 result-integer `logxor'  &rest integers =>\nresult-integer\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "integers",
                    "desc": "integers."
                },
                {
                    "name": "integer",
                    "desc": "an integer."
                },
                {
                    "name": "integer-1",
                    "desc": "an integer."
                },
                {
                    "name": "integer-2",
                    "desc": "an integer."
                },
                {
                    "name": "result-integer",
                    "desc": "an integer."
                }
            ]
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "identity",
                    "text": "is shown, it indicates the value yielded by the function whenno arguments are supplied.\n\n  Function  Identity  Operation performed                         \n  logandc1  --       and complement of integer-1 with integer-2  \n  logandc2  --       and integer-1 with complement of integer-2  \n  logand    -1        and                                         \n  logeqv    -1        equivalence (exclusive nor)                 \n  logior    0         inclusive or                                \n  lognand   --       complement of integer-1 and integer-2       \n  lognor    --       complement of integer-1 or integer-2        \n  lognot    --       complement                                  \n  logorc1   --       or complement of integer-1 with integer-2   \n  logorc2   --       or integer-1 with complement of integer-2   \n  logxor    0         exclusive or                                \n\n       Figure 12-17: Bit-wise Logical Operations on Integers     \n\n\nNegative integers are treated as if they were in two's-complement notation.\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Examples",
            "text": "      (logior 1 2 4 8) =>  15\n      (logxor 1 3 7 15) =>  10\n      (logeqv) =>  -1\n      (logand 16 31) =>  16\n      (lognot 0) =>  -1\n      (lognot 1) =>  -2\n      (lognot -1) =>  0\n      (lognot (1+ (lognot 1000))) =>  999\n     ;;; In the following example, m is a mask.  For each bit in\n     ;;; the mask that is a 1, the corresponding bits in x and y are\n     ;;; exchanged.  For each bit in the mask that is a 0, the\n     ;;; corresponding bits of x and y are left unchanged.\n      (flet ((show (m x y)\n               (format t \"~\n                       m x y)))\n        (let ((m #o007750)\n              (x #o452576)\n              (y #o317407))\n          (show m x y)\n          (let ((z (logand (logxor x y) m)))\n            (setq x (logxor z x))\n            (setq y (logxor z y))\n            (show m x y))))\n      |>  m = #o007750\n      |>  x = #o452576\n      |>  y = #o317407\n      |> \n      |>  m = #o007750\n      |>  x = #o457426\n      |>  y = #o312557\n     =>  NIL\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal type-error if any argument is not an integer.\n"
        },
        {
            "type": "See Also",
            "text": "*Note boole::\n"
        },
        {
            "type": "Notes",
            "text": "(logbitp k -1) returns true for all values of k.\nBecause the following functions are not associative, they take exactly two\narguments rather than any number of arguments.\n      (lognand n1 n2) == (lognot (logand n1 n2))\n      (lognor n1 n2) == (lognot (logior n1 n2))\n      (logandc1 n1 n2) == (logand (lognot n1) n2)\n      (logandc2 n1 n2) == (logand n1 (lognot n2))\n      (logiorc1 n1 n2) == (logior (lognot n1) n2)\n      (logiorc2 n1 n2) == (logior n1 (lognot n2))\n      (logbitp j (lognot x)) == (not (logbitp j x))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: logand,  Next: logbitp,  Prev: boole-1,  Up: Numbers Dictionary\n\nlogand,  logandc1, logandc2, logeqv,  logior,\n---------------------------------------------\n\nlognand, lognor,   lognot,   logorc1, logorc2,\n----------------------------------------------\n\nlogxor\n------\n\n                                                                [Function]\n\n`logand'  &rest integers =>  result-integer\n\n`logandc'  1 =>  integer-1 integer-2 result-integer `logandc'  2 =>\ninteger-1 integer-2 result-integer `logeqv'  &rest integers =>\nresult-integer\n\n`logior'  &rest integers =>  result-integer\n\n`lognand'  integer-1 integer-2 =>  result-integer\n\n`lognor'  integer-1 integer-2 =>  result-integer\n\n`lognot'  integer =>  result-integer\n\n`logorc'  1 =>  integer-1 integer-2 result-integer `logorc'  2 =>\ninteger-1 integer-2 result-integer `logxor'  &rest integers =>\nresult-integer\n\nArguments and Values::\n......................\n\nintegers--integers.\n\ninteger--an integer.\n\ninteger-1--an integer.\n\ninteger-2--an integer.\n\nresult-integer--an integer.\n\nDescription::\n.............\n\nThe functions logandc1, logandc2, logand, logeqv, logior, lognand, lognor,\nlognot, logorc1, logorc2, and logxor perform bit-wise logical operations\non their arguments, that are treated as if they were binary.\n\nFigure 12-17 lists the meaning of each of the functions.  Where an\n`identity' is shown, it indicates the value yielded by the function when\nno arguments are supplied.\n\n  Function  Identity  Operation performed                         \n  logandc1  --       and complement of integer-1 with integer-2  \n  logandc2  --       and integer-1 with complement of integer-2  \n  logand    -1        and                                         \n  logeqv    -1        equivalence (exclusive nor)                 \n  logior    0         inclusive or                                \n  lognand   --       complement of integer-1 and integer-2       \n  lognor    --       complement of integer-1 or integer-2        \n  lognot    --       complement                                  \n  logorc1   --       or complement of integer-1 with integer-2   \n  logorc2   --       or integer-1 with complement of integer-2   \n  logxor    0         exclusive or                                \n\n       Figure 12-17: Bit-wise Logical Operations on Integers     \n\n\nNegative integers are treated as if they were in two's-complement notation.\n\nExamples::\n..........\n\n      (logior 1 2 4 8) =>  15\n      (logxor 1 3 7 15) =>  10\n      (logeqv) =>  -1\n      (logand 16 31) =>  16\n      (lognot 0) =>  -1\n      (lognot 1) =>  -2\n      (lognot -1) =>  0\n      (lognot (1+ (lognot 1000))) =>  999\n     \n     ;;; In the following example, m is a mask.  For each bit in\n     ;;; the mask that is a 1, the corresponding bits in x and y are\n     ;;; exchanged.  For each bit in the mask that is a 0, the\n     ;;; corresponding bits of x and y are left unchanged.\n      (flet ((show (m x y)\n               (format t \"~\n                       m x y)))\n        (let ((m #o007750)\n              (x #o452576)\n              (y #o317407))\n          (show m x y)\n          (let ((z (logand (logxor x y) m)))\n            (setq x (logxor z x))\n            (setq y (logxor z y))\n            (show m x y))))\n      |>  m = #o007750\n      |>  x = #o452576\n      |>  y = #o317407\n      |> \n      |>  m = #o007750\n      |>  x = #o457426\n      |>  y = #o312557\n     =>  NIL\n\nExceptional Situations::\n........................\n\nShould signal type-error if any argument is not an integer.\n\nSee Also::\n..........\n\n*Note boole::\n\nNotes::\n.......\n\n(logbitp k -1) returns true for all values of k.\n\nBecause the following functions are not associative, they take exactly two\narguments rather than any number of arguments.\n\n      (lognand n1 n2) == (lognot (logand n1 n2))\n      (lognor n1 n2) == (lognot (logior n1 n2))\n      (logandc1 n1 n2) == (logand (lognot n1) n2)\n      (logandc2 n1 n2) == (logand n1 (lognot n2))\n      (logiorc1 n1 n2) == (logior (lognot n1) n2)\n      (logiorc2 n1 n2) == (logior n1 (lognot n2))\n      (logbitp j (lognot x)) == (not (logbitp j x))\n\n"
}