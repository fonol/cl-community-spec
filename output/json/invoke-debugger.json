{
    "name": "invoke-debugger",
    "prev": "simple-warning",
    "next": "break",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Function",
        "text": "invoke-debugger"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "invoke-debugger",
                    "text": " condition =>  #<NoValue>\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "condition",
                    "desc": "a condition object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "invoke-debugger attempts to enter the debugger with condition.\nIf *debugger-hook* is not nil, it should be a function (or the name of a\nfunction) to be called prior to entry to the standard debugger.  The\nfunction is called with *debugger-hook* bound to nil, and the function\nmust accept two arguments: the condition and the value of *debugger-hook*\nprior to binding it to nil.  If the function returns normally, the\nstandard debugger is entered.\nThe standard debugger never directly returns.  Return can occur only by a\nnon-local transfer of control, such as the use of a restart function.\n"
        },
        {
            "type": "Examples",
            "text": "      (ignore-errors ;Normally, this would suppress debugger entry\n        (handler-bind ((error #'invoke-debugger)) ;But this forces debugger entry\n          (error \"Foo.\")))\n     Debug: Foo.\n     To continue, type :CONTINUE followed by an option number:\n      1: Return to Lisp Toplevel.\n     Debug>\n"
        },
        {
            "type": "Side Effects",
            "text": "*debugger-hook* is bound to nil, program execution is discontinued, and\nthe debugger is entered.\n"
        },
        {
            "type": "Affected By",
            "text": "*debug-io* and *debugger-hook*.\n"
        },
        {
            "type": "See Also",
            "text": "*Note error:: , *Note break::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: invoke-debugger,  Next: break,  Prev: simple-warning,  Up: Conditions Dictionary\n\ninvoke-debugger                                                  [Function]\n---------------------------------------------------------------------------\n\n`invoke-debugger'  condition =>  #<NoValue>\n\nArguments and Values::\n......................\n\ncondition--a condition object.\n\nDescription::\n.............\n\ninvoke-debugger attempts to enter the debugger with condition.\n\nIf *debugger-hook* is not nil, it should be a function (or the name of a\nfunction) to be called prior to entry to the standard debugger.  The\nfunction is called with *debugger-hook* bound to nil, and the function\nmust accept two arguments: the condition and the value of *debugger-hook*\nprior to binding it to nil.  If the function returns normally, the\nstandard debugger is entered.\n\nThe standard debugger never directly returns.  Return can occur only by a\nnon-local transfer of control, such as the use of a restart function.\n\nExamples::\n..........\n\n      (ignore-errors ;Normally, this would suppress debugger entry\n        (handler-bind ((error #'invoke-debugger)) ;But this forces debugger entry\n          (error \"Foo.\")))\n     Debug: Foo.\n     To continue, type :CONTINUE followed by an option number:\n      1: Return to Lisp Toplevel.\n     Debug>\n\nSide Effects::\n..............\n\n*debugger-hook* is bound to nil, program execution is discontinued, and\nthe debugger is entered.\n\nAffected By::\n.............\n\n*debug-io* and *debugger-hook*.\n\nSee Also::\n..........\n\n*Note error:: , *Note break::\n\n"
}