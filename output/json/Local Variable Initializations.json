{
    "name": "Local Variable Initializations",
    "prev": "Examples of for-as-package subclause",
    "next": "Examples of WITH clause",
    "up": "Variable Initialization and Stepping Clauses",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Local Variable Initializations",
            "text": "When a loop form is executed, the local variables are bound and are\ninitialized to some value.  These local variables exist until loop\niteration terminates, at which point they cease to exist.  Implicit\nvariables are also established by iteration control clauses and the into\npreposition of accumulation clauses.\nThe with construct initializes variables that are local to a loop.  The\nvariables are initialized one time only.  If the optional type-spec\nargument is supplied for the variable var, but there is no related\nexpression to be evaluated, var is initialized to an appropriate default\nvalue for its type.  For example, for the types t, number, and float, the\ndefault values are nil, 0, and 0.0 respectively.  The consequences are\nundefined if a type-spec argument is supplied for var if the related\nexpression returns a value that is not of the supplied type.  By default,\nthe with construct initializes variables sequentially; that is, one\nvariable is assigned a value before the next expression is evaluated.\nHowever, by using the loop keyword and to join several with clauses,\ninitializations can be forced to occur in parallel; that is, all of the\nsupplied forms are evaluated, and the results are bound to the respective\nvariables simultaneously.\nSequential binding is used when it is desireable for the initialization of\nsome variables to depend on the values of previously bound variables.  For\nexample, suppose the variables a, b, and c are to be bound in sequence:\n      (loop with a = 1\n            with b = (+ a 2)\n            with c = (+ b 3)\n            return (list a b c))\n     =>  (1 3 6)\nThe execution of the above loop is equivalent to the execution of the\nfollowing code:\n      (block nil\n        (let* ((a 1)\n               (b (+ a 2))\n               (c (+ b 3)))\n          (tagbody\n              (next-loop (return (list a b c))\n                         (go next-loop)\n                         end-loop))))\nIf the values of previously bound variables are not needed for the\ninitialization of other local variables, an and clause can be used to\nspecify that the bindings are to occur in parallel:\n      (loop with a = 1\n            and b = 2\n            and c = 3\n            return (list a b c))\n     =>  (1 2 3)\nThe execution of the above loop is equivalent to the execution of the\nfollowing code:\n      (block nil\n        (let ((a 1)\n              (b 2)\n              (c 3))\n          (tagbody\n              (next-loop (return (list a b c))\n                         (go next-loop)\n                         end-loop))))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Local Variable Initializations,  Next: Examples of WITH clause,  Prev: Examples of for-as-package subclause,  Up: Variable Initialization and Stepping Clauses\n\nLocal Variable Initializations\n..............................\n\nWhen a loop form is executed, the local variables are bound and are\ninitialized to some value.  These local variables exist until loop\niteration terminates, at which point they cease to exist.  Implicit\nvariables are also established by iteration control clauses and the into\npreposition of accumulation clauses.\n\nThe with construct initializes variables that are local to a loop.  The\nvariables are initialized one time only.  If the optional type-spec\nargument is supplied for the variable var, but there is no related\nexpression to be evaluated, var is initialized to an appropriate default\nvalue for its type.  For example, for the types t, number, and float, the\ndefault values are nil, 0, and 0.0 respectively.  The consequences are\nundefined if a type-spec argument is supplied for var if the related\nexpression returns a value that is not of the supplied type.  By default,\nthe with construct initializes variables sequentially; that is, one\nvariable is assigned a value before the next expression is evaluated.\nHowever, by using the loop keyword and to join several with clauses,\ninitializations can be forced to occur in parallel; that is, all of the\nsupplied forms are evaluated, and the results are bound to the respective\nvariables simultaneously.\n\nSequential binding is used when it is desireable for the initialization of\nsome variables to depend on the values of previously bound variables.  For\nexample, suppose the variables a, b, and c are to be bound in sequence:\n\n      (loop with a = 1\n            with b = (+ a 2)\n            with c = (+ b 3)\n            return (list a b c))\n     =>  (1 3 6)\n\nThe execution of the above loop is equivalent to the execution of the\nfollowing code:\n\n      (block nil\n        (let* ((a 1)\n               (b (+ a 2))\n               (c (+ b 3)))\n          (tagbody\n              (next-loop (return (list a b c))\n                         (go next-loop)\n                         end-loop))))\n\nIf the values of previously bound variables are not needed for the\ninitialization of other local variables, an and clause can be used to\nspecify that the bindings are to occur in parallel:\n\n      (loop with a = 1\n            and b = 2\n            and c = 3\n            return (list a b c))\n     =>  (1 2 3)\n\nThe execution of the above loop is equivalent to the execution of the\nfollowing code:\n\n      (block nil\n        (let ((a 1)\n              (b 2)\n              (c 3))\n          (tagbody\n              (next-loop (return (list a b c))\n                         (go next-loop)\n                         end-loop))))\n\n"
}