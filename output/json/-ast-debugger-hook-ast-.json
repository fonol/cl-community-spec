{
    "name": "*debugger-hook*",
    "prev": "break",
    "next": "*break-on-signals*",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Variable",
        "text": "*debugger-hook*"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Value Type",
            "text": "a designator for a function of two arguments (a condition and the value of\n*debugger-hook* at the time the debugger was entered), or nil.\n"
        },
        {
            "type": "Initial Value",
            "text": "nil.\n"
        },
        {
            "type": "Description",
            "text": "When the value of *debugger-hook* is non-nil, it is called prior to normal\nentry into the debugger, either due to a call to invoke-debugger or due to\nautomatic entry into the debugger from a call to error or cerror with a\ncondition that is not handled.  The function may either handle the\ncondition (transfer control) or return normally (allowing the standard\ndebugger to run).  To minimize recursive errors while debugging,\n*debugger-hook* is bound to nil by invoke-debugger prior to calling the\nfunction.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun one-of (choices &optional (prompt \"Choice\"))\n        (let ((n (length choices)) (i))\n          (do ((c choices (cdr c)) (i 1 (+ i 1)))\n              ((null c))\n            (format t \"~&[~D] ~A~\n          (do () ((typep i `(integer 1 ,n)))\n            (format t \"~&~A: \" prompt)\n            (setq i (read))\n            (fresh-line))\n          (nth (- i 1) choices)))\n      (defun my-debugger (condition me-or-my-encapsulation)\n        (format t \"~&Fooey: ~A\" condition)\n        (let ((restart (one-of (compute-restarts))))\n          (if (not restart) (error \"My debugger got an error.\"))\n          (let ((*debugger-hook* me-or-my-encapsulation))\n            (invoke-restart-interactively restart))))\n      (let ((*debugger-hook* #'my-debugger))\n        (+ 3 'a))\n      |>  Fooey: The argument to +, A, is not a number.\n      |>   [1] Supply a replacement for A.\n      |>   [2] Return to Cloe Toplevel.\n      |>  Choice: 1\n      |>   Form to evaluate and use: (+ 5 'b)\n      |>   Fooey: The argument to +, B, is not a number.\n      |>   [1] Supply a replacement for B.\n      |>   [2] Supply a replacement for A.\n      |>   [3] Return to Cloe Toplevel.\n      |>  Choice: 1\n      |>   Form to evaluate and use: 1\n     =>  9\n"
        },
        {
            "type": "Affected By",
            "text": "invoke-debugger\n"
        },
        {
            "type": "Notes",
            "text": "When evaluating code typed in by the user interactively, it is sometimes\nuseful to have the hook function bind *debugger-hook* to the function that\nwas its second argument so that recursive errors can be handled using the\nsame interactive facility.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: *debugger-hook*,  Next: *break-on-signals*,  Prev: break,  Up: Conditions Dictionary\n\n*debugger-hook*                                                  [Variable]\n---------------------------------------------------------------------------\n\nValue Type::\n............\n\na designator for a function of two arguments (a condition and the value of\n*debugger-hook* at the time the debugger was entered), or nil.\n\nInitial Value::\n...............\n\nnil.\n\nDescription::\n.............\n\nWhen the value of *debugger-hook* is non-nil, it is called prior to normal\nentry into the debugger, either due to a call to invoke-debugger or due to\nautomatic entry into the debugger from a call to error or cerror with a\ncondition that is not handled.  The function may either handle the\ncondition (transfer control) or return normally (allowing the standard\ndebugger to run).  To minimize recursive errors while debugging,\n*debugger-hook* is bound to nil by invoke-debugger prior to calling the\nfunction.\n\nExamples::\n..........\n\n      (defun one-of (choices &optional (prompt \"Choice\"))\n        (let ((n (length choices)) (i))\n          (do ((c choices (cdr c)) (i 1 (+ i 1)))\n              ((null c))\n            (format t \"~&[~D] ~A~\n          (do () ((typep i `(integer 1 ,n)))\n            (format t \"~&~A: \" prompt)\n            (setq i (read))\n            (fresh-line))\n          (nth (- i 1) choices)))\n     \n      (defun my-debugger (condition me-or-my-encapsulation)\n        (format t \"~&Fooey: ~A\" condition)\n        (let ((restart (one-of (compute-restarts))))\n          (if (not restart) (error \"My debugger got an error.\"))\n          (let ((*debugger-hook* me-or-my-encapsulation))\n            (invoke-restart-interactively restart))))\n     \n      (let ((*debugger-hook* #'my-debugger))\n        (+ 3 'a))\n      |>  Fooey: The argument to +, A, is not a number.\n      |>   [1] Supply a replacement for A.\n      |>   [2] Return to Cloe Toplevel.\n      |>  Choice: 1\n      |>   Form to evaluate and use: (+ 5 'b)\n      |>   Fooey: The argument to +, B, is not a number.\n      |>   [1] Supply a replacement for B.\n      |>   [2] Supply a replacement for A.\n      |>   [3] Return to Cloe Toplevel.\n      |>  Choice: 1\n      |>   Form to evaluate and use: 1\n     =>  9\n\nAffected By::\n.............\n\ninvoke-debugger\n\nNotes::\n.......\n\nWhen evaluating code typed in by the user interactively, it is sometimes\nuseful to have the hook function bind *debugger-hook* to the function that\nwas its second argument so that recursive errors can be handled using the\nsame interactive facility.\n\n"
}