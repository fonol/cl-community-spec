{
    "name": "revappend",
    "prev": "append",
    "next": "butlast",
    "up": "Conses Dictionary",
    "header": {
        "type": "Function",
        "text": "revappend, nreconc"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "revappend",
                    "text": " list tail =>  result-list\n"
                },
                {
                    "name": "nreconc",
                    "text": " list tail =>  result-list\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "list",
                    "desc": "a proper list."
                },
                {
                    "name": "tail",
                    "desc": "an object."
                },
                {
                    "name": "result-list",
                    "desc": "an object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "revappend constructs a copy_2 of list, but with the elements in reverse\norder.  It then appends (as if by nconc) the tail to that reversed list\nand returns the result.\nnreconc reverses the order of elements in list (as if by nreverse).  It\nthen appends (as if by nconc) the tail to that reversed list and returns\nthe result.\nThe resulting list shares list structure with tail.\n"
        },
        {
            "type": "Examples",
            "text": "      (let ((list-1 (list 1 2 3))\n            (list-2 (list 'a 'b 'c)))\n        (print (revappend list-1 list-2))\n        (print (equal list-1 '(1 2 3)))\n        (print (equal list-2 '(a b c))))\n      |>  (3 2 1 A B C)\n      |>  T\n      |>  T\n     =>  T\n      (revappend '(1 2 3) '()) =>  (3 2 1)\n      (revappend '(1 2 3) '(a . b)) =>  (3 2 1 A . B)\n      (revappend '() '(a b c)) =>  (A B C)\n      (revappend '(1 2 3) 'a) =>  (3 2 1 . A)\n      (revappend '() 'a) =>  A   ;degenerate case\n      (let ((list-1 '(1 2 3))\n            (list-2 '(a b c)))\n        (print (nreconc list-1 list-2))\n        (print (equal list-1 '(1 2 3)))\n        (print (equal list-2 '(a b c))))\n      |>  (3 2 1 A B C)\n      |>  NIL\n      |>  T\n     =>  T\n"
        },
        {
            "type": "Side Effects",
            "text": "revappend does not modify either of its arguments.  nreconc is permitted\nto modify list but not tail.\nAlthough it might be implemented differently, nreconc is constrained to\nhave side-effect behavior equivalent to:\n      (nconc (nreverse list) tail)\n"
        },
        {
            "type": "See Also",
            "text": "*Note reverse; nreverse:: , nreverse, *Note nconc::\n"
        },
        {
            "type": "Notes",
            "text": "The following functional equivalences are true, although good\nimplementations will typically use a faster algorithm for achieving the\nsame effect:\n      (revappend list tail) == (nconc (reverse list) tail)\n      (nreconc list tail) == (nconc (nreverse list) tail)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: revappend,  Next: butlast,  Prev: append,  Up: Conses Dictionary\n\nrevappend, nreconc                                               [Function]\n---------------------------------------------------------------------------\n\n`revappend'  list tail =>  result-list\n\n`nreconc'  list tail =>  result-list\n\nArguments and Values::\n......................\n\nlist--a proper list.\n\ntail--an object.\n\nresult-list--an object.\n\nDescription::\n.............\n\nrevappend constructs a copy_2 of list, but with the elements in reverse\norder.  It then appends (as if by nconc) the tail to that reversed list\nand returns the result.\n\nnreconc reverses the order of elements in list (as if by nreverse).  It\nthen appends (as if by nconc) the tail to that reversed list and returns\nthe result.\n\nThe resulting list shares list structure with tail.\n\nExamples::\n..........\n\n      (let ((list-1 (list 1 2 3))\n            (list-2 (list 'a 'b 'c)))\n        (print (revappend list-1 list-2))\n        (print (equal list-1 '(1 2 3)))\n        (print (equal list-2 '(a b c))))\n      |>  (3 2 1 A B C)\n      |>  T\n      |>  T\n     =>  T\n     \n      (revappend '(1 2 3) '()) =>  (3 2 1)\n      (revappend '(1 2 3) '(a . b)) =>  (3 2 1 A . B)\n      (revappend '() '(a b c)) =>  (A B C)\n      (revappend '(1 2 3) 'a) =>  (3 2 1 . A)\n      (revappend '() 'a) =>  A   ;degenerate case\n     \n      (let ((list-1 '(1 2 3))\n            (list-2 '(a b c)))\n        (print (nreconc list-1 list-2))\n        (print (equal list-1 '(1 2 3)))\n        (print (equal list-2 '(a b c))))\n      |>  (3 2 1 A B C)\n      |>  NIL\n      |>  T\n     =>  T\n\nSide Effects::\n..............\n\nrevappend does not modify either of its arguments.  nreconc is permitted\nto modify list but not tail.\n\nAlthough it might be implemented differently, nreconc is constrained to\nhave side-effect behavior equivalent to:\n\n      (nconc (nreverse list) tail)\n\nSee Also::\n..........\n\n*Note reverse; nreverse:: , nreverse, *Note nconc::\n\nNotes::\n.......\n\nThe following functional equivalences are true, although good\nimplementations will typically use a faster algorithm for achieving the\nsame effect:\n\n      (revappend list tail) == (nconc (reverse list) tail)\n      (nreconc list tail) == (nconc (nreverse list) tail)\n\n"
}