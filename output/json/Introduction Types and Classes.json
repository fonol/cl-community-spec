{
    "name": "Introduction (Types and Classes)",
    "prev": "Types and Classes",
    "next": "Types",
    "up": "Types and Classes",
    "header": {
        "type": null,
        "text": "Introduction"
    },
    "sections": [
        {
            "type": "",
            "text": "A type is a (possibly infinite) set of objects.  An object can belong to\nmore than one type.  Types are never explicitly represented as objects by\nCommon Lisp.  Instead, they are referred to indirectly by the use of type\nspecifiers, which are objects that denote types.\nNew types can be defined using deftype, defstruct, defclass, and\ndefine-condition.\nThe function typep, a set membership test, is used to determine whether a\ngiven object is of a given type.  The function subtypep, a subset test, is\nused to determine whether a given type is a subtype of another given type.\nThe function type-of returns a particular type to which a given object\nbelongs, even though that object must belong to one or more other types as\nwell.  (For example, every object is of type t, but type-of always returns\na type specifier for a type more specific than t.)\nObjects, not variables, have types.  Normally, any variable can have any\nobject as its value.  It is possible to declare that a variable takes on\nonly values of a given type by making an explicit type declaration.  Types\nare arranged in a directed acyclic graph, except for the presence of\nequivalences.\nDeclarations can be made about types using declare, proclaim, declaim, or\nthe.  For more information about declarations, see *Note Declarations::.\nAmong the fundamental objects of the object system are classes.  A class\ndetermines the structure and behavior of a set of other objects, which are\ncalled its instances.  Every object is a direct instance of a class.  The\nclass of an object determines the set of operations that can be performed\non the object.  For more information, see *Note Classes::.\nIt is possible to write functions that have behavior specialized to the\nclass of the objects which are their arguments.  For more information, see\n*Note Generic Functions and Methods::.\nThe class of the class of an object is called its metaclass .  For more\ninformation about metaclasses, see *Note Meta-Objects::.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Introduction (Types and Classes),  Next: Types,  Prev: Types and Classes,  Up: Types and Classes\n\nIntroduction\n============\n\nA type is a (possibly infinite) set of objects.  An object can belong to\nmore than one type.  Types are never explicitly represented as objects by\nCommon Lisp.  Instead, they are referred to indirectly by the use of type\nspecifiers, which are objects that denote types.\n\nNew types can be defined using deftype, defstruct, defclass, and\ndefine-condition.\n\nThe function typep, a set membership test, is used to determine whether a\ngiven object is of a given type.  The function subtypep, a subset test, is\nused to determine whether a given type is a subtype of another given type.\nThe function type-of returns a particular type to which a given object\nbelongs, even though that object must belong to one or more other types as\nwell.  (For example, every object is of type t, but type-of always returns\na type specifier for a type more specific than t.)\n\nObjects, not variables, have types.  Normally, any variable can have any\nobject as its value.  It is possible to declare that a variable takes on\nonly values of a given type by making an explicit type declaration.  Types\nare arranged in a directed acyclic graph, except for the presence of\nequivalences.\n\nDeclarations can be made about types using declare, proclaim, declaim, or\nthe.  For more information about declarations, see *Note Declarations::.\n\nAmong the fundamental objects of the object system are classes.  A class\ndetermines the structure and behavior of a set of other objects, which are\ncalled its instances.  Every object is a direct instance of a class.  The\nclass of an object determines the set of operations that can be performed\non the object.  For more information, see *Note Classes::.\n\nIt is possible to write functions that have behavior specialized to the\nclass of the objects which are their arguments.  For more information, see\n*Note Generic Functions and Methods::.\n\nThe class of the class of an object is called its metaclass .  For more\ninformation about metaclasses, see *Note Meta-Objects::.\n\n"
}