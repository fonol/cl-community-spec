{
    "name": "getf",
    "prev": "get-properties",
    "next": "remf",
    "up": "Conses Dictionary",
    "header": {
        "type": "Accessor",
        "text": "getf"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "getf",
                    "text": " plist indicator &optional default =>  value\n(setf (`         getf' place indicator &optional default) new-value)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "plist",
                    "desc": "a property list."
                },
                {
                    "name": "place",
                    "desc": "a place, the value of which is a property list."
                },
                {
                    "name": "indicator",
                    "desc": "an object."
                },
                {
                    "name": "default",
                    "desc": "an object.  The default is nil."
                },
                {
                    "name": "value",
                    "desc": "an object."
                },
                {
                    "name": "new-value",
                    "desc": "an object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "getf finds a property on the plist whose property indicator is identical\nto indicator, and returns its corresponding property value.\nIf there are multiple properties_1 with that property indicator, getf uses\nthe first such property.\nIf there is no property with that property indicator, default is returned.\nsetf of getf may be used to associate a new object with an existing\nindicator in the property list held by place, or to create a new\nassocation if none exists.\nIf there are multiple properties_1 with that property indicator, setf of\ngetf associates the new-value with the first such property.\nWhen a getf form is used as a setf place, any default which is supplied is\nevaluated according to normal left-to-right evaluation rules, but its\nvalue is ignored.\nsetf of getf is permitted to either write the value of place itself, or\nmodify of any part, car or cdr, of the list structure held by place.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq x '()) =>  NIL\n      (getf x 'prop1) =>  NIL\n      (getf x 'prop1 7) =>  7\n      (getf x 'prop1) =>  NIL\n      (setf (getf x 'prop1) 'val1) =>  VAL1\n      (eq (getf x 'prop1) 'val1) =>  true\n      (getf x 'prop1) =>  VAL1\n      (getf x 'prop1 7) =>  VAL1\n      x =>  (PROP1 VAL1)\n     ;; Examples of implementation variation permitted.\n      (setq foo (list 'a 'b 'c 'd 'e 'f)) =>  (A B C D E F)\n      (setq bar (cddr foo)) =>  (C D E F)\n      (remf foo 'c) =>  true\n      foo =>  (A B E F)\n      bar\n     =>  (C D E F)\n     OR=> (C)\n     OR=> (NIL)\n     OR=> (C NIL)\n     OR=> (C D)\n"
        },
        {
            "type": "See Also",
            "text": "*Note get:: , *Note get-properties:: , *Note setf; psetf:: , *Note\nFunction Call Forms as Places::\n"
        },
        {
            "type": "Notes",
            "text": "There is no way (using getf) to distinguish an absent property from one\nwhose value is default; but see get-properties.\nNote that while supplying a default argument to getf in a setf situation\nis sometimes not very interesting, it is still important because some\nmacros, such as push and incf, require a place argument which data is both\nread from and written to.  In such a context, if a default argument is to\nbe supplied for the read situation, it must be syntactically valid for the\nwrite situation as well. For example,\n      (let ((plist '()))\n        (incf (getf plist 'count 0))\n        plist) =>  (COUNT 1)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: getf,  Next: remf,  Prev: get-properties,  Up: Conses Dictionary\n\ngetf                                                             [Accessor]\n---------------------------------------------------------------------------\n\n`getf'  plist indicator &optional default =>  value\n\n(setf (`         getf' place indicator &optional default) new-value)\nArguments and Values::\n......................\n\nplist--a property list.\n\nplace--a place, the value of which is a property list.\n\nindicator--an object.\n\ndefault--an object.  The default is nil.\n\nvalue--an object.\n\nnew-value--an object.\n\nDescription::\n.............\n\ngetf finds a property on the plist whose property indicator is identical\nto indicator, and returns its corresponding property value.\n\nIf there are multiple properties_1 with that property indicator, getf uses\nthe first such property.\n\nIf there is no property with that property indicator, default is returned.\n\nsetf of getf may be used to associate a new object with an existing\nindicator in the property list held by place, or to create a new\nassocation if none exists.\n\nIf there are multiple properties_1 with that property indicator, setf of\ngetf associates the new-value with the first such property.\n\nWhen a getf form is used as a setf place, any default which is supplied is\nevaluated according to normal left-to-right evaluation rules, but its\nvalue is ignored.\n\nsetf of getf is permitted to either write the value of place itself, or\nmodify of any part, car or cdr, of the list structure held by place.\n\nExamples::\n..........\n\n      (setq x '()) =>  NIL\n      (getf x 'prop1) =>  NIL\n      (getf x 'prop1 7) =>  7\n      (getf x 'prop1) =>  NIL\n      (setf (getf x 'prop1) 'val1) =>  VAL1\n      (eq (getf x 'prop1) 'val1) =>  true\n      (getf x 'prop1) =>  VAL1\n      (getf x 'prop1 7) =>  VAL1\n      x =>  (PROP1 VAL1)\n     \n     ;; Examples of implementation variation permitted.\n      (setq foo (list 'a 'b 'c 'd 'e 'f)) =>  (A B C D E F)\n      (setq bar (cddr foo)) =>  (C D E F)\n      (remf foo 'c) =>  true\n      foo =>  (A B E F)\n      bar\n     =>  (C D E F)\n     OR=> (C)\n     OR=> (NIL)\n     OR=> (C NIL)\n     OR=> (C D)\n\nSee Also::\n..........\n\n*Note get:: , *Note get-properties:: , *Note setf; psetf:: , *Note\nFunction Call Forms as Places::\n\nNotes::\n.......\n\nThere is no way (using getf) to distinguish an absent property from one\nwhose value is default; but see get-properties.\n\nNote that while supplying a default argument to getf in a setf situation\nis sometimes not very interesting, it is still important because some\nmacros, such as push and incf, require a place argument which data is both\nread from and written to.  In such a context, if a default argument is to\nbe supplied for the read situation, it must be syntactically valid for the\nwrite situation as well. For example,\n\n      (let ((plist '()))\n        (incf (getf plist 'count 0))\n        plist) =>  (COUNT 1)\n\n"
}