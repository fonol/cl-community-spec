{
    "name": "defpackage",
    "prev": "use-package",
    "next": "do-symbols",
    "up": "Packages Dictionary",
    "header": {
        "type": "Macro",
        "text": "defpackage"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "defpackage",
                    "text": " defined-package-name [[!option]] =>  package\noption ::={(:nicknames {nickname}*)}* | \n           (:documentation string) | \n           {(:use {package-name}*)}* | \n           {(:shadow {!symbol-name}*)}* | \n           {(:shadowing-import-from package-name {!symbol-name}*)}* | \n           {(:import-from package-name {!symbol-name}*)}* | \n           {(:export {!symbol-name}*)}* | \n           {(:intern {!symbol-name}*)}* |             (:size integer)\n\nsymbol-name ::=(symbol | string)\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "defined-package-name",
                    "desc": "a string designator."
                },
                {
                    "name": "package-name",
                    "desc": "a package designator."
                },
                {
                    "name": "nickname",
                    "desc": "a string designator."
                },
                {
                    "name": "symbol-name",
                    "desc": "a string designator."
                },
                {
                    "name": "package",
                    "desc": "the package named package-name."
                }
            ]
        },
        {
            "type": "Description",
            "text": "defpackage creates a package as specified and returns the package.\nIf defined-package-name already refers to an existing package, the\nname-to-package mapping for that name is not changed.  If the new\ndefinition is at variance with the current state of that package, the\nconsequences are undefined;  an implementation might choose to modify the\nexisting package to reflect the new definition.  If defined-package-name\nis a symbol, its name is used.\nThe standard options are described below.\n:nicknames\n     The arguments to :nicknames set the package's nicknames to the\n     supplied names.\n:documentation\n     The argument to :documentation specifies a documentation string; it\n     is attached as a documentation string to the package.  At most one\n     :documentation option can appear in a single defpackage form.\n:use\n     The arguments to :use set the packages that the package named by\n     package-name will inherit from. If :use is not supplied,\n     it defaults to the same implementation-dependent value as the :use\n     argument to make-package.\n:shadow\n     The arguments to :shadow, symbol-names, name symbols that are to be\n     created in the package being defined.  These symbols are added to the\n     list of shadowing symbols effectively as if by shadow.\n:shadowing-import-from\n     The symbols named by the argument symbol-names are found (involving a\n     lookup as if by find-symbol) in the specified package-name.  The\n     resulting symbols are imported into the package being defined, and\n     placed on the shadowing symbols list as if by shadowing-import.  In\n     no case are symbols created in any package other than the one being\n     defined.\n:import-from\n     The symbols named by the argument symbol-names are found in the\n     package named by package-name and they are imported into the package\n     being defined.  In no case are symbols created in any package other\n     than the one being defined.\n:export\n     The symbols named by the argument symbol-names  are found or created\n     in the package being defined and exported.  The :export option\n     interacts with the :use option, since inherited symbols can be used\n     rather than new ones created.  The :export option interacts with the\n     :import-from and :shadowing-import-from options, since imported\n     symbols can be used rather than new ones created.  If an argument to\n     the :export option is accessible as an (inherited) internal symbol\n     via use-package, that the symbol named by symbol-name is first\n     imported into the package being defined, and is then exported from\n     that package.\n:intern\n     The symbols named by the argument symbol-names are found or created\n     in the package being defined.  The :intern option interacts with the\n     :use option, since inherited symbols can be used rather than new ones\n     created.\n:size\n     The argument to the :size option declares the approximate number of\n     symbols expected in the package.  This is an efficiency hint only and\n     might be ignored by an implementation.\nThe order in which the options appear in a defpackage form is irrelevant.\nThe order in which they are executed is as follows:\n1.\n     :shadow and :shadowing-import-from.\n2.\n     :use.\n3.\n     :import-from and :intern.\n4.\n     :export.\nShadows are established first, since they might  be necessary to block\nspurious name conflicts when the :use option is processed. The :use option\nis executed next so that :intern and :export options can refer to normally\ninherited symbols.  The :export option is executed last so that it can\nrefer to symbols created by any of the other options; in particular,\nshadowing symbols and imported symbols can be made external.\nIf a defpackage form appears as a top level form, all of the actions\nnormally performed by this macro at load time must also be performed at\ncompile time.\n"
        },
        {
            "type": "Examples",
            "text": "      (defpackage \"MY-PACKAGE\"\n        (:nicknames \"MYPKG\" \"MY-PKG\")\n        (:use \"COMMON-LISP\")\n        (:shadow \"CAR\" \"CDR\")\n        (:shadowing-import-from \"VENDOR-COMMON-LISP\"  \"CONS\")\n        (:import-from \"VENDOR-COMMON-LISP\"  \"GC\")\n        (:export \"EQ\" \"CONS\" \"FROBOLA\")\n        )\n      (defpackage my-package\n        (:nicknames mypkg :MY-PKG)  ; remember Common Lisp conventions for case\n        (:use common-lisp)          ; conversion on symbols\n        (:shadow CAR :cdr #:cons)\n        (:export \"CONS\")            ; this is the shadowed one.\n        )\n"
        },
        {
            "type": "Affected By",
            "text": "Existing packages.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If one of the supplied :nicknames already refers to an existing package,\nan error of type package-error is signaled.\nAn error of type program-error should be signaled if :size or\n:documentation appears more than once.\nSince implementations might allow extended options an error of type\nprogram-error should be signaled if an option is present that is not\nactually supported in the host implementation.\nThe collection of symbol-name arguments given to the options :shadow,\n:intern, :import-from, and :shadowing-import-from must all be disjoint;\nadditionally, the symbol-name arguments given to :export and :intern must\nbe disjoint.  Disjoint in this context is defined as no two of the\nsymbol-names being string= with each other. If either condition is\nviolated, an error of type program-error should be signaled.\nFor the :shadowing-import-from and :import-from options, a correctable\nerror of type package-error is signaled if no symbol is accessible in the\npackage named by package-name for one of the argument symbol-names.\nName conflict errors are handled by the underlying calls to make-package,\nuse-package, import, and export. See *Note Package Concepts::.\n"
        },
        {
            "type": "See Also",
            "text": "*Note documentation; (setf documentation):: , *Note Package Concepts::,\n*Note Compilation::\n"
        },
        {
            "type": "Notes",
            "text": "The :intern option is useful if an :import-from or a\n:shadowing-import-from option in a subsequent call to defpackage (for some\nother package) expects to find these symbols accessible but not\nnecessarily external.\nIt is recommended that the entire package definition is put in a single\nplace, and that all the package definitions of a program are in a single\nfile.  This file can be loaded before loading or compiling anything else\nthat depends on those packages. Such a file can be read in the\nCOMMON-LISP-USER package, avoiding any initial state issues.\ndefpackage cannot be used to create two \"mutually recursive\" packages,\nsuch as:\n      (defpackage my-package\n        (:use common-lisp your-package)    ;requires your-package to exist first\n        (:export \"MY-FUN\"))\n      (defpackage your-package\n        (:use common-lisp)\n        (:import-from my-package \"MY-FUN\") ;requires my-package to exist first\n        (:export \"MY-FUN\"))\nHowever, nothing prevents the user from using the package-affecting\nfunctions such as use-package, import, and export to establish such links\nafter a more standard use of defpackage.\nThe macroexpansion of defpackage could usefully canonicalize the names\ninto strings, so that even if a source file has random symbols in the\ndefpackage form, the compiled file would only contain strings.\nFrequently additional implementation-dependent options take the form of a\nkeyword standing by itself as an abbreviation for a list (keyword T); this\nsyntax should be properly reported as an unrecognized option in\nimplementations that do not support it.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: defpackage,  Next: do-symbols,  Prev: use-package,  Up: Packages Dictionary\n\ndefpackage                                                          [Macro]\n---------------------------------------------------------------------------\n\n`defpackage'  defined-package-name [[!option]] =>  package\n\noption ::={(:nicknames {nickname}*)}* | \n           (:documentation string) | \n           {(:use {package-name}*)}* | \n           {(:shadow {!symbol-name}*)}* | \n           {(:shadowing-import-from package-name {!symbol-name}*)}* | \n           {(:import-from package-name {!symbol-name}*)}* | \n           {(:export {!symbol-name}*)}* | \n           {(:intern {!symbol-name}*)}* |             (:size integer)\n\nsymbol-name ::=(symbol | string)\n\nArguments and Values::\n......................\n\ndefined-package-name--a string designator.\n\npackage-name--a package designator.\n\nnickname--a string designator.\n\nsymbol-name--a string designator.\n\npackage--the package named package-name.\n\nDescription::\n.............\n\ndefpackage creates a package as specified and returns the package.\n\nIf defined-package-name already refers to an existing package, the\nname-to-package mapping for that name is not changed.  If the new\ndefinition is at variance with the current state of that package, the\nconsequences are undefined;  an implementation might choose to modify the\nexisting package to reflect the new definition.  If defined-package-name\nis a symbol, its name is used.\n\nThe standard options are described below.\n\n:nicknames\n     The arguments to :nicknames set the package's nicknames to the\n     supplied names.\n\n:documentation\n     The argument to :documentation specifies a documentation string; it\n     is attached as a documentation string to the package.  At most one\n     :documentation option can appear in a single defpackage form.\n\n:use\n     The arguments to :use set the packages that the package named by\n     package-name will inherit from. If :use is not supplied,\n\n     it defaults to the same implementation-dependent value as the :use\n     argument to make-package.\n\n:shadow\n     The arguments to :shadow, symbol-names, name symbols that are to be\n     created in the package being defined.  These symbols are added to the\n     list of shadowing symbols effectively as if by shadow.\n\n:shadowing-import-from\n     The symbols named by the argument symbol-names are found (involving a\n     lookup as if by find-symbol) in the specified package-name.  The\n     resulting symbols are imported into the package being defined, and\n     placed on the shadowing symbols list as if by shadowing-import.  In\n     no case are symbols created in any package other than the one being\n     defined.\n\n:import-from\n     The symbols named by the argument symbol-names are found in the\n     package named by package-name and they are imported into the package\n     being defined.  In no case are symbols created in any package other\n     than the one being defined.\n\n:export\n     The symbols named by the argument symbol-names  are found or created\n     in the package being defined and exported.  The :export option\n     interacts with the :use option, since inherited symbols can be used\n     rather than new ones created.  The :export option interacts with the\n     :import-from and :shadowing-import-from options, since imported\n     symbols can be used rather than new ones created.  If an argument to\n     the :export option is accessible as an (inherited) internal symbol\n     via use-package, that the symbol named by symbol-name is first\n     imported into the package being defined, and is then exported from\n     that package.\n\n:intern\n     The symbols named by the argument symbol-names are found or created\n     in the package being defined.  The :intern option interacts with the\n     :use option, since inherited symbols can be used rather than new ones\n     created.\n\n:size\n     The argument to the :size option declares the approximate number of\n     symbols expected in the package.  This is an efficiency hint only and\n     might be ignored by an implementation.\n\nThe order in which the options appear in a defpackage form is irrelevant.\nThe order in which they are executed is as follows:\n1.\n     :shadow and :shadowing-import-from.\n\n2.\n     :use.\n\n3.\n     :import-from and :intern.\n\n4.\n     :export.\n\nShadows are established first, since they might  be necessary to block\nspurious name conflicts when the :use option is processed. The :use option\nis executed next so that :intern and :export options can refer to normally\ninherited symbols.  The :export option is executed last so that it can\nrefer to symbols created by any of the other options; in particular,\nshadowing symbols and imported symbols can be made external.\n\nIf a defpackage form appears as a top level form, all of the actions\nnormally performed by this macro at load time must also be performed at\ncompile time.\n\nExamples::\n..........\n\n      (defpackage \"MY-PACKAGE\"\n        (:nicknames \"MYPKG\" \"MY-PKG\")\n        (:use \"COMMON-LISP\")\n        (:shadow \"CAR\" \"CDR\")\n        (:shadowing-import-from \"VENDOR-COMMON-LISP\"  \"CONS\")\n        (:import-from \"VENDOR-COMMON-LISP\"  \"GC\")\n        (:export \"EQ\" \"CONS\" \"FROBOLA\")\n        )\n     \n      (defpackage my-package\n        (:nicknames mypkg :MY-PKG)  ; remember Common Lisp conventions for case\n        (:use common-lisp)          ; conversion on symbols\n        (:shadow CAR :cdr #:cons)\n        (:export \"CONS\")            ; this is the shadowed one.\n        )\n\nAffected By::\n.............\n\nExisting packages.\n\nExceptional Situations::\n........................\n\nIf one of the supplied :nicknames already refers to an existing package,\nan error of type package-error is signaled.\n\nAn error of type program-error should be signaled if :size or\n:documentation appears more than once.\n\nSince implementations might allow extended options an error of type\nprogram-error should be signaled if an option is present that is not\nactually supported in the host implementation.\n\nThe collection of symbol-name arguments given to the options :shadow,\n:intern, :import-from, and :shadowing-import-from must all be disjoint;\nadditionally, the symbol-name arguments given to :export and :intern must\nbe disjoint.  Disjoint in this context is defined as no two of the\nsymbol-names being string= with each other. If either condition is\nviolated, an error of type program-error should be signaled.\n\nFor the :shadowing-import-from and :import-from options, a correctable\nerror of type package-error is signaled if no symbol is accessible in the\npackage named by package-name for one of the argument symbol-names.\n\nName conflict errors are handled by the underlying calls to make-package,\nuse-package, import, and export. See *Note Package Concepts::.\n\nSee Also::\n..........\n\n*Note documentation; (setf documentation):: , *Note Package Concepts::,\n*Note Compilation::\n\nNotes::\n.......\n\nThe :intern option is useful if an :import-from or a\n:shadowing-import-from option in a subsequent call to defpackage (for some\nother package) expects to find these symbols accessible but not\nnecessarily external.\n\nIt is recommended that the entire package definition is put in a single\nplace, and that all the package definitions of a program are in a single\nfile.  This file can be loaded before loading or compiling anything else\nthat depends on those packages. Such a file can be read in the\nCOMMON-LISP-USER package, avoiding any initial state issues.\n\ndefpackage cannot be used to create two \"mutually recursive\" packages,\nsuch as:\n\n      (defpackage my-package\n        (:use common-lisp your-package)    ;requires your-package to exist first\n        (:export \"MY-FUN\"))\n      (defpackage your-package\n        (:use common-lisp)\n        (:import-from my-package \"MY-FUN\") ;requires my-package to exist first\n        (:export \"MY-FUN\"))\n\nHowever, nothing prevents the user from using the package-affecting\nfunctions such as use-package, import, and export to establish such links\nafter a more standard use of defpackage.\n\nThe macroexpansion of defpackage could usefully canonicalize the names\ninto strings, so that even if a source file has random symbols in the\ndefpackage form, the compiled file would only contain strings.\n\nFrequently additional implementation-dependent options take the form of a\nkeyword standing by itself as an abbreviation for a list (keyword T); this\nsyntax should be properly reported as an unrecognized option in\nimplementations that do not support it.\n\n"
}