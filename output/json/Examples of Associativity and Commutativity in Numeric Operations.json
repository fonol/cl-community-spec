{
    "name": "Examples of Associativity and Commutativity in Numeric Operations",
    "prev": "Associativity and Commutativity in Numeric Operations",
    "next": "Contagion in Numeric Operations",
    "up": "Numeric Operations",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Examples of Associativity and Commutativity in Numeric Operations",
            "text": "Consider the following expression, in which we assume that 1.0 and 1.0e-15\nboth denote single floats:\n      (+ 1/3 2/3 1.0d0 1.0 1.0e-15)\nOne conforming implementation might process the arguments from left to\nright, first adding 1/3 and 2/3 to get 1, then converting that to a double\nfloat for combination with 1.0d0, then successively converting and adding\n1.0 and 1.0e-15.\nAnother conforming implementation might process the arguments from right\nto left, first performing a single float addition of 1.0 and 1.0e-15\n(perhaps losing accuracy in the process), then converting the sum to a\ndouble float and adding 1.0d0, then converting 2/3 to a double float and\nadding it, and then converting 1/3 and adding that.\nA third conforming implementation might first scan all the arguments,\nprocess all the rationals first to keep that part of the computation exact,\nthen find an argument of the largest floating-point format among all the\narguments and add that, and then add in all other arguments, converting\neach in turn (all in a perhaps misguided attempt to make the computation\nas accurate as possible).\nIn any case, all three strategies are legitimate.\nA conforming program could control the order by writing, for example,\n      (+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Examples of Associativity and Commutativity in Numeric Operations,  Next: Contagion in Numeric Operations,  Prev: Associativity and Commutativity in Numeric Operations,  Up: Numeric Operations\n\nExamples of Associativity and Commutativity in Numeric Operations\n.................................................................\n\nConsider the following expression, in which we assume that 1.0 and 1.0e-15\nboth denote single floats:\n\n      (+ 1/3 2/3 1.0d0 1.0 1.0e-15)\n\nOne conforming implementation might process the arguments from left to\nright, first adding 1/3 and 2/3 to get 1, then converting that to a double\nfloat for combination with 1.0d0, then successively converting and adding\n1.0 and 1.0e-15.\n\nAnother conforming implementation might process the arguments from right\nto left, first performing a single float addition of 1.0 and 1.0e-15\n(perhaps losing accuracy in the process), then converting the sum to a\ndouble float and adding 1.0d0, then converting 2/3 to a double float and\nadding it, and then converting 1/3 and adding that.\n\nA third conforming implementation might first scan all the arguments,\nprocess all the rationals first to keep that part of the computation exact,\nthen find an argument of the largest floating-point format among all the\narguments and add that, and then add in all other arguments, converting\neach in turn (all in a perhaps misguided attempt to make the computation\nas accurate as possible).\n\nIn any case, all three strategies are legitimate.\n\nA conforming program could control the order by writing, for example,\n\n      (+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)\n\n"
}