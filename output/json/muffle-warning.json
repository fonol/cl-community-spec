{
    "name": "muffle-warning",
    "prev": "continue",
    "next": "store-value",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Restart",
        "text": "muffle-warning"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Data Arguments Required",
            "text": "None.\n"
        },
        {
            "type": "Description",
            "text": "This restart is established by warn so that handlers of warning conditions\nhave a way to tell warn that a warning has already been dealt with and\nthat no further action is warranted.\n"
        },
        {
            "type": "Examples",
            "text": "      (defvar *all-quiet* nil) =>  *ALL-QUIET*\n      (defvar *saved-warnings* '()) =>  *SAVED-WARNINGS*\n      (defun quiet-warning-handler (c)\n        (when *all-quiet*\n          (let ((r (find-restart 'muffle-warning c)))\n            (when r\n              (push c *saved-warnings*)\n              (invoke-restart r)))))\n     =>  CUSTOM-WARNING-HANDLER\n      (defmacro with-quiet-warnings (&body forms)\n        `(let ((*all-quiet* t)\n               (*saved-warnings* '()))\n           (handler-bind ((warning #'quiet-warning-handler))\n             ,@forms\n             *saved-warnings*)))\n     =>  WITH-QUIET-WARNINGS\n      (setq saved\n        (with-quiet-warnings\n          (warn \"Situation #1.\")\n          (let ((*all-quiet* nil))\n            (warn \"Situation #2.\"))\n          (warn \"Situation #3.\")))\n      |>  Warning: Situation #2.\n     =>  (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)\n      (dolist (s saved) (format t \"~&~A~\n      |>  Situation #3.\n      |>  Situation #1.\n     =>  NIL\n"
        },
        {
            "type": "See Also",
            "text": "*Note Restarts::, *Note Interfaces to Restarts::, *Note invoke-restart:: ,\n*Note muffle-warning:: (function), *Note warn::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: muffle-warning,  Next: store-value,  Prev: continue,  Up: Conditions Dictionary\n\nmuffle-warning                                                    [Restart]\n---------------------------------------------------------------------------\n\nData Arguments Required::\n.........................\n\nNone.\n\nDescription::\n.............\n\nThis restart is established by warn so that handlers of warning conditions\nhave a way to tell warn that a warning has already been dealt with and\nthat no further action is warranted.\n\nExamples::\n..........\n\n      (defvar *all-quiet* nil) =>  *ALL-QUIET*\n      (defvar *saved-warnings* '()) =>  *SAVED-WARNINGS*\n      (defun quiet-warning-handler (c)\n        (when *all-quiet*\n          (let ((r (find-restart 'muffle-warning c)))\n            (when r\n              (push c *saved-warnings*)\n              (invoke-restart r)))))\n     =>  CUSTOM-WARNING-HANDLER\n      (defmacro with-quiet-warnings (&body forms)\n        `(let ((*all-quiet* t)\n               (*saved-warnings* '()))\n           (handler-bind ((warning #'quiet-warning-handler))\n             ,@forms\n             *saved-warnings*)))\n     =>  WITH-QUIET-WARNINGS\n      (setq saved\n        (with-quiet-warnings\n          (warn \"Situation #1.\")\n          (let ((*all-quiet* nil))\n            (warn \"Situation #2.\"))\n          (warn \"Situation #3.\")))\n      |>  Warning: Situation #2.\n     =>  (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)\n      (dolist (s saved) (format t \"~&~A~\n      |>  Situation #3.\n      |>  Situation #1.\n     =>  NIL\n\nSee Also::\n..........\n\n*Note Restarts::, *Note Interfaces to Restarts::, *Note invoke-restart:: ,\n*Note muffle-warning:: (function), *Note warn::\n\n"
}