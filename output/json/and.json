{
    "name": "and",
    "prev": "every",
    "next": "cond",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "and"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "and",
                    "text": " {form}* =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "form",
                    "desc": "a form."
                },
                {
                    "name": "results",
                    "desc": "the values resulting from the evaluation of the last form, or the"
                }
            ]
        },
        {
            "type": "Description",
            "text": "The macro and evaluates each form one at a time from left to right.  As\nsoon as any form evaluates to nil, and returns nil without evaluating the\nremaining forms.  If all forms but the last evaluate to true values, and\nreturns the results produced by evaluating the last form.\nIf no forms are supplied, (and) returns t.\nand passes back multiple values from the last subform but not from\nsubforms other than the last.\n"
        },
        {
            "type": "Examples",
            "text": "      (if (and (>= n 0)\n               (< n (length a-simple-vector))\n               (eq (elt a-simple-vector n) 'foo))\n          (princ \"Foo!\"))\nThe above expression prints Foo! if element n of a-simple-vector is the\nsymbol foo, provided also that n is indeed a valid index for\na-simple-vector.  Because and guarantees left-to-right testing of its\nparts, elt is not called if n is out of range.\n      (setq temp1 1 temp2 1 temp3 1) =>  1\n      (and (incf temp1) (incf temp2) (incf temp3)) =>  2\n      (and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) =>  true\n      (decf temp3) =>  1\n      (and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) =>  NIL\n      (and (eql temp1 temp2) (eql temp2 temp3)) =>  true\n      (and) =>  T\n"
        },
        {
            "type": "See Also",
            "text": "*Note cond:: , *Note every; some; notevery; notany:: , *Note if:: , *Note\nor:: , *Note when; unless::\n"
        },
        {
            "type": "Notes",
            "text": "      (and form) == (let () form)\n      (and form1 form2 ...) == (when form1 (and form2 ...))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: and,  Next: cond,  Prev: every,  Up: Data and Control Flow Dictionary\n\nand                                                                 [Macro]\n---------------------------------------------------------------------------\n\n`and'  {form}* =>  {result}*\n\nArguments and Values::\n......................\n\nform--a form.\n\nresults--the values resulting from the evaluation of the last form, or the\nsymbols nil or t.\n\nDescription::\n.............\n\nThe macro and evaluates each form one at a time from left to right.  As\nsoon as any form evaluates to nil, and returns nil without evaluating the\nremaining forms.  If all forms but the last evaluate to true values, and\nreturns the results produced by evaluating the last form.\n\nIf no forms are supplied, (and) returns t.\n\nand passes back multiple values from the last subform but not from\nsubforms other than the last.\n\nExamples::\n..........\n\n      (if (and (>= n 0)\n               (< n (length a-simple-vector))\n               (eq (elt a-simple-vector n) 'foo))\n          (princ \"Foo!\"))\n\nThe above expression prints Foo! if element n of a-simple-vector is the\nsymbol foo, provided also that n is indeed a valid index for\na-simple-vector.  Because and guarantees left-to-right testing of its\nparts, elt is not called if n is out of range.\n\n      (setq temp1 1 temp2 1 temp3 1) =>  1\n      (and (incf temp1) (incf temp2) (incf temp3)) =>  2\n      (and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) =>  true\n      (decf temp3) =>  1\n      (and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) =>  NIL\n      (and (eql temp1 temp2) (eql temp2 temp3)) =>  true\n      (and) =>  T\n\nSee Also::\n..........\n\n*Note cond:: , *Note every; some; notevery; notany:: , *Note if:: , *Note\nor:: , *Note when; unless::\n\nNotes::\n.......\n\n      (and form) == (let () form)\n      (and form1 form2 ...) == (when form1 (and form2 ...))\n\n"
}