{
    "name": "adjust-array",
    "prev": "make-array",
    "next": "adjustable-array-p",
    "up": "Arrays Dictionary",
    "header": {
        "type": "Function",
        "text": "adjust-array"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "adjust-array",
                    "text": " array new-dimensions &key element-type initial-elementinitial-contents fill-pointer displaced-to displaced-index-offset\n=>  adjusted-array\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "array",
                    "desc": "an array."
                },
                {
                    "name": "new-dimensions",
                    "desc": "a valid array dimension or a list of valid array"
                },
                {
                    "name": "new-dimensions",
                    "desc": "a valid array dimension or a list of valid arraydimensions.\n"
                },
                {
                    "name": "element-type",
                    "desc": "a type specifier."
                },
                {
                    "name": "initial-element",
                    "desc": "an object.  Initial-element must not be supplied if either"
                },
                {
                    "name": "initial-element",
                    "desc": "an object.  Initial-element must not be supplied if eitherinitial-contents or displaced-to is supplied.\n"
                },
                {
                    "name": "initial-contents",
                    "desc": "an object.  If array has rank greater than zero, theninitial-contents is composed of nested sequences, the depth of which must\nequal the rank of array.  Otherwise, array is zero-dimensional and\ninitial-contents supplies the single element.  initial-contents must not\nbe supplied if either initial-element or displaced-to is given.\n"
                },
                {
                    "name": "fill-pointer",
                    "desc": "a valid fill pointer for the array to be created, or t, or"
                },
                {
                    "name": "fill-pointer",
                    "desc": "a valid fill pointer for the array to be created, or t, ornil.  The default is nil.\n"
                },
                {
                    "name": "displaced-to",
                    "desc": "an array or nil.  initial-elements and initial-contents must"
                },
                {
                    "name": "displaced-to",
                    "desc": "an array or nil.  initial-elements and initial-contents mustnot be supplied if displaced-to is supplied.\n"
                },
                {
                    "name": "displaced-index-offset",
                    "desc": "an object of type (fixnum 0 n) where n is(array-total-size displaced-to).  displaced-index-offset may be supplied\nonly if displaced-to is supplied.\n"
                },
                {
                    "name": "adjusted-array",
                    "desc": "an array."
                }
            ]
        },
        {
            "type": "Description",
            "text": "adjust-array changes the dimensions or elements of array.  The result is\nan array of the same type and rank as array, that is either the modified\narray, or a newly created array to which array can be displaced, and that\nhas the given new-dimensions.\nNew-dimensions specify the size of each dimension of array.\nElement-type specifies the type of the elements of the resulting array.\nIf element-type is supplied, the consequences are unspecified if the\nupgraded array element type of element-type is not the same as the actual\narray element type of array.\nIf initial-contents is supplied, it is treated as for make-array.  In this\ncase none of the original contents of array appears in the resulting array.\nIf fill-pointer is an integer, it becomes the fill pointer for the\nresulting array.  If fill-pointer is the symbol t, it indicates that the\nsize of the resulting array should be used as the fill pointer.  If\nfill-pointer is nil, it indicates that the fill pointer should be left as\nit is.\nIf displaced-to non-nil, a displaced array is created. The resulting array\nshares its contents with the array given by displaced-to.  The resulting\narray cannot contain more elements than the array it is displaced to.  If\ndisplaced-to is not supplied or nil, the resulting array is not a\ndisplaced array.  If array A is created displaced to array B and\nsubsequently array B is given to adjust-array, array A will still be\ndisplaced to array B.  Although array might be a displaced array, the\nresulting array is not a displaced array unless displaced-to is supplied\nand not nil.\nThe interaction between adjust-array and displaced arrays is as follows\ngiven three arrays, A, B, and~C:\nA is not displaced before or after the call\n           (adjust-array A ...)\n     The dimensions of A are altered, and the contents rearranged as\n     appropriate.  Additional elements of A are taken from initial-element.\n     The use of initial-contents causes all old contents to be discarded.\nA is not displaced before, but is displaced to\n     C after the call\n           (adjust-array A ... :displaced-to C)\n     None of the original contents of A appears in A afterwards; A now\n     contains the contents of C, without any rearrangement of C.\nA is displaced to B\n     before the call, and is displaced to C after the call\n           (adjust-array A ... :displaced-to B)\n           (adjust-array A ... :displaced-to C)\n     B and C might be the same. The contents of B do not appear in A\n     afterward unless such contents also happen to be in C  If\n     displaced-index-offset is not supplied in the adjust-array call, it\n     defaults to zero; the old offset into B is not retained.\nA is displaced to B before the call, but not displaced\n     afterward.\n           (adjust-array A ... :displaced-to B)\n           (adjust-array A ... :displaced-to nil)\n     A gets a new \"data region,\" and contents of B are copied into it as\n     appropriate to maintain the existing old contents; additional\n     elements of A are taken from initial-element if supplied.  However,\n     the use of initial-contents causes all old contents to be discarded.\nIf displaced-index-offset is supplied, it specifies the offset of the\nresulting array from the beginning of the array that it is displaced to.\nIf displaced-index-offset is not supplied, the offset is~0.  The size of\nthe resulting array plus the offset value cannot exceed the size of the\narray that it is displaced to.\nIf only new-dimensions and an initial-element argument are supplied, those\nelements of array that are still in bounds appear in the resulting array.\nThe elements of the resulting array that are not in the bounds of array\nare initialized to initial-element; if initial-element is not provided,\nthe consequences of later reading any such new element of new-array before\nit has been initialized are undefined.\nIf initial-contents or displaced-to is supplied, then none of the original\ncontents of array appears in the new array.\nThe consequences are unspecified if array is adjusted to a size smaller\nthan its fill pointer without supplying the fill-pointer argument so that\nits fill-pointer is properly adjusted in the process.\nIf A is displaced to B, the consequences are unspecified if B is adjusted\nin such a way that it no longer has enough elements to satisfy A.\nIf adjust-array is applied to an array that is actually adjustable, the\narray returned is identical to array.  If the array returned by\nadjust-array is distinct from array, then the argument array is unchanged.\nNote that if an array A is displaced to another array B, and B is\ndisplaced to another array C, and B is altered by adjust-array, A must now\nrefer to the adjust contents of B.  This means that an implementation\ncannot collapse the chain to make A refer to C directly and forget that\nthe chain of reference passes through B.  However, caching techniques are\npermitted as long as they preserve the semantics specified here.\n"
        },
        {
            "type": "Examples",
            "text": "      (adjustable-array-p\n       (setq ada (adjust-array\n                   (make-array '(2 3)\n                               :adjustable t\n                               :initial-contents '((a b c) (1 2 3)))\n                   '(4 6)))) =>  T\n      (array-dimensions ada) =>  (4 6)\n      (aref ada 1 1) =>  2\n      (setq beta (make-array '(2 3) :adjustable t))\n     =>  #2A((NIL NIL NIL) (NIL NIL NIL))\n      (adjust-array beta '(4 6) :displaced-to ada)\n     =>  #2A((A B C NIL NIL NIL)\n            (1 2 3 NIL NIL NIL)\n            (NIL NIL NIL NIL NIL NIL)\n            (NIL NIL NIL NIL NIL NIL))\n      (array-dimensions beta) =>  (4 6)\n      (aref beta 1 1) =>  2\nSuppose that the 4-by-4 array in m looks like this:\n     #2A(( alpha     beta      gamma     delta )\n         ( epsilon   zeta      eta       theta )\n         ( iota      kappa     lambda    mu    )\n         ( nu        xi        omicron   pi    ))\nThen the result of\n      (adjust-array m '(3 5) :initial-element 'baz)\nis a 3-by-5 array with contents\n     #2A(( alpha     beta      gamma     delta     baz )\n         ( epsilon   zeta      eta       theta     baz )\n         ( iota      kappa     lambda    mu        baz ))\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "An error of type error is signaled if fill-pointer is supplied and non-nil\nbut array has no fill pointer.\n"
        },
        {
            "type": "See Also",
            "text": "*Note adjustable-array-p:: , *Note make-array:: , *Note\narray-dimension-limit:: , *Note array-total-size-limit:: , array\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: adjust-array,  Next: adjustable-array-p,  Prev: make-array,  Up: Arrays Dictionary\n\nadjust-array                                                     [Function]\n---------------------------------------------------------------------------\n\n`adjust-array'  array new-dimensions &key element-type initial-element\ninitial-contents fill-pointer displaced-to displaced-index-offset\n=>  adjusted-array\n\nArguments and Values::\n......................\n\narray--an array.\n\nnew-dimensions--a valid array dimension or a list of valid array\ndimensions.\n\nelement-type--a type specifier.\n\ninitial-element--an object.  Initial-element must not be supplied if either\ninitial-contents or displaced-to is supplied.\n\ninitial-contents--an object.  If array has rank greater than zero, then\ninitial-contents is composed of nested sequences, the depth of which must\nequal the rank of array.  Otherwise, array is zero-dimensional and\ninitial-contents supplies the single element.  initial-contents must not\nbe supplied if either initial-element or displaced-to is given.\n\nfill-pointer--a valid fill pointer for the array to be created, or t, or\nnil.  The default is nil.\n\ndisplaced-to--an array or nil.  initial-elements and initial-contents must\nnot be supplied if displaced-to is supplied.\n\ndisplaced-index-offset--an object of type (fixnum 0 n) where n is\n(array-total-size displaced-to).  displaced-index-offset may be supplied\nonly if displaced-to is supplied.\n\nadjusted-array--an array.\n\nDescription::\n.............\n\nadjust-array changes the dimensions or elements of array.  The result is\nan array of the same type and rank as array, that is either the modified\narray, or a newly created array to which array can be displaced, and that\nhas the given new-dimensions.\n\nNew-dimensions specify the size of each dimension of array.\n\nElement-type specifies the type of the elements of the resulting array.\nIf element-type is supplied, the consequences are unspecified if the\nupgraded array element type of element-type is not the same as the actual\narray element type of array.\n\nIf initial-contents is supplied, it is treated as for make-array.  In this\ncase none of the original contents of array appears in the resulting array.\n\nIf fill-pointer is an integer, it becomes the fill pointer for the\nresulting array.  If fill-pointer is the symbol t, it indicates that the\nsize of the resulting array should be used as the fill pointer.  If\nfill-pointer is nil, it indicates that the fill pointer should be left as\nit is.\n\nIf displaced-to non-nil, a displaced array is created. The resulting array\nshares its contents with the array given by displaced-to.  The resulting\narray cannot contain more elements than the array it is displaced to.  If\ndisplaced-to is not supplied or nil, the resulting array is not a\ndisplaced array.  If array A is created displaced to array B and\nsubsequently array B is given to adjust-array, array A will still be\ndisplaced to array B.  Although array might be a displaced array, the\nresulting array is not a displaced array unless displaced-to is supplied\nand not nil.\n\nThe interaction between adjust-array and displaced arrays is as follows\ngiven three arrays, A, B, and~C:\n\nA is not displaced before or after the call\n           (adjust-array A ...)\n\n     The dimensions of A are altered, and the contents rearranged as\n     appropriate.  Additional elements of A are taken from initial-element.\n     The use of initial-contents causes all old contents to be discarded.\n\nA is not displaced before, but is displaced to\n     C after the call\n           (adjust-array A ... :displaced-to C)\n\n     None of the original contents of A appears in A afterwards; A now\n     contains the contents of C, without any rearrangement of C.\n\nA is displaced to B\n     before the call, and is displaced to C after the call\n           (adjust-array A ... :displaced-to B)\n           (adjust-array A ... :displaced-to C)\n\n     B and C might be the same. The contents of B do not appear in A\n     afterward unless such contents also happen to be in C  If\n     displaced-index-offset is not supplied in the adjust-array call, it\n     defaults to zero; the old offset into B is not retained.\n\nA is displaced to B before the call, but not displaced\n     afterward.\n           (adjust-array A ... :displaced-to B)\n           (adjust-array A ... :displaced-to nil)\n\n     A gets a new \"data region,\" and contents of B are copied into it as\n     appropriate to maintain the existing old contents; additional\n     elements of A are taken from initial-element if supplied.  However,\n     the use of initial-contents causes all old contents to be discarded.\n\nIf displaced-index-offset is supplied, it specifies the offset of the\nresulting array from the beginning of the array that it is displaced to.\nIf displaced-index-offset is not supplied, the offset is~0.  The size of\nthe resulting array plus the offset value cannot exceed the size of the\narray that it is displaced to.\n\nIf only new-dimensions and an initial-element argument are supplied, those\nelements of array that are still in bounds appear in the resulting array.\nThe elements of the resulting array that are not in the bounds of array\nare initialized to initial-element; if initial-element is not provided,\n\nthe consequences of later reading any such new element of new-array before\nit has been initialized are undefined.\n\nIf initial-contents or displaced-to is supplied, then none of the original\ncontents of array appears in the new array.\n\nThe consequences are unspecified if array is adjusted to a size smaller\nthan its fill pointer without supplying the fill-pointer argument so that\nits fill-pointer is properly adjusted in the process.\n\nIf A is displaced to B, the consequences are unspecified if B is adjusted\nin such a way that it no longer has enough elements to satisfy A.\n\nIf adjust-array is applied to an array that is actually adjustable, the\narray returned is identical to array.  If the array returned by\nadjust-array is distinct from array, then the argument array is unchanged.\n\nNote that if an array A is displaced to another array B, and B is\ndisplaced to another array C, and B is altered by adjust-array, A must now\nrefer to the adjust contents of B.  This means that an implementation\ncannot collapse the chain to make A refer to C directly and forget that\nthe chain of reference passes through B.  However, caching techniques are\npermitted as long as they preserve the semantics specified here.\n\nExamples::\n..........\n\n      (adjustable-array-p\n       (setq ada (adjust-array\n                   (make-array '(2 3)\n                               :adjustable t\n                               :initial-contents '((a b c) (1 2 3)))\n                   '(4 6)))) =>  T\n      (array-dimensions ada) =>  (4 6)\n      (aref ada 1 1) =>  2\n      (setq beta (make-array '(2 3) :adjustable t))\n     =>  #2A((NIL NIL NIL) (NIL NIL NIL))\n      (adjust-array beta '(4 6) :displaced-to ada)\n     =>  #2A((A B C NIL NIL NIL)\n            (1 2 3 NIL NIL NIL)\n            (NIL NIL NIL NIL NIL NIL)\n            (NIL NIL NIL NIL NIL NIL))\n      (array-dimensions beta) =>  (4 6)\n      (aref beta 1 1) =>  2\n\nSuppose that the 4-by-4 array in m looks like this:\n\n     #2A(( alpha     beta      gamma     delta )\n         ( epsilon   zeta      eta       theta )\n         ( iota      kappa     lambda    mu    )\n         ( nu        xi        omicron   pi    ))\n\nThen the result of\n\n      (adjust-array m '(3 5) :initial-element 'baz)\n\nis a 3-by-5 array with contents\n\n     #2A(( alpha     beta      gamma     delta     baz )\n         ( epsilon   zeta      eta       theta     baz )\n         ( iota      kappa     lambda    mu        baz ))\n\nExceptional Situations::\n........................\n\nAn error of type error is signaled if fill-pointer is supplied and non-nil\nbut array has no fill pointer.\n\nSee Also::\n..........\n\n*Note adjustable-array-p:: , *Note make-array:: , *Note\narray-dimension-limit:: , *Note array-total-size-limit:: , array\n\n"
}