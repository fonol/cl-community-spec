{
    "name": "Boa Lambda Lists",
    "prev": "Destructuring Lambda Lists",
    "next": "Defsetf Lambda Lists",
    "up": "Lambda Lists",
    "header": {
        "type": null,
        "text": "Boa Lambda Lists"
    },
    "sections": [
        {
            "type": "",
            "text": "A boa lambda list is a lambda list that is syntactically like an ordinary\nlambda list, but that is processed in \"by order of argument\" style.\nA boa lambda list is used only in a defstruct form, when explicitly\nspecifying the lambda list of a constructor function (sometimes called a\n\"boa constructor\").\nThe &optional, &rest, &aux,\n&key, and &allow-other-keys\nlambda list keywords are recognized in a boa lambda list.  The way these\nlambda list keywords differ from their use in an ordinary lambda list\nfollows.\nConsider this example, which describes how destruct processes its\n:constructor option.\n      (:constructor create-foo\n              (a &optional b (c 'sea) &rest d &aux e (f 'eff)))\nThis defines create-foo to be a constructor of one or more arguments.  The\nfirst argument is used to initialize the a slot.  The second argument is\nused to initialize the b slot.  If there isn't any second argument, then\nthe default value given in the body of the defstruct (if given) is used\ninstead.  The third argument is used to initialize the c slot.  If there\nisn't any third argument, then the symbol sea is used instead.  Any\narguments following the third argument are collected into a list and used\nto initialize the d slot.  If there are three or fewer arguments, then nil\nis placed in the d slot.  The e slot is not initialized; its initial value\nis implementation-defined.  Finally, the f slot is initialized to contain\nthe symbol eff.\n&key and &allow-other-keys arguments default in a manner similar to that\nof &optional arguments: if no default is supplied in the lambda list then\nthe default value given in the body of the defstruct (if given) is used\ninstead.  For example:\n      (defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)\n                                                  &key (d 2)\n                                                  &aux e (f 'eff))))\n        (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))\n      (create-foo 10) =>  #S(FOO A 10 B 2 C SEA D 2 E implemention-dependent F EFF)\n      (create-foo 10 'bee 'see :d 'dee)\n     =>  #S(FOO A 10 B BEE C SEE D DEE E implemention-dependent F EFF)\nIf keyword arguments of the form ((key var) [default [svar]]) are\nspecified, the slot name is matched with var (not key).\nThe actions taken in the b and e cases were carefully chosen to allow the\nuser to specify all possible behaviors.  The &aux variables can be used to\ncompletely override the default initializations given in the body.\nIf no default value is supplied for an aux variable variable, the\nconsequences are undefined if an attempt is later made to read the\ncorresponding slot's value before a value is explicitly assigned.  If such\na slot has a :type option specified, this suppressed initialization does\nnot imply a type mismatch situation; the declared type is only required to\napply when the slot is finally assigned.\nWith this definition, the following can be written:\n      (create-foo 1 2)\ninstead of\n      (make-foo :a 1 :b 2)\nand create-foo provides defaulting different from that of make-foo.\nAdditional arguments that do not correspond to slot names but are merely\npresent to supply values used in subsequent initialization computations\nare allowed.  For example, in the definition\n      (defstruct (frob (:constructor create-frob\n                       (a &key (b 3 have-b) (c-token 'c)\n                               (c (list c-token (if have-b 7 2))))))\n              a b c)\nthe c-token argument is used merely to supply a value used in the\ninitialization of the c slot. The supplied-p parameters associated with\noptional parameters and keyword parameters might also be used this way.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Boa Lambda Lists,  Next: Defsetf Lambda Lists,  Prev: Destructuring Lambda Lists,  Up: Lambda Lists\n\nBoa Lambda Lists\n----------------\n\nA boa lambda list is a lambda list that is syntactically like an ordinary\nlambda list, but that is processed in \"by order of argument\" style.\n\nA boa lambda list is used only in a defstruct form, when explicitly\nspecifying the lambda list of a constructor function (sometimes called a\n\"boa constructor\").\n\nThe &optional, &rest, &aux,\n\n&key, and &allow-other-keys\n\nlambda list keywords are recognized in a boa lambda list.  The way these\nlambda list keywords differ from their use in an ordinary lambda list\nfollows.\n\nConsider this example, which describes how destruct processes its\n:constructor option.\n\n      (:constructor create-foo\n              (a &optional b (c 'sea) &rest d &aux e (f 'eff)))\n\nThis defines create-foo to be a constructor of one or more arguments.  The\nfirst argument is used to initialize the a slot.  The second argument is\nused to initialize the b slot.  If there isn't any second argument, then\nthe default value given in the body of the defstruct (if given) is used\ninstead.  The third argument is used to initialize the c slot.  If there\nisn't any third argument, then the symbol sea is used instead.  Any\narguments following the third argument are collected into a list and used\nto initialize the d slot.  If there are three or fewer arguments, then nil\nis placed in the d slot.  The e slot is not initialized; its initial value\nis implementation-defined.  Finally, the f slot is initialized to contain\nthe symbol eff.\n\n&key and &allow-other-keys arguments default in a manner similar to that\nof &optional arguments: if no default is supplied in the lambda list then\nthe default value given in the body of the defstruct (if given) is used\ninstead.  For example:\n\n      (defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)\n                                                  &key (d 2)\n                                                  &aux e (f 'eff))))\n        (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))\n     \n      (create-foo 10) =>  #S(FOO A 10 B 2 C SEA D 2 E implemention-dependent F EFF)\n      (create-foo 10 'bee 'see :d 'dee)\n     =>  #S(FOO A 10 B BEE C SEE D DEE E implemention-dependent F EFF)\n\nIf keyword arguments of the form ((key var) [default [svar]]) are\nspecified, the slot name is matched with var (not key).\n\nThe actions taken in the b and e cases were carefully chosen to allow the\nuser to specify all possible behaviors.  The &aux variables can be used to\ncompletely override the default initializations given in the body.\n\nIf no default value is supplied for an aux variable variable, the\nconsequences are undefined if an attempt is later made to read the\ncorresponding slot's value before a value is explicitly assigned.  If such\na slot has a :type option specified, this suppressed initialization does\nnot imply a type mismatch situation; the declared type is only required to\napply when the slot is finally assigned.\n\nWith this definition, the following can be written:\n\n      (create-foo 1 2)\n\ninstead of\n\n      (make-foo :a 1 :b 2)\n\nand create-foo provides defaulting different from that of make-foo.\n\nAdditional arguments that do not correspond to slot names but are merely\npresent to supply values used in subsequent initialization computations\nare allowed.  For example, in the definition\n\n      (defstruct (frob (:constructor create-frob\n                       (a &key (b 3 have-b) (c-token 'c)\n                               (c (list c-token (if have-b 7 2))))))\n              a b c)\n\nthe c-token argument is used merely to supply a value used in the\ninitialization of the c slot. The supplied-p parameters associated with\noptional parameters and keyword parameters might also be used this way.\n\n"
}