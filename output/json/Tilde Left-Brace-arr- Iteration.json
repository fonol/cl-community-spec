{
    "name": "Tilde Left-Brace-> Iteration",
    "prev": "Tilde Right-Bracket-> End of Conditional Expression",
    "next": "Tilde Right-Brace-> End of Iteration",
    "up": "FORMAT Control-Flow Operations",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Tilde Left-Brace: Iteration",
            "text": "~{str~}\nThis is an iteration construct.  The argument should be a list, which is\nused as a set of arguments as if for a recursive call to format.  The\nstring str is used repeatedly as the control string.  Each iteration can\nabsorb as many elements of the list as it likes as arguments; if str uses\nup two arguments by itself, then two elements of the list will get used up\neach time around the loop.  If before any iteration step the list is\nempty, then the iteration is terminated.  Also, if a prefix parameter n is\ngiven, then there will be at most n repetitions of processing of str.\nFinally, the ~^  directive can be used to terminate the iteration\nprematurely.\nFor example:\n      (format nil \"The winners are:~{ ~S~}.\"\n              '(fred harry jill))\n     =>  \"The winners are: FRED HARRY JILL.\"\n      (format nil \"Pairs:~{ <~S,~S>~}.\"\n              '(a 1 b 2 c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n~:{ str~}   is similar, but the argument should be a list of sublists.  At\neach repetition step, one sublist is used as the set of arguments for\nprocessing str; on the next repetition, a new sublist is used, whether or\nnot all of the last sublist had been processed.  For example:\n      (format nil \"Pairs:~:{ <~S,~S>~} .\"\n                      '((a 1) (b 2) (c 3)))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n~@{ str~}  is similar to ~{ str~}  , but instead of using one argument\nthat is a list, all the remaining arguments are used as the list of\narguments for the iteration.  Example:\n      (format nil \"Pairs:~@{ <~S,~S>~} .\" 'a 1 'b 2 'c 3)\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\nIf the iteration is terminated before all the remaining arguments are\nconsumed, then any arguments not processed by the iteration remain to be\nprocessed by any directives following the iteration construct.\n~:@{ str~}   combines the features of ~:{ str~}   and ~@{ str~}  .  All\nthe remaining arguments are used, and each one must be a list.  On each\niteration, the next argument is used as a list of arguments to str.\nExample:\n      (format nil \"Pairs:~:@{ <~S,~S>~} .\"\n                   '(a 1) '(b 2) '(c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\nTerminating the repetition construct with ~:}  instead of ~}   forces str\nto be processed at least once, even if the initial list of arguments is\nnull. However, this will not override an explicit prefix parameter of zero.\nIf str is empty, then an argument is used as str.  It must be a format\ncontrol and precede any arguments processed by the iteration.  As an\nexample, the following are equivalent:\n         (apply #'format stream string arguments)\n      == (format stream \"~1{~:}\" string arguments)\nThis will use string as a formatting string.  The ~1{  says it will be\nprocessed at most once, and the ~:}  says it will be processed at least\nonce.  Therefore it is processed exactly once, using arguments as the\narguments.  This case may be handled more clearly by the ~? directive, but\nthis general feature of ~{   is more powerful than ~?.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Tilde Left-Brace-> Iteration,  Next: Tilde Right-Brace-> End of Iteration,  Prev: Tilde Right-Bracket-> End of Conditional Expression,  Up: FORMAT Control-Flow Operations\n\nTilde Left-Brace: Iteration\n...........................\n\n~{str~}\n\nThis is an iteration construct.  The argument should be a list, which is\nused as a set of arguments as if for a recursive call to format.  The\nstring str is used repeatedly as the control string.  Each iteration can\nabsorb as many elements of the list as it likes as arguments; if str uses\nup two arguments by itself, then two elements of the list will get used up\neach time around the loop.  If before any iteration step the list is\nempty, then the iteration is terminated.  Also, if a prefix parameter n is\ngiven, then there will be at most n repetitions of processing of str.\nFinally, the ~^  directive can be used to terminate the iteration\nprematurely.\n\nFor example:\n\n      (format nil \"The winners are:~{ ~S~}.\"\n              '(fred harry jill))\n     =>  \"The winners are: FRED HARRY JILL.\"\n      (format nil \"Pairs:~{ <~S,~S>~}.\"\n              '(a 1 b 2 c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\n~:{ str~}   is similar, but the argument should be a list of sublists.  At\neach repetition step, one sublist is used as the set of arguments for\nprocessing str; on the next repetition, a new sublist is used, whether or\nnot all of the last sublist had been processed.  For example:\n\n      (format nil \"Pairs:~:{ <~S,~S>~} .\"\n                      '((a 1) (b 2) (c 3)))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\n~@{ str~}  is similar to ~{ str~}  , but instead of using one argument\nthat is a list, all the remaining arguments are used as the list of\narguments for the iteration.  Example:\n\n      (format nil \"Pairs:~@{ <~S,~S>~} .\" 'a 1 'b 2 'c 3)\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\nIf the iteration is terminated before all the remaining arguments are\nconsumed, then any arguments not processed by the iteration remain to be\nprocessed by any directives following the iteration construct.\n\n~:@{ str~}   combines the features of ~:{ str~}   and ~@{ str~}  .  All\nthe remaining arguments are used, and each one must be a list.  On each\niteration, the next argument is used as a list of arguments to str.\nExample:\n\n      (format nil \"Pairs:~:@{ <~S,~S>~} .\"\n                   '(a 1) '(b 2) '(c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\nTerminating the repetition construct with ~:}  instead of ~}   forces str\nto be processed at least once, even if the initial list of arguments is\nnull. However, this will not override an explicit prefix parameter of zero.\n\nIf str is empty, then an argument is used as str.  It must be a format\ncontrol and precede any arguments processed by the iteration.  As an\nexample, the following are equivalent:\n\n         (apply #'format stream string arguments)\n      == (format stream \"~1{~:}\" string arguments)\n\nThis will use string as a formatting string.  The ~1{  says it will be\nprocessed at most once, and the ~:}  says it will be processed at least\nonce.  Therefore it is processed exactly once, using arguments as the\narguments.  This case may be handled more clearly by the ~? directive, but\nthis general feature of ~{   is more powerful than ~?.\n\n"
}