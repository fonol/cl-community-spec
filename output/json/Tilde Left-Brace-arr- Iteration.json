{
    "name": "Tilde Left-Brace-> Iteration",
    "prev": "Tilde Right-Bracket-> End of Conditional Expression",
    "next": "Tilde Right-Brace-> End of Iteration",
    "up": "FORMAT Control-Flow Operations",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Tilde Left-Brace: Iteration",
            "text": "篝蟒茴澡轶轶犷轸弪狒轱泔铙趄蹉舢澡狎珲礤铘箬秕熹忮扉篝麒殂轶茴躞邃狍箦镦狎珲礤铘狍殒骘蝈沲蝮轹汜祆麸骘蝽狒澡遘铙趄轭篝轶躞邃蝈疱狒邃禊狍翳泔铘蝻篝蜷铉裴汨轸弪狒轱汜钴钺怏矧狍磲铢屐屙孱趔镦翳扉篝狍轸扉脲狍狎珲礤铘蠡殒篝躞弩茴躔赭狎珲礤铘怡轸箦戽翳孱赭屐屙孱趔镦翳扉篝鏖祆珏躞邃躔茴遽汨糸礤狎秕钿翳祜镳涉忮骘蝈犷轸弪狒轱篝屦翳扉篝轶茴屙痿翳孱翳轸弪狒轱轶翦蝽轭狒邃领箫殒痱彐轼疳蜥礤翦轶茴玳鲥瞵翳孱翳弪鏖祆忮狒盹篝蝈疱糸糸镱镦痱镢弩箝铉镦篝虍茴崎钺祆翳溟蝈泗轹汜忮躞邃麸翦蝽轭狒翳轸弪狒轱钴铕蝈磲趱蝈禊茴骑屮犴痨搴茴ㄦ矧磲铋堍澡鏖铑弪狎搴誉堍茴Ж骝邃栳蝌觊祆┅茴骄堍澡鏖铑弪狎搴埔拍攘乙噬烫堍茴ㄦ矧磲铋堍嗅轵蠛件蝇泳.\"\n              '(a 1 b 2 c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n:{ str}   is similar, but the argument should be a list of sublists.  At\neach repetition step, one sublist is used as the set of arguments for\nprocessing str; on the next repetition, a new sublist is used, whether or\nnot all of the last sublist had been processed.  For example:\n      (format nil \"Pairs::{ <S,S>} .\"\n                      '((a 1) (b 2) (c 3)))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n@{ str}  is similar to 篝蟒怩轭篝遽镦躞轭镱狎珲礤铘茴翳狒轶扉篝犰翳蝈磲轭轭狎珲礤铘狎躞邃狍翳扉篝镦茴狎珲礤铘骘翳轸弪狒轱町砒犴痨搴茴ㄦ矧磲铋堍嗅轵蠛利件蝇泳 .\" 'a 1 'b 2 'c 3)\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\nIf the iteration is terminated before all the remaining arguments are\nconsumed, then any arguments not processed by the iteration remain to be\nprocessed by any directives following the iteration construct.\n:@{ str}   combines the features of :{ str}   and @{ str}  .  All\nthe remaining arguments are used, and each one must be a list.  On each\niteration, the next argument is used as a list of arguments to str.\nExample:\n      (format nil \"Pairs::@{ <S,S>} .\"\n                   '(a 1) '(b 2) '(c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\nTerminating the repetition construct with :}  instead of }   forces str\nto be processed at least once, even if the initial list of arguments is\nnull. However, this will not override an explicit prefix parameter of zero.\nIf str is empty, then an argument is used as str.  It must be a format\ncontrol and precede any arguments processed by the iteration.  As an\nexample, the following are equivalent:\n         (apply #'format stream string arguments)\n      == (format stream \"1{:}\" string arguments)\nThis will use string as a formatting string.  The 1{  says it will be\nprocessed at most once, and the :}  says it will be processed at least\nonce.  Therefore it is processed exactly once, using arguments as the\narguments.  This case may be handled more clearly by the ? directive, but\nthis general feature of 轶盹蝈痫麇蜴蹯翳犷慨茴莠⑦雉屮簪⑵殪搴玢飚轭骘物溴蚤熹体骠买徙瀛婶弪狒轱瞵五艉蚤熹议玷舡买徙瀛蓬镦婶弪狒轱瞵序弼蚤熹议玷舡买徙脲舡蓬镦蔑钿轸轱钺砒痱弩箝镱震葡彝猎蔑铘蝻飙旗秣橡弪狒轱铙茴茴蚤熹体骠买徙搴婶弪狒轱钴町茴茴篝蟒茴茴澡轶轶犷轸弪狒轱泔铙趄蹉舢澡狎珲礤铘箬秕熹忮扉篝麒殂轶茴躞邃狍箦镦狎珲礤铘狍殒骘蝈沲蝮轹汜祆麸骘蝽狒澡遘铙趄轭篝轶躞邃蝈疱狒邃禊狍翳泔铘蝻篝蜷铉裴汨轸弪狒轱汜钴钺怏矧狍磲铢屐屙孱趔镦翳扉篝狍轸扉脲狍狎珲礤铘蠡殒篝躞弩茴躔赭狎珲礤铘怡轸箦戽翳孱赭屐屙孱趔镦翳扉篝鏖祆珏躞邃躔茴遽汨糸礤狎秕钿翳祜镳涉忮骘蝈犷轸弪狒轱篝屦翳扉篝轶茴屙痿翳孱翳轸弪狒轱轶翦蝽轭狒邃领箫殒痱彐轼疳蜥礤翦轶茴玳鲥瞵翳孱翳弪鏖祆忮狒盹篝蝈疱糸糸镱镦痱镢弩箝铉镦篝虍茴崎钺祆翳溟蝈泗轹汜忮躞邃麸翦蝽轭狒翳轸弪狒轱钴铕蝈磲趱蝈禊茴茴骑屮犴痨搴茴茴ㄦ矧磲铋堍澡鏖铑弪狎搴誉堍茴Ж骝邃栳蝌觊祆┅茴骄堍澡鏖铑弪狎搴埔拍攘乙噬烫堍茴ㄦ矧磲铋堍嗅轵蠛件蝇泳.\"\n              '(a 1 b 2 c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\n:{ str}   is similar, but the argument should be a list of sublists.  At\neach repetition step, one sublist is used as the set of arguments for\nprocessing str; on the next repetition, a new sublist is used, whether or\nnot all of the last sublist had been processed.  For example:\n\n      (format nil \"Pairs::{ <S,S>} .\"\n                      '((a 1) (b 2) (c 3)))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\n@{ str}  is similar to 篝蟒怩轭篝遽镦躞轭镱狎珲礤铘茴翳狒轶扉篝犰翳蝈磲轭轭狎珲礤铘狎躞邃狍翳扉篝镦茴狎珲礤铘骘翳轸弪狒轱町砒犴痨搴茴茴ㄦ矧磲铋堍嗅轵蠛利件蝇泳 .\" 'a 1 'b 2 'c 3)\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\nIf the iteration is terminated before all the remaining arguments are\nconsumed, then any arguments not processed by the iteration remain to be\nprocessed by any directives following the iteration construct.\n\n:@{ str}   combines the features of :{ str}   and @{ str}  .  All\nthe remaining arguments are used, and each one must be a list.  On each\niteration, the next argument is used as a list of arguments to str.\nExample:\n\n      (format nil \"Pairs::@{ <S,S>} .\"\n                   '(a 1) '(b 2) '(c 3))\n     =>  \"Pairs: <A,1> <B,2> <C,3>.\"\n\nTerminating the repetition construct with :}  instead of }   forces str\nto be processed at least once, even if the initial list of arguments is\nnull. However, this will not override an explicit prefix parameter of zero.\n\nIf str is empty, then an argument is used as str.  It must be a format\ncontrol and precede any arguments processed by the iteration.  As an\nexample, the following are equivalent:\n\n         (apply #'format stream string arguments)\n      == (format stream \"1{:}\" string arguments)\n\nThis will use string as a formatting string.  The 1{  says it will be\nprocessed at most once, and the :}  says it will be processed at least\nonce.  Therefore it is processed exactly once, using arguments as the\narguments.  This case may be handled more clearly by the ? directive, but\nthis general feature of 轶盹蝈痫麇蜴蹯翳犷慨茴茴