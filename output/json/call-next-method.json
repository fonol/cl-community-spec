{
    "name": "call-next-method",
    "prev": "call-method",
    "next": "compute-applicable-methods",
    "up": "Objects Dictionary",
    "header": {
        "type": "Local Function",
        "text": "call-next-method"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "call-next-method",
                    "text": " &rest args =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "arg",
                    "desc": "an object."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the method it calls."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The function call-next-method can be used\nwithin the body forms (but not the lambda list)\nof a method defined by a method-defining form to call the next method.\nIf there is no next method, the generic function no-next-method is called.\nThe type of method combination used determines which methods can invoke\ncall-next-method.  The standard method combination type allows\ncall-next-method to be used within primary methods and around methods.\nFor generic functions using a type of method combination defined by the\nshort form of define-method-combination, call-next-method can be used in\naround methods only.\nWhen call-next-method is called with no arguments, it passes the current\nmethod's original arguments to the next method.  Neither argument\ndefaulting, nor using setq, nor rebinding variables with the same names as\nparameters of the method affects the values call-next-method passes to the\nmethod it calls.\nWhen call-next-method is called with arguments, the next method is called\nwith those arguments.\nIf call-next-method is called with arguments but omits optional arguments,\nthe next method called defaults those arguments.\nThe function call-next-method returns any values that are returned by the\nnext method.\nThe function call-next-method has lexical scope and indefinite extent and\ncan only be used within the body of a method defined by a method-defining\nform.\nWhether or not call-next-method is fbound in the global environment is\nimplementation-dependent; however, the restrictions on redefinition and\nshadowing of call-next-method are the same as for symbols in the\nCOMMON-LISP package which are fbound in the global environment.  The\nconsequences of attempting to use call-next-method outside of a\nmethod-defining form are undefined.\n"
        },
        {
            "type": "Affected By",
            "text": "defmethod, call-method, define-method-combination.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "When providing arguments to call-next-method, the following rule must be\nsatisfied or an error of type error should be signaled: the ordered set of\napplicable methods for a changed set of arguments for call-next-method\nmust be the same as the ordered set of applicable methods for the original\narguments to the generic function.  Optimizations of the error checking\nare possible, but they must not change the semantics of call-next-method.\n"
        },
        {
            "type": "See Also",
            "text": "*Note define-method-combination:: , *Note defmethod:: , *Note\nnext-method-p:: , *Note no-next-method:: , *Note call-method; make-method::\n, *Note Method Selection and Combination::, *Note Standard Method\nCombination::, *Note Built-in Method Combination Types::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: call-next-method,  Next: compute-applicable-methods,  Prev: call-method,  Up: Objects Dictionary\n\ncall-next-method                                           [Local Function]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n`call-next-method'  &rest args =>  {result}*\n\nArguments and Values::\n......................\n\narg--an object.\n\nresults--the values returned by the method it calls.\n\nDescription::\n.............\n\nThe function call-next-method can be used\n\nwithin the body forms (but not the lambda list)\n\nof a method defined by a method-defining form to call the next method.\n\nIf there is no next method, the generic function no-next-method is called.\n\nThe type of method combination used determines which methods can invoke\ncall-next-method.  The standard method combination type allows\ncall-next-method to be used within primary methods and around methods.\nFor generic functions using a type of method combination defined by the\nshort form of define-method-combination, call-next-method can be used in\naround methods only.\n\nWhen call-next-method is called with no arguments, it passes the current\nmethod's original arguments to the next method.  Neither argument\ndefaulting, nor using setq, nor rebinding variables with the same names as\nparameters of the method affects the values call-next-method passes to the\nmethod it calls.\n\nWhen call-next-method is called with arguments, the next method is called\nwith those arguments.\n\nIf call-next-method is called with arguments but omits optional arguments,\nthe next method called defaults those arguments.\n\nThe function call-next-method returns any values that are returned by the\nnext method.\n\nThe function call-next-method has lexical scope and indefinite extent and\ncan only be used within the body of a method defined by a method-defining\nform.\n\nWhether or not call-next-method is fbound in the global environment is\nimplementation-dependent; however, the restrictions on redefinition and\nshadowing of call-next-method are the same as for symbols in the\nCOMMON-LISP package which are fbound in the global environment.  The\nconsequences of attempting to use call-next-method outside of a\nmethod-defining form are undefined.\n\nAffected By::\n.............\n\ndefmethod, call-method, define-method-combination.\n\nExceptional Situations::\n........................\n\nWhen providing arguments to call-next-method, the following rule must be\nsatisfied or an error of type error should be signaled: the ordered set of\napplicable methods for a changed set of arguments for call-next-method\nmust be the same as the ordered set of applicable methods for the original\narguments to the generic function.  Optimizations of the error checking\nare possible, but they must not change the semantics of call-next-method.\n\nSee Also::\n..........\n\n*Note define-method-combination:: , *Note defmethod:: , *Note\nnext-method-p:: , *Note no-next-method:: , *Note call-method; make-method::\n, *Note Method Selection and Combination::, *Note Standard Method\nCombination::, *Note Built-in Method Combination Types::\n\n"
}