{
    "name": "Closures and Lexical Binding",
    "prev": "Lambda Expressions",
    "next": "Shadowing",
    "up": "Evaluation",
    "header": {
        "type": null,
        "text": "Closures and Lexical Binding"
    },
    "sections": [
        {
            "type": "",
            "text": "A lexical closure is a function that can refer to and alter the values of\nlexical bindings established by binding forms that textually include the\nfunction definition.\nConsider this code, where x is not declared special:\n      (defun two-funs (x)\n        (list (function (lambda () x))\n              (function (lambda (y) (setq x y)))))\n      (setq funs (two-funs 6))\n      (funcall (car funs)) =>  6\n      (funcall (cadr funs) 43) =>  43\n      (funcall (car funs)) =>  43\nThe function special form coerces a lambda expression into a closure in\nwhich the lexical environment in effect when the special form is evaluated\nis captured along with the lambda expression.\nThe function two-funs returns a list of two functions, each of which\nrefers to the binding of the variable x created on entry to the function\ntwo-funs when it was called.  This variable has the value 6 initially, but\nsetq can alter this binding.  The lexical closure created for the first\nlambda expression does not \"snapshot\" the value 6 for x when the closure\nis created; rather it captures the binding of x.  The second function can\nbe used to alter the value in the same (captured) binding (to 43, in the\nexample), and this altered variable binding then affects the value\nreturned by the first function.\nIn situations where a closure of a lambda expression over the same set of\nbindings may be produced more than once, the various resulting closures may\nor may not be identical, at the discretion of the implementation.  That\nis, two functions that are behaviorally indistinguishable might or might\nnot be identical.  Two functions that are behaviorally distinguishable are\ndistinct.  For example:\n      (let ((x 5) (funs '()))\n        (dotimes (j 10)\n          (push #'(lambda (z)\n                    (if (null z) (setq x 0) (+ x z)))\n                funs))\n        funs)\nThe result of the above form is a list of ten closures.  Each requires\nonly the binding of x.  It is the same binding in each case, but the ten\nclosure objects might or might not be identical.  On the other hand, the\nresult of the form\n      (let ((funs '()))\n        (dotimes (j 10)\n          (let ((x 5))\n            (push (function (lambda (z)\n                             (if (null z) (setq x 0) (+ x z))))\n                  funs)))\n       funs)\nis also a list of ten closures.  However, in this case no two of the\nclosure objects can be identical because each closure is closed over a\ndistinct binding of x, and these bindings can be behaviorally\ndistinguished because of the use of setq.\nThe result of the form\n      (let ((funs '()))\n        (dotimes (j 10)\n          (let ((x 5))\n            (push (function (lambda (z) (+ x z)))\n                 funs)))\n        funs)\nis a list of ten closure objects that might or might not be identical.  A\ndifferent binding of x is involved for each closure, but the bindings\ncannot be distinguished because their values are the same and immutable\n(there being no occurrence of setq on x).  A compiler could internally\ntransform the form to\n      (let ((funs '()))\n        (dotimes (j 10)\n          (push (function (lambda (z) (+ 5 z)))\n                funs))\n       funs)\nwhere the closures may be identical.\nIt is possible that a closure does not close over any variable bindings.\nIn the code fragment\n      (mapcar (function (lambda (x) (+ x 2))) y)\nthe function (lambda (x) (+ x 2)) contains no references to any outside\nobject. In this case, the same closure might be returned for all\nevaluations of the function form.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Closures and Lexical Binding,  Next: Shadowing,  Prev: Lambda Expressions,  Up: Evaluation\n\nClosures and Lexical Binding\n----------------------------\n\nA lexical closure is a function that can refer to and alter the values of\nlexical bindings established by binding forms that textually include the\nfunction definition.\n\nConsider this code, where x is not declared special:\n\n      (defun two-funs (x)\n        (list (function (lambda () x))\n              (function (lambda (y) (setq x y)))))\n      (setq funs (two-funs 6))\n      (funcall (car funs)) =>  6\n      (funcall (cadr funs) 43) =>  43\n      (funcall (car funs)) =>  43\n\nThe function special form coerces a lambda expression into a closure in\nwhich the lexical environment in effect when the special form is evaluated\nis captured along with the lambda expression.\n\nThe function two-funs returns a list of two functions, each of which\nrefers to the binding of the variable x created on entry to the function\ntwo-funs when it was called.  This variable has the value 6 initially, but\nsetq can alter this binding.  The lexical closure created for the first\nlambda expression does not \"snapshot\" the value 6 for x when the closure\nis created; rather it captures the binding of x.  The second function can\nbe used to alter the value in the same (captured) binding (to 43, in the\nexample), and this altered variable binding then affects the value\nreturned by the first function.\n\nIn situations where a closure of a lambda expression over the same set of\nbindings may be produced more than once, the various resulting closures may\nor may not be identical, at the discretion of the implementation.  That\nis, two functions that are behaviorally indistinguishable might or might\nnot be identical.  Two functions that are behaviorally distinguishable are\ndistinct.  For example:\n\n      (let ((x 5) (funs '()))\n        (dotimes (j 10)\n          (push #'(lambda (z)\n                    (if (null z) (setq x 0) (+ x z)))\n                funs))\n        funs)\n\nThe result of the above form is a list of ten closures.  Each requires\nonly the binding of x.  It is the same binding in each case, but the ten\nclosure objects might or might not be identical.  On the other hand, the\nresult of the form\n\n      (let ((funs '()))\n        (dotimes (j 10)\n          (let ((x 5))\n            (push (function (lambda (z)\n                             (if (null z) (setq x 0) (+ x z))))\n                  funs)))\n       funs)\n\nis also a list of ten closures.  However, in this case no two of the\nclosure objects can be identical because each closure is closed over a\ndistinct binding of x, and these bindings can be behaviorally\ndistinguished because of the use of setq.\n\nThe result of the form\n\n      (let ((funs '()))\n        (dotimes (j 10)\n          (let ((x 5))\n            (push (function (lambda (z) (+ x z)))\n                 funs)))\n        funs)\n\nis a list of ten closure objects that might or might not be identical.  A\ndifferent binding of x is involved for each closure, but the bindings\ncannot be distinguished because their values are the same and immutable\n(there being no occurrence of setq on x).  A compiler could internally\ntransform the form to\n\n      (let ((funs '()))\n        (dotimes (j 10)\n          (push (function (lambda (z) (+ 5 z)))\n                funs))\n       funs)\n\nwhere the closures may be identical.\n\nIt is possible that a closure does not close over any variable bindings.\nIn the code fragment\n\n      (mapcar (function (lambda (x) (+ x 2))) y)\n\nthe function (lambda (x) (+ x 2)) contains no references to any outside\nobject. In this case, the same closure might be returned for all\nevaluations of the function form.\n\n"
}