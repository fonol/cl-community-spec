{
    "name": "Semantic Constraints",
    "prev": "Minimal Compilation",
    "next": null,
    "up": "Compilation Semantics",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Semantic Constraints",
            "text": "All conforming programs must obey the following constraints, which are\ndesigned to minimize the observable differences between compiled and\ninterpreted programs:\n*\n     Definitions of any referenced macros must be present in the\n     compilation environment.  Any form that is a list beginning with a\n     symbol that does not name a special operator or a macro defined in the\n     compilation environment is treated by the compiler as a function call.\n*\n     Special proclamations for dynamic variables must be made in the\n     compilation environment.  Any binding for which there is no special\n     declaration or proclamation in the compilation environment is treated\n     by the compiler as a lexical binding.\n*\n     The definition of a function that is defined and declared inline in\n     the compilation environment must be the same at run time.\n*\n     Within a function named F, the compiler may (but is not required to)\n     assume that an apparent recursive call to a function named F refers\n     to the same definition of F, unless that function has been declared\n     notinline.  The consequences of redefining such a recursively defined\n     function F while it is executing are undefined.\n*\n     A call within a file to a named function that is defined in the same\n     file refers to that function, unless that function has been declared\n     notinline.  The consequences are unspecified if functions are\n     redefined individually at run time or multiply defined in the same\n     file.\n*\n     The argument syntax and number of return values for all functions\n     whose ftype is declared at compile time must remain the same at run\n     time.\n*\n     Constant variables defined in the compilation environment must have a\n     similar value at run time.  A reference to a constant variable in\n     source code is equivalent to a reference to a literal object that is\n     the value of the constant variable.\n*\n     Type definitions made with deftype or defstruct in the compilation\n     environment must retain the same definition at run time.  Classes\n     defined by defclass in the compilation environment must be defined at\n     run time to have the same superclasses and same metaclass.\n     This implies that subtype/supertype relationships of type specifiers\n     must not change between compile time and run time.\n*\n     Type declarations present in the compilation environment must\n     accurately describe the corresponding values at run time; otherwise,\n     the consequences are undefined.  It is permissible for an unknown\n     type to appear in a declaration at compile time, though a warning\n     might be signaled in such a case.\n*\n     Except in the situations explicitly listed above, a function defined\n     in the evaluation environment is permitted to have a different\n     definition or a different signature at run time, and the run-time\n     definition prevails.\nConforming programs should not be written using any additional assumptions\nabout consistency between the run-time environment and the startup,\nevaluation, and compilation environments.\nExcept where noted, when a compile-time and a run-time definition are\ndifferent, one of the following occurs at run time:\n*\n     an error of type error is signaled\n*\n     the compile-time definition prevails\n*\n     the run-time definition prevails\nIf the compiler processes a function form whose operator is not defined at\ncompile time, no error is signaled at compile time.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Semantic Constraints,  Prev: Minimal Compilation,  Up: Compilation Semantics\n\nSemantic Constraints\n....................\n\nAll conforming programs must obey the following constraints, which are\ndesigned to minimize the observable differences between compiled and\ninterpreted programs:\n\n*\n     Definitions of any referenced macros must be present in the\n     compilation environment.  Any form that is a list beginning with a\n     symbol that does not name a special operator or a macro defined in the\n     compilation environment is treated by the compiler as a function call.\n\n*\n     Special proclamations for dynamic variables must be made in the\n     compilation environment.  Any binding for which there is no special\n     declaration or proclamation in the compilation environment is treated\n     by the compiler as a lexical binding.\n\n*\n     The definition of a function that is defined and declared inline in\n     the compilation environment must be the same at run time.\n\n*\n     Within a function named F, the compiler may (but is not required to)\n     assume that an apparent recursive call to a function named F refers\n     to the same definition of F, unless that function has been declared\n     notinline.  The consequences of redefining such a recursively defined\n     function F while it is executing are undefined.\n\n*\n     A call within a file to a named function that is defined in the same\n     file refers to that function, unless that function has been declared\n     notinline.  The consequences are unspecified if functions are\n     redefined individually at run time or multiply defined in the same\n     file.\n\n*\n     The argument syntax and number of return values for all functions\n     whose ftype is declared at compile time must remain the same at run\n     time.\n\n*\n     Constant variables defined in the compilation environment must have a\n     similar value at run time.  A reference to a constant variable in\n     source code is equivalent to a reference to a literal object that is\n     the value of the constant variable.\n\n*\n     Type definitions made with deftype or defstruct in the compilation\n     environment must retain the same definition at run time.  Classes\n     defined by defclass in the compilation environment must be defined at\n     run time to have the same superclasses and same metaclass.\n\n     This implies that subtype/supertype relationships of type specifiers\n     must not change between compile time and run time.\n\n*\n     Type declarations present in the compilation environment must\n     accurately describe the corresponding values at run time; otherwise,\n     the consequences are undefined.  It is permissible for an unknown\n     type to appear in a declaration at compile time, though a warning\n     might be signaled in such a case.\n\n*\n     Except in the situations explicitly listed above, a function defined\n     in the evaluation environment is permitted to have a different\n     definition or a different signature at run time, and the run-time\n     definition prevails.\n\nConforming programs should not be written using any additional assumptions\nabout consistency between the run-time environment and the startup,\nevaluation, and compilation environments.\n\nExcept where noted, when a compile-time and a run-time definition are\ndifferent, one of the following occurs at run time:\n\n*\n     an error of type error is signaled\n\n*\n     the compile-time definition prevails\n\n*\n     the run-time definition prevails\n\nIf the compiler processes a function form whose operator is not defined at\ncompile time, no error is signaled at compile time.\n\n"
}