{
    "name": "Prevention of Name Conflicts in Packages",
    "prev": "Locating a Symbol in a Package",
    "next": null,
    "up": "Introduction to Packages",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Prevention of Name Conflicts in Packages",
            "text": "Within one package, any particular name can refer to at most one symbol.\nA name conflict is said to occur when there would be more than one\ncandidate symbol.  Any time a name conflict is about to occur, a\ncorrectable error is signaled.\nThe following rules apply to name conflicts:\n-\n     Name conflicts are detected when they become possible, that is, when\n     the package structure is altered.  Name conflicts are not checked\n     during every name lookup.\n-\n     If the same symbol is accessible to a package through more than one\n     path, there is no name conflict.  A symbol cannot conflict with\n     itself.  Name conflicts occur only between distinct symbols with the\n     same name (under string=).\n-\n     Every package has a list of shadowing symbols.  A shadowing symbol\n     takes precedence over any other symbol of the same name that would\n     otherwise be accessible in the package.  A name conflict involving a\n     shadowing symbol is always resolved in favor of the shadowing symbol,\n     without signaling an error (except for one exception involving\n     import).  See shadow and shadowing-import.\n-\n     The functions use-package, import, and export check for name\n     conflicts.\n-\n     shadow and shadowing-import never signal a name-conflict error.\n-\n     unuse-package and unexport do not need to do any name-conflict\n     checking.  unintern does name-conflict checking only when a symbol\n     being uninterned is a shadowing symbol .\n-\n     Giving a shadowing symbol to unintern can uncover a name conflict\n     that had previously been resolved by the shadowing.\n-\n     Package functions signal name-conflict errors of type package-error\n     before making any change to the package structure.  When multiple\n     changes are to be made, it is permissible for the implementation to\n     process each change separately.  For example, when export is given a\n     list of symbols, aborting from a name conflict caused by the second\n     symbol in the list might still export the first symbol in the list.\n     However, a name-conflict error caused by export of a single symbol\n     will be signaled before that symbol's accessibility in any package is\n     changed.\n-\n     Continuing from a name-conflict error must offer the user a chance to\n     resolve the name conflict in favor of either of the candidates.  The\n     package structure should be altered to reflect the resolution of the\n     name conflict, via shadowing-import, unintern, or unexport.\n-\n     A name conflict in use-package between a symbol present in the using\n     package and an external symbol of the used package is resolved in\n     favor of the first symbol by making it a shadowing symbol, or in\n     favor of the second symbol by uninterning the first symbol from the\n     using package.\n-\n     A name conflict in export or unintern due to a package's inheriting\n     two distinct symbols with the same name (under string=) from two\n     other packages can be resolved in favor of either symbol by importing\n     it into the using package and making it a shadowing symbol , just as\n     with use-package.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Prevention of Name Conflicts in Packages,  Prev: Locating a Symbol in a Package,  Up: Introduction to Packages\n\nPrevention of Name Conflicts in Packages\n........................................\n\nWithin one package, any particular name can refer to at most one symbol.\nA name conflict is said to occur when there would be more than one\ncandidate symbol.  Any time a name conflict is about to occur, a\ncorrectable error is signaled.\n\nThe following rules apply to name conflicts:\n-\n     Name conflicts are detected when they become possible, that is, when\n     the package structure is altered.  Name conflicts are not checked\n     during every name lookup.\n\n-\n     If the same symbol is accessible to a package through more than one\n     path, there is no name conflict.  A symbol cannot conflict with\n     itself.  Name conflicts occur only between distinct symbols with the\n     same name (under string=).\n\n-\n     Every package has a list of shadowing symbols.  A shadowing symbol\n     takes precedence over any other symbol of the same name that would\n     otherwise be accessible in the package.  A name conflict involving a\n     shadowing symbol is always resolved in favor of the shadowing symbol,\n     without signaling an error (except for one exception involving\n     import).  See shadow and shadowing-import.\n\n-\n     The functions use-package, import, and export check for name\n     conflicts.\n\n-\n     shadow and shadowing-import never signal a name-conflict error.\n\n-\n     unuse-package and unexport do not need to do any name-conflict\n     checking.  unintern does name-conflict checking only when a symbol\n     being uninterned is a shadowing symbol .\n\n-\n     Giving a shadowing symbol to unintern can uncover a name conflict\n     that had previously been resolved by the shadowing.\n\n-\n     Package functions signal name-conflict errors of type package-error\n     before making any change to the package structure.  When multiple\n     changes are to be made, it is permissible for the implementation to\n     process each change separately.  For example, when export is given a\n     list of symbols, aborting from a name conflict caused by the second\n     symbol in the list might still export the first symbol in the list.\n     However, a name-conflict error caused by export of a single symbol\n     will be signaled before that symbol's accessibility in any package is\n     changed.\n\n-\n     Continuing from a name-conflict error must offer the user a chance to\n     resolve the name conflict in favor of either of the candidates.  The\n     package structure should be altered to reflect the resolution of the\n     name conflict, via shadowing-import, unintern, or unexport.\n\n-\n     A name conflict in use-package between a symbol present in the using\n     package and an external symbol of the used package is resolved in\n     favor of the first symbol by making it a shadowing symbol, or in\n     favor of the second symbol by uninterning the first symbol from the\n     using package.\n\n-\n     A name conflict in export or unintern due to a package's inheriting\n     two distinct symbols with the same name (under string=) from two\n     other packages can be resolved in favor of either symbol by importing\n     it into the using package and making it a shadowing symbol , just as\n     with use-package.\n\n"
}