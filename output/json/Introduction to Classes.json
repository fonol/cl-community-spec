{
    "name": "Introduction to Classes",
    "prev": "Classes",
    "next": "Defining Classes",
    "up": "Classes",
    "header": {
        "type": null,
        "text": "Introduction to Classes"
    },
    "sections": [
        {
            "type": "",
            "text": "A class is an object that determines the structure and behavior of a set\nof other objects, which are called its instances .\nA class can inherit structure and behavior from other classes.  A class\nwhose definition refers to other classes for the purpose of inheriting\nfrom them is said to be a subclass of each of those classes. The classes\nthat are designated for purposes of inheritance are said to be\nsuperclasses of the inheriting class.\nA class can have a name. The function class-name takes a class object and\nreturns its name.  The name of an anonymous class is nil.  A symbol can\nname a class. The function find-class takes a symbol and returns the class\nthat the symbol names.  A class has a proper name if the name is a symbol\nand if the name of the class names that class.  That is, a class~C has the\nproper name~S if S= (class-name C) and C= (find-class S).  Notice that it\nis possible for (find-class S_1) = (find-class S_2) and S_1!= S_2.  If C=\n(find-class S), we say that C is the class named S.\nA class C_1 is a direct superclass of a class C_2 if C_2 explicitly\ndesignates C_1 as a superclass in its definition.  In this case C_2 is a\ndirect subclass of C_1.  A class C_n is a superclass of a class C_1 if\nthere exists a series of classes C_2,...,C_{n-1} such that C_{i+1} is a\ndirect superclass of C_i for 1 <= i<n.  In this case, C_1 is a subclass of\nC_n.  A class is considered neither a superclass nor a subclass of itself.\nThat is, if C_1 is a superclass of C_2, then C_1 != C_2.  The set of\nclasses consisting of some given class C along with all of its\nsuperclasses is called \"C and its superclasses.\"\nEach class has a class precedence list , which is a total ordering on the\nset of the given class and its superclasses.  The total ordering is\nexpressed as a list ordered from most specific to least specific.  The\nclass precedence list is used in several ways.  In general, more specific\nclasses can shadow _1 features that would otherwise be inherited from less\nspecific classes.  The method selection and combination process uses the\nclass precedence list to order methods from most specific to least\nspecific.\nWhen a class is defined, the order in which its direct superclasses are\nmentioned in the defining form is important.  Each class has a local\nprecedence order , which is a list consisting of the class followed by its\ndirect superclasses in the order mentioned in the defining form.\nA class precedence list is always consistent with the local precedence\norder of each class in the list.  The classes in each local precedence\norder appear within the class precedence list in the same order.  If the\nlocal precedence orders are inconsistent with each other, no class\nprecedence list can be constructed, and an error is signaled.  The class\nprecedence list and its computation is discussed in *Note Determining the\nClass Precedence List::.\nclasses are organized into a directed acyclic graph.  There are two\ndistinguished classes, named t and standard-object.  The class named t has\nno superclasses.  It is a superclass of every class except itself.  The\nclass named standard-object is an instance of the class standard-class and\nis a superclass of every class that is an instance of the class\nstandard-class except itself.\n[Reviewer Note by Barmar: This or something like it needs to be said in\nthe introduction.] There is a mapping from the object system class space\ninto the type space.  Many of the standard types specified in this\ndocument have a corresponding class that has the same name as the type.\nSome types do not have a corresponding class. The integration of the type\nand class systems is discussed in *Note Integrating Types and Classes::.\nClasses are represented by objects that are themselves instances of\nclasses.  The class of the class of an object is termed the metaclass of\nthat object. When no misinterpretation is possible, the term metaclass is\nused to refer to a class that has instances that are themselves classes.\nThe metaclass determines the form of inheritance used by the classes that\nare its instances and the representation of the instances of those classes.\nThe object system provides a default metaclass, standard-class, that is\nappropriate for most programs.\nExcept where otherwise specified, all classes mentioned in this standard\nare instances of the class standard-class, all generic functions are\ninstances of the class standard-generic-function, and all methods are\ninstances of the class standard-method.\n* Menu:\n* Standard Metaclasses::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Introduction to Classes,  Next: Defining Classes,  Prev: Classes,  Up: Classes\n\nIntroduction to Classes\n-----------------------\n\nA class is an object that determines the structure and behavior of a set\nof other objects, which are called its instances .\n\nA class can inherit structure and behavior from other classes.  A class\nwhose definition refers to other classes for the purpose of inheriting\nfrom them is said to be a subclass of each of those classes. The classes\nthat are designated for purposes of inheritance are said to be\nsuperclasses of the inheriting class.\n\nA class can have a name. The function class-name takes a class object and\nreturns its name.  The name of an anonymous class is nil.  A symbol can\nname a class. The function find-class takes a symbol and returns the class\nthat the symbol names.  A class has a proper name if the name is a symbol\nand if the name of the class names that class.  That is, a class~C has the\nproper name~S if S= (class-name C) and C= (find-class S).  Notice that it\nis possible for (find-class S_1) = (find-class S_2) and S_1!= S_2.  If C=\n(find-class S), we say that C is the class named S.\n\nA class C_1 is a direct superclass of a class C_2 if C_2 explicitly\ndesignates C_1 as a superclass in its definition.  In this case C_2 is a\ndirect subclass of C_1.  A class C_n is a superclass of a class C_1 if\nthere exists a series of classes C_2,...,C_{n-1} such that C_{i+1} is a\ndirect superclass of C_i for 1 <= i<n.  In this case, C_1 is a subclass of\nC_n.  A class is considered neither a superclass nor a subclass of itself.\nThat is, if C_1 is a superclass of C_2, then C_1 != C_2.  The set of\nclasses consisting of some given class C along with all of its\nsuperclasses is called \"C and its superclasses.\"\n\nEach class has a class precedence list , which is a total ordering on the\nset of the given class and its superclasses.  The total ordering is\nexpressed as a list ordered from most specific to least specific.  The\nclass precedence list is used in several ways.  In general, more specific\nclasses can shadow _1 features that would otherwise be inherited from less\nspecific classes.  The method selection and combination process uses the\nclass precedence list to order methods from most specific to least\nspecific.\n\nWhen a class is defined, the order in which its direct superclasses are\nmentioned in the defining form is important.  Each class has a local\nprecedence order , which is a list consisting of the class followed by its\ndirect superclasses in the order mentioned in the defining form.\n\nA class precedence list is always consistent with the local precedence\norder of each class in the list.  The classes in each local precedence\norder appear within the class precedence list in the same order.  If the\nlocal precedence orders are inconsistent with each other, no class\nprecedence list can be constructed, and an error is signaled.  The class\nprecedence list and its computation is discussed in *Note Determining the\nClass Precedence List::.\n\nclasses are organized into a directed acyclic graph.  There are two\ndistinguished classes, named t and standard-object.  The class named t has\nno superclasses.  It is a superclass of every class except itself.  The\nclass named standard-object is an instance of the class standard-class and\nis a superclass of every class that is an instance of the class\nstandard-class except itself.\n\n[Reviewer Note by Barmar: This or something like it needs to be said in\nthe introduction.] There is a mapping from the object system class space\ninto the type space.  Many of the standard types specified in this\ndocument have a corresponding class that has the same name as the type.\nSome types do not have a corresponding class. The integration of the type\nand class systems is discussed in *Note Integrating Types and Classes::.\n\nClasses are represented by objects that are themselves instances of\nclasses.  The class of the class of an object is termed the metaclass of\nthat object. When no misinterpretation is possible, the term metaclass is\nused to refer to a class that has instances that are themselves classes.\nThe metaclass determines the form of inheritance used by the classes that\nare its instances and the representation of the instances of those classes.\nThe object system provides a default metaclass, standard-class, that is\nappropriate for most programs.\n\nExcept where otherwise specified, all classes mentioned in this standard\nare instances of the class standard-class, all generic functions are\ninstances of the class standard-generic-function, and all methods are\ninstances of the class standard-method.\n\n* Menu:\n\n* Standard Metaclasses::\n\n"
}