{
    "name": "Setf Expansions",
    "prev": "Examples of Evaluation of Subforms to Places",
    "next": "Examples of Setf Expansions",
    "up": "Overview of Places and Generalized Reference",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Setf Expansions",
            "text": "Sometimes it is possible to avoid evaluating subforms of a place multiple\ntimes or in the wrong order.  A\nsetf expansion\nfor a given access form can be expressed as an ordered collection of five\nobjects:\nList of temporary variables\n     a list of symbols naming temporary variables to be bound\n     sequentially, as if by let*, to values resulting from value forms.\nList of value forms\n     a list of forms (typically, subforms of the place) which when\n     evaluated yield the values to which the corresponding temporary\n     variables should be bound.\nList of store variables\n     a list of symbols naming temporary store variables which are to hold\n     the new values that will be assigned to the place.\nStoring form\n     a form which can reference both the temporary and the store variables,\n     and which changes the value of the place and guarantees to return as\n     its values the values of the store variables, which are the correct\n     values for setf to return.\nAccessing form\n     a form which can reference the temporary variables, and which returns\n     the value of the place.\nThe value returned by the accessing form is affected by execution of the\nstoring form, but either of these forms might be evaluated any number of\ntimes.\nIt is possible to do more than one setf in parallel via psetf, shiftf, and\nrotatef.  Because of this, the\nsetf expander\nmust produce new temporary and store variable names every time.  For\nexamples of how to do this, see gensym.\nFor each standardized accessor function F, unless it is explicitly\ndocumented otherwise, it is implementation-dependent whether the ability to\nuse an F form as a setf place is implemented by a setf expander or a setf\nfunction.  Also, it follows from this that it is implementation-dependent\nwhether the name (setf F) is fbound.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Setf Expansions,  Next: Examples of Setf Expansions,  Prev: Examples of Evaluation of Subforms to Places,  Up: Overview of Places and Generalized Reference\n\nSetf Expansions\n...............\n\nSometimes it is possible to avoid evaluating subforms of a place multiple\ntimes or in the wrong order.  A\n\nsetf expansion\n\nfor a given access form can be expressed as an ordered collection of five\nobjects:\n\nList of temporary variables\n     a list of symbols naming temporary variables to be bound\n     sequentially, as if by let*, to values resulting from value forms.\n\nList of value forms\n     a list of forms (typically, subforms of the place) which when\n     evaluated yield the values to which the corresponding temporary\n     variables should be bound.\n\nList of store variables\n     a list of symbols naming temporary store variables which are to hold\n     the new values that will be assigned to the place.\n\nStoring form\n     a form which can reference both the temporary and the store variables,\n     and which changes the value of the place and guarantees to return as\n     its values the values of the store variables, which are the correct\n     values for setf to return.\n\nAccessing form\n     a form which can reference the temporary variables, and which returns\n     the value of the place.\n\nThe value returned by the accessing form is affected by execution of the\nstoring form, but either of these forms might be evaluated any number of\ntimes.\n\nIt is possible to do more than one setf in parallel via psetf, shiftf, and\nrotatef.  Because of this, the\n\nsetf expander\n\nmust produce new temporary and store variable names every time.  For\nexamples of how to do this, see gensym.\n\nFor each standardized accessor function F, unless it is explicitly\ndocumented otherwise, it is implementation-dependent whether the ability to\nuse an F form as a setf place is implemented by a setf expander or a setf\nfunction.  Also, it follows from this that it is implementation-dependent\nwhether the name (setf F) is fbound.\n\n"
}