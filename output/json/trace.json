{
    "name": "trace",
    "prev": "describe-object",
    "next": "step",
    "up": "Environment Dictionary",
    "header": {
        "type": "Macro",
        "text": "trace, untrace"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "trace",
                    "text": " {function-name}* =>  trace-result\n"
                },
                {
                    "name": "untrace",
                    "text": " {function-name}* =>  untrace-result\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "function-name",
                    "desc": "a function name."
                },
                {
                    "name": "trace-result",
                    "desc": "implementation-dependent, unless no function-names are"
                },
                {
                    "name": "trace-result",
                    "desc": "implementation-dependent, unless no function-names aresupplied, in which case trace-result is a list of function names.\n"
                },
                {
                    "name": "untrace-result",
                    "desc": "implementation-dependent."
                }
            ]
        },
        {
            "type": "Description",
            "text": "trace and untrace control the invocation of the trace facility.\nInvoking trace with one or more function-names causes the denoted\nfunctions to be \"traced.\" Whenever a traced function is invoked,\ninformation about the call, about the arguments passed, and about any\neventually returned values is printed to trace output.  If trace is used\nwith no function-names, no tracing action is performed; instead, a list of\nthe functions currently being traced is returned.\nInvoking untrace with one or more function names causes those functions to\nbe \"untraced\" (i.e., no longer traced).  If untrace is used with no\nfunction-names, all functions currently being traced are untraced.\nIf a function to be traced has been open-coded (e.g., because it was\ndeclared inline), a call to that function might not produce trace output.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun fact (n) (if (zerop n) 1 (* n (fact (- n 1)))))\n     =>  FACT\n      (trace fact)\n     =>  (FACT)\n     ;; Of course, the format of traced output is implementation-dependent.\n      (fact 3)\n      |>  1 Enter FACT 3\n      |>  | 2 Enter FACT 2\n      |>  |   3 Enter FACT 1\n      |>  |   | 4 Enter FACT 0\n      |>  |   | 4 Exit FACT 1\n      |>  |   3 Exit FACT 1\n      |>  | 2 Exit FACT 2\n      |>  1 Exit FACT 6\n     =>  6\n"
        },
        {
            "type": "Side Effects",
            "text": "Might change the definitions of the functions named by function-names.\n"
        },
        {
            "type": "Affected By",
            "text": "Whether the functions named are defined or already being traced.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Tracing an already traced function, or untracing a function not currently\nbeing traced, should produce no harmful effects, but might signal a\nwarning.\n"
        },
        {
            "type": "See Also",
            "text": "*trace-output*, *Note step::\n"
        },
        {
            "type": "Notes",
            "text": "trace and untrace may also accept additional implementation-dependent\nargument formats.  The format of the trace output is\nimplementation-dependent.\nAlthough trace can be extended to permit non-standard options,\nimplementations are nevertheless encouraged (but not required) to warn\nabout the use of syntax or options that are neither specified by this\nstandard nor added as an extension by the implementation, since they could\nbe symptomatic of typographical errors or of reliance on features\nsupported in implementations other than the current implementation.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: trace,  Next: step,  Prev: describe-object,  Up: Environment Dictionary\n\ntrace, untrace                                                      [Macro]\n---------------------------------------------------------------------------\n\n`trace'  {function-name}* =>  trace-result\n\n`untrace'  {function-name}* =>  untrace-result\n\nArguments and Values::\n......................\n\nfunction-name--a function name.\n\ntrace-result--implementation-dependent, unless no function-names are\nsupplied, in which case trace-result is a list of function names.\n\nuntrace-result--implementation-dependent.\n\nDescription::\n.............\n\ntrace and untrace control the invocation of the trace facility.\n\nInvoking trace with one or more function-names causes the denoted\nfunctions to be \"traced.\" Whenever a traced function is invoked,\ninformation about the call, about the arguments passed, and about any\neventually returned values is printed to trace output.  If trace is used\nwith no function-names, no tracing action is performed; instead, a list of\nthe functions currently being traced is returned.\n\nInvoking untrace with one or more function names causes those functions to\nbe \"untraced\" (i.e., no longer traced).  If untrace is used with no\nfunction-names, all functions currently being traced are untraced.\n\nIf a function to be traced has been open-coded (e.g., because it was\ndeclared inline), a call to that function might not produce trace output.\n\nExamples::\n..........\n\n      (defun fact (n) (if (zerop n) 1 (* n (fact (- n 1)))))\n     =>  FACT\n      (trace fact)\n     =>  (FACT)\n     ;; Of course, the format of traced output is implementation-dependent.\n      (fact 3)\n      |>  1 Enter FACT 3\n      |>  | 2 Enter FACT 2\n      |>  |   3 Enter FACT 1\n      |>  |   | 4 Enter FACT 0\n      |>  |   | 4 Exit FACT 1\n      |>  |   3 Exit FACT 1\n      |>  | 2 Exit FACT 2\n      |>  1 Exit FACT 6\n     =>  6\n\nSide Effects::\n..............\n\nMight change the definitions of the functions named by function-names.\n\nAffected By::\n.............\n\nWhether the functions named are defined or already being traced.\n\nExceptional Situations::\n........................\n\nTracing an already traced function, or untracing a function not currently\nbeing traced, should produce no harmful effects, but might signal a\nwarning.\n\nSee Also::\n..........\n\n*trace-output*, *Note step::\n\nNotes::\n.......\n\ntrace and untrace may also accept additional implementation-dependent\nargument formats.  The format of the trace output is\nimplementation-dependent.\n\nAlthough trace can be extended to permit non-standard options,\nimplementations are nevertheless encouraged (but not required) to warn\nabout the use of syntax or options that are neither specified by this\nstandard nor added as an extension by the implementation, since they could\nbe symptomatic of typographical errors or of reliance on features\nsupported in implementations other than the current implementation.\n\n"
}