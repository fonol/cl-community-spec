{
    "name": "get",
    "prev": "symbol-value",
    "next": "remprop",
    "up": "Symbols Dictionary",
    "header": {
        "type": "Accessor",
        "text": "get"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "get",
                    "text": " symbol indicator &optional default =>  value\n(setf (`         get' symbol indicator &optional default) new-value)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "symbol",
                    "desc": "a symbol."
                },
                {
                    "name": "indicator",
                    "desc": "an object."
                },
                {
                    "name": "default",
                    "desc": "an object.  The default is nil."
                },
                {
                    "name": "value",
                    "desc": "if the indicated property exists, the object that is its value;"
                },
                {
                    "name": "value",
                    "desc": "if the indicated property exists, the object that is its value;otherwise, the specified default.\n"
                },
                {
                    "name": "new-value",
                    "desc": "an object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "get finds a property on the property list_2 of symbol whose property\nindicator is identical to indicator, and returns its corresponding\nproperty value.\nIf there are multiple properties_1 with that property indicator, get uses\nthe first such property.\nIf there is no property with that property indicator, default is returned.\nsetf of get may be used to associate a new object with an existing\nindicator already on the symbol's property list, or to create a new\nassocation if none exists.\nIf there are multiple properties_1 with that property indicator, setf of\nget associates the new-value with the first such property.\nWhen a get form is used as a setf place, any default which is supplied is\nevaluated according to normal left-to-right evaluation rules, but its\nvalue is ignored.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun make-person (first-name last-name)\n        (let ((person (gensym \"PERSON\")))\n          (setf (get person 'first-name) first-name)\n          (setf (get person 'last-name) last-name)\n          person)) =>  MAKE-PERSON\n      (defvar *john* (make-person \"John\" \"Dow\")) =>  *JOHN*\n      *john* =>  #:PERSON4603\n      (defvar *sally* (make-person \"Sally\" \"Jones\")) =>  *SALLY*\n      (get *john* 'first-name) =>  \"John\"\n      (get *sally* 'last-name) =>  \"Jones\"\n      (defun marry (man woman married-name)\n        (setf (get man 'wife) woman)\n        (setf (get woman 'husband) man)\n        (setf (get man 'last-name) married-name)\n        (setf (get woman 'last-name) married-name)\n        married-name) =>  MARRY\n      (marry *john* *sally* \"Dow-Jones\") =>  \"Dow-Jones\"\n      (get *john* 'last-name) =>  \"Dow-Jones\"\n      (get (get *john* 'wife) 'first-name) =>  \"Sally\"\n      (symbol-plist *john*)\n     =>  (WIFE #:PERSON4604 LAST-NAME \"Dow-Jones\" FIRST-NAME \"John\")\n      (defmacro age (person &optional (default ''thirty-something))\n        `(get ,person 'age ,default)) =>  AGE\n      (age *john*) =>  THIRTY-SOMETHING\n      (age *john* 20) =>  20\n      (setf (age *john*) 25) =>  25\n      (age *john*) =>  25\n      (age *john* 20) =>  25\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if symbol is not a symbol.\n"
        },
        {
            "type": "See Also",
            "text": "*Note getf:: , *Note symbol-plist:: , *Note remprop::\n"
        },
        {
            "type": "Notes",
            "text": "      (get x y) == (getf (symbol-plist x) y)\nNumbers and characters are not recommended for use as indicators in\nportable code since get tests with eq rather than eql, and consequently\nthe effect of using such indicators is implementation-dependent.\nThere is no way using get to distinguish an absent property from one whose\nvalue is default.  However, see get-properties.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: get,  Next: remprop,  Prev: symbol-value,  Up: Symbols Dictionary\n\nget                                                              [Accessor]\n---------------------------------------------------------------------------\n\n`get'  symbol indicator &optional default =>  value\n\n(setf (`         get' symbol indicator &optional default) new-value)\nArguments and Values::\n......................\n\nsymbol--a symbol.\n\nindicator--an object.\n\ndefault--an object.  The default is nil.\n\nvalue--if the indicated property exists, the object that is its value;\notherwise, the specified default.\n\nnew-value--an object.\n\nDescription::\n.............\n\nget finds a property on the property list_2 of symbol whose property\nindicator is identical to indicator, and returns its corresponding\nproperty value.\n\nIf there are multiple properties_1 with that property indicator, get uses\nthe first such property.\n\nIf there is no property with that property indicator, default is returned.\n\nsetf of get may be used to associate a new object with an existing\nindicator already on the symbol's property list, or to create a new\nassocation if none exists.\n\nIf there are multiple properties_1 with that property indicator, setf of\nget associates the new-value with the first such property.\n\nWhen a get form is used as a setf place, any default which is supplied is\nevaluated according to normal left-to-right evaluation rules, but its\nvalue is ignored.\n\nExamples::\n..........\n\n      (defun make-person (first-name last-name)\n        (let ((person (gensym \"PERSON\")))\n          (setf (get person 'first-name) first-name)\n          (setf (get person 'last-name) last-name)\n          person)) =>  MAKE-PERSON\n      (defvar *john* (make-person \"John\" \"Dow\")) =>  *JOHN*\n      *john* =>  #:PERSON4603\n      (defvar *sally* (make-person \"Sally\" \"Jones\")) =>  *SALLY*\n      (get *john* 'first-name) =>  \"John\"\n      (get *sally* 'last-name) =>  \"Jones\"\n      (defun marry (man woman married-name)\n        (setf (get man 'wife) woman)\n        (setf (get woman 'husband) man)\n        (setf (get man 'last-name) married-name)\n        (setf (get woman 'last-name) married-name)\n        married-name) =>  MARRY\n      (marry *john* *sally* \"Dow-Jones\") =>  \"Dow-Jones\"\n      (get *john* 'last-name) =>  \"Dow-Jones\"\n      (get (get *john* 'wife) 'first-name) =>  \"Sally\"\n      (symbol-plist *john*)\n     =>  (WIFE #:PERSON4604 LAST-NAME \"Dow-Jones\" FIRST-NAME \"John\")\n      (defmacro age (person &optional (default ''thirty-something))\n        `(get ,person 'age ,default)) =>  AGE\n      (age *john*) =>  THIRTY-SOMETHING\n      (age *john* 20) =>  20\n      (setf (age *john*) 25) =>  25\n      (age *john*) =>  25\n      (age *john* 20) =>  25\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if symbol is not a symbol.\n\nSee Also::\n..........\n\n*Note getf:: , *Note symbol-plist:: , *Note remprop::\n\nNotes::\n.......\n\n      (get x y) == (getf (symbol-plist x) y)\n\nNumbers and characters are not recommended for use as indicators in\nportable code since get tests with eq rather than eql, and consequently\nthe effect of using such indicators is implementation-dependent.\n\nThere is no way using get to distinguish an absent property from one whose\nvalue is default.  However, see get-properties.\n\n"
}