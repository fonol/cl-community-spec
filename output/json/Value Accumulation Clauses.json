{
    "name": "Value Accumulation Clauses",
    "prev": "Variable Initialization and Stepping Clauses",
    "next": "Termination Test Clauses",
    "up": "The LOOP Facility",
    "header": {
        "type": null,
        "text": "Value Accumulation Clauses"
    },
    "sections": [
        {
            "type": "",
            "text": "The constructs collect, collecting, append, appending, nconc, nconcing,\ncount, counting, maximize, maximizing, minimize, minimizing, sum, and\nsumming, allow values to be accumulated in a loop.\nThe constructs collect, collecting, append, appending, nconc, and nconcing,\ndesignate clauses that accumulate values in lists and return them.  The\nconstructs count, counting, maximize, maximizing, minimize, minimizing,\nsum, and summing designate clauses that accumulate and return numerical\nvalues.\nDuring each iteration,  the constructs collect and collecting collect the\nvalue of the supplied form into a list.  When iteration terminates, the\nlist is returned.  The argument var is set to the list of collected\nvalues; if var is supplied, the loop does not return the final list\nautomatically.  If var is not supplied, it is equivalent to supplying an\ninternal name for var and returning its value in a finally clause.  The\nvar argument is bound as if by the construct with.  No mechanism is\nprovided for declaring the type of var; it must be of type list.\nThe constructs append, appending, nconc, and  nconcing are similar to\ncollect except that the values of the supplied form must be lists.\n*\n     The append keyword causes its list values to be concatenated into a\n     single list, as if they were arguments to the function append.\n*\n     The nconc keyword causes its list values to be concatenated into a\n     single list, as if they were arguments to the function nconc.\nThe argument var is set to the list of concatenated values; if var is\nsupplied, loop does not return the final list automatically.  The var\nargument is bound as if by the construct with.  A type cannot be supplied\nfor var; it must be of type list.  The construct nconc destructively\nmodifies its argument lists.\nThe count construct counts the number of times that the supplied form\nreturns true.  The argument var accumulates the number of occurrences; if\nvar is supplied, loop does not return the final count automatically.  The\nvar argument is bound as if by the construct with to a zero of the\nappropriate type.  Subsequent values (including any necessary coercions)\nare computed as if by the function 1+.  If into var is used, a type can be\nsupplied  for var with the type-spec argument; the consequences are\nunspecified if a nonnumeric type is supplied.  If there is no into\nvariable, the optional type-spec argument applies to the internal variable\nthat is keeping the count.  The default type is implementation-dependent;\nbut it must be a supertype of type fixnum.\nThe maximize and minimize constructs compare the value of the supplied\nform obtained during the first iteration with values obtained in\nsuccessive iterations.  The maximum (for maximize) or minimum (for\nminimize) value encountered is determined (as if by the function max for\nmaximize and as if by the function min for minimize) and returned.  If the\nmaximize or minimize clause is never executed, the accumulated value is\nunspecified.  The argument var accumulates the maximum or minimum value;\nif var is supplied, loop does not return the maximum or minimum\nautomatically.  The var argument is bound as if by the construct with.  If\ninto var is used, a type can be supplied for var with the type-spec\nargument; the consequences are unspecified if a nonnumeric type is\nsupplied.  If there is no into variable, the optional type-spec argument\napplies to the internal variable that is keeping the maximum or minimum\nvalue.  The default type is implementation-dependent; but it must be a\nsupertype of type real.\nThe sum construct forms a cumulative sum of the successive primary values\nof the supplied form at each iteration.  The argument var is used to\naccumulate the sum; if var is supplied, loop does not return the final sum\nautomatically.  The var argument is bound as if by the construct with to a\nzero of the appropriate type.  Subsequent values (including any necessary\ncoercions) are computed as if by the function +.  If into var is used, a\ntype can be supplied for var with the type-spec argument; the consequences\nare unspecified if a nonnumeric type is supplied.  If there is no into\nvariable, the optional type-spec argument applies to the internal variable\nthat is keeping the sum.  The default type is implementation-dependent;\nbut it must be a supertype of type number.\nIf into is used, the construct does not provide a default return value;\nhowever, the variable is available for use in any finally clause.\nCertain kinds of accumulation clauses can be combined in a loop if their\ndestination is the same (the result of loop or an into var) because they\nare considered to accumulate conceptually compatible quantities.  In\nparticular, any elements of following sets of accumulation clauses can be\nmixed with other elements of the same set for the same destination in a\nloop form:\n*\n     collect, append, nconc\n*\n     sum, count\n*\n     maximize, minimize\n     ;; Collect every name and the kids in one list by using\n     ;; COLLECT and APPEND.\n      (loop for name in '(fred sue alice joe june)\n            for kids in '((bob ken) () () (kris sunshine) ())\n            collect name\n            append kids)\n     =>  (FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)\nAny two clauses that do not accumulate the same type of object can coexist\nin a loop only if each clause accumulates its values into a different\nvariable.\n* Menu:\n* Examples of COLLECT clause::\n* Examples of APPEND and NCONC clauses::\n* Examples of COUNT clause::\n* Examples of MAXIMIZE and MINIMIZE clauses::\n* Examples of SUM clause::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Value Accumulation Clauses,  Next: Termination Test Clauses,  Prev: Variable Initialization and Stepping Clauses,  Up: The LOOP Facility\n\nValue Accumulation Clauses\n--------------------------\n\nThe constructs collect, collecting, append, appending, nconc, nconcing,\ncount, counting, maximize, maximizing, minimize, minimizing, sum, and\nsumming, allow values to be accumulated in a loop.\n\nThe constructs collect, collecting, append, appending, nconc, and nconcing,\ndesignate clauses that accumulate values in lists and return them.  The\nconstructs count, counting, maximize, maximizing, minimize, minimizing,\nsum, and summing designate clauses that accumulate and return numerical\nvalues.\n\nDuring each iteration,  the constructs collect and collecting collect the\nvalue of the supplied form into a list.  When iteration terminates, the\nlist is returned.  The argument var is set to the list of collected\nvalues; if var is supplied, the loop does not return the final list\nautomatically.  If var is not supplied, it is equivalent to supplying an\ninternal name for var and returning its value in a finally clause.  The\nvar argument is bound as if by the construct with.  No mechanism is\nprovided for declaring the type of var; it must be of type list.\n\nThe constructs append, appending, nconc, and  nconcing are similar to\ncollect except that the values of the supplied form must be lists.\n\n*\n     The append keyword causes its list values to be concatenated into a\n     single list, as if they were arguments to the function append.\n\n*\n     The nconc keyword causes its list values to be concatenated into a\n     single list, as if they were arguments to the function nconc.\n\nThe argument var is set to the list of concatenated values; if var is\nsupplied, loop does not return the final list automatically.  The var\nargument is bound as if by the construct with.  A type cannot be supplied\nfor var; it must be of type list.  The construct nconc destructively\nmodifies its argument lists.\n\nThe count construct counts the number of times that the supplied form\nreturns true.  The argument var accumulates the number of occurrences; if\nvar is supplied, loop does not return the final count automatically.  The\nvar argument is bound as if by the construct with to a zero of the\nappropriate type.  Subsequent values (including any necessary coercions)\nare computed as if by the function 1+.  If into var is used, a type can be\nsupplied  for var with the type-spec argument; the consequences are\nunspecified if a nonnumeric type is supplied.  If there is no into\nvariable, the optional type-spec argument applies to the internal variable\nthat is keeping the count.  The default type is implementation-dependent;\nbut it must be a supertype of type fixnum.\n\nThe maximize and minimize constructs compare the value of the supplied\nform obtained during the first iteration with values obtained in\nsuccessive iterations.  The maximum (for maximize) or minimum (for\nminimize) value encountered is determined (as if by the function max for\nmaximize and as if by the function min for minimize) and returned.  If the\nmaximize or minimize clause is never executed, the accumulated value is\nunspecified.  The argument var accumulates the maximum or minimum value;\nif var is supplied, loop does not return the maximum or minimum\nautomatically.  The var argument is bound as if by the construct with.  If\ninto var is used, a type can be supplied for var with the type-spec\nargument; the consequences are unspecified if a nonnumeric type is\nsupplied.  If there is no into variable, the optional type-spec argument\napplies to the internal variable that is keeping the maximum or minimum\nvalue.  The default type is implementation-dependent; but it must be a\nsupertype of type real.\n\nThe sum construct forms a cumulative sum of the successive primary values\nof the supplied form at each iteration.  The argument var is used to\naccumulate the sum; if var is supplied, loop does not return the final sum\nautomatically.  The var argument is bound as if by the construct with to a\nzero of the appropriate type.  Subsequent values (including any necessary\ncoercions) are computed as if by the function +.  If into var is used, a\ntype can be supplied for var with the type-spec argument; the consequences\nare unspecified if a nonnumeric type is supplied.  If there is no into\nvariable, the optional type-spec argument applies to the internal variable\nthat is keeping the sum.  The default type is implementation-dependent;\nbut it must be a supertype of type number.\n\nIf into is used, the construct does not provide a default return value;\nhowever, the variable is available for use in any finally clause.\n\nCertain kinds of accumulation clauses can be combined in a loop if their\ndestination is the same (the result of loop or an into var) because they\nare considered to accumulate conceptually compatible quantities.  In\nparticular, any elements of following sets of accumulation clauses can be\nmixed with other elements of the same set for the same destination in a\nloop form:\n\n*\n     collect, append, nconc\n\n*\n     sum, count\n\n*\n     maximize, minimize\n\n     ;; Collect every name and the kids in one list by using\n     ;; COLLECT and APPEND.\n      (loop for name in '(fred sue alice joe june)\n            for kids in '((bob ken) () () (kris sunshine) ())\n            collect name\n            append kids)\n     =>  (FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)\n\nAny two clauses that do not accumulate the same type of object can coexist\nin a loop only if each clause accumulates its values into a different\nvariable.\n\n* Menu:\n\n* Examples of COLLECT clause::\n* Examples of APPEND and NCONC clauses::\n* Examples of COUNT clause::\n* Examples of MAXIMIZE and MINIMIZE clauses::\n* Examples of SUM clause::\n\n"
}