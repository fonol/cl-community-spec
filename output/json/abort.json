{
    "name": "abort",
    "prev": "use-value",
    "next": null,
    "up": "Conditions Dictionary",
    "header": {
        "type": "Function",
        "text": "abort, continue, muffle-warning, store-value, use-value"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "abort",
                    "text": " &optional condition =>  #<NoValue>\n"
                },
                {
                    "name": "continue",
                    "text": " &optional condition =>  nil\n\n"
                },
                {
                    "name": "muffle-warning",
                    "text": " &optional condition =>  #<NoValue>\n\n"
                },
                {
                    "name": "store-value",
                    "text": " value &optional condition =>  nil\n\n"
                },
                {
                    "name": "use-value",
                    "text": " value &optional condition =>  nil\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "value",
                    "desc": "an object."
                },
                {
                    "name": "condition",
                    "desc": "a condition object, or nil."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Transfers control to the most recently established applicable restart\nhaving the same name as the function.  That is, the function abort\nsearches for an applicable abort    restart, the function continue\nsearches for an applicable continue restart, and so on.\nIf no such restart exists, the functions continue, store-value, and\nuse-value return nil, and the functions abort and muffle-warning signal an\nerror of type control-error.\nWhen condition is non-nil, only those restarts are considered that are\neither explicitly associated with that condition, or not associated with\nany condition; that is, the excluded restarts are those that are\nassociated with a non-empty set of conditions of which the given condition\nis not an element.  If condition is nil, all restarts are considered.\n"
        },
        {
            "type": "Examples",
            "text": "     ;;; Example of the ABORT retart\n      (defmacro abort-on-error (&body forms)\n        `(handler-bind ((error #'abort))\n           ,@forms)) =>  ABORT-ON-ERROR\n      (abort-on-error (+ 3 5)) =>  8\n      (abort-on-error (error \"You lose.\"))\n      |>  Returned to Lisp Top Level.\n     ;;; Example of the CONTINUE restart\n      (defun real-sqrt (n)\n        (when (minusp n)\n          (setq n (- n))\n          (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))\n        (sqrt n))\n      (real-sqrt 4) =>  2\n      (real-sqrt -9)\n      |>  Error: Tried to take sqrt(-9).\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Return sqrt(9) instead.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>(continue)<<|\n      |>  Return sqrt(9) instead.\n     =>  3\n      (handler-bind ((error #'(lambda (c) (continue))))\n        (real-sqrt -9)) =>  3\n     ;;; Example of the MUFFLE-WARNING restart\n      (defun count-down (x)\n        (do ((counter x (1- counter)))\n            ((= counter 0) 'done)\n          (when (= counter 1)\n            (warn \"Almost done\"))\n          (format t \"~&~D~\n     =>  COUNT-DOWN\n      (count-down 3)\n      |>  3\n      |>  2\n      |>  Warning: Almost done\n      |>  1\n     =>  DONE\n      (defun ignore-warnings-while-counting (x)\n        (handler-bind ((warning #'ignore-warning))\n          (count-down x)))\n     =>  IGNORE-WARNINGS-WHILE-COUNTING\n      (defun ignore-warning (condition)\n        (declare (ignore condition))\n        (muffle-warning))\n     =>  IGNORE-WARNING\n      (ignore-warnings-while-counting 3)\n      |>  3\n      |>  2\n      |>  1\n     =>  DONE\n     ;;; Example of the STORE-VALUE and USE-VALUE restarts\n      (defun careful-symbol-value (symbol)\n        (check-type symbol symbol)\n        (restart-case (if (boundp symbol)\n                          (return-from careful-symbol-value\n                                       (symbol-value symbol))\n                          (error 'unbound-variable\n                                 :name symbol))\n          (use-value (value)\n            :report \"Specify a value to use this time.\"\n            value)\n          (store-value (value)\n            :report \"Specify a value to store and use in the future.\"\n            (setf (symbol-value symbol) value))))\n      (setq a 1234) =>  1234\n      (careful-symbol-value 'a) =>  1234\n      (makunbound 'a) =>  A\n      (careful-symbol-value 'a)\n      |>  Error: A is not bound.\n      |>  To continue, type :CONTINUE followed by an option number.\n      |>   1: Specify a value to use this time.\n      |>   2: Specify a value to store and use in the future.\n      |>   3: Return to Lisp Toplevel.\n      |>  Debug> |>>(use-value 12)<<|\n     =>  12\n      (careful-symbol-value 'a)\n      |>  Error: A is not bound.\n      |>  To continue, type :CONTINUE followed by an option number.\n      |>    1: Specify a value to use this time.\n      |>    2: Specify a value to store and use in the future.\n      |>    3: Return to Lisp Toplevel.\n      |>  Debug> |>>(store-value 24)<<|\n     =>  24\n      (careful-symbol-value 'a)\n     =>  24\n     ;;; Example of the USE-VALUE restart\n      (defun add-symbols-with-default (default &rest symbols)\n        (handler-bind ((sys:unbound-symbol\n                         #'(lambda (c)\n                             (declare (ignore c))\n                             (use-value default))))\n          (apply #'+ (mapcar #'careful-symbol-value symbols))))\n     =>  ADD-SYMBOLS-WITH-DEFAULT\n      (setq x 1 y 2) =>  2\n      (add-symbols-with-default 3 'x 'y 'z) =>  6\n"
        },
        {
            "type": "Side Effects",
            "text": "A transfer of control may occur if an appropriate restart is available, or\n(in the case of the function abort or the function muffle-warning)\nexecution may be stopped.\n"
        },
        {
            "type": "Affected By",
            "text": "Each of these functions can be affected by the presence of a restart\nhaving the same name.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If an appropriate abort restart is not available for the function abort,\nor an appropriate muffle-warning restart is not available for the function\nmuffle-warning, an error of type control-error is signaled.\n"
        },
        {
            "type": "See Also",
            "text": "*Note invoke-restart:: , *Note Restarts::, *Note Interfaces to Restarts::,\n*Note assert:: , ccase, *Note cerror:: , *Note check-type:: , ctypecase,\n*Note use-value:: , *Note warn::\n"
        },
        {
            "type": "Notes",
            "text": "      (abort condition) == (invoke-restart 'abort)\n      (muffle-warning)  == (invoke-restart 'muffle-warning)\n      (continue)        == (let ((r (find-restart 'continue))) (if r (invoke-restart r)))\n      (use-value x) == (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))\n      (store-value x) == (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))\nNo functions defined in this specification are required to provide a\nuse-value restart.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: abort,  Prev: use-value,  Up: Conditions Dictionary\n\nabort, continue, muffle-warning, store-value, use-value          [Function]\n---------------------------------------------------------------------------\n\n`abort'  &optional condition =>  #<NoValue>\n\n`continue'  &optional condition =>  nil\n\n`muffle-warning'  &optional condition =>  #<NoValue>\n\n`store-value'  value &optional condition =>  nil\n\n`use-value'  value &optional condition =>  nil\n\nArguments and Values::\n......................\n\nvalue--an object.\n\ncondition--a condition object, or nil.\n\nDescription::\n.............\n\nTransfers control to the most recently established applicable restart\nhaving the same name as the function.  That is, the function abort\nsearches for an applicable abort    restart, the function continue\nsearches for an applicable continue restart, and so on.\n\nIf no such restart exists, the functions continue, store-value, and\nuse-value return nil, and the functions abort and muffle-warning signal an\nerror of type control-error.\n\nWhen condition is non-nil, only those restarts are considered that are\neither explicitly associated with that condition, or not associated with\nany condition; that is, the excluded restarts are those that are\nassociated with a non-empty set of conditions of which the given condition\nis not an element.  If condition is nil, all restarts are considered.\n\nExamples::\n..........\n\n     ;;; Example of the ABORT retart\n     \n      (defmacro abort-on-error (&body forms)\n        `(handler-bind ((error #'abort))\n           ,@forms)) =>  ABORT-ON-ERROR\n      (abort-on-error (+ 3 5)) =>  8\n      (abort-on-error (error \"You lose.\"))\n      |>  Returned to Lisp Top Level.\n     \n     ;;; Example of the CONTINUE restart\n     \n      (defun real-sqrt (n)\n        (when (minusp n)\n          (setq n (- n))\n          (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))\n        (sqrt n))\n     \n      (real-sqrt 4) =>  2\n      (real-sqrt -9)\n      |>  Error: Tried to take sqrt(-9).\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Return sqrt(9) instead.\n      |>   2: Return to Lisp Toplevel.\n      |>  Debug> |>>(continue)<<|\n      |>  Return sqrt(9) instead.\n     =>  3\n     \n      (handler-bind ((error #'(lambda (c) (continue))))\n        (real-sqrt -9)) =>  3\n     \n     ;;; Example of the MUFFLE-WARNING restart\n     \n      (defun count-down (x)\n        (do ((counter x (1- counter)))\n            ((= counter 0) 'done)\n          (when (= counter 1)\n            (warn \"Almost done\"))\n          (format t \"~&~D~\n     =>  COUNT-DOWN\n      (count-down 3)\n      |>  3\n      |>  2\n      |>  Warning: Almost done\n      |>  1\n     =>  DONE\n      (defun ignore-warnings-while-counting (x)\n        (handler-bind ((warning #'ignore-warning))\n          (count-down x)))\n     =>  IGNORE-WARNINGS-WHILE-COUNTING\n      (defun ignore-warning (condition)\n        (declare (ignore condition))\n        (muffle-warning))\n     =>  IGNORE-WARNING\n      (ignore-warnings-while-counting 3)\n      |>  3\n      |>  2\n      |>  1\n     =>  DONE\n     \n     ;;; Example of the STORE-VALUE and USE-VALUE restarts\n     \n      (defun careful-symbol-value (symbol)\n        (check-type symbol symbol)\n        (restart-case (if (boundp symbol)\n                          (return-from careful-symbol-value\n                                       (symbol-value symbol))\n                          (error 'unbound-variable\n                                 :name symbol))\n          (use-value (value)\n            :report \"Specify a value to use this time.\"\n            value)\n          (store-value (value)\n            :report \"Specify a value to store and use in the future.\"\n            (setf (symbol-value symbol) value))))\n      (setq a 1234) =>  1234\n      (careful-symbol-value 'a) =>  1234\n      (makunbound 'a) =>  A\n      (careful-symbol-value 'a)\n      |>  Error: A is not bound.\n      |>  To continue, type :CONTINUE followed by an option number.\n      |>   1: Specify a value to use this time.\n      |>   2: Specify a value to store and use in the future.\n      |>   3: Return to Lisp Toplevel.\n      |>  Debug> |>>(use-value 12)<<|\n     =>  12\n      (careful-symbol-value 'a)\n      |>  Error: A is not bound.\n      |>  To continue, type :CONTINUE followed by an option number.\n      |>    1: Specify a value to use this time.\n      |>    2: Specify a value to store and use in the future.\n      |>    3: Return to Lisp Toplevel.\n      |>  Debug> |>>(store-value 24)<<|\n     =>  24\n      (careful-symbol-value 'a)\n     =>  24\n     \n     ;;; Example of the USE-VALUE restart\n     \n      (defun add-symbols-with-default (default &rest symbols)\n        (handler-bind ((sys:unbound-symbol\n                         #'(lambda (c)\n                             (declare (ignore c))\n                             (use-value default))))\n          (apply #'+ (mapcar #'careful-symbol-value symbols))))\n     =>  ADD-SYMBOLS-WITH-DEFAULT\n      (setq x 1 y 2) =>  2\n      (add-symbols-with-default 3 'x 'y 'z) =>  6\n\nSide Effects::\n..............\n\nA transfer of control may occur if an appropriate restart is available, or\n(in the case of the function abort or the function muffle-warning)\nexecution may be stopped.\n\nAffected By::\n.............\n\nEach of these functions can be affected by the presence of a restart\nhaving the same name.\n\nExceptional Situations::\n........................\n\nIf an appropriate abort restart is not available for the function abort,\nor an appropriate muffle-warning restart is not available for the function\nmuffle-warning, an error of type control-error is signaled.\n\nSee Also::\n..........\n\n*Note invoke-restart:: , *Note Restarts::, *Note Interfaces to Restarts::,\n*Note assert:: , ccase, *Note cerror:: , *Note check-type:: , ctypecase,\n*Note use-value:: , *Note warn::\n\nNotes::\n.......\n\n      (abort condition) == (invoke-restart 'abort)\n      (muffle-warning)  == (invoke-restart 'muffle-warning)\n      (continue)        == (let ((r (find-restart 'continue))) (if r (invoke-restart r)))\n      (use-value x) == (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))\n      (store-value x) == (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))\n\nNo functions defined in this specification are required to provide a\nuse-value restart.\n\n"
}