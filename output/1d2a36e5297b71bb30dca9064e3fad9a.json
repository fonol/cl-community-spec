{
    "name": "Condition Types",
    "prev": "Condition System Concepts",
    "next": "Creating Conditions",
    "up": "Condition System Concepts",
    "header": {
        "type": null,
        "text": "Condition Types"
    },
    "sections": [
        {
            "type": "",
            "text": "Figure 9-1 lists the standardized condition types.  Additional condition\ntypes can be defined by using define-condition.\n arithmetic-error                 floating-point-overflow  simple-type-error  \n cell-error                       floating-point-underflow simple-warning     \n condition                        package-error            storage-condition  \n control-error                    parse-error              stream-error       \n division-by-zero                 print-not-readable       style-warning      \n end-of-file                      program-error            type-error         \n error                            reader-error             unbound-slot       \n file-error                       serious-condition        unbound-variable   \n floating-point-inexact           simple-condition         undefined-function \n floating-point-invalid-operation simple-error             warning            \n                    Figure 9-1: Standardized Condition Types                  \nAll condition types are subtypes of type condition.  That is,\n      (typep c 'condition) =>  true\nif and only if c is a condition.\nImplementations must define all specified subtype relationships.  Except\nwhere noted, all subtype relationships indicated in this document are not\nmutually exclusive.  A condition inherits the structure of its supertypes.\nThe metaclass of the class condition is not specified.  Names of condition\ntypes may be used to specify supertype relationships in define-condition,\nbut the consequences are not specified if an attempt is made to use a\ncondition type as a superclass in a defclass form.\nFigure 9-2 shows operators that define condition types and creating\nconditions.\n  define-condition  make-condition    \n  Figure 9-2: Operators that define and create conditions.\nFigure 9-3 shows operators that read the value of condition slots.\n  arithmetic-error-operands   simple-condition-format-arguments  \n  arithmetic-error-operation  simple-condition-format-control    \n  cell-error-name             stream-error-stream                \n  file-error-pathname         type-error-datum                   \n  package-error-package       type-error-expected-type           \n  print-not-readable-object   unbound-slot-instance              \n         Figure 9-3: Operators that read condition slots.       \n* Menu:\n* Serious Conditions::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Condition Types,  Next: Creating Conditions,  Prev: Condition System Concepts,  Up: Condition System Concepts\n\nCondition Types\n---------------\n\nFigure 9-1 lists the standardized condition types.  Additional condition\ntypes can be defined by using define-condition.\n\n arithmetic-error                 floating-point-overflow  simple-type-error  \n cell-error                       floating-point-underflow simple-warning     \n condition                        package-error            storage-condition  \n control-error                    parse-error              stream-error       \n division-by-zero                 print-not-readable       style-warning      \n end-of-file                      program-error            type-error         \n error                            reader-error             unbound-slot       \n file-error                       serious-condition        unbound-variable   \n floating-point-inexact           simple-condition         undefined-function \n floating-point-invalid-operation simple-error             warning            \n\n                    Figure 9-1: Standardized Condition Types                  \n\n\nAll condition types are subtypes of type condition.  That is,\n\n      (typep c 'condition) =>  true\n\nif and only if c is a condition.\n\nImplementations must define all specified subtype relationships.  Except\nwhere noted, all subtype relationships indicated in this document are not\nmutually exclusive.  A condition inherits the structure of its supertypes.\n\nThe metaclass of the class condition is not specified.  Names of condition\ntypes may be used to specify supertype relationships in define-condition,\nbut the consequences are not specified if an attempt is made to use a\ncondition type as a superclass in a defclass form.\n\nFigure 9-2 shows operators that define condition types and creating\nconditions.\n\n  define-condition  make-condition    \n\n  Figure 9-2: Operators that define and create conditions.\n\n\nFigure 9-3 shows operators that read the value of condition slots.\n\n  arithmetic-error-operands   simple-condition-format-arguments  \n  arithmetic-error-operation  simple-condition-format-control    \n  cell-error-name             stream-error-stream                \n  file-error-pathname         type-error-datum                   \n  package-error-package       type-error-expected-type           \n  print-not-readable-object   unbound-slot-instance              \n\n         Figure 9-3: Operators that read condition slots.       \n\n\n* Menu:\n\n* Serious Conditions::\n\n"
}