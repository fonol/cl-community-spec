{
    "name": "Introduction to Packages",
    "prev": "Package Concepts",
    "next": "Standardized Packages",
    "up": "Package Concepts",
    "header": {
        "type": null,
        "text": "Introduction to Packages"
    },
    "sections": [
        {
            "type": "",
            "text": "A package establishes a mapping from names to symbols.  At any given time,\none package is current.  The current package is the one that is the value\nof *package*.  When using the Lisp reader, it is possible to refer to\nsymbols in packages other than the current one through the use of package\nprefixes in the printed representation of the symbol.\nFigure 11-1 lists some defined names that are applicable to packages.\nWhere an operator takes an argument that is either a symbol or a list of\nsymbols, an argument of nil is treated as an empty list of symbols.  Any\npackage argument may be either a string, a symbol, or a package.  If a\nsymbol is supplied, its name will be used as the package name.\n  *modules*            import                     provide           \n  *package*            in-package                 rename-package    \n  defpackage           intern                     require           \n  do-all-symbols       list-all-packages          shadow            \n  do-external-symbols  make-package               shadowing-import  \n  do-symbols           package-name               unexport          \n  export               package-nicknames          unintern          \n  find-all-symbols     package-shadowing-symbols  unuse-package     \n  find-package         package-use-list           use-package       \n  find-symbol          package-used-by-list                         \n         Figure 11-1: Some Defined Names related to Packages       \n* Menu:\n* Package Names and Nicknames::\n* Symbols in a Package::\n* Internal and External Symbols::\n* Package Inheritance::\n* Accessibility of Symbols in a Package::\n* Locating a Symbol in a Package::\n* Prevention of Name Conflicts in Packages::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Introduction to Packages,  Next: Standardized Packages,  Prev: Package Concepts,  Up: Package Concepts\n\nIntroduction to Packages\n------------------------\n\nA package establishes a mapping from names to symbols.  At any given time,\none package is current.  The current package is the one that is the value\nof *package*.  When using the Lisp reader, it is possible to refer to\nsymbols in packages other than the current one through the use of package\nprefixes in the printed representation of the symbol.\n\nFigure 11-1 lists some defined names that are applicable to packages.\nWhere an operator takes an argument that is either a symbol or a list of\nsymbols, an argument of nil is treated as an empty list of symbols.  Any\npackage argument may be either a string, a symbol, or a package.  If a\nsymbol is supplied, its name will be used as the package name.\n\n  *modules*            import                     provide           \n  *package*            in-package                 rename-package    \n  defpackage           intern                     require           \n  do-all-symbols       list-all-packages          shadow            \n  do-external-symbols  make-package               shadowing-import  \n  do-symbols           package-name               unexport          \n  export               package-nicknames          unintern          \n  find-all-symbols     package-shadowing-symbols  unuse-package     \n  find-package         package-use-list           use-package       \n  find-symbol          package-used-by-list                         \n\n         Figure 11-1: Some Defined Names related to Packages       \n\n\n* Menu:\n\n* Package Names and Nicknames::\n* Symbols in a Package::\n* Internal and External Symbols::\n* Package Inheritance::\n* Accessibility of Symbols in a Package::\n* Locating a Symbol in a Package::\n* Prevention of Name Conflicts in Packages::\n\n"
}