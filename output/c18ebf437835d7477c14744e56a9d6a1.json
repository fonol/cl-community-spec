{
    "name": "Extent",
    "prev": "Shadowing",
    "next": "Return Values",
    "up": "Evaluation",
    "header": {
        "type": null,
        "text": "Extent"
    },
    "sections": [
        {
            "type": "",
            "text": "Contorted-example works only because the function named by f is invoked\nduring the extent of the exit point.  Once the flow of execution has left\nthe block, the exit point is disestablished.  For example:\n      (defun invalid-example ()\n        (let ((y (block here #'(lambda (z) (return-from here z)))))\n          (if (numberp y) y (funcall y 5))))\nOne might expect the call (invalid-example) to produce 5 by the following\nincorrect reasoning: let binds y to the value of block; this value is a\nfunction resulting from the lambda expression.  Because y is not a number,\nit is invoked on the value 5.  The return-from should then return this\nvalue from the exit point named here, thereby exiting from the block again\nand giving y the value 5 which, being a number, is then returned as the\nvalue of the call to invalid-example.\nThe argument fails only because exit points have dynamic extent.  The\nargument is correct up to the execution of return-from.  The execution of\nreturn-from should signal an error of type control-error, however, not\nbecause it cannot refer to the exit point, but because it does correctly\nrefer to an exit point and that exit point has been disestablished.\nA reference by name to a dynamic exit point binding such as a catch tag\nrefers to the most recently established binding of that name that has not\nbeen disestablished.  For example:\n      (defun fun1 (x)\n        (catch 'trap (+ 3 (fun2 x))))\n      (defun fun2 (y)\n        (catch 'trap (* 5 (fun3 y))))\n      (defun fun3 (z)\n        (throw 'trap z))\nConsider the call (fun1 7).  The result is 10.  At the time the throw is\nexecuted, there are two outstanding catchers with the name trap: one\nestablished within procedure fun1, and the other within procedure fun2.\nThe latter is the more recent, and so the value 7 is returned from catch\nin fun2.  Viewed from within fun3, the catch in fun2 shadows the one in\nfun1.  Had fun2 been defined as\n      (defun fun2 (y)\n        (catch 'snare (* 5 (fun3 y))))\nthen the two exit points would have different names, and therefore the one\nin fun1 would not be shadowed.  The result would then have been 7.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Extent,  Next: Return Values,  Prev: Shadowing,  Up: Evaluation\n\nExtent\n------\n\nContorted-example works only because the function named by f is invoked\nduring the extent of the exit point.  Once the flow of execution has left\nthe block, the exit point is disestablished.  For example:\n\n      (defun invalid-example ()\n        (let ((y (block here #'(lambda (z) (return-from here z)))))\n          (if (numberp y) y (funcall y 5))))\n\nOne might expect the call (invalid-example) to produce 5 by the following\nincorrect reasoning: let binds y to the value of block; this value is a\nfunction resulting from the lambda expression.  Because y is not a number,\nit is invoked on the value 5.  The return-from should then return this\nvalue from the exit point named here, thereby exiting from the block again\nand giving y the value 5 which, being a number, is then returned as the\nvalue of the call to invalid-example.\n\nThe argument fails only because exit points have dynamic extent.  The\nargument is correct up to the execution of return-from.  The execution of\nreturn-from should signal an error of type control-error, however, not\nbecause it cannot refer to the exit point, but because it does correctly\nrefer to an exit point and that exit point has been disestablished.\n\nA reference by name to a dynamic exit point binding such as a catch tag\nrefers to the most recently established binding of that name that has not\nbeen disestablished.  For example:\n\n      (defun fun1 (x)\n        (catch 'trap (+ 3 (fun2 x))))\n      (defun fun2 (y)\n        (catch 'trap (* 5 (fun3 y))))\n      (defun fun3 (z)\n        (throw 'trap z))\n\nConsider the call (fun1 7).  The result is 10.  At the time the throw is\nexecuted, there are two outstanding catchers with the name trap: one\nestablished within procedure fun1, and the other within procedure fun2.\nThe latter is the more recent, and so the value 7 is returned from catch\nin fun2.  Viewed from within fun3, the catch in fun2 shadows the one in\nfun1.  Had fun2 been defined as\n\n      (defun fun2 (y)\n        (catch 'snare (* 5 (fun3 y))))\n\nthen the two exit points would have different names, and therefore the one\nin fun1 would not be shadowed.  The result would then have been 7.\n\n"
}