{
    "name": "load-time-value",
    "prev": "eval-when",
    "next": "quote",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "load-time-value"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "load-time-value",
                    "text": " form &optional read-only-p =>  object\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "form",
                    "desc": "a form; evaluated as described below."
                },
                {
                    "name": "read-only-p",
                    "desc": "a boolean; not evaluated."
                },
                {
                    "name": "object",
                    "desc": "the primary value resulting from evaluating form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "load-time-value provides a mechanism for delaying evaluation of form until\nthe expression is in the run-time environment; see *Note Compilation::.\nRead-only-p designates whether the result can be considered a constant\nobject.  If t, the result is a read-only quantity that can, if appropriate\nto the implementation, be copied into read-only space and/or coalesced\nwith similar constant objects from other programs.  If nil (the default),\nthe result must be neither copied nor coalesced; it must be considered to\nbe potentially modifiable data.\nIf a load-time-value expression is processed by compile-file, the compiler\nperforms its normal semantic processing (such as macro expansion and\ntranslation into machine code) on form, but arranges for the execution of\nform to occur at load time in a null lexical environment, with the result\nof this evaluation then being treated as a literal object at run time.  It\nis guaranteed that the evaluation of form will take place only once when\nthe file is loaded, but the order of evaluation with respect to the\nevaluation of top level forms in the file is implementation-dependent.\nIf a load-time-value expression appears within a function compiled with\ncompile, the form is evaluated at compile time in a null lexical\nenvironment.  The result of this compile-time evaluation is treated as a\nliteral object in the compiled code.\nIf a load-time-value expression is processed by eval, form is evaluated in\na null lexical environment, and one value is returned.  Implementations\nthat implicitly compile (or partially compile) expressions processed by\neval might evaluate form only once, at the time this compilation is\nperformed.\nIf the same list (load-time-value form) is evaluated or compiled more than\nonce, it is implementation-dependent whether form is evaluated only once\nor is evaluated more than once.  This can happen both when an expression\nbeing evaluated or compiled shares substructure, and when the same form is\nprocessed by eval or compile multiple times.  Since a load-time-value\nexpression can be referenced in more than one place and can be evaluated\nmultiple times by eval, it is implementation-dependent whether each\nexecution returns a fresh object or returns the same object as some other\nexecution.  Users must use caution when destructively modifying the\nresulting object.\nIf two lists (load-time-value form) that are the same under equal but are\nnot identical are evaluated or compiled, their values always come from\ndistinct evaluations of form.  Their values may not be coalesced unless\nread-only-p is t.\n"
        },
        {
            "type": "Examples",
            "text": "     ;;; The function INCR1 always returns the same value, even in different images.\n     ;;; The function INCR2 always returns the same value in a given image,\n     ;;; but the value it returns might vary from image to image.\n     (defun incr1 (x) (+ x #.(random 17)))\n     (defun incr2 (x) (+ x (load-time-value (random 17))))\n     ;;; The function FOO1-REF references the nth element of the first of\n     ;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for\n     ;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the\n     ;;; updated values.\n     (defvar *foo-arrays* (list (make-array 7) (make-array 8)))\n     (defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))\n     (defun set-foo1-ref (n val)\n       (setf (aref (load-time-value (first *my-arrays*) nil) n) val))\n     ;;; The function BAR1-REF references the nth element of the first of\n     ;;; the *BAR-ARRAYS* that is available at load time.  The programmer has\n     ;;; promised that the array will be treated as read-only, so the system\n     ;;; can copy or coalesce the array.\n     (defvar *bar-arrays* (list (make-array 7) (make-array 8)))\n     (defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))\n     ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced\n     ;;; even though NIL was specified, because the object was already read-only\n     ;;; when it was written as a literal vector rather than created by a constructor.\n     ;;; User programs must treat the vector v as read-only.\n     (defun baz-ref (n)\n       (let ((v (load-time-value #(A B C) nil)))\n         (values (svref v n) v)))\n     ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced\n     ;;; even though NIL was specified in the outer situation because T was specified\n     ;;; in the inner situation.  User programs must treat the vector v as read-only.\n     (defun baz-ref (n)\n       (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))\n         (values (svref v n) v)))\n"
        },
        {
            "type": "See Also",
            "text": "*Note compile-file:: , *Note compile:: , *Note eval:: , *Note Minimal\nCompilation::, *Note Compilation::\n"
        },
        {
            "type": "Notes",
            "text": "load-time-value must appear outside of quoted structure in a \"for\nevaluation\" position.  In situations which would appear to call for use of\nload-time-value within a quoted structure, the backquote reader macro is\nprobably called for; see *Note Backquote::.\nSpecifying nil for read-only-p is not a way to force an object to become\nmodifiable if it has already been made read-only.  It is only a way to say\nthat, for an object that is modifiable, this operation is not intended to\nmake that object read-only.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: load-time-value,  Next: quote,  Prev: eval-when,  Up: Evaluation and Compilation Dictionary\n\nload-time-value                                          [Special Operator]\n---------------------------------------------------------------------------\n\n`load-time-value'  form &optional read-only-p =>  object\n\nArguments and Values::\n......................\n\nform--a form; evaluated as described below.\n\nread-only-p--a boolean; not evaluated.\n\nobject--the primary value resulting from evaluating form.\n\nDescription::\n.............\n\nload-time-value provides a mechanism for delaying evaluation of form until\nthe expression is in the run-time environment; see *Note Compilation::.\n\nRead-only-p designates whether the result can be considered a constant\nobject.  If t, the result is a read-only quantity that can, if appropriate\nto the implementation, be copied into read-only space and/or coalesced\nwith similar constant objects from other programs.  If nil (the default),\nthe result must be neither copied nor coalesced; it must be considered to\nbe potentially modifiable data.\n\nIf a load-time-value expression is processed by compile-file, the compiler\nperforms its normal semantic processing (such as macro expansion and\ntranslation into machine code) on form, but arranges for the execution of\nform to occur at load time in a null lexical environment, with the result\nof this evaluation then being treated as a literal object at run time.  It\nis guaranteed that the evaluation of form will take place only once when\nthe file is loaded, but the order of evaluation with respect to the\nevaluation of top level forms in the file is implementation-dependent.\n\nIf a load-time-value expression appears within a function compiled with\ncompile, the form is evaluated at compile time in a null lexical\nenvironment.  The result of this compile-time evaluation is treated as a\nliteral object in the compiled code.\n\nIf a load-time-value expression is processed by eval, form is evaluated in\na null lexical environment, and one value is returned.  Implementations\nthat implicitly compile (or partially compile) expressions processed by\neval might evaluate form only once, at the time this compilation is\nperformed.\n\nIf the same list (load-time-value form) is evaluated or compiled more than\nonce, it is implementation-dependent whether form is evaluated only once\nor is evaluated more than once.  This can happen both when an expression\nbeing evaluated or compiled shares substructure, and when the same form is\nprocessed by eval or compile multiple times.  Since a load-time-value\nexpression can be referenced in more than one place and can be evaluated\nmultiple times by eval, it is implementation-dependent whether each\nexecution returns a fresh object or returns the same object as some other\nexecution.  Users must use caution when destructively modifying the\nresulting object.\n\nIf two lists (load-time-value form) that are the same under equal but are\nnot identical are evaluated or compiled, their values always come from\ndistinct evaluations of form.  Their values may not be coalesced unless\nread-only-p is t.\n\nExamples::\n..........\n\n     ;;; The function INCR1 always returns the same value, even in different images.\n     ;;; The function INCR2 always returns the same value in a given image,\n     ;;; but the value it returns might vary from image to image.\n     (defun incr1 (x) (+ x #.(random 17)))\n     (defun incr2 (x) (+ x (load-time-value (random 17))))\n     \n     ;;; The function FOO1-REF references the nth element of the first of\n     ;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for\n     ;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the\n     ;;; updated values.\n     (defvar *foo-arrays* (list (make-array 7) (make-array 8)))\n     (defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))\n     (defun set-foo1-ref (n val)\n       (setf (aref (load-time-value (first *my-arrays*) nil) n) val))\n     \n     ;;; The function BAR1-REF references the nth element of the first of\n     ;;; the *BAR-ARRAYS* that is available at load time.  The programmer has\n     ;;; promised that the array will be treated as read-only, so the system\n     ;;; can copy or coalesce the array.\n     (defvar *bar-arrays* (list (make-array 7) (make-array 8)))\n     (defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))\n     \n     ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced\n     ;;; even though NIL was specified, because the object was already read-only\n     ;;; when it was written as a literal vector rather than created by a constructor.\n     ;;; User programs must treat the vector v as read-only.\n     (defun baz-ref (n)\n       (let ((v (load-time-value #(A B C) nil)))\n         (values (svref v n) v)))\n     \n     ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced\n     ;;; even though NIL was specified in the outer situation because T was specified\n     ;;; in the inner situation.  User programs must treat the vector v as read-only.\n     (defun baz-ref (n)\n       (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))\n         (values (svref v n) v)))\n\nSee Also::\n..........\n\n*Note compile-file:: , *Note compile:: , *Note eval:: , *Note Minimal\nCompilation::, *Note Compilation::\n\nNotes::\n.......\n\nload-time-value must appear outside of quoted structure in a \"for\nevaluation\" position.  In situations which would appear to call for use of\nload-time-value within a quoted structure, the backquote reader macro is\nprobably called for; see *Note Backquote::.\n\nSpecifying nil for read-only-p is not a way to force an object to become\nmodifiable if it has already been made read-only.  It is only a way to say\nthat, for an object that is modifiable, this operation is not intended to\nmake that object read-only.\n\n"
}