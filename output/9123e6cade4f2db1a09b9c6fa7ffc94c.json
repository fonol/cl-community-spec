{
    "name": "Iteration Control",
    "prev": "Variable Initialization and Stepping Clauses",
    "next": "The for-as-arithmetic subclause",
    "up": "Variable Initialization and Stepping Clauses",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Iteration Control",
            "text": "Iteration control clauses allow direction of loop iteration.  The loop\nkeywords for and as designate iteration control clauses.  Iteration\ncontrol clauses differ with respect to the specification of termination\ntests and to the initialization and stepping_1 of loop variables.\nIteration clauses by themselves do not cause the Loop Facility to return\nvalues, but they can be used in conjunction with value-accumulation\nclauses to return values.\nAll variables are initialized in the loop prologue.  A variable binding\nhas lexical scope unless it is proclaimed special; thus, by default, the\nvariable can be accessed only by forms that lie textually within the loop.\nStepping assignments are made in the loop body before any other forms are\nevaluated in the body.\nThe variable argument in iteration control clauses can be a destructuring\nlist.  A destructuring list is a tree whose non-nil atoms are variable\nnames.  See *Note Destructuring::.\nThe iteration control clauses for, as,  and repeat must precede any other\nloop clauses, except initially, with, and named, since they establish\nvariable bindings.  When iteration control clauses are used in a loop, the\ncorresponding termination tests in the loop body are evaluated before any\nother loop body code is executed.\nIf multiple iteration clauses are used to control iteration, variable\ninitialization and stepping_1 occur sequentially by default.  The and\nconstruct can be used to connect two or more iteration clauses when\nsequential binding and stepping_1 are not necessary.  The iteration\nbehavior of clauses joined by and is analogous to the behavior of the\nmacro do with respect to do*.\nThe for and as clauses iterate by using one or more local loop  variables\nthat are initialized to some value and that can be modified or stepped_1\nafter each iteration.  For these clauses, iteration terminates when a local\nvariable reaches some supplied value or when some other loop clause\nterminates iteration.  At each iteration, variables can be stepped_1 by an\nincrement or a decrement or can be assigned a new value by the evaluation\nof a form).  Destructuring can be used to assign values to variables\nduring iteration.\nThe for and as keywords are synonyms; they can be used interchangeably.\nThere are seven syntactic formats for these constructs.  In each syntactic\nformat, the type of var can be supplied by the optional type-spec\nargument.  If var is a destructuring list, the type supplied by the\ntype-spec argument must appropriately match the elements of the list.  By\nconvention, for introduces new iterations and as introduces iterations\nthat depend on a previous iteration specification.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Iteration Control,  Next: The for-as-arithmetic subclause,  Prev: Variable Initialization and Stepping Clauses,  Up: Variable Initialization and Stepping Clauses\n\nIteration Control\n.................\n\nIteration control clauses allow direction of loop iteration.  The loop\nkeywords for and as designate iteration control clauses.  Iteration\ncontrol clauses differ with respect to the specification of termination\ntests and to the initialization and stepping_1 of loop variables.\nIteration clauses by themselves do not cause the Loop Facility to return\nvalues, but they can be used in conjunction with value-accumulation\nclauses to return values.\n\nAll variables are initialized in the loop prologue.  A variable binding\nhas lexical scope unless it is proclaimed special; thus, by default, the\nvariable can be accessed only by forms that lie textually within the loop.\nStepping assignments are made in the loop body before any other forms are\nevaluated in the body.\n\nThe variable argument in iteration control clauses can be a destructuring\nlist.  A destructuring list is a tree whose non-nil atoms are variable\nnames.  See *Note Destructuring::.\n\nThe iteration control clauses for, as,  and repeat must precede any other\nloop clauses, except initially, with, and named, since they establish\nvariable bindings.  When iteration control clauses are used in a loop, the\ncorresponding termination tests in the loop body are evaluated before any\nother loop body code is executed.\n\nIf multiple iteration clauses are used to control iteration, variable\ninitialization and stepping_1 occur sequentially by default.  The and\nconstruct can be used to connect two or more iteration clauses when\nsequential binding and stepping_1 are not necessary.  The iteration\nbehavior of clauses joined by and is analogous to the behavior of the\nmacro do with respect to do*.\n\nThe for and as clauses iterate by using one or more local loop  variables\nthat are initialized to some value and that can be modified or stepped_1\nafter each iteration.  For these clauses, iteration terminates when a local\nvariable reaches some supplied value or when some other loop clause\nterminates iteration.  At each iteration, variables can be stepped_1 by an\nincrement or a decrement or can be assigned a new value by the evaluation\nof a form).  Destructuring can be used to assign values to variables\nduring iteration.\n\nThe for and as keywords are synonyms; they can be used interchangeably.\nThere are seven syntactic formats for these constructs.  In each syntactic\nformat, the type of var can be supplied by the optional type-spec\nargument.  If var is a destructuring list, the type supplied by the\ntype-spec argument must appropriately match the elements of the list.  By\nconvention, for introduces new iterations and as introduces iterations\nthat depend on a previous iteration specification.\n\n"
}