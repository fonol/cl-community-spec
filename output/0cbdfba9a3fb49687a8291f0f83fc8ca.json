{
    "name": "Introduction to Methods",
    "prev": "Introduction to Generic Functions",
    "next": "Agreement on Parameter Specializers and Qualifiers",
    "up": "Generic Functions and Methods",
    "header": {
        "type": null,
        "text": "Introduction to Methods"
    },
    "sections": [
        {
            "type": "",
            "text": "Methods define the class-specific or identity-specific behavior and\noperations of a generic function.\nA method object is associated with code that implements the method's\nbehavior, a sequence of parameter specializers that specify when the given\nmethod is applicable, a lambda list, and a sequence of qualifiers that are\nused by the method combination facility to distinguish among methods.\nA method object is not a function and cannot be invoked as a function.\nVarious mechanisms in the object system take a method object and invoke\nits method function, as is the case when a generic function is invoked.\nWhen this occurs it is said that the method is invoked or called.\nA method-defining form contains the code that is to be run when the\narguments to the generic function cause the method that it defines to be\ninvoked.  When a method-defining form is evaluated, a method object is\ncreated and one of four actions is taken:\n*\n     If a generic function of the given name already exists and if a\n     method object already exists that agrees with the new one on\n     parameter specializers and qualifiers, the new method object replaces\n     the old one.  For a definition of one method agreeing with another on\n     parameter specializers and qualifiers, see *Note Agreement on\n     Parameter Specializers and Qualifiers::.\n*\n     If a generic function of the given name already exists and if there\n     is no method object that agrees with the new one on parameter\n     specializers and qualifiers, the existing generic function object is\n     modified to contain the new method object.\n*\n     If the given name names an ordinary function, a macro, or a special\n     operator, an error is signaled.\n*\n     Otherwise a generic function is created with the method specified by\n     the method-defining form.\nIf the lambda list of a new method is not congruent with the lambda list\nof the generic function, an error is signaled.  If a method-defining\noperator that cannot specify generic function options creates a new\ngeneric function, a lambda list for that generic function is derived from\nthe lambda list of the method in the method-defining form in such a way as\nto be congruent with it.  For a discussion of congruence , see *Note\nCongruent Lambda-lists for all Methods of a Generic Function::.\nEach method has a specialized lambda list, which determines when that\nmethod can be applied.  A specialized lambda list is like an ordinary\nlambda list except that a specialized parameter may occur instead of the\nname of a required parameter.  A specialized parameter is a list\n(variable-name parameter-specializer-name), where\nparameter-specializer-name is one of the following:\na symbol\n     denotes a parameter specializer which is the class named by that\n     symbol.\na class\n     denotes a parameter specializer which is the class itself.\n(eql form)\n     denotes a parameter specializer which satisfies the type specifier\n     (eql object), where object is the result of evaluating form.  The\n     form form is evaluated in the lexical environment in which the\n     method-defining form is evaluated.  Note that form is evaluated only\n     once, at the time the method is defined, not each time the generic\n     function is called.\nParameter specializer names are used in macros intended as the user-level\ninterface (defmethod), while parameter specializers are used in the\nfunctional interface.\nOnly required parameters may be specialized, and there must be a parameter\nspecializer for each required parameter.  For notational simplicity, if\nsome required parameter in a specialized lambda list in a method-defining\nform is simply a variable name, its parameter specializer defaults to the\nclass t.\nGiven a generic function and a set of arguments, an applicable method is a\nmethod for that generic function whose parameter specializers are\nsatisfied by their corresponding arguments.  The following definition\nspecifies what it means for a method to be applicable and for an argument\nto satisfy a parameter specializer.\nLet < A_1, ..., A_n> be the required arguments to a generic function in\norder. Let < P_1, ..., P_n> be the parameter specializers corresponding to\nthe required parameters of the method M in order.  The method M is\napplicable when each A_i is of the type specified by the type specifier\nP_i.  Because every valid parameter specializer is also a valid type\nspecifier, the function typep can be used during method selection to\ndetermine whether an argument satisfies a parameter specializer.\nA method all of whose parameter specializers are the class t is called a\ndefault method ; it is always applicable but may be shadowed by a more\nspecific method.\nMethods can have qualifiers, which give the method combination procedure a\nway to distinguish among methods.  A method that has one or more\nqualifiers is called a qualified method.  A method with no qualifiers is\ncalled an unqualified method.  A qualifier is any non-list.  The\nqualifiers defined by the standardized method combination types are\nsymbols.\nIn this specification, the terms \"primary method\" and \"auxiliary method\"\nare used to partition methods within a method combination type according\nto their intended use.  In standard method combination, primary methods are\nunqualified methods and auxiliary methods are methods with a single\nqualifier that is one of :around, :before, or :after.  Methods with these\nqualifiers are called around methods, before methods, and after methods,\nrespectively.  When a method combination type is defined using the short\nform of define-method-combination, primary methods are methods qualified\nwith the name of the type of method combination, and auxiliary methods\nhave the qualifier :around.  Thus the terms \"primary method\" and\n\"auxiliary method\" have only a relative definition within a given method\ncombination type.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Introduction to Methods,  Next: Agreement on Parameter Specializers and Qualifiers,  Prev: Introduction to Generic Functions,  Up: Generic Functions and Methods\n\nIntroduction to Methods\n-----------------------\n\nMethods define the class-specific or identity-specific behavior and\noperations of a generic function.\n\nA method object is associated with code that implements the method's\nbehavior, a sequence of parameter specializers that specify when the given\nmethod is applicable, a lambda list, and a sequence of qualifiers that are\nused by the method combination facility to distinguish among methods.\n\nA method object is not a function and cannot be invoked as a function.\nVarious mechanisms in the object system take a method object and invoke\nits method function, as is the case when a generic function is invoked.\nWhen this occurs it is said that the method is invoked or called.\n\nA method-defining form contains the code that is to be run when the\narguments to the generic function cause the method that it defines to be\ninvoked.  When a method-defining form is evaluated, a method object is\ncreated and one of four actions is taken:\n\n*\n     If a generic function of the given name already exists and if a\n     method object already exists that agrees with the new one on\n     parameter specializers and qualifiers, the new method object replaces\n     the old one.  For a definition of one method agreeing with another on\n     parameter specializers and qualifiers, see *Note Agreement on\n     Parameter Specializers and Qualifiers::.\n\n*\n     If a generic function of the given name already exists and if there\n     is no method object that agrees with the new one on parameter\n     specializers and qualifiers, the existing generic function object is\n     modified to contain the new method object.\n\n*\n     If the given name names an ordinary function, a macro, or a special\n     operator, an error is signaled.\n\n*\n     Otherwise a generic function is created with the method specified by\n     the method-defining form.\n\nIf the lambda list of a new method is not congruent with the lambda list\nof the generic function, an error is signaled.  If a method-defining\noperator that cannot specify generic function options creates a new\ngeneric function, a lambda list for that generic function is derived from\nthe lambda list of the method in the method-defining form in such a way as\nto be congruent with it.  For a discussion of congruence , see *Note\nCongruent Lambda-lists for all Methods of a Generic Function::.\n\nEach method has a specialized lambda list, which determines when that\nmethod can be applied.  A specialized lambda list is like an ordinary\nlambda list except that a specialized parameter may occur instead of the\nname of a required parameter.  A specialized parameter is a list\n(variable-name parameter-specializer-name), where\nparameter-specializer-name is one of the following:\n\na symbol\n     denotes a parameter specializer which is the class named by that\n     symbol.\n\na class\n     denotes a parameter specializer which is the class itself.\n\n(eql form)\n     denotes a parameter specializer which satisfies the type specifier\n     (eql object), where object is the result of evaluating form.  The\n     form form is evaluated in the lexical environment in which the\n     method-defining form is evaluated.  Note that form is evaluated only\n     once, at the time the method is defined, not each time the generic\n     function is called.\n\nParameter specializer names are used in macros intended as the user-level\ninterface (defmethod), while parameter specializers are used in the\nfunctional interface.\n\nOnly required parameters may be specialized, and there must be a parameter\nspecializer for each required parameter.  For notational simplicity, if\nsome required parameter in a specialized lambda list in a method-defining\nform is simply a variable name, its parameter specializer defaults to the\nclass t.\n\nGiven a generic function and a set of arguments, an applicable method is a\nmethod for that generic function whose parameter specializers are\nsatisfied by their corresponding arguments.  The following definition\nspecifies what it means for a method to be applicable and for an argument\nto satisfy a parameter specializer.\n\nLet < A_1, ..., A_n> be the required arguments to a generic function in\norder. Let < P_1, ..., P_n> be the parameter specializers corresponding to\nthe required parameters of the method M in order.  The method M is\napplicable when each A_i is of the type specified by the type specifier\nP_i.  Because every valid parameter specializer is also a valid type\nspecifier, the function typep can be used during method selection to\ndetermine whether an argument satisfies a parameter specializer.\n\nA method all of whose parameter specializers are the class t is called a\ndefault method ; it is always applicable but may be shadowed by a more\nspecific method.\n\nMethods can have qualifiers, which give the method combination procedure a\nway to distinguish among methods.  A method that has one or more\nqualifiers is called a qualified method.  A method with no qualifiers is\ncalled an unqualified method.  A qualifier is any non-list.  The\nqualifiers defined by the standardized method combination types are\nsymbols.\n\nIn this specification, the terms \"primary method\" and \"auxiliary method\"\nare used to partition methods within a method combination type according\nto their intended use.  In standard method combination, primary methods are\nunqualified methods and auxiliary methods are methods with a single\nqualifier that is one of :around, :before, or :after.  Methods with these\nqualifiers are called around methods, before methods, and after methods,\nrespectively.  When a method combination type is defined using the short\nform of define-method-combination, primary methods are methods qualified\nwith the name of the type of method combination, and auxiliary methods\nhave the qualifier :around.  Thus the terms \"primary method\" and\n\"auxiliary method\" have only a relative definition within a given method\ncombination type.\n\n"
}