{
    "name": "defmethod",
    "prev": "defgeneric",
    "next": "find-class",
    "up": "Objects Dictionary",
    "header": {
        "type": "Macro",
        "text": "defmethod"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "defmethod",
                    "text": " function-name {method-qualifier}* specialized-lambda-list[[{declaration}* | documentation]] {form}*\n=>  new-method\n\nfunction-name::= {symbol | (setf symbol)}\n\nmethod-qualifier::= non-list\n\n specialized-lambda-list::= ({var | (var parameter-specializer-name)}*\n                             [&optional {var | (var [initform [supplied-p-parameter] ])}*]\n                             [&rest var]\n                             [&key{var | ({var | (keywordvar)} [initform [supplied-p-parameter] ])}*\n                                          [&allow-other-keys] ]\n                             [&aux {var | (var [initform] )}*] )\n parameter-specializer-name::= symbol | (eql eql-specializer-form)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "documentation",
                    "desc": "a string; not evaluated."
                },
                {
                    "name": "var",
                    "desc": "a variable name."
                },
                {
                    "name": "eql-specializer-form",
                    "desc": "a form."
                },
                {
                    "name": "Form",
                    "desc": "a form."
                },
                {
                    "name": "Initform",
                    "desc": "a form."
                },
                {
                    "name": "Supplied-p-parameter",
                    "desc": "variable name."
                },
                {
                    "name": "new-method",
                    "desc": "the new method object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The macro defmethod defines a method on a generic function.\nIf (fboundp function-name) is nil, a generic function is created with\ndefault values for the argument precedence order (each argument is more\nspecific than the arguments to its right in the argument list), for the\ngeneric function class (the class standard-generic-function), for the\nmethod class (the class standard-method), and for the method combination\ntype (the standard method combination type).  The lambda list of the\ngeneric function is congruent with the lambda list of the method being\ndefined; if the defmethod form mentions keyword arguments, the lambda list\nof the generic function will mention &key (but no keyword arguments).  If\nfunction-name names an ordinary function, a macro, or a special operator,\nan error is signaled.\nIf a generic function is currently named by function-name, the lambda list\nof the method must be congruent with the lambda list of the generic\nfunction.  If this condition does not hold, an error is signaled.  For a\ndefinition of congruence in this context, see *Note Congruent Lambda-lists\nfor all Methods of a Generic Function::.\nEach method-qualifier argument is an object that is used by method\ncombination to identify the given method.  The method combination type\nmight further restrict what a method qualifier can be.  The standard\nmethod combination type allows for unqualified methods and methods whose\nsole qualifier is one of the keywords :before, :after, or :around.\nThe specialized-lambda-list argument is like an ordinary lambda list\nexcept that the names of required parameters can be replaced by\nspecialized parameters.  A specialized parameter is a list of the form\n(var parameter-specializer-name).  Only required parameters can be\nspecialized.  If parameter-specializer-name is a symbol it names a class;\nif it is a list, it is of the form (eql eql-specializer-form).  The\nparameter specializer name (eql eql-specializer-form) indicates that the\ncorresponding argument must be eql to the object that is the value of\neql-specializer-form for the method to be applicable.  The\neql-specializer-form is evaluated at the time that the expansion of the\ndefmethod macro is evaluated.  If no parameter specializer name is\nspecified for a given required parameter, the parameter specializer\ndefaults to the class t.  For further discussion, see *Note Introduction\nto Methods::.\nThe form arguments specify the method body.  The body of the method is\nenclosed in an implicit block.  If function-name is a symbol, this block\nbears the same name as the generic function.  If function-name is a list\nof the form (setf symbol), the name of the block is symbol.\nThe class of the method object that is created is that given by the method\nclass option of the generic function on which the method is defined.\nIf the generic function already has a method that agrees with the method\nbeing defined on parameter specializers and qualifiers, defmethod replaces\nthe existing method with the one now being defined.  For a definition of\nagreement in this context.  see *Note Agreement on Parameter Specializers\nand Qualifiers::.\nThe parameter specializers are derived from the parameter specializer\nnames as described in *Note Introduction to Methods::.\nThe expansion of the defmethod macro \"refers to\" each specialized\nparameter (see the description of ignore within the description of\ndeclare).  This includes parameters that have an explicit parameter\nspecializer name of t.  This means that a compiler warning does not occur\nif the body of the method does not refer to a specialized parameter, while\na warning might occur if the body of the method does not refer to an\nunspecialized parameter.  For this reason, a parameter that specializes on\nt is not quite synonymous with an unspecialized parameter in this context.\nDeclarations at the head of the method body that apply to the method's\nlambda variables are treated as bound declarations whose scope is the same\nas the corresponding bindings.\nDeclarations at the head of the method body that apply to the functional\nbindings of call-next-method or next-method-p apply to references to those\nfunctions within the method body forms.  Any outer bindings of the\nfunction names call-next-method and next-method-p, and declarations\nassociated with such bindings are shadowed_2 within the method body forms.\nThe scope of free declarations at the head of the method body is the\nentire method body, which includes any implicit local function definitions\nbut excludes initialization forms for the lambda variables.\ndefmethod is not required to perform any compile-time side effects.  In\nparticular, the methods are not installed for invocation during\ncompilation.  An implementation may choose to store information about the\ngeneric function for the purposes of compile-time error-checking (such as\nchecking the number of arguments on calls, or noting that a definition for\nthe function name has been seen).\nDocumentation is attached as a documentation string to the method object.\n"
        },
        {
            "type": "Affected By",
            "text": "The definition of the referenced generic function.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If function-name names an ordinary function, a macro, or a special\noperator, an error of type error is signaled.\nIf a generic function is currently named by function-name, the lambda list\nof the method must be congruent with the lambda list of the generic\nfunction, or an error of type error is signaled.\n"
        },
        {
            "type": "See Also",
            "text": "*Note defgeneric:: , *Note documentation; (setf documentation):: , *Note\nIntroduction to Methods::, *Note Congruent Lambda-lists for all Methods of\na Generic Function::, *Note Agreement on Parameter Specializers and\nQualifiers::, *Note Syntactic Interaction of Documentation Strings and\nDeclarations::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: defmethod,  Next: find-class,  Prev: defgeneric,  Up: Objects Dictionary\n\ndefmethod                                                           [Macro]\n---------------------------------------------------------------------------\n\n`defmethod'  function-name {method-qualifier}* specialized-lambda-list\n[[{declaration}* | documentation]] {form}*\n=>  new-method\n\nfunction-name::= {symbol | (setf symbol)}\n\nmethod-qualifier::= non-list\n\n specialized-lambda-list::= ({var | (var parameter-specializer-name)}*\n                             [&optional {var | (var [initform [supplied-p-parameter] ])}*]\n                             [&rest var]\n                             [&key{var | ({var | (keywordvar)} [initform [supplied-p-parameter] ])}*\n                                          [&allow-other-keys] ]\n                             [&aux {var | (var [initform] )}*] )\n parameter-specializer-name::= symbol | (eql eql-specializer-form)\nArguments and Values::\n......................\n\ndeclaration--a declare expression; not evaluated.\n\ndocumentation--a string; not evaluated.\n\nvar--a variable name.\n\neql-specializer-form--a form.\n\nForm--a form.\n\nInitform--a form.\n\nSupplied-p-parameter--variable name.\n\nnew-method--the new method object.\n\nDescription::\n.............\n\nThe macro defmethod defines a method on a generic function.\n\nIf (fboundp function-name) is nil, a generic function is created with\ndefault values for the argument precedence order (each argument is more\nspecific than the arguments to its right in the argument list), for the\ngeneric function class (the class standard-generic-function), for the\nmethod class (the class standard-method), and for the method combination\ntype (the standard method combination type).  The lambda list of the\ngeneric function is congruent with the lambda list of the method being\ndefined; if the defmethod form mentions keyword arguments, the lambda list\nof the generic function will mention &key (but no keyword arguments).  If\nfunction-name names an ordinary function, a macro, or a special operator,\nan error is signaled.\n\nIf a generic function is currently named by function-name, the lambda list\nof the method must be congruent with the lambda list of the generic\nfunction.  If this condition does not hold, an error is signaled.  For a\ndefinition of congruence in this context, see *Note Congruent Lambda-lists\nfor all Methods of a Generic Function::.\n\nEach method-qualifier argument is an object that is used by method\ncombination to identify the given method.  The method combination type\nmight further restrict what a method qualifier can be.  The standard\nmethod combination type allows for unqualified methods and methods whose\nsole qualifier is one of the keywords :before, :after, or :around.\n\nThe specialized-lambda-list argument is like an ordinary lambda list\nexcept that the names of required parameters can be replaced by\nspecialized parameters.  A specialized parameter is a list of the form\n(var parameter-specializer-name).  Only required parameters can be\nspecialized.  If parameter-specializer-name is a symbol it names a class;\nif it is a list, it is of the form (eql eql-specializer-form).  The\nparameter specializer name (eql eql-specializer-form) indicates that the\ncorresponding argument must be eql to the object that is the value of\neql-specializer-form for the method to be applicable.  The\neql-specializer-form is evaluated at the time that the expansion of the\ndefmethod macro is evaluated.  If no parameter specializer name is\nspecified for a given required parameter, the parameter specializer\ndefaults to the class t.  For further discussion, see *Note Introduction\nto Methods::.\n\nThe form arguments specify the method body.  The body of the method is\nenclosed in an implicit block.  If function-name is a symbol, this block\nbears the same name as the generic function.  If function-name is a list\nof the form (setf symbol), the name of the block is symbol.\n\nThe class of the method object that is created is that given by the method\nclass option of the generic function on which the method is defined.\n\nIf the generic function already has a method that agrees with the method\nbeing defined on parameter specializers and qualifiers, defmethod replaces\nthe existing method with the one now being defined.  For a definition of\nagreement in this context.  see *Note Agreement on Parameter Specializers\nand Qualifiers::.\n\nThe parameter specializers are derived from the parameter specializer\nnames as described in *Note Introduction to Methods::.\n\nThe expansion of the defmethod macro \"refers to\" each specialized\nparameter (see the description of ignore within the description of\ndeclare).  This includes parameters that have an explicit parameter\nspecializer name of t.  This means that a compiler warning does not occur\nif the body of the method does not refer to a specialized parameter, while\na warning might occur if the body of the method does not refer to an\nunspecialized parameter.  For this reason, a parameter that specializes on\nt is not quite synonymous with an unspecialized parameter in this context.\n\nDeclarations at the head of the method body that apply to the method's\nlambda variables are treated as bound declarations whose scope is the same\nas the corresponding bindings.\n\nDeclarations at the head of the method body that apply to the functional\nbindings of call-next-method or next-method-p apply to references to those\nfunctions within the method body forms.  Any outer bindings of the\nfunction names call-next-method and next-method-p, and declarations\nassociated with such bindings are shadowed_2 within the method body forms.\n\nThe scope of free declarations at the head of the method body is the\nentire method body, which includes any implicit local function definitions\nbut excludes initialization forms for the lambda variables.\n\ndefmethod is not required to perform any compile-time side effects.  In\nparticular, the methods are not installed for invocation during\ncompilation.  An implementation may choose to store information about the\ngeneric function for the purposes of compile-time error-checking (such as\nchecking the number of arguments on calls, or noting that a definition for\nthe function name has been seen).\n\nDocumentation is attached as a documentation string to the method object.\n\nAffected By::\n.............\n\nThe definition of the referenced generic function.\n\nExceptional Situations::\n........................\n\nIf function-name names an ordinary function, a macro, or a special\noperator, an error of type error is signaled.\n\nIf a generic function is currently named by function-name, the lambda list\nof the method must be congruent with the lambda list of the generic\nfunction, or an error of type error is signaled.\n\nSee Also::\n..........\n\n*Note defgeneric:: , *Note documentation; (setf documentation):: , *Note\nIntroduction to Methods::, *Note Congruent Lambda-lists for all Methods of\na Generic Function::, *Note Agreement on Parameter Specializers and\nQualifiers::, *Note Syntactic Interaction of Documentation Strings and\nDeclarations::\n\n"
}