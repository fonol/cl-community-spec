{
    "name": "defconstant",
    "prev": "lambda-parameters-limit",
    "next": "defparameter",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "defconstant"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "defconstant",
                    "text": " name initial-value [documentation] =>  name\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a symbol; not evaluated."
                },
                {
                    "name": "initial-value",
                    "desc": "a form; evaluated."
                },
                {
                    "name": "documentation",
                    "desc": "a string; not evaluated."
                }
            ]
        },
        {
            "type": "Description",
            "text": "defconstant causes the global variable named by name to be given a value\nthat is the result of evaluating initial-value.\nA constant defined by defconstant can be redefined with defconstant.\nHowever, the consequences are undefined if an attempt is made to assign a\nvalue to the symbol using another operator, or to assign it to a different\nvalue using a subsequent defconstant.\nIf documentation is supplied, it is attached to name as a documentation\nstring of kind variable.\ndefconstant normally appears as a top level form, but it is meaningful for\nit to appear as a non-top-level form.  However, the compile-time side\neffects described below only take place when defconstant appears as a top\nlevel form.\nThe consequences are undefined if there are any bindings of the variable\nnamed by name at the time defconstant is executed or if the value is not\neql to the value of initial-value.\nThe consequences are undefined when constant symbols are rebound as either\nlexical or dynamic variables.  In other words, a reference to a symbol\ndeclared with defconstant always refers to its global value.\nThe side effects of the execution of defconstant must be equivalent to at\nleast the side effects of the execution of the following code:\n      (setf (symbol-value 'name) initial-value)\n      (setf (documentation 'name 'variable) 'documentation)\nIf a defconstant form appears as a top level form, the compiler must\nrecognize that name names a constant variable.  An implementation may\nchoose to evaluate the value-form at compile time, load time, or both.\nTherefore, users must ensure that the initial-value can be evaluated at\ncompile time (regardless of whether or not references to name appear in\nthe file) and that it always evaluates to the same value.\n[Editorial Note by KMP: Does \"same value\" here mean eql or similar?]\n[Reviewer Note by Moon: Probably depends on whether load time is compared\nto compile time, or two compiles.]\n"
        },
        {
            "type": "Examples",
            "text": "      (defconstant this-is-a-constant 'never-changing \"for a test\") =>  THIS-IS-A-CONSTANT\n     this-is-a-constant =>  NEVER-CHANGING\n      (documentation 'this-is-a-constant 'variable) =>  \"for a test\"\n      (constantp 'this-is-a-constant) =>  true\n"
        },
        {
            "type": "See Also",
            "text": "*Note declaim:: , *Note defparameter; defvar:: , defvar, *Note\ndocumentation; (setf documentation):: , *Note proclaim:: , *Note Constant\nVariables::, *Note Compilation::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: defconstant,  Next: defparameter,  Prev: lambda-parameters-limit,  Up: Data and Control Flow Dictionary\n\ndefconstant                                                         [Macro]\n---------------------------------------------------------------------------\n\n`defconstant'  name initial-value [documentation] =>  name\n\nArguments and Values::\n......................\n\nname--a symbol; not evaluated.\n\ninitial-value--a form; evaluated.\n\ndocumentation--a string; not evaluated.\n\nDescription::\n.............\n\ndefconstant causes the global variable named by name to be given a value\nthat is the result of evaluating initial-value.\n\nA constant defined by defconstant can be redefined with defconstant.\nHowever, the consequences are undefined if an attempt is made to assign a\nvalue to the symbol using another operator, or to assign it to a different\nvalue using a subsequent defconstant.\n\nIf documentation is supplied, it is attached to name as a documentation\nstring of kind variable.\n\ndefconstant normally appears as a top level form, but it is meaningful for\nit to appear as a non-top-level form.  However, the compile-time side\neffects described below only take place when defconstant appears as a top\nlevel form.\n\nThe consequences are undefined if there are any bindings of the variable\nnamed by name at the time defconstant is executed or if the value is not\neql to the value of initial-value.\n\nThe consequences are undefined when constant symbols are rebound as either\nlexical or dynamic variables.  In other words, a reference to a symbol\ndeclared with defconstant always refers to its global value.\n\nThe side effects of the execution of defconstant must be equivalent to at\nleast the side effects of the execution of the following code:\n\n      (setf (symbol-value 'name) initial-value)\n      (setf (documentation 'name 'variable) 'documentation)\n\nIf a defconstant form appears as a top level form, the compiler must\nrecognize that name names a constant variable.  An implementation may\nchoose to evaluate the value-form at compile time, load time, or both.\nTherefore, users must ensure that the initial-value can be evaluated at\ncompile time (regardless of whether or not references to name appear in\nthe file) and that it always evaluates to the same value.\n\n[Editorial Note by KMP: Does \"same value\" here mean eql or similar?]\n\n[Reviewer Note by Moon: Probably depends on whether load time is compared\nto compile time, or two compiles.]\n\nExamples::\n..........\n\n      (defconstant this-is-a-constant 'never-changing \"for a test\") =>  THIS-IS-A-CONSTANT\n     this-is-a-constant =>  NEVER-CHANGING\n      (documentation 'this-is-a-constant 'variable) =>  \"for a test\"\n      (constantp 'this-is-a-constant) =>  true\n\nSee Also::\n..........\n\n*Note declaim:: , *Note defparameter; defvar:: , defvar, *Note\ndocumentation; (setf documentation):: , *Note proclaim:: , *Note Constant\nVariables::, *Note Compilation::\n\n"
}