{
    "name": "multiple-value-bind",
    "prev": "typecase",
    "next": "multiple-value-call",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "multiple-value-bind"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "multiple-value-bind",
                    "text": " ({var}*) values-form {declaration}* {form}*=>  {result}*\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "var",
                    "desc": "a symbol naming a variable; not evaluated."
                },
                {
                    "name": "values-form",
                    "desc": "a form; evaluated."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Creates new variable bindings for the vars and executes a series of forms\nthat use these bindings.\nThe variable bindings created are lexical unless special declarations are\nspecified.\nValues-form is evaluated, and each of the vars is bound to the respective\nvalue returned by that form.  If there are more vars than values returned,\nextra values of nil are given to the remaining vars. If there are more\nvalues than vars, the excess values are discarded.  The vars are bound to\nthe values over the execution of the forms, which make up an implicit\nprogn.  The consequences are unspecified if a type declaration is specified\nfor a var, but the value to which that var is bound  is not consistent with\nthe type declaration.\nThe scopes of the name binding and declarations do not include the\nvalues-form.\n"
        },
        {
            "type": "Examples",
            "text": "      (multiple-value-bind (f r)\n          (floor 130 11)\n        (list f r)) =>  (11 9)\n"
        },
        {
            "type": "See Also",
            "text": "*Note let; let*:: , *Note multiple-value-call::\n"
        },
        {
            "type": "Notes",
            "text": "      (multiple-value-bind ({var}*) values-form {form}*)\n      == (multiple-value-call #'(lambda (&optional {var}* &rest #1=#:ignore)\n                                  (declare (ignore #1#))\n                                  {form}*)\n                              values-form)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: multiple-value-bind,  Next: multiple-value-call,  Prev: typecase,  Up: Data and Control Flow Dictionary\n\nmultiple-value-bind                                                 [Macro]\n---------------------------------------------------------------------------\n\n`multiple-value-bind'  ({var}*) values-form {declaration}* {form}*\n=>  {result}*\n\nArguments and Values::\n......................\n\nvar--a symbol naming a variable; not evaluated.\n\nvalues-form--a form; evaluated.\n\ndeclaration--a declare expression; not evaluated.\n\nforms--an implicit progn.\n\nresults--the values returned by the forms.\n\nDescription::\n.............\n\nCreates new variable bindings for the vars and executes a series of forms\nthat use these bindings.\n\nThe variable bindings created are lexical unless special declarations are\nspecified.\n\nValues-form is evaluated, and each of the vars is bound to the respective\nvalue returned by that form.  If there are more vars than values returned,\nextra values of nil are given to the remaining vars. If there are more\nvalues than vars, the excess values are discarded.  The vars are bound to\nthe values over the execution of the forms, which make up an implicit\nprogn.  The consequences are unspecified if a type declaration is specified\nfor a var, but the value to which that var is bound  is not consistent with\nthe type declaration.\n\nThe scopes of the name binding and declarations do not include the\nvalues-form.\n\nExamples::\n..........\n\n      (multiple-value-bind (f r)\n          (floor 130 11)\n        (list f r)) =>  (11 9)\n\nSee Also::\n..........\n\n*Note let; let*:: , *Note multiple-value-call::\n\nNotes::\n.......\n\n      (multiple-value-bind ({var}*) values-form {form}*)\n      == (multiple-value-call #'(lambda (&optional {var}* &rest #1=#:ignore)\n                                  (declare (ignore #1#))\n                                  {form}*)\n                              values-form)\n\n"
}