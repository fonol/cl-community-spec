{
    "name": "copy-symbol",
    "prev": "make-symbol",
    "next": "gensym",
    "up": "Symbols Dictionary",
    "header": {
        "type": "Function",
        "text": "copy-symbol"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "copy-symbol",
                    "text": " symbol &optional copy-properties =>  new-symbol\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "symbol",
                    "desc": "a symbol."
                },
                {
                    "name": "copy-properties",
                    "desc": "a generalized boolean.  The default is false."
                },
                {
                    "name": "new-symbol",
                    "desc": "a fresh, uninterned symbol."
                }
            ]
        },
        {
            "type": "Description",
            "text": "copy-symbol returns a fresh, uninterned symbol, the name of which is\nstring= to and possibly the same as the name of the given symbol.\nIf copy-properties is false, the new-symbol is neither bound nor fbound\nand has a null property list.  If copy-properties is true, then the\ninitial value of new-symbol is the value of symbol, the initial function\ndefinition of new-symbol is the functional value of symbol, and the\nproperty list of new-symbol is\na copy_2 of the property list of symbol.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq fred 'fred-smith) =>  FRED-SMITH\n      (setf (symbol-value fred) 3) =>  3\n      (setq fred-clone-1a (copy-symbol fred nil)) =>  #:FRED-SMITH\n      (setq fred-clone-1b (copy-symbol fred nil)) =>  #:FRED-SMITH\n      (setq fred-clone-2a (copy-symbol fred t))   =>  #:FRED-SMITH\n      (setq fred-clone-2b (copy-symbol fred t))   =>  #:FRED-SMITH\n      (eq fred fred-clone-1a) =>  false\n      (eq fred-clone-1a fred-clone-1b) =>  false\n      (eq fred-clone-2a fred-clone-2b) =>  false\n      (eq fred-clone-1a fred-clone-2a) =>  false\n      (symbol-value fred) =>  3\n      (boundp fred-clone-1a) =>  false\n      (symbol-value fred-clone-2a) =>  3\n      (setf (symbol-value fred-clone-2a) 4) =>  4\n      (symbol-value fred) =>  3\n      (symbol-value fred-clone-2a) =>  4\n      (symbol-value fred-clone-2b) =>  3\n      (boundp fred-clone-1a) =>  false\n      (setf (symbol-function fred) #'(lambda (x) x)) =>  #<FUNCTION anonymous>\n      (fboundp fred) =>  true\n      (fboundp fred-clone-1a) =>  false\n      (fboundp fred-clone-2a) =>  false\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if symbol is not a symbol.\n"
        },
        {
            "type": "See Also",
            "text": "*Note make-symbol::\n"
        },
        {
            "type": "Notes",
            "text": "Implementors are encouraged not to copy the string which is the symbol's\nname unnecessarily.  Unless there is a good reason to do so, the normal\nimplementation strategy is for the new-symbol's name to be identical to\nthe given symbol's name.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: copy-symbol,  Next: gensym,  Prev: make-symbol,  Up: Symbols Dictionary\n\ncopy-symbol                                                      [Function]\n---------------------------------------------------------------------------\n\n`copy-symbol'  symbol &optional copy-properties =>  new-symbol\n\nArguments and Values::\n......................\n\nsymbol--a symbol.\n\ncopy-properties--a generalized boolean.  The default is false.\n\nnew-symbol--a fresh, uninterned symbol.\n\nDescription::\n.............\n\ncopy-symbol returns a fresh, uninterned symbol, the name of which is\nstring= to and possibly the same as the name of the given symbol.\n\nIf copy-properties is false, the new-symbol is neither bound nor fbound\nand has a null property list.  If copy-properties is true, then the\ninitial value of new-symbol is the value of symbol, the initial function\ndefinition of new-symbol is the functional value of symbol, and the\nproperty list of new-symbol is\n\na copy_2 of the property list of symbol.\n\nExamples::\n..........\n\n      (setq fred 'fred-smith) =>  FRED-SMITH\n      (setf (symbol-value fred) 3) =>  3\n      (setq fred-clone-1a (copy-symbol fred nil)) =>  #:FRED-SMITH\n      (setq fred-clone-1b (copy-symbol fred nil)) =>  #:FRED-SMITH\n      (setq fred-clone-2a (copy-symbol fred t))   =>  #:FRED-SMITH\n      (setq fred-clone-2b (copy-symbol fred t))   =>  #:FRED-SMITH\n      (eq fred fred-clone-1a) =>  false\n      (eq fred-clone-1a fred-clone-1b) =>  false\n      (eq fred-clone-2a fred-clone-2b) =>  false\n      (eq fred-clone-1a fred-clone-2a) =>  false\n      (symbol-value fred) =>  3\n      (boundp fred-clone-1a) =>  false\n      (symbol-value fred-clone-2a) =>  3\n      (setf (symbol-value fred-clone-2a) 4) =>  4\n      (symbol-value fred) =>  3\n      (symbol-value fred-clone-2a) =>  4\n      (symbol-value fred-clone-2b) =>  3\n      (boundp fred-clone-1a) =>  false\n      (setf (symbol-function fred) #'(lambda (x) x)) =>  #<FUNCTION anonymous>\n      (fboundp fred) =>  true\n      (fboundp fred-clone-1a) =>  false\n      (fboundp fred-clone-2a) =>  false\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if symbol is not a symbol.\n\nSee Also::\n..........\n\n*Note make-symbol::\n\nNotes::\n.......\n\nImplementors are encouraged not to copy the string which is the symbol's\nname unnecessarily.  Unless there is a good reason to do so, the normal\nimplementation strategy is for the new-symbol's name to be identical to\nthe given symbol's name.\n\n"
}