{
    "name": "loop",
    "prev": "dolist",
    "next": "loop-finish",
    "up": "Iteration Dictionary",
    "header": {
        "type": "Macro",
        "text": "loop"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "loop",
                    "text": " {compound-form}* =>  {result}*\nThe \"extended\" loop form:\n\n"
                },
                {
                    "name": "loop",
                    "text": " [!name-clause] {!variable-clause}* {!main-clause}* =>  {result}*\n\nname-clause ::=named name\n\nvariable-clause ::=!with-clause | !initial-final | !for-as-clause\n\nwith-clause ::=with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}*\n\nmain-clause ::=!unconditional | !accumulation | !conditional | !termination-test | !initial-final\n\ninitial-final ::=initially {compound-form}^+ | finally {compound-form}^+\n\nunconditional ::={do | doing} {compound-form}^+ | return {form | it}\n\naccumulation ::=!list-accumulation | !numeric-accumulation\n\nlist-accumulation ::={collect | collecting | append | appending | nconc | nconcing} {form | it} \n                      [into simple-var]\n\nnumeric-accumulation ::={count | counting | sum | summing | }                          maximize | maximizing | minimize | minimizing {form | it} \n                         [into simple-var] [type-spec]\n\nconditional ::={if | when | unless} form !selectable-clause {and !selectable-clause}* \n                [else !selectable-clause {and !selectable-clause}*] \n                [end]\n\nselectable-clause ::=!unconditional | !accumulation | !conditional\n\ntermination-test ::=while form | until form | repeat form | always form | never form | thereis form\n\nfor-as-clause ::={for | as} !for-as-subclause {and !for-as-subclause}*\n\nfor-as-subclause ::=!for-as-arithmetic | !for-as-in-list | !for-as-on-list | !for-as-equals-then |\n                     !for-as-across | !for-as-hash | !for-as-package\n\nfor-as-arithmetic ::=var [type-spec] !for-as-arithmetic-subclause\n\nfor-as-arithmetic-subclause ::=!arithmetic-up | !arithmetic-downto | !arithmetic-downfrom\n\narithmetic-up ::=[[{from | upfrom} form1 | {to | upto | below} form2 | by form3]]^+\n\narithmetic-downto ::=[[{from form1}^1 | {{downto | above} form2}^1 | by form3]]\n\narithmetic-downfrom ::=[[{downfrom form1}^1 | {to | downto | above} form2 | by form3]]\n\nfor-as-in-list ::=var [type-spec] in form1 [by step-fun]\n\nfor-as-on-list ::=var [type-spec] on form1 [by step-fun]\n\nfor-as-equals-then ::=var [type-spec] = form1 [then form2]\n\nfor-as-across ::=var [type-spec] across vector\n\nfor-as-hash ::=var [type-spec] being {each | the} \n                {{hash-key | hash-keys} {in | of} hash-table \n                [using (hash-value other-var)] | \n                {hash-value | hash-values} {in | of} hash-table \n                [using (hash-key other-var)]}\n\nfor-as-package ::=var [type-spec] being {each | the} \n                   {symbol | symbols |\n                   present-symbol | present-symbols |\n                   external-symbol | external-symbols} \n                   [{in | of} package]\n\ntype-spec ::=!simple-type-spec | !destructured-type-spec\n\nsimple-type-spec ::=fixnum | float | t | nil\n\ndestructured-type-spec ::=of-type d-type-spec\n\nd-type-spec ::=type-specifier | (d-type-spec . d-type-spec)\n\nvar ::=!d-var-spec\n\nvar1 ::=!d-var-spec\n\nvar2 ::=!d-var-spec\n\nother-var ::=!d-var-spec\n\nd-var-spec ::=simple-var | nil | (!d-var-spec . !d-var-spec)\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "compound-form",
                    "desc": "a compound form."
                },
                {
                    "name": "name",
                    "desc": "a symbol."
                },
                {
                    "name": "simple-var",
                    "desc": "a symbol (a variable name)."
                },
                {
                    "name": "form, form1, form2, form3",
                    "desc": "a form."
                },
                {
                    "name": "step-fun",
                    "desc": "a form that evaluates to a function of one argument."
                },
                {
                    "name": "vector",
                    "desc": "a form that evaluates to a vector."
                },
                {
                    "name": "hash-table",
                    "desc": "a form that evaluates to a hash table."
                },
                {
                    "name": "package",
                    "desc": "a form that evaluates to a package designator."
                },
                {
                    "name": "type-specifier",
                    "desc": "a type specifier.  This might be either an atomic typespecifier or a compound type specifier, which introduces some additional\ncomplications to proper parsing in the face of destructuring; for further\ninformation, see *Note Destructuring::.\n"
                },
                {
                    "name": "result",
                    "desc": "an object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "For details, see *Note The LOOP Facility::.\n"
        },
        {
            "type": "Examples",
            "text": "     ;; An example of the simple form of LOOP.\n      (defun sqrt-advisor ()\n        (loop (format t \"~&Number: \")\n              (let ((n (parse-integer (read-line) :junk-allowed t)))\n                (when (not n) (return))\n                (format t \"~&The square root of ~D is ~D.~\n     =>  SQRT-ADVISOR\n      (sqrt-advisor)\n      |>  Number: |>>5[<--~]<<|\n      |>  The square root of 5 is 2.236068.\n      |>  Number: |>>4[<--~]<<|\n      |>  The square root of 4 is 2.\n      |>  Number: |>>done[<--~]<<|\n     =>  NIL\n     ;; An example of the extended form of LOOP.\n      (defun square-advisor ()\n        (loop as n = (progn (format t \"~&Number: \")\n                            (parse-integer (read-line) :junk-allowed t))\n              while n\n              do (format t \"~&The square of ~D is ~D.~\n     =>  SQUARE-ADVISOR\n      (square-advisor)\n      |>  Number: |>>4[<--~]<<|\n      |>  The square of 4 is 16.\n      |>  Number: |>>23[<--~]<<|\n      |>  The square of 23 is 529.\n      |>  Number: |>>done[<--~]<<|\n     =>  NIL\n     ;; Another example of the extended form of LOOP.\n      (loop for n from 1 to 10\n            when (oddp n)\n              collect n)\n     =>  (1 3 5 7 9)\n"
        },
        {
            "type": "See Also",
            "text": "*Note do; do*:: , *Note dolist:: , *Note dotimes:: , *Note return:: ,\n*Note go:: , *Note throw:: , *Note Destructuring::\n"
        },
        {
            "type": "Notes",
            "text": "Except that loop-finish cannot be used within a simple loop form, a simple\nloop form is related to an extended loop form in the following way:\n      (loop {compound-form}*) == (loop do {compound-form}*)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: loop,  Next: loop-finish,  Prev: dolist,  Up: Iteration Dictionary\n\nloop                                                                [Macro]\n---------------------------------------------------------------------------\n\nThe \"simple\" loop form:\n\n`loop'  {compound-form}* =>  {result}*\n\nThe \"extended\" loop form:\n\n`loop'  [!name-clause] {!variable-clause}* {!main-clause}* =>  {result}*\n\nname-clause ::=named name\n\nvariable-clause ::=!with-clause | !initial-final | !for-as-clause\n\nwith-clause ::=with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}*\n\nmain-clause ::=!unconditional | !accumulation | !conditional | !termination-test | !initial-final\n\ninitial-final ::=initially {compound-form}^+ | finally {compound-form}^+\n\nunconditional ::={do | doing} {compound-form}^+ | return {form | it}\n\naccumulation ::=!list-accumulation | !numeric-accumulation\n\nlist-accumulation ::={collect | collecting | append | appending | nconc | nconcing} {form | it} \n                      [into simple-var]\n\nnumeric-accumulation ::={count | counting | sum | summing | }                          maximize | maximizing | minimize | minimizing {form | it} \n                         [into simple-var] [type-spec]\n\nconditional ::={if | when | unless} form !selectable-clause {and !selectable-clause}* \n                [else !selectable-clause {and !selectable-clause}*] \n                [end]\n\nselectable-clause ::=!unconditional | !accumulation | !conditional\n\ntermination-test ::=while form | until form | repeat form | always form | never form | thereis form\n\nfor-as-clause ::={for | as} !for-as-subclause {and !for-as-subclause}*\n\nfor-as-subclause ::=!for-as-arithmetic | !for-as-in-list | !for-as-on-list | !for-as-equals-then |\n                     !for-as-across | !for-as-hash | !for-as-package\n\nfor-as-arithmetic ::=var [type-spec] !for-as-arithmetic-subclause\n\nfor-as-arithmetic-subclause ::=!arithmetic-up | !arithmetic-downto | !arithmetic-downfrom\n\narithmetic-up ::=[[{from | upfrom} form1 | {to | upto | below} form2 | by form3]]^+\n\narithmetic-downto ::=[[{from form1}^1 | {{downto | above} form2}^1 | by form3]]\n\narithmetic-downfrom ::=[[{downfrom form1}^1 | {to | downto | above} form2 | by form3]]\n\nfor-as-in-list ::=var [type-spec] in form1 [by step-fun]\n\nfor-as-on-list ::=var [type-spec] on form1 [by step-fun]\n\nfor-as-equals-then ::=var [type-spec] = form1 [then form2]\n\nfor-as-across ::=var [type-spec] across vector\n\nfor-as-hash ::=var [type-spec] being {each | the} \n                {{hash-key | hash-keys} {in | of} hash-table \n                [using (hash-value other-var)] | \n                {hash-value | hash-values} {in | of} hash-table \n                [using (hash-key other-var)]}\n\nfor-as-package ::=var [type-spec] being {each | the} \n                   {symbol | symbols |\n                   present-symbol | present-symbols |\n                   external-symbol | external-symbols} \n                   [{in | of} package]\n\ntype-spec ::=!simple-type-spec | !destructured-type-spec\n\nsimple-type-spec ::=fixnum | float | t | nil\n\ndestructured-type-spec ::=of-type d-type-spec\n\nd-type-spec ::=type-specifier | (d-type-spec . d-type-spec)\n\nvar ::=!d-var-spec\n\nvar1 ::=!d-var-spec\n\nvar2 ::=!d-var-spec\n\nother-var ::=!d-var-spec\n\nd-var-spec ::=simple-var | nil | (!d-var-spec . !d-var-spec)\n\nArguments and Values::\n......................\n\ncompound-form--a compound form.\n\nname--a symbol.\n\nsimple-var--a symbol (a variable name).\n\nform, form1, form2, form3--a form.\n\nstep-fun--a form that evaluates to a function of one argument.\n\nvector--a form that evaluates to a vector.\n\nhash-table--a form that evaluates to a hash table.\n\npackage--a form that evaluates to a package designator.\n\ntype-specifier--a type specifier.  This might be either an atomic type\nspecifier or a compound type specifier, which introduces some additional\ncomplications to proper parsing in the face of destructuring; for further\ninformation, see *Note Destructuring::.\n\nresult--an object.\n\nDescription::\n.............\n\nFor details, see *Note The LOOP Facility::.\n\nExamples::\n..........\n\n     ;; An example of the simple form of LOOP.\n      (defun sqrt-advisor ()\n        (loop (format t \"~&Number: \")\n              (let ((n (parse-integer (read-line) :junk-allowed t)))\n                (when (not n) (return))\n                (format t \"~&The square root of ~D is ~D.~\n     =>  SQRT-ADVISOR\n      (sqrt-advisor)\n      |>  Number: |>>5[<--~]<<|\n      |>  The square root of 5 is 2.236068.\n      |>  Number: |>>4[<--~]<<|\n      |>  The square root of 4 is 2.\n      |>  Number: |>>done[<--~]<<|\n     =>  NIL\n     \n     ;; An example of the extended form of LOOP.\n      (defun square-advisor ()\n        (loop as n = (progn (format t \"~&Number: \")\n                            (parse-integer (read-line) :junk-allowed t))\n              while n\n              do (format t \"~&The square of ~D is ~D.~\n     =>  SQUARE-ADVISOR\n      (square-advisor)\n      |>  Number: |>>4[<--~]<<|\n      |>  The square of 4 is 16.\n      |>  Number: |>>23[<--~]<<|\n      |>  The square of 23 is 529.\n      |>  Number: |>>done[<--~]<<|\n     =>  NIL\n     \n     ;; Another example of the extended form of LOOP.\n      (loop for n from 1 to 10\n            when (oddp n)\n              collect n)\n     =>  (1 3 5 7 9)\n\nSee Also::\n..........\n\n*Note do; do*:: , *Note dolist:: , *Note dotimes:: , *Note return:: ,\n*Note go:: , *Note throw:: , *Note Destructuring::\n\nNotes::\n.......\n\nExcept that loop-finish cannot be used within a simple loop form, a simple\nloop form is related to an extended loop form in the following way:\n\n      (loop {compound-form}*) == (loop do {compound-form}*)\n\n"
}