{
    "name": "delete-package",
    "prev": "shadowing-import",
    "next": "make-package",
    "up": "Packages Dictionary",
    "header": {
        "type": "Function",
        "text": "delete-package"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "delete-package",
                    "text": " package =>  generalized-boolean\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "package",
                    "desc": "a package designator."
                },
                {
                    "name": "generalized-boolean",
                    "desc": "a generalized boolean."
                }
            ]
        },
        {
            "type": "Description",
            "text": "delete-package deletes package from all package system data structures.\nIf the operation is successful, delete-package returns true, otherwise nil.\nThe effect of delete-package is that the name and nicknames of package\ncease to be recognized package names.  The package object is still a\npackage (i.e., packagep is true of it) but package-name returns nil.  The\nconsequences of deleting the COMMON-LISP package or the KEYWORD package\nare undefined.  The consequences of invoking any other package operation\non package once it has been deleted are unspecified.  In particular, the\nconsequences of invoking find-symbol, intern and other functions that look\nfor a symbol name in a package are unspecified if they are called with\n*package* bound to the deleted package or with the deleted package as an\nargument.\nIf package is a package object that has already been deleted,\ndelete-package immediately returns nil.\nAfter this operation completes, the home package of any symbol whose home\npackage had previously been package is implementation-dependent.  Except\nfor this, symbols accessible in package are not modified in any other way;\nsymbols whose home package is not package remain unchanged.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq *foo-package* (make-package \"FOO\" :use nil))\n      (setq *foo-symbol*  (intern \"FOO\" *foo-package*))\n      (export *foo-symbol* *foo-package*)\n      (setq *bar-package* (make-package \"BAR\" :use '(\"FOO\")))\n      (setq *bar-symbol*  (intern \"BAR\" *bar-package*))\n      (export *foo-symbol* *bar-package*)\n      (export *bar-symbol* *bar-package*)\n      (setq *baz-package* (make-package \"BAZ\" :use '(\"BAR\")))\n      (symbol-package *foo-symbol*) =>  #<PACKAGE \"FOO\">\n      (symbol-package *bar-symbol*) =>  #<PACKAGE \"BAR\">\n      (prin1-to-string *foo-symbol*) =>  \"FOO:FOO\"\n      (prin1-to-string *bar-symbol*) =>  \"BAR:BAR\"\n      (find-symbol \"FOO\" *bar-package*) =>  FOO:FOO, :EXTERNAL\n      (find-symbol \"FOO\" *baz-package*) =>  FOO:FOO, :INHERITED\n      (find-symbol \"BAR\" *baz-package*) =>  BAR:BAR, :INHERITED\n      (packagep *foo-package*) =>  true\n      (packagep *bar-package*) =>  true\n      (packagep *baz-package*) =>  true\n      (package-name *foo-package*) =>  \"FOO\"\n      (package-name *bar-package*) =>  \"BAR\"\n      (package-name *baz-package*) =>  \"BAZ\"\n      (package-use-list *foo-package*) =>  ()\n      (package-use-list *bar-package*) =>  (#<PACKAGE \"FOO\">)\n      (package-use-list *baz-package*) =>  (#<PACKAGE \"BAR\">)\n      (package-used-by-list *foo-package*) =>  (#<PACKAGE \"BAR\">)\n      (package-used-by-list *bar-package*) =>  (#<PACKAGE \"BAZ\">)\n      (package-used-by-list *baz-package*) =>  ()\n      (delete-package *bar-package*)\n      |>  Error: Package BAZ uses package BAR.\n      |>  If continued, BAZ will be made to unuse-package BAR,\n      |>  and then BAR will be deleted.\n      |>  Type :CONTINUE to continue.\n      |>  Debug> |>>:CONTINUE<<|\n     =>  T\n      (symbol-package *foo-symbol*) =>  #<PACKAGE \"FOO\">\n      (symbol-package *bar-symbol*) is unspecified\n      (prin1-to-string *foo-symbol*) =>  \"FOO:FOO\"\n      (prin1-to-string *bar-symbol*) is unspecified\n      (find-symbol \"FOO\" *bar-package*) is unspecified\n      (find-symbol \"FOO\" *baz-package*) =>  NIL, NIL\n      (find-symbol \"BAR\" *baz-package*) =>  NIL, NIL\n      (packagep *foo-package*) =>  T\n      (packagep *bar-package*) =>  T\n      (packagep *baz-package*) =>  T\n      (package-name *foo-package*) =>  \"FOO\"\n      (package-name *bar-package*) =>  NIL\n      (package-name *baz-package*) =>  \"BAZ\"\n      (package-use-list *foo-package*) =>  ()\n      (package-use-list *bar-package*) is unspecified\n      (package-use-list *baz-package*) =>  ()\n      (package-used-by-list *foo-package*) =>  ()\n      (package-used-by-list *bar-package*) is unspecified\n      (package-used-by-list *baz-package*) =>  ()\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If the package designator is a name that does not currently name a package,\na correctable error of type package-error is signaled.  If correction is\nattempted, no deletion action is attempted; instead, delete-package\nimmediately returns nil.\nIf package is used by other packages, a correctable error of type\npackage-error is signaled.  If correction is attempted, unuse-package is\neffectively called to remove any dependencies, causing package's external\nsymbols to cease being accessible to those packages that use package.\ndelete-package then deletes package just as it would have had there been\nno packages that used it.\n"
        },
        {
            "type": "See Also",
            "text": "*Note unuse-package::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: delete-package,  Next: make-package,  Prev: shadowing-import,  Up: Packages Dictionary\n\ndelete-package                                                   [Function]\n---------------------------------------------------------------------------\n\n`delete-package'  package =>  generalized-boolean\n\nArguments and Values::\n......................\n\npackage--a package designator.\n\ngeneralized-boolean--a generalized boolean.\n\nDescription::\n.............\n\ndelete-package deletes package from all package system data structures.\nIf the operation is successful, delete-package returns true, otherwise nil.\nThe effect of delete-package is that the name and nicknames of package\ncease to be recognized package names.  The package object is still a\npackage (i.e., packagep is true of it) but package-name returns nil.  The\nconsequences of deleting the COMMON-LISP package or the KEYWORD package\nare undefined.  The consequences of invoking any other package operation\non package once it has been deleted are unspecified.  In particular, the\nconsequences of invoking find-symbol, intern and other functions that look\nfor a symbol name in a package are unspecified if they are called with\n*package* bound to the deleted package or with the deleted package as an\nargument.\n\nIf package is a package object that has already been deleted,\ndelete-package immediately returns nil.\n\nAfter this operation completes, the home package of any symbol whose home\npackage had previously been package is implementation-dependent.  Except\nfor this, symbols accessible in package are not modified in any other way;\nsymbols whose home package is not package remain unchanged.\n\nExamples::\n..........\n\n      (setq *foo-package* (make-package \"FOO\" :use nil))\n      (setq *foo-symbol*  (intern \"FOO\" *foo-package*))\n      (export *foo-symbol* *foo-package*)\n     \n      (setq *bar-package* (make-package \"BAR\" :use '(\"FOO\")))\n      (setq *bar-symbol*  (intern \"BAR\" *bar-package*))\n      (export *foo-symbol* *bar-package*)\n      (export *bar-symbol* *bar-package*)\n     \n      (setq *baz-package* (make-package \"BAZ\" :use '(\"BAR\")))\n     \n      (symbol-package *foo-symbol*) =>  #<PACKAGE \"FOO\">\n      (symbol-package *bar-symbol*) =>  #<PACKAGE \"BAR\">\n     \n      (prin1-to-string *foo-symbol*) =>  \"FOO:FOO\"\n      (prin1-to-string *bar-symbol*) =>  \"BAR:BAR\"\n     \n      (find-symbol \"FOO\" *bar-package*) =>  FOO:FOO, :EXTERNAL\n     \n      (find-symbol \"FOO\" *baz-package*) =>  FOO:FOO, :INHERITED\n      (find-symbol \"BAR\" *baz-package*) =>  BAR:BAR, :INHERITED\n     \n      (packagep *foo-package*) =>  true\n      (packagep *bar-package*) =>  true\n      (packagep *baz-package*) =>  true\n     \n      (package-name *foo-package*) =>  \"FOO\"\n      (package-name *bar-package*) =>  \"BAR\"\n      (package-name *baz-package*) =>  \"BAZ\"\n     \n      (package-use-list *foo-package*) =>  ()\n      (package-use-list *bar-package*) =>  (#<PACKAGE \"FOO\">)\n      (package-use-list *baz-package*) =>  (#<PACKAGE \"BAR\">)\n     \n      (package-used-by-list *foo-package*) =>  (#<PACKAGE \"BAR\">)\n      (package-used-by-list *bar-package*) =>  (#<PACKAGE \"BAZ\">)\n      (package-used-by-list *baz-package*) =>  ()\n     \n      (delete-package *bar-package*)\n      |>  Error: Package BAZ uses package BAR.\n      |>  If continued, BAZ will be made to unuse-package BAR,\n      |>  and then BAR will be deleted.\n      |>  Type :CONTINUE to continue.\n      |>  Debug> |>>:CONTINUE<<|\n     =>  T\n     \n      (symbol-package *foo-symbol*) =>  #<PACKAGE \"FOO\">\n      (symbol-package *bar-symbol*) is unspecified\n     \n      (prin1-to-string *foo-symbol*) =>  \"FOO:FOO\"\n      (prin1-to-string *bar-symbol*) is unspecified\n     \n      (find-symbol \"FOO\" *bar-package*) is unspecified\n     \n      (find-symbol \"FOO\" *baz-package*) =>  NIL, NIL\n      (find-symbol \"BAR\" *baz-package*) =>  NIL, NIL\n     \n      (packagep *foo-package*) =>  T\n      (packagep *bar-package*) =>  T\n      (packagep *baz-package*) =>  T\n     \n      (package-name *foo-package*) =>  \"FOO\"\n      (package-name *bar-package*) =>  NIL\n      (package-name *baz-package*) =>  \"BAZ\"\n     \n      (package-use-list *foo-package*) =>  ()\n      (package-use-list *bar-package*) is unspecified\n      (package-use-list *baz-package*) =>  ()\n     \n      (package-used-by-list *foo-package*) =>  ()\n      (package-used-by-list *bar-package*) is unspecified\n      (package-used-by-list *baz-package*) =>  ()\n\nExceptional Situations::\n........................\n\nIf the package designator is a name that does not currently name a package,\na correctable error of type package-error is signaled.  If correction is\nattempted, no deletion action is attempted; instead, delete-package\nimmediately returns nil.\n\nIf package is used by other packages, a correctable error of type\npackage-error is signaled.  If correction is attempted, unuse-package is\neffectively called to remove any dependencies, causing package's external\nsymbols to cease being accessible to those packages that use package.\ndelete-package then deletes package just as it would have had there been\nno packages that used it.\n\nSee Also::\n..........\n\n*Note unuse-package::\n\n"
}