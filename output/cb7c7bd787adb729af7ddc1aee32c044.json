{
    "name": "unwind-protect",
    "prev": "throw",
    "next": "nil",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "unwind-protect"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "unwind-protect",
                    "text": " protected-form {cleanup-form}* =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "protected-form",
                    "desc": "a form."
                },
                {
                    "name": "cleanup-form",
                    "desc": "a form."
                },
                {
                    "name": "results",
                    "desc": "the values of the protected-form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "unwind-protect evaluates protected-form and guarantees that cleanup-forms\nare executed before unwind-protect exits, whether it terminates normally\nor is aborted by a control transfer of some kind.  unwind-protect is\nintended to be used to make sure that certain side effects take place\nafter the evaluation of protected-form.\nIf a non-local exit occurs during execution of cleanup-forms, no special\naction is taken.  The cleanup-forms of unwind-protect are not protected by\nthat unwind-protect.\nunwind-protect protects against all attempts to exit from protected-form,\nincluding go, handler-case, ignore-errors, restart-case, return-from,\nthrow, and with-simple-restart.\nUndoing of handler and restart bindings during an exit happens in parallel\nwith the undoing of the bindings of dynamic variables and catch tags, in\nthe reverse order in which they were established.  The effect of this is\nthat cleanup-form sees the same handler and restart bindings, as well as\ndynamic variable bindings and catch tags, as were visible when the\nunwind-protect was entered.\n"
        },
        {
            "type": "Examples",
            "text": "      (tagbody\n        (let ((x 3))\n          (unwind-protect\n            (if (numberp x) (go out))\n            (print x)))\n       out\n        ...)\nWhen go is executed, the call to print is executed first, and then the\ntransfer of control to the tag out is completed.\n      (defun dummy-function (x)\n         (setq state 'running)\n         (unless (numberp x) (throw 'abort 'not-a-number))\n         (setq state (1+ x))) =>  DUMMY-FUNCTION\n      (catch 'abort (dummy-function 1)) =>  2\n      state =>  2\n      (catch 'abort (dummy-function 'trash)) =>  NOT-A-NUMBER\n      state =>  RUNNING\n      (catch 'abort (unwind-protect (dummy-function 'trash)\n                       (setq state 'aborted))) =>  NOT-A-NUMBER\n      state =>  ABORTED\nThe following code is not correct:\n      (unwind-protect\n        (progn (incf *access-count*)\n               (perform-access))\n        (decf *access-count*))\nIf an exit occurs before completion of incf, the decf form is executed\nanyway, resulting in an incorrect value for *access-count*.  The correct\nway to code this is as follows:\n      (let ((old-count *access-count*))\n        (unwind-protect\n          (progn (incf *access-count*)\n                 (perform-access))\n          (setq *access-count* old-count)))\n     ;;; The following returns 2.\n      (block nil\n        (unwind-protect (return 1)\n          (return 2)))\n     ;;; The following has undefined consequences.\n      (block a\n        (block b\n          (unwind-protect (return-from a 1)\n            (return-from b 2))))\n     ;;; The following returns 2.\n      (catch nil\n        (unwind-protect (throw nil 1)\n          (throw nil 2)))\n     ;;; The following has undefined consequences because the catch of B is\n     ;;; passed over by the first THROW, hence portable programs must assume\n     ;;; its dynamic extent is terminated.  The binding of the catch tag is not\n     ;;; yet disestablished and therefore it is the target of the second throw.\n      (catch 'a\n        (catch 'b\n          (unwind-protect (throw 'a 1)\n            (throw 'b 2))))\n     ;;; The following prints \"The inner catch returns :SECOND-THROW\"\n     ;;; and then returns :OUTER-CATCH.\n      (catch 'foo\n              (format t \"The inner catch returns ~s.~\n                      (catch 'foo\n                          (unwind-protect (throw 'foo :first-throw)\n                              (throw 'foo :second-throw))))\n              :outer-catch)\n     ;;; The following returns 10. The inner CATCH of A is passed over, but\n     ;;; because that CATCH is disestablished before the THROW to A is executed,\n     ;;; it isn't seen.\n      (catch 'a\n        (catch 'b\n          (unwind-protect (1+ (catch 'a (throw 'b 1)))\n            (throw 'a 10))))\n     ;;; The following has undefined consequences because the extent of\n     ;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...)\n     ;;; commences.\n      (catch 'foo\n        (catch 'bar\n            (unwind-protect (throw 'foo 3)\n              (throw 'bar 4)\n              (print 'xxx))))\n     ;;; The following returns 4; XXX is not printed.\n     ;;; The (THROW 'FOO ...) has no effect on the scope of the BAR\n     ;;; catch tag or the extent of the (CATCH 'BAR ...) exit.\n      (catch 'bar\n        (catch 'foo\n            (unwind-protect (throw 'foo 3)\n              (throw 'bar 4)\n              (print 'xxx))))\n     ;;; The following prints 5.\n      (block nil\n        (let ((x 5))\n          (declare (special x))\n          (unwind-protect (return)\n            (print x))))\n"
        },
        {
            "type": "See Also",
            "text": "*Note catch:: , *Note go:: , *Note handler-case:: , *Note restart-case:: ,\n*Note return:: , *Note return-from:: , *Note throw:: , *Note Evaluation::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: unwind-protect,  Next: nil,  Prev: throw,  Up: Data and Control Flow Dictionary\n\nunwind-protect                                           [Special Operator]\n---------------------------------------------------------------------------\n\n`unwind-protect'  protected-form {cleanup-form}* =>  {result}*\n\nArguments and Values::\n......................\n\nprotected-form--a form.\n\ncleanup-form--a form.\n\nresults--the values of the protected-form.\n\nDescription::\n.............\n\nunwind-protect evaluates protected-form and guarantees that cleanup-forms\nare executed before unwind-protect exits, whether it terminates normally\nor is aborted by a control transfer of some kind.  unwind-protect is\nintended to be used to make sure that certain side effects take place\nafter the evaluation of protected-form.\n\nIf a non-local exit occurs during execution of cleanup-forms, no special\naction is taken.  The cleanup-forms of unwind-protect are not protected by\nthat unwind-protect.\n\nunwind-protect protects against all attempts to exit from protected-form,\nincluding go, handler-case, ignore-errors, restart-case, return-from,\nthrow, and with-simple-restart.\n\nUndoing of handler and restart bindings during an exit happens in parallel\nwith the undoing of the bindings of dynamic variables and catch tags, in\nthe reverse order in which they were established.  The effect of this is\nthat cleanup-form sees the same handler and restart bindings, as well as\ndynamic variable bindings and catch tags, as were visible when the\nunwind-protect was entered.\n\nExamples::\n..........\n\n      (tagbody\n        (let ((x 3))\n          (unwind-protect\n            (if (numberp x) (go out))\n            (print x)))\n       out\n        ...)\n\nWhen go is executed, the call to print is executed first, and then the\ntransfer of control to the tag out is completed.\n\n      (defun dummy-function (x)\n         (setq state 'running)\n         (unless (numberp x) (throw 'abort 'not-a-number))\n         (setq state (1+ x))) =>  DUMMY-FUNCTION\n      (catch 'abort (dummy-function 1)) =>  2\n      state =>  2\n      (catch 'abort (dummy-function 'trash)) =>  NOT-A-NUMBER\n      state =>  RUNNING\n      (catch 'abort (unwind-protect (dummy-function 'trash)\n                       (setq state 'aborted))) =>  NOT-A-NUMBER\n      state =>  ABORTED\n\nThe following code is not correct:\n\n      (unwind-protect\n        (progn (incf *access-count*)\n               (perform-access))\n        (decf *access-count*))\n\nIf an exit occurs before completion of incf, the decf form is executed\nanyway, resulting in an incorrect value for *access-count*.  The correct\nway to code this is as follows:\n\n      (let ((old-count *access-count*))\n        (unwind-protect\n          (progn (incf *access-count*)\n                 (perform-access))\n          (setq *access-count* old-count)))\n\n     ;;; The following returns 2.\n      (block nil\n        (unwind-protect (return 1)\n          (return 2)))\n     \n     ;;; The following has undefined consequences.\n      (block a\n        (block b\n          (unwind-protect (return-from a 1)\n            (return-from b 2))))\n     \n     ;;; The following returns 2.\n      (catch nil\n        (unwind-protect (throw nil 1)\n          (throw nil 2)))\n     \n     ;;; The following has undefined consequences because the catch of B is\n     ;;; passed over by the first THROW, hence portable programs must assume\n     ;;; its dynamic extent is terminated.  The binding of the catch tag is not\n     ;;; yet disestablished and therefore it is the target of the second throw.\n      (catch 'a\n        (catch 'b\n          (unwind-protect (throw 'a 1)\n            (throw 'b 2))))\n     \n     ;;; The following prints \"The inner catch returns :SECOND-THROW\"\n     ;;; and then returns :OUTER-CATCH.\n      (catch 'foo\n              (format t \"The inner catch returns ~s.~\n                      (catch 'foo\n                          (unwind-protect (throw 'foo :first-throw)\n                              (throw 'foo :second-throw))))\n              :outer-catch)\n     \n     ;;; The following returns 10. The inner CATCH of A is passed over, but\n     ;;; because that CATCH is disestablished before the THROW to A is executed,\n     ;;; it isn't seen.\n      (catch 'a\n        (catch 'b\n          (unwind-protect (1+ (catch 'a (throw 'b 1)))\n            (throw 'a 10))))\n     \n     ;;; The following has undefined consequences because the extent of\n     ;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...)\n     ;;; commences.\n      (catch 'foo\n        (catch 'bar\n            (unwind-protect (throw 'foo 3)\n              (throw 'bar 4)\n              (print 'xxx))))\n     \n     ;;; The following returns 4; XXX is not printed.\n     ;;; The (THROW 'FOO ...) has no effect on the scope of the BAR\n     ;;; catch tag or the extent of the (CATCH 'BAR ...) exit.\n      (catch 'bar\n        (catch 'foo\n            (unwind-protect (throw 'foo 3)\n              (throw 'bar 4)\n              (print 'xxx))))\n     \n     ;;; The following prints 5.\n      (block nil\n        (let ((x 5))\n          (declare (special x))\n          (unwind-protect (return)\n            (print x))))\n\nSee Also::\n..........\n\n*Note catch:: , *Note go:: , *Note handler-case:: , *Note restart-case:: ,\n*Note return:: , *Note return-from:: , *Note throw:: , *Note Evaluation::\n\n"
}