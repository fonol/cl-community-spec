{
    "name": "Examples of using the Pretty Printer",
    "prev": "Pretty Printer Concepts",
    "next": "Notes about the Pretty Printer's Background",
    "up": "The Lisp Pretty Printer",
    "header": {
        "type": null,
        "text": "Examples of using the Pretty Printer"
    },
    "sections": [
        {
            "type": "",
            "text": "As an example of the interaction of logical blocks, conditional newlines,\nand indentation, consider the function simple-pprint-defun below.  This\nfunction prints out lists whose cars are defun in the standard way\nassuming that the list has exactly length 4.\n     (defun simple-pprint-defun (*standard-output* list)\n       (pprint-logical-block (*standard-output* list :prefix \"(\" :suffix \")\")\n         (write (first list))\n         (write-char #\\Space)\n         (pprint-newline :miser)\n         (pprint-indent :current 0)\n         (write (second list))\n         (write-char #\\Space)\n         (pprint-newline :fill)\n         (write (third list))\n         (pprint-indent :block 1)\n         (write-char #\\Space)\n         (pprint-newline :linear)\n         (write (fourth list))))\nSuppose that one evaluates the following:\n     (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))\nIf the line width available is greater than or equal to 26, then all of the\noutput appears on one line.  If the line width available is reduced to 25,\na line break is inserted at the linear-style conditional newline\nbefore the expression (* x y), producing the output shown.  The\n(pprint-indent :block 1) causes (* x y) to be printed at a relative\nindentation of 1 in the logical block.\n      (DEFUN PROD (X Y)\n        (* X Y))\nIf the line width available is 15, a line break is also inserted at the\nfill style conditional newline before the argument list.  The call on\n(pprint-indent :current 0) causes the argument list to line up under the\nfunction name.\n     (DEFUN PROD\n            (X Y)\n       (* X Y))\nIf *print-miser-width* were greater than or equal to 14, the example\noutput above would have been as follows, because all indentation changes\nare ignored in miser mode and line breaks are inserted at miser-style\nconditional newlines.\n      (DEFUN\n       PROD\n       (X Y)\n       (* X Y))\nAs an example of a per-line prefix, consider that evaluating the following\nproduces the output shown with a line width of 20 and *print-miser-width*\nof nil.\n      (pprint-logical-block (*standard-output* nil :per-line-prefix \";;; \")\n        (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))\n      ;;; (DEFUN PROD\n      ;;;        (X Y)\n      ;;;   (* X Y))\nAs a more complex (and realistic) example, consider the function pprint-let\nbelow.  This specifies how to print a let form in the traditional style.\nIt is more complex than the example above, because it has to deal with\nnested structure.  Also, unlike the example above it contains complete\ncode to readably print any possible list that begins with the symbol let.\nThe outermost pprint-logical-block form handles the printing of the input\nlist as a whole and specifies that parentheses should be printed in the\noutput.  The second pprint-logical-block form handles the list of binding\npairs.  Each pair in the list is itself printed by the innermost\npprint-logical-block.  (A loop form is used instead of merely decomposing\nthe pair into two objects so that readable output will be produced no\nmatter whether the list corresponding to the pair has one element, two\nelements, or (being malformed) has more than two elements.) A space and a\nfill-style conditional newline\nare placed after each pair except the last.  The loop at the end of the\ntopmost pprint-logical-block form prints out the forms in the body of the\nlet form separated by spaces and linear-style conditional newlines.\n      (defun pprint-let (*standard-output* list)\n        (pprint-logical-block (nil list :prefix \"(\" :suffix \")\")\n          (write (pprint-pop))\n          (pprint-exit-if-list-exhausted)\n          (write-char #\\Space)\n          (pprint-logical-block (nil (pprint-pop) :prefix \"(\" :suffix \")\")\n            (pprint-exit-if-list-exhausted)\n            (loop (pprint-logical-block (nil (pprint-pop) :prefix \"(\" :suffix \")\")\n                    (pprint-exit-if-list-exhausted)\n                    (loop (write (pprint-pop))\n                          (pprint-exit-if-list-exhausted)\n                          (write-char #\\Space)\n                          (pprint-newline :linear)))\n                  (pprint-exit-if-list-exhausted)\n                  (write-char #\\Space)\n                  (pprint-newline :fill)))\n          (pprint-indent :block 1)\n          (loop (pprint-exit-if-list-exhausted)\n                (write-char #\\Space)\n                (pprint-newline :linear)\n                (write (pprint-pop)))))\nSuppose that one evaluates the following with *print-level* being 4, and\n*print-circle* being true.\n      (pprint-let *standard-output*\n                  '#1=(let (x (*print-length* (f (g 3)))\n                            (z . 2) (k (car y)))\n                        (setq x (sqrt z)) #1#))\nIf the line length is greater than or equal to 77, the output produced\nappears on one line.  However, if the line length is 76, line breaks are\ninserted at the linear-style conditional newlines separating the forms in\nthe body and the output below is produced.  Note that, the degenerate\nbinding pair x is printed readably even though it fails to be a list; a\ndepth abbreviation marker is printed in place of (g 3); the binding pair\n(z . 2) is printed readably even though it is not a proper list; and\nappropriate circularity markers are printed.\n      #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))\n           (SETQ X (SQRT Z))\n           #1#)\nIf the line length is reduced to 35, a line break is inserted at one of the\nfill-style conditional newlines separating the binding pairs.\n      #1=(LET (X (*PRINT-PRETTY* (F #))\n               (Z . 2) (K (CAR Y)))\n           (SETQ X (SQRT Z))\n           #1#)\nSuppose that the line length is further reduced to 22 and *print-length* is\nset to 3. In this situation, line breaks are inserted after both the first\nand second binding pairs.  In addition, the second binding pair is itself\nbroken across two lines.  Clause (b) of the description of fill-style\nconditional newlines (see the function pprint-newline) prevents the\nbinding pair (z . 2) from being printed at the end of the third line.\nNote that the length abbreviation hides the circularity from view and\ntherefore the printing of circularity markers disappears.\n      (LET (X\n            (*PRINT-LENGTH*\n             (F #))\n            (Z . 2) ...)\n        (SETQ X (SQRT Z))\n        ...)\nThe next function prints a vector using \"#(...)\" notation.\n     (defun pprint-vector (*standard-output* v)\n       (pprint-logical-block (nil nil :prefix \"#(\" :suffix \")\")\n         (let ((end (length v)) (i 0))\n           (when (plusp end)\n             (loop (pprint-pop)\n                   (write (aref v i))\n                   (if (= (incf i) end) (return nil))\n                   (write-char #\\Space)\n                   (pprint-newline :fill))))))\nEvaluating the following with a line length of 15 produces the output\nshown.\n      (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))\n      #(12 34 567 8\n        9012 34 567\n        89 0 1 23)\nAs examples of the convenience of specifying pretty printing with format\nstrings, consider that the functions simple-pprint-defun and pprint-let\nused as examples above can be compactly defined as follows.  (The function\npprint-vector cannot be defined using format because the data structure it\ntraverses is not a list.)\n     (defun simple-pprint-defun (*standard-output* list)\n       (format T \"~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>\" list))\n     (defun pprint-let (*standard-output* list)\n       (format T \"~:<~W~^~:<~@{~:<~@{~W~^~_~}~:>~^~:_~}~:>~1I~@{~^~_~W~}~:>\" list))\nIn the following example, the first form restores *print-pprint-dispatch*\nto the equivalent of its initial value.  The next two forms then set up a\nspecial way to pretty print ratios.  Note that the more specific type\nspecifier has to be associated with a higher priority.\n      (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))\n      (set-pprint-dispatch 'ratio\n        #'(lambda (s obj)\n            (format s \"#.(/ ~W ~W)\"\n                      (numerator obj) (denominator obj))))\n      (set-pprint-dispatch '(and ratio (satisfies minusp))\n        #'(lambda (s obj)\n            (format s \"#.(- (/ ~W ~W))\"\n                    (- (numerator obj)) (denominator obj)))\n        5)\n      (pprint '(1/3 -2/3))\n      (#.(/ 1 3) #.(- (/ 2 3)))\nThe following two forms illustrate the definition of pretty printing\nfunctions for types of code.  The first form illustrates how to specify\nthe traditional method for printing quoted objects using single-quote.\nNote the care taken to ensure that data lists that happen to begin with\nquote will be printed readably.  The second form specifies that lists\nbeginning with the symbol my-let should print the same way that lists\nbeginning with let print when the initial pprint dispatch table is in\neffect.\n      (set-pprint-dispatch '(cons (member quote)) ()\n        #'(lambda (s list)\n            (if (and (consp (cdr list)) (null (cddr list)))\n               (funcall (formatter \"'~W\") s (cadr list))\n               (pprint-fill s list))))\n      (set-pprint-dispatch '(cons (member my-let))\n                           (pprint-dispatch '(let) nil))\nThe next example specifies a default method for printing lists that do not\ncorrespond to function calls.  Note that the functions pprint-linear,\npprint-fill, and pprint-tabular are all defined with optional colon-p and\nat-sign-p arguments so that they can be used as pprint dispatch functions\nas well as ~/.../ functions.\n      (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))\n                           #'pprint-fill -5)\n      ;; Assume a line length of 9\n      (pprint '(0 b c d e f g h i j k))\n      (0 b c d\n       e f g h\n       i j k)\nThis final example shows how to define a pretty printing function for a\nuser defined data structure.\n      (defstruct family mom kids)\n      (set-pprint-dispatch 'family\n        #'(lambda (s f)\n            (funcall (formatter \"~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>\")\n                    s (family-mom f) (family-kids f))))\nThe pretty printing function for the structure family specifies how to\nadjust the layout of the output so that it can fit aesthetically into a\nvariety of line widths.  In addition, it obeys the printer control\nvariables *print-level*, *print-length*, *print-lines*, *print-circle* and\n*print-escape*, and can tolerate several different kinds of malformity in\nthe data structure.  The output below shows what is printed out with a\nright margin of 25, *print-pretty* being true, *print-escape* being false,\nand a malformed kids list.\n      (write (list 'principal-family\n                   (make-family :mom \"Lucy\"\n                                :kids '(\"Mark\" \"Bob\" . \"Dan\")))\n             :right-margin 25 :pretty T :escape nil :miser-width nil)\n      (PRINCIPAL-FAMILY\n       #<Lucy and\n           Mark Bob . Dan>)\nNote that a pretty printing function for a structure is different from the\nstructure's print-object method.  While print-object methods are\npermanently associated with a structure, pretty printing functions are\nstored in pprint dispatch tables and can be rapidly changed to reflect\ndifferent printing needs.  If there is no pretty printing function for a\nstructure in the current pprint dispatch table, its print-object method is\nused instead.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Examples of using the Pretty Printer,  Next: Notes about the Pretty Printer's Background,  Prev: Pretty Printer Concepts,  Up: The Lisp Pretty Printer\n\nExamples of using the Pretty Printer\n------------------------------------\n\nAs an example of the interaction of logical blocks, conditional newlines,\nand indentation, consider the function simple-pprint-defun below.  This\nfunction prints out lists whose cars are defun in the standard way\nassuming that the list has exactly length 4.\n\n     (defun simple-pprint-defun (*standard-output* list)\n       (pprint-logical-block (*standard-output* list :prefix \"(\" :suffix \")\")\n         (write (first list))\n         (write-char #\\Space)\n         (pprint-newline :miser)\n         (pprint-indent :current 0)\n         (write (second list))\n         (write-char #\\Space)\n         (pprint-newline :fill)\n         (write (third list))\n         (pprint-indent :block 1)\n         (write-char #\\Space)\n         (pprint-newline :linear)\n         (write (fourth list))))\n\nSuppose that one evaluates the following:\n\n     (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))\n\nIf the line width available is greater than or equal to 26, then all of the\noutput appears on one line.  If the line width available is reduced to 25,\na line break is inserted at the linear-style conditional newline\n\nbefore the expression (* x y), producing the output shown.  The\n(pprint-indent :block 1) causes (* x y) to be printed at a relative\nindentation of 1 in the logical block.\n\n      (DEFUN PROD (X Y)\n        (* X Y))\n\nIf the line width available is 15, a line break is also inserted at the\nfill style conditional newline before the argument list.  The call on\n(pprint-indent :current 0) causes the argument list to line up under the\nfunction name.\n\n     (DEFUN PROD\n            (X Y)\n       (* X Y))\n\nIf *print-miser-width* were greater than or equal to 14, the example\noutput above would have been as follows, because all indentation changes\nare ignored in miser mode and line breaks are inserted at miser-style\nconditional newlines.\n\n      (DEFUN\n       PROD\n       (X Y)\n       (* X Y))\n\nAs an example of a per-line prefix, consider that evaluating the following\nproduces the output shown with a line width of 20 and *print-miser-width*\nof nil.\n\n      (pprint-logical-block (*standard-output* nil :per-line-prefix \";;; \")\n        (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))\n     \n      ;;; (DEFUN PROD\n      ;;;        (X Y)\n      ;;;   (* X Y))\n\nAs a more complex (and realistic) example, consider the function pprint-let\nbelow.  This specifies how to print a let form in the traditional style.\nIt is more complex than the example above, because it has to deal with\nnested structure.  Also, unlike the example above it contains complete\ncode to readably print any possible list that begins with the symbol let.\nThe outermost pprint-logical-block form handles the printing of the input\nlist as a whole and specifies that parentheses should be printed in the\noutput.  The second pprint-logical-block form handles the list of binding\npairs.  Each pair in the list is itself printed by the innermost\npprint-logical-block.  (A loop form is used instead of merely decomposing\nthe pair into two objects so that readable output will be produced no\nmatter whether the list corresponding to the pair has one element, two\nelements, or (being malformed) has more than two elements.) A space and a\nfill-style conditional newline\n\nare placed after each pair except the last.  The loop at the end of the\ntopmost pprint-logical-block form prints out the forms in the body of the\nlet form separated by spaces and linear-style conditional newlines.\n\n      (defun pprint-let (*standard-output* list)\n        (pprint-logical-block (nil list :prefix \"(\" :suffix \")\")\n          (write (pprint-pop))\n          (pprint-exit-if-list-exhausted)\n          (write-char #\\Space)\n          (pprint-logical-block (nil (pprint-pop) :prefix \"(\" :suffix \")\")\n            (pprint-exit-if-list-exhausted)\n            (loop (pprint-logical-block (nil (pprint-pop) :prefix \"(\" :suffix \")\")\n                    (pprint-exit-if-list-exhausted)\n                    (loop (write (pprint-pop))\n                          (pprint-exit-if-list-exhausted)\n                          (write-char #\\Space)\n                          (pprint-newline :linear)))\n                  (pprint-exit-if-list-exhausted)\n                  (write-char #\\Space)\n                  (pprint-newline :fill)))\n          (pprint-indent :block 1)\n          (loop (pprint-exit-if-list-exhausted)\n                (write-char #\\Space)\n                (pprint-newline :linear)\n                (write (pprint-pop)))))\n\nSuppose that one evaluates the following with *print-level* being 4, and\n*print-circle* being true.\n\n      (pprint-let *standard-output*\n                  '#1=(let (x (*print-length* (f (g 3)))\n                            (z . 2) (k (car y)))\n                        (setq x (sqrt z)) #1#))\n\nIf the line length is greater than or equal to 77, the output produced\nappears on one line.  However, if the line length is 76, line breaks are\ninserted at the linear-style conditional newlines separating the forms in\nthe body and the output below is produced.  Note that, the degenerate\nbinding pair x is printed readably even though it fails to be a list; a\ndepth abbreviation marker is printed in place of (g 3); the binding pair\n(z . 2) is printed readably even though it is not a proper list; and\nappropriate circularity markers are printed.\n\n      #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))\n           (SETQ X (SQRT Z))\n           #1#)\n\nIf the line length is reduced to 35, a line break is inserted at one of the\nfill-style conditional newlines separating the binding pairs.\n\n      #1=(LET (X (*PRINT-PRETTY* (F #))\n               (Z . 2) (K (CAR Y)))\n           (SETQ X (SQRT Z))\n           #1#)\n\nSuppose that the line length is further reduced to 22 and *print-length* is\nset to 3. In this situation, line breaks are inserted after both the first\nand second binding pairs.  In addition, the second binding pair is itself\nbroken across two lines.  Clause (b) of the description of fill-style\nconditional newlines (see the function pprint-newline) prevents the\nbinding pair (z . 2) from being printed at the end of the third line.\nNote that the length abbreviation hides the circularity from view and\ntherefore the printing of circularity markers disappears.\n\n      (LET (X\n            (*PRINT-LENGTH*\n             (F #))\n            (Z . 2) ...)\n        (SETQ X (SQRT Z))\n        ...)\n\nThe next function prints a vector using \"#(...)\" notation.\n\n     (defun pprint-vector (*standard-output* v)\n       (pprint-logical-block (nil nil :prefix \"#(\" :suffix \")\")\n         (let ((end (length v)) (i 0))\n           (when (plusp end)\n             (loop (pprint-pop)\n                   (write (aref v i))\n                   (if (= (incf i) end) (return nil))\n                   (write-char #\\Space)\n                   (pprint-newline :fill))))))\n\nEvaluating the following with a line length of 15 produces the output\nshown.\n\n      (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))\n     \n      #(12 34 567 8\n        9012 34 567\n        89 0 1 23)\n\nAs examples of the convenience of specifying pretty printing with format\nstrings, consider that the functions simple-pprint-defun and pprint-let\nused as examples above can be compactly defined as follows.  (The function\npprint-vector cannot be defined using format because the data structure it\ntraverses is not a list.)\n\n     (defun simple-pprint-defun (*standard-output* list)\n       (format T \"~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>\" list))\n     \n     (defun pprint-let (*standard-output* list)\n       (format T \"~:<~W~^~:<~@{~:<~@{~W~^~_~}~:>~^~:_~}~:>~1I~@{~^~_~W~}~:>\" list))\n\nIn the following example, the first form restores *print-pprint-dispatch*\nto the equivalent of its initial value.  The next two forms then set up a\nspecial way to pretty print ratios.  Note that the more specific type\nspecifier has to be associated with a higher priority.\n\n      (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))\n     \n      (set-pprint-dispatch 'ratio\n        #'(lambda (s obj)\n            (format s \"#.(/ ~W ~W)\"\n                      (numerator obj) (denominator obj))))\n     \n      (set-pprint-dispatch '(and ratio (satisfies minusp))\n        #'(lambda (s obj)\n            (format s \"#.(- (/ ~W ~W))\"\n                    (- (numerator obj)) (denominator obj)))\n        5)\n     \n      (pprint '(1/3 -2/3))\n      (#.(/ 1 3) #.(- (/ 2 3)))\n\nThe following two forms illustrate the definition of pretty printing\nfunctions for types of code.  The first form illustrates how to specify\nthe traditional method for printing quoted objects using single-quote.\nNote the care taken to ensure that data lists that happen to begin with\nquote will be printed readably.  The second form specifies that lists\nbeginning with the symbol my-let should print the same way that lists\nbeginning with let print when the initial pprint dispatch table is in\neffect.\n\n      (set-pprint-dispatch '(cons (member quote)) ()\n        #'(lambda (s list)\n            (if (and (consp (cdr list)) (null (cddr list)))\n               (funcall (formatter \"'~W\") s (cadr list))\n               (pprint-fill s list))))\n     \n      (set-pprint-dispatch '(cons (member my-let))\n                           (pprint-dispatch '(let) nil))\n\nThe next example specifies a default method for printing lists that do not\ncorrespond to function calls.  Note that the functions pprint-linear,\npprint-fill, and pprint-tabular are all defined with optional colon-p and\nat-sign-p arguments so that they can be used as pprint dispatch functions\nas well as ~/.../ functions.\n\n      (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))\n                           #'pprint-fill -5)\n     \n      ;; Assume a line length of 9\n      (pprint '(0 b c d e f g h i j k))\n      (0 b c d\n       e f g h\n       i j k)\n\nThis final example shows how to define a pretty printing function for a\nuser defined data structure.\n\n      (defstruct family mom kids)\n     \n      (set-pprint-dispatch 'family\n        #'(lambda (s f)\n            (funcall (formatter \"~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>\")\n                    s (family-mom f) (family-kids f))))\n\nThe pretty printing function for the structure family specifies how to\nadjust the layout of the output so that it can fit aesthetically into a\nvariety of line widths.  In addition, it obeys the printer control\nvariables *print-level*, *print-length*, *print-lines*, *print-circle* and\n*print-escape*, and can tolerate several different kinds of malformity in\nthe data structure.  The output below shows what is printed out with a\nright margin of 25, *print-pretty* being true, *print-escape* being false,\nand a malformed kids list.\n\n      (write (list 'principal-family\n                   (make-family :mom \"Lucy\"\n                                :kids '(\"Mark\" \"Bob\" . \"Dan\")))\n             :right-margin 25 :pretty T :escape nil :miser-width nil)\n      (PRINCIPAL-FAMILY\n       #<Lucy and\n           Mark Bob . Dan>)\n\nNote that a pretty printing function for a structure is different from the\nstructure's print-object method.  While print-object methods are\npermanently associated with a structure, pretty printing functions are\nstored in pprint dispatch tables and can be rapidly changed to reflect\ndifferent printing needs.  If there is no pretty printing function for a\nstructure in the current pprint dispatch table, its print-object method is\nused instead.\n\n"
}