{
    "name": "The for-as-package subclause",
    "prev": "The for-as-hash subclause",
    "next": "Examples of for-as-package subclause",
    "up": "Variable Initialization and Stepping Clauses",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "The for-as-package subclause",
            "text": "In the for-as-package subclause the for or as construct iterates over the\nsymbols in a package.  In this syntax, a compound preposition is used to\ndesignate access to a package.  The variable var takes on the value of\neach symbol in the supplied package.  The following loop keywords serve as\nvalid prepositions within this syntax:\nbeing\n     The keyword being introduces either the Loop schema symbol,\n     present-symbol,  or external-symbol.\neach, the\n     The loop keyword each follows the loop keyword being when symbol,\n     present-symbol, or external-symbol is used.  The loop keyword the is\n     used with symbols, present-symbols, and external-symbols only for\n     ease of reading.  This agreement isn't required.\npresent-symbol, present-symbols\n     These Loop schemas iterate over the symbols\n     that are present in a package.\n     The package to be iterated over is supplied in the same way that\n     package arguments to find-package are supplied.  If the package for\n     the iteration is not supplied, the current package is used.  If a\n     package that does not exist is supplied, an error of type\n     package-error is signaled.\nsymbol, symbols\n     These Loop schemas iterate over symbols that are accessible in a\n     given package.  The package to be iterated over is supplied in the\n     same way that package arguments to find-package are supplied.  If the\n     package for the iteration is not supplied, the current package is\n     used.  If a package that does not exist is supplied, an error of type\n     package-error is signaled.\nexternal-symbol, external-symbols\n     These Loop schemas iterate over the external symbols of a package.\n     The package to be iterated over is supplied in the same way that\n     package arguments to find-package are supplied.  If the package for\n     the iteration is not supplied, the current package is used.  If a\n     package that does not exist is supplied, an error of type\n     package-error is signaled.\nin, of\n     These loop prepositions introduce package.\nIn effect\nbeing {each | the} {symbol          | symbols         | present-symbol  |\npresent-symbols | external-symbol | external-symbols} {in | of}\nis a compound preposition.\nIteration stops when there are no more symbols to be referenced in the\nsupplied package.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: The for-as-package subclause,  Next: Examples of for-as-package subclause,  Prev: The for-as-hash subclause,  Up: Variable Initialization and Stepping Clauses\n\nThe for-as-package subclause\n............................\n\nIn the for-as-package subclause the for or as construct iterates over the\nsymbols in a package.  In this syntax, a compound preposition is used to\ndesignate access to a package.  The variable var takes on the value of\neach symbol in the supplied package.  The following loop keywords serve as\nvalid prepositions within this syntax:\n\nbeing\n     The keyword being introduces either the Loop schema symbol,\n     present-symbol,  or external-symbol.\n\neach, the\n     The loop keyword each follows the loop keyword being when symbol,\n     present-symbol, or external-symbol is used.  The loop keyword the is\n     used with symbols, present-symbols, and external-symbols only for\n     ease of reading.  This agreement isn't required.\n\npresent-symbol, present-symbols\n     These Loop schemas iterate over the symbols\n\n     that are present in a package.\n\n     The package to be iterated over is supplied in the same way that\n     package arguments to find-package are supplied.  If the package for\n     the iteration is not supplied, the current package is used.  If a\n     package that does not exist is supplied, an error of type\n     package-error is signaled.\n\nsymbol, symbols\n     These Loop schemas iterate over symbols that are accessible in a\n     given package.  The package to be iterated over is supplied in the\n     same way that package arguments to find-package are supplied.  If the\n     package for the iteration is not supplied, the current package is\n     used.  If a package that does not exist is supplied, an error of type\n     package-error is signaled.\n\nexternal-symbol, external-symbols\n     These Loop schemas iterate over the external symbols of a package.\n     The package to be iterated over is supplied in the same way that\n     package arguments to find-package are supplied.  If the package for\n     the iteration is not supplied, the current package is used.  If a\n     package that does not exist is supplied, an error of type\n     package-error is signaled.\n\nin, of\n     These loop prepositions introduce package.\n\nIn effect\n\nbeing {each | the} {symbol          | symbols         | present-symbol  |\npresent-symbols | external-symbol | external-symbols} {in | of}\n\nis a compound preposition.\n\nIteration stops when there are no more symbols to be referenced in the\nsupplied package.\n\n"
}