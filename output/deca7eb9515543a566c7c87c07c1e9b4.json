{
    "name": "with-simple-restart",
    "prev": "with-condition-restarts",
    "next": "abort",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Macro",
        "text": "with-simple-restart"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "with-simple-restart",
                    "text": " (name format-control {format-argument}*) {form}*=>  {result}*\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a symbol."
                },
                {
                    "name": "format-control",
                    "desc": "a format control."
                },
                {
                    "name": "format-argument",
                    "desc": "an object (i.e., a format argument)."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "in the normal situation, the values returned by the forms; in theexceptional situation where the restart named name is invoked, two\n"
                },
                {
                    "name": "values",
                    "desc": "nil and t."
                }
            ]
        },
        {
            "type": "Description",
            "text": "with-simple-restart establishes a restart.\nIf the restart designated by name is not invoked while executing forms,\nall values returned by the last of forms are returned.  If the restart\ndesignated by name is invoked, control is transferred to\nwith-simple-restart, which returns two values, nil and t.\nIf name is nil, an anonymous restart is established.\nThe format-control and format-arguments are used report the restart.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun read-eval-print-loop (level)\n        (with-simple-restart (abort \"Exit command level ~D.\" level)\n          (loop\n            (with-simple-restart (abort \"Return to command level ~D.\" level)\n              (let ((form (prog2 (fresh-line) (read) (fresh-line))))\n                (prin1 (eval form)))))))\n     =>  READ-EVAL-PRINT-LOOP\n      (read-eval-print-loop 1)\n      (+ 'a 3)\n      |>  Error: The argument, A, to the function + was of the wrong type.\n      |>         The function expected a number.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use this time.\n      |>   2: Return to command level 1.\n      |>   3: Exit command level 1.\n      |>   4: Return to Lisp Toplevel.\n      (defun compute-fixnum-power-of-2 (x)\n        (with-simple-restart (nil \"Give up on computing 2^~D.\" x)\n          (let ((result 1))\n            (dotimes (i x result)\n              (setq result (* 2 result))\n              (unless (fixnump result)\n                (error \"Power of 2 is too large.\"))))))\n     COMPUTE-FIXNUM-POWER-OF-2\n      (defun compute-power-of-2 (x)\n        (or (compute-fixnum-power-of-2 x) 'something big))\n     COMPUTE-POWER-OF-2\n      (compute-power-of-2 10)\n     1024\n      (compute-power-of-2 10000)\n      |>  Error: Power of 2 is too large.\n      |>  To continue, type :CONTINUE followed by an option number.\n      |>   1: Give up on computing 2^10000.\n      |>   2: Return to Lisp Toplevel\n      |>  Debug> |>>:continue 1<<|\n     =>  SOMETHING-BIG\n"
        },
        {
            "type": "See Also",
            "text": "*Note restart-case::\n"
        },
        {
            "type": "Notes",
            "text": "with-simple-restart is shorthand for one of the most common uses of\nrestart-case.\nwith-simple-restart could be defined by:\n      (defmacro with-simple-restart ((restart-name format-control\n                                                   &rest format-arguments)\n                                     &body forms)\n        `(restart-case (progn ,@forms)\n           (,restart-name ()\n               :report (lambda (stream)\n                         (format stream ,format-control ,@format-arguments))\n              (values nil t))))\nBecause the second return value is t in the exceptional case, it is common\n(but not required) to arrange for the second return value in the normal\ncase to be missing or nil so that the two situations can be distinguished.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: with-simple-restart,  Next: abort,  Prev: with-condition-restarts,  Up: Conditions Dictionary\n\nwith-simple-restart                                                 [Macro]\n---------------------------------------------------------------------------\n\n`with-simple-restart'  (name format-control {format-argument}*) {form}*\n=>  {result}*\n\nArguments and Values::\n......................\n\nname--a symbol.\n\nformat-control--a format control.\n\nformat-argument--an object (i.e., a format argument).\n\nforms--an implicit progn.\n\nresults--in the normal situation, the values returned by the forms; in the\nexceptional situation where the restart named name is invoked, two\nvalues--nil and t.\n\nDescription::\n.............\n\nwith-simple-restart establishes a restart.\n\nIf the restart designated by name is not invoked while executing forms,\nall values returned by the last of forms are returned.  If the restart\ndesignated by name is invoked, control is transferred to\nwith-simple-restart, which returns two values, nil and t.\n\nIf name is nil, an anonymous restart is established.\n\nThe format-control and format-arguments are used report the restart.\n\nExamples::\n..........\n\n      (defun read-eval-print-loop (level)\n        (with-simple-restart (abort \"Exit command level ~D.\" level)\n          (loop\n            (with-simple-restart (abort \"Return to command level ~D.\" level)\n              (let ((form (prog2 (fresh-line) (read) (fresh-line))))\n                (prin1 (eval form)))))))\n     =>  READ-EVAL-PRINT-LOOP\n      (read-eval-print-loop 1)\n      (+ 'a 3)\n      |>  Error: The argument, A, to the function + was of the wrong type.\n      |>         The function expected a number.\n      |>  To continue, type :CONTINUE followed by an option number:\n      |>   1: Specify a value to use this time.\n      |>   2: Return to command level 1.\n      |>   3: Exit command level 1.\n      |>   4: Return to Lisp Toplevel.\n\n      (defun compute-fixnum-power-of-2 (x)\n        (with-simple-restart (nil \"Give up on computing 2^~D.\" x)\n          (let ((result 1))\n            (dotimes (i x result)\n              (setq result (* 2 result))\n              (unless (fixnump result)\n                (error \"Power of 2 is too large.\"))))))\n     COMPUTE-FIXNUM-POWER-OF-2\n      (defun compute-power-of-2 (x)\n        (or (compute-fixnum-power-of-2 x) 'something big))\n     COMPUTE-POWER-OF-2\n      (compute-power-of-2 10)\n     1024\n      (compute-power-of-2 10000)\n      |>  Error: Power of 2 is too large.\n      |>  To continue, type :CONTINUE followed by an option number.\n      |>   1: Give up on computing 2^10000.\n      |>   2: Return to Lisp Toplevel\n      |>  Debug> |>>:continue 1<<|\n     =>  SOMETHING-BIG\n\nSee Also::\n..........\n\n*Note restart-case::\n\nNotes::\n.......\n\nwith-simple-restart is shorthand for one of the most common uses of\nrestart-case.\n\nwith-simple-restart could be defined by:\n\n      (defmacro with-simple-restart ((restart-name format-control\n                                                   &rest format-arguments)\n                                     &body forms)\n        `(restart-case (progn ,@forms)\n           (,restart-name ()\n               :report (lambda (stream)\n                         (format stream ,format-control ,@format-arguments))\n              (values nil t))))\n\nBecause the second return value is t in the exceptional case, it is common\n(but not required) to arrange for the second return value in the normal\ncase to be missing or nil so that the two situations can be distinguished.\n\n"
}