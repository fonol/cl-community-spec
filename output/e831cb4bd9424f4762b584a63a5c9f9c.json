{
    "name": "Valid Patterns for Tokens",
    "prev": "Symbols as Tokens",
    "next": "Package System Consistency Rules",
    "up": "Interpretation of Tokens",
    "header": {
        "type": null,
        "text": "Valid Patterns for Tokens"
    },
    "sections": [
        {
            "type": "",
            "text": "The valid patterns for tokens are summarized in Figure 2-17.\n  nnnnn              a number                                           \n  xxxxx              a symbol in the current package                    \n  :xxxxx             a symbol in the the KEYWORD package                \n  ppppp:xxxxx        an external symbol in the ppppp package            \n  ppppp::xxxxx       a (possibly internal) symbol in the ppppp package  \n  :nnnnn             undefined                                          \n  ppppp:nnnnn        undefined                                          \n  ppppp::nnnnn       undefined                                          \n  ::aaaaa            undefined                                          \n  aaaaa:             undefined                                          \n  aaaaa:aaaaa:aaaaa  undefined                                          \n                 Figure 2-17: Valid patterns for tokens                \nNote that nnnnn has number syntax, neither xxxxx nor ppppp has number\nsyntax, and aaaaa has any syntax.\nA summary of rules concerning package markers follows.  In each case,\nexamples are offered to illustrate the case; for presentational\nsimplicity, the examples assume that the readtable case of the current\nreadtable is :upcase.\n1.\n     If there is a single package marker, and it occurs at the beginning\n     of the token, then the token is interpreted as a symbol in the\n     KEYWORD package.  It also sets the symbol-value of the newly-created\n     symbol to that same symbol so that the symbol will self-evaluate.\n     For example, :bar, when read, interns BAR as an external symbol in\n     the KEYWORD package.\n2.\n     If there is a single package marker not at the beginning or end of the\n     token, then it divides the token into two parts.  The first part\n     specifies a package; the second part is the name of an external symbol\n     available in that package.\n     For example, foo:bar, when read, looks up BAR among the external\n     symbols of the package named FOO.\n3.\n     If there are two adjacent package markers not at the beginning or end\n     of the token, then they divide the token into two parts.  The first\n     part specifies a package; the second part is the name of a symbol\n     within that package (possibly an internal symbol).\n     For example, foo::bar, when read, interns BAR in the package named\n     FOO.\n4.\n     If the token contains no package markers, and does not have potential\n     number syntax, then the entire token is the name of the symbol.  The\n     symbol is looked up in the current package.\n     For example, bar, when read, interns BAR in the current package.\n5.\n     The consequences are unspecified if any other pattern of package\n     markers in a token is used.  All other uses of package markers within\n     names of symbols are not defined by this standard but are reserved\n     for implementation-dependent use.\nFor example, assuming the readtable case of the current readtable is\n:upcase, editor:buffer refers to the external symbol named BUFFER present\nin the package named editor, regardless of whether there is a symbol named\nBUFFER in the current package.  If there is no package named editor, or if\nno symbol named BUFFER is present in editor, or if BUFFER is not exported\nby editor, the reader signals a correctable error.  If editor::buffer is\nseen, the effect is exactly the same as reading buffer with the EDITOR\npackage being the current package.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Valid Patterns for Tokens,  Next: Package System Consistency Rules,  Prev: Symbols as Tokens,  Up: Interpretation of Tokens\n\nValid Patterns for Tokens\n-------------------------\n\nThe valid patterns for tokens are summarized in Figure 2-17.\n\n  nnnnn              a number                                           \n  xxxxx              a symbol in the current package                    \n  :xxxxx             a symbol in the the KEYWORD package                \n  ppppp:xxxxx        an external symbol in the ppppp package            \n  ppppp::xxxxx       a (possibly internal) symbol in the ppppp package  \n  :nnnnn             undefined                                          \n  ppppp:nnnnn        undefined                                          \n  ppppp::nnnnn       undefined                                          \n  ::aaaaa            undefined                                          \n  aaaaa:             undefined                                          \n  aaaaa:aaaaa:aaaaa  undefined                                          \n\n                 Figure 2-17: Valid patterns for tokens                \n\n\nNote that nnnnn has number syntax, neither xxxxx nor ppppp has number\nsyntax, and aaaaa has any syntax.\n\nA summary of rules concerning package markers follows.  In each case,\nexamples are offered to illustrate the case; for presentational\nsimplicity, the examples assume that the readtable case of the current\nreadtable is :upcase.\n\n1.\n     If there is a single package marker, and it occurs at the beginning\n     of the token, then the token is interpreted as a symbol in the\n     KEYWORD package.  It also sets the symbol-value of the newly-created\n     symbol to that same symbol so that the symbol will self-evaluate.\n\n     For example, :bar, when read, interns BAR as an external symbol in\n     the KEYWORD package.\n\n2.\n     If there is a single package marker not at the beginning or end of the\n     token, then it divides the token into two parts.  The first part\n     specifies a package; the second part is the name of an external symbol\n     available in that package.\n\n     For example, foo:bar, when read, looks up BAR among the external\n     symbols of the package named FOO.\n\n3.\n     If there are two adjacent package markers not at the beginning or end\n     of the token, then they divide the token into two parts.  The first\n     part specifies a package; the second part is the name of a symbol\n     within that package (possibly an internal symbol).\n\n     For example, foo::bar, when read, interns BAR in the package named\n     FOO.\n\n4.\n     If the token contains no package markers, and does not have potential\n     number syntax, then the entire token is the name of the symbol.  The\n     symbol is looked up in the current package.\n\n     For example, bar, when read, interns BAR in the current package.\n\n5.\n     The consequences are unspecified if any other pattern of package\n     markers in a token is used.  All other uses of package markers within\n     names of symbols are not defined by this standard but are reserved\n     for implementation-dependent use.\n\nFor example, assuming the readtable case of the current readtable is\n:upcase, editor:buffer refers to the external symbol named BUFFER present\nin the package named editor, regardless of whether there is a symbol named\nBUFFER in the current package.  If there is no package named editor, or if\nno symbol named BUFFER is present in editor, or if BUFFER is not exported\nby editor, the reader signals a correctable error.  If editor::buffer is\nseen, the effect is exactly the same as reading buffer with the EDITOR\npackage being the current package.\n\n"
}