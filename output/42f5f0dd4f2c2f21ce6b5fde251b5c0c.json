{
    "name": "list-length",
    "prev": "list",
    "next": "listp",
    "up": "Conses Dictionary",
    "header": {
        "type": "Function",
        "text": "list-length"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "list-length",
                    "text": " list =>  length\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "list",
                    "desc": "a proper list or a circular list."
                },
                {
                    "name": "length",
                    "desc": "a non-negative integer, or nil."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Returns the length of list if list is a proper list.  Returns nil if list\nis a circular list.\n"
        },
        {
            "type": "Examples",
            "text": "      (list-length '(a b c d)) =>  4\n      (list-length '(a (b c) d)) =>  3\n      (list-length '()) =>  0\n      (list-length nil) =>  0\n      (defun circular-list (&rest elements)\n        (let ((cycle (copy-list elements)))\n          (nconc cycle cycle)))\n      (list-length (circular-list 'a 'b)) =>  NIL\n      (list-length (circular-list 'a)) =>  NIL\n      (list-length (circular-list)) =>  0\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if list is not a proper list or\na circular list.\n"
        },
        {
            "type": "See Also",
            "text": "*Note length::\n"
        },
        {
            "type": "Notes",
            "text": "list-length could be implemented as follows:\n      (defun list-length (x)\n        (do ((n 0 (+ n 2))           ;Counter.\n             (fast x (cddr fast))    ;Fast pointer: leaps by 2.\n             (slow x (cdr slow)))    ;Slow pointer: leaps by 1.\n            (nil)\n          ;; If fast pointer hits the end, return the count.\n          (when (endp fast) (return n))\n          (when (endp (cdr fast)) (return (+ n 1)))\n          ;; If fast pointer eventually equals slow pointer,\n          ;;  then we must be stuck in a circular list.\n          ;; (A deeper property is the converse: if we are\n          ;;  stuck in a circular list, then eventually the\n          ;;  fast pointer will equal the slow pointer.\n          ;;  That fact justifies this implementation.)\n          (when (and (eq fast slow) (> n 0)) (return nil))))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: list-length,  Next: listp,  Prev: list,  Up: Conses Dictionary\n\nlist-length                                                      [Function]\n---------------------------------------------------------------------------\n\n`list-length'  list =>  length\n\nArguments and Values::\n......................\n\nlist--a proper list or a circular list.\n\nlength--a non-negative integer, or nil.\n\nDescription::\n.............\n\nReturns the length of list if list is a proper list.  Returns nil if list\nis a circular list.\n\nExamples::\n..........\n\n      (list-length '(a b c d)) =>  4\n      (list-length '(a (b c) d)) =>  3\n      (list-length '()) =>  0\n      (list-length nil) =>  0\n      (defun circular-list (&rest elements)\n        (let ((cycle (copy-list elements)))\n          (nconc cycle cycle)))\n      (list-length (circular-list 'a 'b)) =>  NIL\n      (list-length (circular-list 'a)) =>  NIL\n      (list-length (circular-list)) =>  0\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if list is not a proper list or\na circular list.\n\nSee Also::\n..........\n\n*Note length::\n\nNotes::\n.......\n\nlist-length could be implemented as follows:\n\n      (defun list-length (x)\n        (do ((n 0 (+ n 2))           ;Counter.\n             (fast x (cddr fast))    ;Fast pointer: leaps by 2.\n             (slow x (cdr slow)))    ;Slow pointer: leaps by 1.\n            (nil)\n          ;; If fast pointer hits the end, return the count.\n          (when (endp fast) (return n))\n          (when (endp (cdr fast)) (return (+ n 1)))\n          ;; If fast pointer eventually equals slow pointer,\n          ;;  then we must be stuck in a circular list.\n          ;; (A deeper property is the converse: if we are\n          ;;  stuck in a circular list, then eventually the\n          ;;  fast pointer will equal the slow pointer.\n          ;;  That fact justifies this implementation.)\n          (when (and (eq fast slow) (> n 0)) (return nil))))\n\n"
}