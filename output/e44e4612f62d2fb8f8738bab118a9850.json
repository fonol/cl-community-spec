{
    "name": "assert",
    "prev": "storage-condition",
    "next": "error",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Macro",
        "text": "assert"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "assert",
                    "text": " test-form [({place}*) [datum-form {argument-form}*]]=>  nil\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "test-form",
                    "desc": "a form; always evaluated."
                },
                {
                    "name": "place",
                    "desc": "a place; evaluated if an error is signaled."
                },
                {
                    "name": "datum-form",
                    "desc": "a form that evaluates to a datum.  Evaluated each time an"
                },
                {
                    "name": "datum-form",
                    "desc": "a form that evaluates to a datum.  Evaluated each time anerror is to be signaled, or not at all if no error is to be signaled.\n"
                },
                {
                    "name": "argument-form",
                    "desc": "a form that evaluates to an argument.  Evaluated each time"
                },
                {
                    "name": "argument-form",
                    "desc": "a form that evaluates to an argument.  Evaluated each timean error is to be signaled, or not at all if no error is to be signaled.\n"
                }
            ]
        },
        {
            "type": "Description",
            "text": "assert assures that test-form evaluates to true.  If test-form evaluates\nto false, assert signals a correctable error (denoted by datum and\narguments).  Continuing from this error using the continue restart makes\nit possible for the user to alter the values of the places before assert\nevaluates test-form again.  If the value of test-form is non-nil, assert\nreturns nil.\nThe places are generalized references to data upon which test-form depends,\nwhose values can be changed by the user in attempting to correct the error.\nSubforms of each place are only evaluated if an error is signaled, and\nmight be re-evaluated if the error is re-signaled (after continuing without\nactually fixing the problem).\nThe order of evaluation of the places is not specified; see *Note\nEvaluation of Subforms to Places::.\nIf a place form is supplied that produces more values than there are store\nvariables, the extra values are ignored. If the supplied form produces\nfewer values than there are store variables, the missing values are set to\nnil.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq x (make-array '(3 5) :initial-element 3))\n     =>  #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))\n      (setq y (make-array '(3 5) :initial-element 7))\n     =>  #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))\n      (defun matrix-multiply (a b)\n        (let ((*print-array* nil))\n          (assert (and (= (array-rank a) (array-rank b) 2)\n                       (= (array-dimension a 1) (array-dimension b 0)))\n                  (a b)\n                  \"Cannot multiply ~S by ~S.\" a b)\n                 (really-matrix-multiply a b))) =>  MATRIX-MULTIPLY\n      (matrix-multiply x y)\n      |>  Correctable error in MATRIX-MULTIPLY:\n      |>  Cannot multiply #<ARRAY ...> by #<ARRAY ...>.\n      |>  Restart options:\n      |>   1: You will be prompted for one or more new values.\n      |>   2: Top level.\n      |>  Debug> |>>:continue 1<<|\n      |>  Value for A: |>>x<<|\n      |>  Value for B: |>>(make-array '(5 3) :initial-element 6)<<|\n     =>  #2A((54 54 54 54 54)\n            (54 54 54 54 54)\n            (54 54 54 54 54)\n            (54 54 54 54 54)\n            (54 54 54 54 54))\n      (defun double-safely (x) (assert (numberp x) (x)) (+ x x))\n      (double-safely 4)\n     =>  8\n      (double-safely t)\n      |>  Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.\n      |>  Restart options:\n      |>   1: You will be prompted for one or more new values.\n      |>   2: Top level.\n      |>  Debug> |>>:continue 1<<|\n      |>  Value for X: |>>7<<|\n     =>  14\n"
        },
        {
            "type": "Affected By",
            "text": "*break-on-signals*\nThe set of active condition handlers.\n"
        },
        {
            "type": "See Also",
            "text": "*Note check-type:: , *Note error:: , *Note Generalized Reference::\n"
        },
        {
            "type": "Notes",
            "text": "The debugger need not include the test-form in the error message, and the\nplaces should not be included in the message, but they should be made\navailable for the user's perusal.  If the user gives the \"continue\"\ncommand, the values of any of the references can be altered.  The details\nof this depend on the implementation's style of user interface.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: assert,  Next: error,  Prev: storage-condition,  Up: Conditions Dictionary\n\nassert                                                              [Macro]\n---------------------------------------------------------------------------\n\n`assert'  test-form [({place}*) [datum-form {argument-form}*]]\n=>  nil\n\nArguments and Values::\n......................\n\ntest-form--a form; always evaluated.\n\nplace--a place; evaluated if an error is signaled.\n\ndatum-form--a form that evaluates to a datum.  Evaluated each time an\nerror is to be signaled, or not at all if no error is to be signaled.\n\nargument-form--a form that evaluates to an argument.  Evaluated each time\nan error is to be signaled, or not at all if no error is to be signaled.\n\ndatum, arguments--designators for a condition of default type error.\n(These designators are the result of evaluating datum-form and each of the\nargument-forms.)\n\nDescription::\n.............\n\nassert assures that test-form evaluates to true.  If test-form evaluates\nto false, assert signals a correctable error (denoted by datum and\narguments).  Continuing from this error using the continue restart makes\nit possible for the user to alter the values of the places before assert\nevaluates test-form again.  If the value of test-form is non-nil, assert\nreturns nil.\n\nThe places are generalized references to data upon which test-form depends,\nwhose values can be changed by the user in attempting to correct the error.\nSubforms of each place are only evaluated if an error is signaled, and\nmight be re-evaluated if the error is re-signaled (after continuing without\nactually fixing the problem).\n\nThe order of evaluation of the places is not specified; see *Note\nEvaluation of Subforms to Places::.\n\nIf a place form is supplied that produces more values than there are store\nvariables, the extra values are ignored. If the supplied form produces\nfewer values than there are store variables, the missing values are set to\nnil.\n\nExamples::\n..........\n\n      (setq x (make-array '(3 5) :initial-element 3))\n     =>  #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))\n      (setq y (make-array '(3 5) :initial-element 7))\n     =>  #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))\n      (defun matrix-multiply (a b)\n        (let ((*print-array* nil))\n          (assert (and (= (array-rank a) (array-rank b) 2)\n                       (= (array-dimension a 1) (array-dimension b 0)))\n                  (a b)\n                  \"Cannot multiply ~S by ~S.\" a b)\n                 (really-matrix-multiply a b))) =>  MATRIX-MULTIPLY\n      (matrix-multiply x y)\n      |>  Correctable error in MATRIX-MULTIPLY:\n      |>  Cannot multiply #<ARRAY ...> by #<ARRAY ...>.\n      |>  Restart options:\n      |>   1: You will be prompted for one or more new values.\n      |>   2: Top level.\n      |>  Debug> |>>:continue 1<<|\n      |>  Value for A: |>>x<<|\n      |>  Value for B: |>>(make-array '(5 3) :initial-element 6)<<|\n     =>  #2A((54 54 54 54 54)\n            (54 54 54 54 54)\n            (54 54 54 54 54)\n            (54 54 54 54 54)\n            (54 54 54 54 54))\n\n      (defun double-safely (x) (assert (numberp x) (x)) (+ x x))\n      (double-safely 4)\n     =>  8\n     \n      (double-safely t)\n      |>  Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.\n      |>  Restart options:\n      |>   1: You will be prompted for one or more new values.\n      |>   2: Top level.\n      |>  Debug> |>>:continue 1<<|\n      |>  Value for X: |>>7<<|\n     =>  14\n\nAffected By::\n.............\n\n*break-on-signals*\n\nThe set of active condition handlers.\n\nSee Also::\n..........\n\n*Note check-type:: , *Note error:: , *Note Generalized Reference::\n\nNotes::\n.......\n\nThe debugger need not include the test-form in the error message, and the\nplaces should not be included in the message, but they should be made\navailable for the user's perusal.  If the user gives the \"continue\"\ncommand, the values of any of the references can be altered.  The details\nof this depend on the implementation's style of user interface.\n\n"
}