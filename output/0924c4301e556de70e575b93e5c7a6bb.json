{
    "name": "Purpose of Compiler Macros",
    "prev": "Compiler Macros",
    "next": "Naming of Compiler Macros",
    "up": "Compilation Semantics",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Purpose of Compiler Macros",
            "text": "The purpose of the compiler macro facility is to permit selective source\ncode transformations as optimization advice to the compiler.  When a\ncompound form is being processed (as by the compiler), if the operator\nnames a compiler macro then the compiler macro function may be invoked on\nthe form, and the resulting expansion recursively processed in preference\nto performing the usual processing on the original form according to its\nnormal interpretation as a function form or macro form.\nA compiler macro function, like a macro function, is a function of two\narguments: the entire call form and the environment. Unlike an ordinary\nmacro function, a compiler macro function can decline to provide an\nexpansion merely by returning a value that is the same as the original\nform.  The consequences are undefined if a compiler macro function\ndestructively modifies any part of its form argument.\nThe form passed to the compiler macro function can either be a list whose\ncar is the function name, or a list whose car is funcall and whose cadr is\na list (function name); note that this affects destructuring of the form\nargument by the compiler macro function.  define-compiler-macro arranges\nfor destructuring of arguments to be performed correctly for both possible\nformats.\nWhen compile-file chooses to expand a top level form that is a compiler\nmacro form, the expansion is also treated as a top level form for the\npurposes of eval-when processing; see *Note Processing of Top Level\nForms::.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Purpose of Compiler Macros,  Next: Naming of Compiler Macros,  Prev: Compiler Macros,  Up: Compilation Semantics\n\nPurpose of Compiler Macros\n..........................\n\nThe purpose of the compiler macro facility is to permit selective source\ncode transformations as optimization advice to the compiler.  When a\ncompound form is being processed (as by the compiler), if the operator\nnames a compiler macro then the compiler macro function may be invoked on\nthe form, and the resulting expansion recursively processed in preference\nto performing the usual processing on the original form according to its\nnormal interpretation as a function form or macro form.\n\nA compiler macro function, like a macro function, is a function of two\narguments: the entire call form and the environment. Unlike an ordinary\nmacro function, a compiler macro function can decline to provide an\nexpansion merely by returning a value that is the same as the original\nform.  The consequences are undefined if a compiler macro function\ndestructively modifies any part of its form argument.\n\nThe form passed to the compiler macro function can either be a list whose\ncar is the function name, or a list whose car is funcall and whose cadr is\na list (function name); note that this affects destructuring of the form\nargument by the compiler macro function.  define-compiler-macro arranges\nfor destructuring of arguments to be performed correctly for both possible\nformats.\n\nWhen compile-file chooses to expand a top level form that is a compiler\nmacro form, the expansion is also treated as a top level form for the\npurposes of eval-when processing; see *Note Processing of Top Level\nForms::.\n\n"
}