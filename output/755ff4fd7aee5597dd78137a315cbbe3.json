{
    "name": "clear-input",
    "prev": "listen",
    "next": "finish-output",
    "up": "Streams Dictionary",
    "header": {
        "type": "Function",
        "text": "clear-input"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "clear-input",
                    "text": " &optional input-stream =>  nil\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "input-stream",
                    "desc": "an input stream designator.  The default is standard input."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Clears any available input from input-stream.\nIf clear-input does not make sense for input-stream, then clear-input does\nnothing.\n"
        },
        {
            "type": "Examples",
            "text": "     ;; The exact I/O behavior of this example might vary from implementation\n     ;; to implementation depending on the kind of interactive buffering that\n     ;; occurs.  (The call to SLEEP here is intended to help even out the\n     ;; differences in implementations which do not do line-at-a-time buffering.)\n     (defun read-sleepily (&optional (clear-p nil) (zzz 0))\n       (list (progn (print '>) (read))\n             ;; Note that input typed within the first ZZZ seconds\n             ;; will be discarded.\n             (progn (print '>)\n                    (if zzz (sleep zzz))\n                    (print '>>)\n                    (if clear-p (clear-input))\n                    (read))))\n     (read-sleepily)\n      |>  > |>>10<<|\n      |>  >\n      |>  >> |>>20<<|\n     =>  (10 20)\n     (read-sleepily t)\n      |>  > |>>10<<|\n      |>  >\n      |>  >> |>>20<<|\n     =>  (10 20)\n     (read-sleepily t 10)\n      |>  > |>>10<<|\n      |>  > |>>20<<|  ; Some implementations won't echo typeahead here.\n      |>  >> |>>30<<|\n     =>  (10 30)\n"
        },
        {
            "type": "Side Effects",
            "text": "The input-stream is modified.\n"
        },
        {
            "type": "Affected By",
            "text": "*standard-input*\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if input-stream is not a stream\ndesignator.\n"
        },
        {
            "type": "See Also",
            "text": "clear-output\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: clear-input,  Next: finish-output,  Prev: listen,  Up: Streams Dictionary\n\nclear-input                                                      [Function]\n---------------------------------------------------------------------------\n\n`clear-input'  &optional input-stream =>  nil\n\nArguments and Values::\n......................\n\ninput-stream--an input stream designator.  The default is standard input.\n\nDescription::\n.............\n\nClears any available input from input-stream.\n\nIf clear-input does not make sense for input-stream, then clear-input does\nnothing.\n\nExamples::\n..........\n\n     ;; The exact I/O behavior of this example might vary from implementation\n     ;; to implementation depending on the kind of interactive buffering that\n     ;; occurs.  (The call to SLEEP here is intended to help even out the\n     ;; differences in implementations which do not do line-at-a-time buffering.)\n     \n     (defun read-sleepily (&optional (clear-p nil) (zzz 0))\n       (list (progn (print '>) (read))\n             ;; Note that input typed within the first ZZZ seconds\n             ;; will be discarded.\n             (progn (print '>)\n                    (if zzz (sleep zzz))\n                    (print '>>)\n                    (if clear-p (clear-input))\n                    (read))))\n     \n     (read-sleepily)\n      |>  > |>>10<<|\n      |>  >\n      |>  >> |>>20<<|\n     =>  (10 20)\n     \n     (read-sleepily t)\n      |>  > |>>10<<|\n      |>  >\n      |>  >> |>>20<<|\n     =>  (10 20)\n     \n     (read-sleepily t 10)\n      |>  > |>>10<<|\n      |>  > |>>20<<|  ; Some implementations won't echo typeahead here.\n      |>  >> |>>30<<|\n     =>  (10 30)\n\nSide Effects::\n..............\n\nThe input-stream is modified.\n\nAffected By::\n.............\n\n*standard-input*\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if input-stream is not a stream\ndesignator.\n\nSee Also::\n..........\n\nclear-output\n\n"
}