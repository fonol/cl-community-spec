{
    "name": "progn",
    "prev": "prog1",
    "next": "define-modify-macro",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "progn"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "progn",
                    "text": " {form}* =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values of the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "progn evaluates forms, in the order in which they are given.\nThe values of each form but the last are discarded.\nIf progn appears as a top level form, then all forms within that progn are\nconsidered by the compiler to be top level forms.\n"
        },
        {
            "type": "Examples",
            "text": "      (progn) =>  NIL\n      (progn 1 2 3) =>  3\n      (progn (values 1 2 3)) =>  1, 2, 3\n      (setq a 1) =>  1\n      (if a\n           (progn (setq a nil) 'here)\n           (progn (setq a t) 'there)) =>  HERE\n      a =>  NIL\n"
        },
        {
            "type": "See Also",
            "text": "*Note prog1; prog2:: , prog2, *Note Evaluation::\n"
        },
        {
            "type": "Notes",
            "text": "Many places in Common Lisp involve syntax that uses implicit progns.  That\nis, part of their syntax allows many forms to be written that are to be\nevaluated sequentially, discarding the results of all forms but the last\nand returning the results of the last form.  Such places include, but are\nnot limited to, the following: the body of a lambda expression; the bodies\nof various control and conditional forms (e.g., case, catch, progn, and\nwhen).\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: progn,  Next: define-modify-macro,  Prev: prog1,  Up: Data and Control Flow Dictionary\n\nprogn                                                    [Special Operator]\n---------------------------------------------------------------------------\n\n`progn'  {form}* =>  {result}*\n\nArguments and Values::\n......................\n\nforms--an implicit progn.\n\nresults--the values of the forms.\n\nDescription::\n.............\n\nprogn evaluates forms, in the order in which they are given.\n\nThe values of each form but the last are discarded.\n\nIf progn appears as a top level form, then all forms within that progn are\nconsidered by the compiler to be top level forms.\n\nExamples::\n..........\n\n      (progn) =>  NIL\n      (progn 1 2 3) =>  3\n      (progn (values 1 2 3)) =>  1, 2, 3\n      (setq a 1) =>  1\n      (if a\n           (progn (setq a nil) 'here)\n           (progn (setq a t) 'there)) =>  HERE\n      a =>  NIL\n\nSee Also::\n..........\n\n*Note prog1; prog2:: , prog2, *Note Evaluation::\n\nNotes::\n.......\n\nMany places in Common Lisp involve syntax that uses implicit progns.  That\nis, part of their syntax allows many forms to be written that are to be\nevaluated sequentially, discarding the results of all forms but the last\nand returning the results of the last form.  Such places include, but are\nnot limited to, the following: the body of a lambda expression; the bodies\nof various control and conditional forms (e.g., case, catch, progn, and\nwhen).\n\n"
}