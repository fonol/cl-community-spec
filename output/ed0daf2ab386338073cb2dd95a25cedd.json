{
    "name": "progv",
    "prev": "let",
    "next": "setq",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "progv"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "progv",
                    "text": " symbols values {form}* =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "symbols",
                    "desc": "a list of symbols; evaluated."
                },
                {
                    "name": "values",
                    "desc": "a list of objects; evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "progv creates new dynamic variable bindings and executes each form using\nthose bindings.  Each form is evaluated in  order.\nprogv allows binding one or more dynamic variables whose names may be\ndetermined at run time.  Each form is evaluated in order with the dynamic\nvariables whose names are in symbols bound to corresponding values.  If\ntoo few values are supplied, the remaining symbols are bound and then made\nto have no value. If too many values are supplied, the excess values are\nignored.  The bindings of the dynamic variables are undone on exit from\nprogv.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq *x* 1) =>  1\n      (progv '(*x*) '(2) *x*) =>  2\n      *x* =>  1\n     Assuming *x* is not globally special,\n      (let ((*x* 3))\n         (progv '(*x*) '(4)\n           (list *x* (symbol-value '*x*)))) =>  (3 4)\n"
        },
        {
            "type": "See Also",
            "text": "*Note let; let*:: , *Note Evaluation::\n"
        },
        {
            "type": "Notes",
            "text": "Among other things, progv is useful when writing interpreters for\nlanguages embedded in Lisp; it provides a handle on the mechanism for\nbinding dynamic variables.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: progv,  Next: setq,  Prev: let,  Up: Data and Control Flow Dictionary\n\nprogv                                                    [Special Operator]\n---------------------------------------------------------------------------\n\n`progv'  symbols values {form}* =>  {result}*\n\nArguments and Values::\n......................\n\nsymbols--a list of symbols; evaluated.\n\nvalues--a list of objects; evaluated.\n\nforms--an implicit progn.\n\nresults--the values returned by the forms.\n\nDescription::\n.............\n\nprogv creates new dynamic variable bindings and executes each form using\nthose bindings.  Each form is evaluated in  order.\n\nprogv allows binding one or more dynamic variables whose names may be\ndetermined at run time.  Each form is evaluated in order with the dynamic\nvariables whose names are in symbols bound to corresponding values.  If\ntoo few values are supplied, the remaining symbols are bound and then made\nto have no value. If too many values are supplied, the excess values are\nignored.  The bindings of the dynamic variables are undone on exit from\nprogv.\n\nExamples::\n..........\n\n      (setq *x* 1) =>  1\n      (progv '(*x*) '(2) *x*) =>  2\n      *x* =>  1\n     \n     Assuming *x* is not globally special,\n     \n      (let ((*x* 3))\n         (progv '(*x*) '(4)\n           (list *x* (symbol-value '*x*)))) =>  (3 4)\n\nSee Also::\n..........\n\n*Note let; let*:: , *Note Evaluation::\n\nNotes::\n.......\n\nAmong other things, progv is useful when writing interpreters for\nlanguages embedded in Lisp; it provides a handle on the mechanism for\nbinding dynamic variables.\n\n"
}