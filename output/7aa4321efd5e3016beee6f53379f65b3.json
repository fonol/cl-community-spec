{
    "name": "symbol-function",
    "prev": "gentemp",
    "next": "symbol-name",
    "up": "Symbols Dictionary",
    "header": {
        "type": "Accessor",
        "text": "symbol-function"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "symbol-function",
                    "text": " symbol =>  contents\n(setf (`         symbol-function' symbol) new-contents)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "symbol",
                    "desc": "a symbol."
                },
                {
                    "name": "contents",
                    "desc": "If the symbol is globally defined as a macro or a special operator, an\nobject of implementation-dependent nature and identity is returned.  If\nthe symbol is not globally defined as either a macro or a special operator,\nand if the symbol is fbound, a function object is returned.\n"
                },
                {
                    "name": "new-contents",
                    "desc": "a function."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Accesses the symbol's function cell.\n"
        },
        {
            "type": "Examples",
            "text": "      (symbol-function 'car) =>  #<FUNCTION CAR>\n      (symbol-function 'twice) is an error   ;because TWICE isn't defined.\n      (defun twice (n) (* n 2)) =>  TWICE\n      (symbol-function 'twice) =>  #<FUNCTION TWICE>\n      (list (twice 3)\n            (funcall (function twice) 3)\n            (funcall (symbol-function 'twice) 3))\n     =>  (6 6 6)\n      (flet ((twice (x) (list x x)))\n        (list (twice 3)\n              (funcall (function twice) 3)\n              (funcall (symbol-function 'twice) 3)))\n     =>  ((3 3) (3 3) 6)\n      (setf (symbol-function 'twice) #'(lambda (x) (list x x)))\n     =>  #<FUNCTION anonymous>\n      (list (twice 3)\n            (funcall (function twice) 3)\n            (funcall (symbol-function 'twice) 3))\n     =>  ((3 3) (3 3) (3 3))\n      (fboundp 'defun) =>  true\n      (symbol-function 'defun)\n     =>  implementation-dependent\n      (functionp (symbol-function 'defun))\n     =>  implementation-dependent\n      (defun symbol-function-or-nil (symbol)\n        (if (and (fboundp symbol)\n                 (not (macro-function symbol))\n                 (not (special-operator-p symbol)))\n            (symbol-function symbol)\n            nil)) =>  SYMBOL-FUNCTION-OR-NIL\n      (symbol-function-or-nil 'car) =>  #<FUNCTION CAR>\n      (symbol-function-or-nil 'defun) =>  NIL\n"
        },
        {
            "type": "Affected By",
            "text": "defun\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type type-error if symbol is not a symbol.\nShould signal undefined-function if symbol is not fbound and an attempt is\nmade to read its definition.  (No such error is signaled on an attempt to\nwrite its definition.)\n"
        },
        {
            "type": "See Also",
            "text": "*Note fboundp:: , *Note fmakunbound:: , *Note macro-function:: ,\n*Note special-operator-p::\n"
        },
        {
            "type": "Notes",
            "text": "symbol-function cannot access the value of a lexical function name\nproduced by flet or labels; it can access only the global function value.\nsetf may be used with symbol-function to replace a global function\ndefinition when the symbol's function definition does not represent a\nspecial operator.\n     (symbol-function symbol) == (fdefinition symbol)\nHowever, fdefinition accepts arguments other than just symbols.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: symbol-function,  Next: symbol-name,  Prev: gentemp,  Up: Symbols Dictionary\n\nsymbol-function                                                  [Accessor]\n---------------------------------------------------------------------------\n\n`symbol-function'  symbol =>  contents\n\n(setf (`         symbol-function' symbol) new-contents)\nArguments and Values::\n......................\n\nsymbol--a symbol.\n\ncontents--\n\nIf the symbol is globally defined as a macro or a special operator, an\nobject of implementation-dependent nature and identity is returned.  If\nthe symbol is not globally defined as either a macro or a special operator,\nand if the symbol is fbound, a function object is returned.\n\nnew-contents--a function.\n\nDescription::\n.............\n\nAccesses the symbol's function cell.\n\nExamples::\n..........\n\n      (symbol-function 'car) =>  #<FUNCTION CAR>\n      (symbol-function 'twice) is an error   ;because TWICE isn't defined.\n      (defun twice (n) (* n 2)) =>  TWICE\n      (symbol-function 'twice) =>  #<FUNCTION TWICE>\n      (list (twice 3)\n            (funcall (function twice) 3)\n            (funcall (symbol-function 'twice) 3))\n     =>  (6 6 6)\n      (flet ((twice (x) (list x x)))\n        (list (twice 3)\n              (funcall (function twice) 3)\n              (funcall (symbol-function 'twice) 3)))\n     =>  ((3 3) (3 3) 6)\n      (setf (symbol-function 'twice) #'(lambda (x) (list x x)))\n     =>  #<FUNCTION anonymous>\n      (list (twice 3)\n            (funcall (function twice) 3)\n            (funcall (symbol-function 'twice) 3))\n     =>  ((3 3) (3 3) (3 3))\n      (fboundp 'defun) =>  true\n      (symbol-function 'defun)\n     =>  implementation-dependent\n      (functionp (symbol-function 'defun))\n     =>  implementation-dependent\n      (defun symbol-function-or-nil (symbol)\n        (if (and (fboundp symbol)\n                 (not (macro-function symbol))\n                 (not (special-operator-p symbol)))\n            (symbol-function symbol)\n            nil)) =>  SYMBOL-FUNCTION-OR-NIL\n      (symbol-function-or-nil 'car) =>  #<FUNCTION CAR>\n      (symbol-function-or-nil 'defun) =>  NIL\n\nAffected By::\n.............\n\ndefun\n\nExceptional Situations::\n........................\n\nShould signal an error of type type-error if symbol is not a symbol.\n\nShould signal undefined-function if symbol is not fbound and an attempt is\nmade to read its definition.  (No such error is signaled on an attempt to\nwrite its definition.)\n\nSee Also::\n..........\n\n*Note fboundp:: , *Note fmakunbound:: , *Note macro-function:: ,\n\n*Note special-operator-p::\n\nNotes::\n.......\n\nsymbol-function cannot access the value of a lexical function name\nproduced by flet or labels; it can access only the global function value.\n\nsetf may be used with symbol-function to replace a global function\ndefinition when the symbol's function definition does not represent a\nspecial operator.\n\n     (symbol-function symbol) == (fdefinition symbol)\n\nHowever, fdefinition accepts arguments other than just symbols.\n\n"
}