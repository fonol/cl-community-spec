{
    "name": "Rule of Canonical Representation for Complex Rationals",
    "prev": "Rule of Complex Contagion",
    "next": "Examples of Rule of Canonical Representation for Complex Rationals",
    "up": "Complex Computations",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Rule of Canonical Representation for Complex Rationals",
            "text": "If the result of any computation would be a complex number whose real part\nis of type rational and whose imaginary part is zero, the result is\nconverted to the rational which is the real part.  This rule does not\napply to complex numbers whose parts are floats.  For example, #C(5 0) and\n5 are not different objects in Common Lisp (they are always the same under\neql); #C(5.0 0.0) and 5.0 are always different objects in Common Lisp\n(they are never the same under eql, although they are the same under\nequalp and =).\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Rule of Canonical Representation for Complex Rationals,  Next: Examples of Rule of Canonical Representation for Complex Rationals,  Prev: Rule of Complex Contagion,  Up: Complex Computations\n\nRule of Canonical Representation for Complex Rationals\n......................................................\n\nIf the result of any computation would be a complex number whose real part\nis of type rational and whose imaginary part is zero, the result is\nconverted to the rational which is the real part.  This rule does not\napply to complex numbers whose parts are floats.  For example, #C(5 0) and\n5 are not different objects in Common Lisp (they are always the same under\neql); #C(5.0 0.0) and 5.0 are always different objects in Common Lisp\n(they are never the same under eql, although they are the same under\nequalp and =).\n\n"
}