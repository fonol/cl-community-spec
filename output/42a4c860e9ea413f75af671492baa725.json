{
    "name": "dotimes",
    "prev": "do",
    "next": "dolist",
    "up": "Iteration Dictionary",
    "header": {
        "type": "Macro",
        "text": "dotimes"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "dotimes",
                    "text": " (var count-form [result-form]) {declaration}* {tag | statement}*=>  {result}*\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "var",
                    "desc": "a symbol."
                },
                {
                    "name": "count-form",
                    "desc": "a form."
                },
                {
                    "name": "result-form",
                    "desc": "a form."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "tag",
                    "desc": "a go tag; not evaluated."
                },
                {
                    "name": "statement",
                    "desc": "a compound form; evaluated as described below."
                }
            ]
        },
        {
            "type": "Description",
            "text": "dotimes iterates over a series of integers.\ndotimes evaluates count-form, which should produce an integer.  If\ncount-form is zero or negative, the body is not executed.  dotimes then\nexecutes the body once for each integer from 0 up to but not including the\nvalue of count-form, in the order in which the tags and statements occur,\nwith var bound to each integer.  Then result-form is evaluated.  At the\ntime result-form is processed, var is bound to the number of times the\nbody was executed.  Tags label statements.\nAn implicit block named nil surrounds dotimes.  return may be used to\nterminate the loop immediately without performing any further iterations,\nreturning zero or more values.\nThe body of the loop is an implicit tagbody; it may contain tags to serve\nas the targets of go statements.  Declarations may appear before the body\nof the loop.\nThe scope of the binding of var does not include the count-form, but the\nresult-form is included.\nIt is implementation-dependent whether dotimes establishes a new binding\nof var on each iteration or whether it establishes a binding for var once\nat the beginning and then assigns it on any subsequent iterations.\n"
        },
        {
            "type": "Examples",
            "text": "      (dotimes (temp-one 10 temp-one)) =>  10\n      (setq temp-two 0) =>  0\n      (dotimes (temp-one 10 t) (incf temp-two)) =>  T\n      temp-two =>  10\nHere is an example of the use of dotimes in processing strings:\n     ;;; True if the specified subsequence of the string is a\n     ;;; palindrome (reads the same forwards and backwards).\n      (defun palindromep (string &optional\n                                (start 0)\n                                (end (length string)))\n        (dotimes (k (floor (- end start) 2) t)\n         (unless (char-equal (char string (+ start k))\n                             (char string (- end k 1)))\n           (return nil))))\n      (palindromep \"Able was I ere I saw Elba\") =>  T\n      (palindromep \"A man, a plan, a canal--Panama!\") =>  NIL\n      (remove-if-not #'alpha-char-p          ;Remove punctuation.\n                    \"A man, a plan, a canal--Panama!\")\n     =>  \"AmanaplanacanalPanama\"\n      (palindromep\n       (remove-if-not #'alpha-char-p\n                     \"A man, a plan, a canal--Panama!\")) =>  T\n      (palindromep\n       (remove-if-not\n        #'alpha-char-p\n        \"Unremarkable was I ere I saw Elba Kramer, nu?\")) =>  T\n      (palindromep\n       (remove-if-not\n        #'alpha-char-p\n        \"A man, a plan, a cat, a ham, a yak,\n                       a yam, a hat, a canal--Panama!\")) =>  T\n"
        },
        {
            "type": "See Also",
            "text": "*Note do; do*:: , *Note dolist:: , *Note tagbody::\n"
        },
        {
            "type": "Notes",
            "text": "go may be used within the body of dotimes to transfer control to a\nstatement labeled by a tag.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: dotimes,  Next: dolist,  Prev: do,  Up: Iteration Dictionary\n\ndotimes                                                             [Macro]\n---------------------------------------------------------------------------\n\n`dotimes'  (var count-form [result-form]) {declaration}* {tag | statement}*\n=>  {result}*\n\nArguments and Values::\n......................\n\nvar--a symbol.\n\ncount-form--a form.\n\nresult-form--a form.\n\ndeclaration--a declare expression; not evaluated.\n\ntag--a go tag; not evaluated.\n\nstatement--a compound form; evaluated as described below.\n\nresults--if a return or return-from form is executed, the values passed\nfrom that form; otherwise, the values returned by the result-form or nil\nif there is no result-form.\n\nDescription::\n.............\n\ndotimes iterates over a series of integers.\n\ndotimes evaluates count-form, which should produce an integer.  If\ncount-form is zero or negative, the body is not executed.  dotimes then\nexecutes the body once for each integer from 0 up to but not including the\nvalue of count-form, in the order in which the tags and statements occur,\nwith var bound to each integer.  Then result-form is evaluated.  At the\ntime result-form is processed, var is bound to the number of times the\nbody was executed.  Tags label statements.\n\nAn implicit block named nil surrounds dotimes.  return may be used to\nterminate the loop immediately without performing any further iterations,\nreturning zero or more values.\n\nThe body of the loop is an implicit tagbody; it may contain tags to serve\nas the targets of go statements.  Declarations may appear before the body\nof the loop.\n\nThe scope of the binding of var does not include the count-form, but the\nresult-form is included.\n\nIt is implementation-dependent whether dotimes establishes a new binding\nof var on each iteration or whether it establishes a binding for var once\nat the beginning and then assigns it on any subsequent iterations.\n\nExamples::\n..........\n\n      (dotimes (temp-one 10 temp-one)) =>  10\n      (setq temp-two 0) =>  0\n      (dotimes (temp-one 10 t) (incf temp-two)) =>  T\n      temp-two =>  10\n\nHere is an example of the use of dotimes in processing strings:\n\n     ;;; True if the specified subsequence of the string is a\n     ;;; palindrome (reads the same forwards and backwards).\n      (defun palindromep (string &optional\n                                (start 0)\n                                (end (length string)))\n        (dotimes (k (floor (- end start) 2) t)\n         (unless (char-equal (char string (+ start k))\n                             (char string (- end k 1)))\n           (return nil))))\n      (palindromep \"Able was I ere I saw Elba\") =>  T\n      (palindromep \"A man, a plan, a canal--Panama!\") =>  NIL\n      (remove-if-not #'alpha-char-p          ;Remove punctuation.\n                    \"A man, a plan, a canal--Panama!\")\n     =>  \"AmanaplanacanalPanama\"\n      (palindromep\n       (remove-if-not #'alpha-char-p\n                     \"A man, a plan, a canal--Panama!\")) =>  T\n      (palindromep\n       (remove-if-not\n        #'alpha-char-p\n        \"Unremarkable was I ere I saw Elba Kramer, nu?\")) =>  T\n      (palindromep\n       (remove-if-not\n        #'alpha-char-p\n        \"A man, a plan, a cat, a ham, a yak,\n                       a yam, a hat, a canal--Panama!\")) =>  T\n\nSee Also::\n..........\n\n*Note do; do*:: , *Note dolist:: , *Note tagbody::\n\nNotes::\n.......\n\ngo may be used within the body of dotimes to transfer control to a\nstatement labeled by a tag.\n\n"
}