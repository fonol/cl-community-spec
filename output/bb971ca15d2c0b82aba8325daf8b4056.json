{
    "name": "Initial and Final Execution",
    "prev": "Examples of NAMED clause",
    "next": null,
    "up": "Miscellaneous Clauses",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Initial and Final Execution",
            "text": "The initially and finally constructs evaluate forms that occur before and\nafter the loop body.\nThe initially construct causes the supplied compound-forms to be evaluated\nin the loop prologue, which precedes all loop code except for initial\nsettings supplied by constructs with, for, or as.  The code for any\ninitially clauses is executed in the order in which the clauses appeared in\nthe loop.\nThe finally construct causes the supplied compound-forms to be evaluated\nin the loop epilogue after normal iteration terminates.  The code for any\nfinally clauses is executed in the order in which the clauses appeared in\nthe loop.  The collected code is executed once in the loop epilogue before\nany implicit values are returned from the accumulation clauses.  An\nexplicit transfer of control (e.g., by return, go, or throw) from the loop\nbody, however, will exit the loop without executing the epilogue code.\nClauses such as return, always, never, and thereis can bypass the finally\nclause.\nreturn (or return-from, if the named option was supplied)\ncan be used after finally to return values from a loop.\nSuch an explicit return\ninside the finally clause takes precedence over returning the accumulation\nfrom clauses supplied by such keywords as collect, nconc, append, sum,\ncount, maximize, and minimize; the accumulation values for these preempted\nclauses are not returned by loop if return or return-from is used.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Initial and Final Execution,  Prev: Examples of NAMED clause,  Up: Miscellaneous Clauses\n\nInitial and Final Execution\n...........................\n\nThe initially and finally constructs evaluate forms that occur before and\nafter the loop body.\n\nThe initially construct causes the supplied compound-forms to be evaluated\nin the loop prologue, which precedes all loop code except for initial\nsettings supplied by constructs with, for, or as.  The code for any\ninitially clauses is executed in the order in which the clauses appeared in\nthe loop.\n\nThe finally construct causes the supplied compound-forms to be evaluated\nin the loop epilogue after normal iteration terminates.  The code for any\nfinally clauses is executed in the order in which the clauses appeared in\nthe loop.  The collected code is executed once in the loop epilogue before\nany implicit values are returned from the accumulation clauses.  An\nexplicit transfer of control (e.g., by return, go, or throw) from the loop\nbody, however, will exit the loop without executing the epilogue code.\n\nClauses such as return, always, never, and thereis can bypass the finally\nclause.\n\nreturn (or return-from, if the named option was supplied)\n\ncan be used after finally to return values from a loop.\n\nSuch an explicit return\n\ninside the finally clause takes precedence over returning the accumulation\nfrom clauses supplied by such keywords as collect, nconc, append, sum,\ncount, maximize, and minimize; the accumulation values for these preempted\nclauses are not returned by loop if return or return-from is used.\n\n"
}