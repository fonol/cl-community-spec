{
    "name": "Macro Forms",
    "prev": "Special Forms",
    "next": "Function Forms",
    "up": "The Evaluation Model",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Macro Forms",
            "text": "If the operator names a macro, its associated macro function is applied to\nthe entire form and the result of that application is used in place of the\noriginal form.\nSpecifically, a symbol names a macro in a given lexical environment if\nmacro-function is true of the symbol and that environment.  The function\nreturned by macro-function is a function of two arguments, called the\nexpansion function.  The expansion function is invoked by calling the\nmacroexpand hook with the expansion function as its first argument, the\nentire macro form as its second argument, and an environment object\n(corresponding to the current lexical environment) as its third argument.\nThe macroexpand hook, in turn, calls the expansion function with the form\nas its first argument and the environment as its second argument.  The\nvalue of the expansion function, which is passed through by the\nmacroexpand hook, is a form.  The returned form is evaluated in place of\nthe original form.\nThe consequences are undefined if a macro function destructively modifies\nany part of its form argument.\nA macro name is not a function designator, and cannot be used as the\nfunction argument to functions such as apply, funcall, or map.\nAn implementation is free to implement a Common Lisp special operator as a\nmacro.  An implementation is free to implement any macro operator as a\nspecial operator, but only if an equivalent definition of the macro is\nalso provided.\nFigure 3-3 lists some defined names that are applicable to macros.\n  *macroexpand-hook*  macro-function  macroexpand-1  \n  defmacro            macroexpand     macrolet       \n    Figure 3-3: Defined names applicable to macros  \n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Macro Forms,  Next: Function Forms,  Prev: Special Forms,  Up: The Evaluation Model\n\nMacro Forms\n...........\n\nIf the operator names a macro, its associated macro function is applied to\nthe entire form and the result of that application is used in place of the\noriginal form.\n\nSpecifically, a symbol names a macro in a given lexical environment if\nmacro-function is true of the symbol and that environment.  The function\nreturned by macro-function is a function of two arguments, called the\nexpansion function.  The expansion function is invoked by calling the\nmacroexpand hook with the expansion function as its first argument, the\nentire macro form as its second argument, and an environment object\n(corresponding to the current lexical environment) as its third argument.\nThe macroexpand hook, in turn, calls the expansion function with the form\nas its first argument and the environment as its second argument.  The\nvalue of the expansion function, which is passed through by the\nmacroexpand hook, is a form.  The returned form is evaluated in place of\nthe original form.\n\nThe consequences are undefined if a macro function destructively modifies\nany part of its form argument.\n\nA macro name is not a function designator, and cannot be used as the\nfunction argument to functions such as apply, funcall, or map.\n\nAn implementation is free to implement a Common Lisp special operator as a\nmacro.  An implementation is free to implement any macro operator as a\nspecial operator, but only if an equivalent definition of the macro is\nalso provided.\n\nFigure 3-3 lists some defined names that are applicable to macros.\n\n  *macroexpand-hook*  macro-function  macroexpand-1  \n  defmacro            macroexpand     macrolet       \n\n    Figure 3-3: Defined names applicable to macros  \n\n\n"
}