{
    "name": "mask-field",
    "prev": "ldb-test",
    "next": "most-positive-fixnum",
    "up": "Numbers Dictionary",
    "header": {
        "type": "Accessor",
        "text": "mask-field"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "mask-field",
                    "text": " bytespec integer =>  masked-integer\n(setf (`         mask-field' bytespec place) new-masked-integer)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "bytespec",
                    "desc": "a byte specifier."
                },
                {
                    "name": "integer",
                    "desc": "an integer."
                },
                {
                    "name": "masked-integer, new-masked-integer",
                    "desc": "a non-negative integer."
                }
            ]
        },
        {
            "type": "Description",
            "text": "mask-field performs a \"mask\" operation on integer.  It returns an integer\nthat has the same bits as integer in the byte specified by bytespec, but\nthat has zero-bits everywhere else.\nsetf may be used with mask-field to modify a byte within the integer that\nis stored in a given place.  The effect is to perform a deposit-field\noperation and then store the result back into the place.\n"
        },
        {
            "type": "Examples",
            "text": "      (mask-field (byte 1 5) -1) =>  32\n      (setq a 15) =>  15\n      (mask-field (byte 2 0) a) =>  3\n      a =>  15\n      (setf (mask-field (byte 2 0) a) 1) =>  1\n      a =>  13\n"
        },
        {
            "type": "See Also",
            "text": "*Note byte; byte-size; byte-position:: , *Note ldb::\n"
        },
        {
            "type": "Notes",
            "text": "      (ldb bs (mask-field bs n)) == (ldb bs n)\n      (logbitp j (mask-field (byte s p) n))\n        == (and (>= j p) (< j s) (logbitp j n))\n      (mask-field bs n) == (logand n (dpb -1 bs 0))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: mask-field,  Next: most-positive-fixnum,  Prev: ldb-test,  Up: Numbers Dictionary\n\nmask-field                                                       [Accessor]\n---------------------------------------------------------------------------\n\n`mask-field'  bytespec integer =>  masked-integer\n\n(setf (`         mask-field' bytespec place) new-masked-integer)\nArguments and Values::\n......................\n\nbytespec--a byte specifier.\n\ninteger--an integer.\n\nmasked-integer, new-masked-integer--a non-negative integer.\n\nDescription::\n.............\n\nmask-field performs a \"mask\" operation on integer.  It returns an integer\nthat has the same bits as integer in the byte specified by bytespec, but\nthat has zero-bits everywhere else.\n\nsetf may be used with mask-field to modify a byte within the integer that\nis stored in a given place.  The effect is to perform a deposit-field\noperation and then store the result back into the place.\n\nExamples::\n..........\n\n      (mask-field (byte 1 5) -1) =>  32\n      (setq a 15) =>  15\n      (mask-field (byte 2 0) a) =>  3\n      a =>  15\n      (setf (mask-field (byte 2 0) a) 1) =>  1\n      a =>  13\n\nSee Also::\n..........\n\n*Note byte; byte-size; byte-position:: , *Note ldb::\n\nNotes::\n.......\n\n      (ldb bs (mask-field bs n)) == (ldb bs n)\n      (logbitp j (mask-field (byte s p) n))\n        == (and (>= j p) (< j s) (logbitp j n))\n      (mask-field bs n) == (logand n (dpb -1 bs 0))\n\n"
}