{
    "name": "loop-finish",
    "prev": "loop",
    "next": null,
    "up": "Iteration Dictionary",
    "header": {
        "type": "Local Macro",
        "text": "loop-finish"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "loop-finish",
                    "text": " <no arguments> =>  #<NoValue>\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Description",
            "text": "The loop-finish macro can be used lexically within an extended loop form\nto terminate that form \"normally.\" That is, it transfers control to the\nloop epilogue of the lexically innermost extended loop form.  This permits\nexecution of any finally clause (for effect) and the return of any\naccumulated result.\n"
        },
        {
            "type": "Examples",
            "text": "     ;; Terminate the loop, but return the accumulated count.\n      (loop for i in '(1 2 3 stop-here 4 5 6)\n            when (symbolp i) do (loop-finish)\n            count i)\n     =>  3\n     ;; The preceding loop is equivalent to:\n      (loop for i in '(1 2 3 stop-here 4 5 6)\n            until (symbolp i)\n            count i)\n     =>  3\n     ;; While LOOP-FINISH can be used can be used in a variety of\n     ;; situations it is really most needed in a situation where a need\n     ;; to exit is detected at other than the loop's `top level'\n     ;; (where UNTIL or WHEN often work just as well), or where some\n     ;; computation must occur between the point where a need to exit is\n     ;; detected and the point where the exit actually occurs.  For example:\n      (defun tokenize-sentence (string)\n        (macrolet ((add-word (wvar svar)\n                     `(when ,wvar\n                        (push (coerce (nreverse ,wvar) 'string) ,svar)\n                        (setq ,wvar nil))))\n          (loop with word = '() and sentence = '() and endpos = nil\n                for i below (length string)\n                do (let ((char (aref string i)))\n                     (case char\n                       (#\\Space (add-word word sentence))\n                       (#\\. (setq endpos (1+ i)) (loop-finish))\n                       (otherwise (push char word))))\n                finally (add-word word sentence)\n                        (return (values (nreverse sentence) endpos)))))\n     =>  TOKENIZE-SENTENCE\n      (tokenize-sentence \"this is a sentence. this is another sentence.\")\n     =>  (\"this\" \"is\" \"a\" \"sentence\"), 19\n      (tokenize-sentence \"this is a sentence\")\n     =>  (\"this\" \"is\" \"a\" \"sentence\"), NIL\n"
        },
        {
            "type": "Side Effects",
            "text": "Transfers control.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Whether or not loop-finish is fbound in the global environment is\nimplementation-dependent; however, the restrictions on redefinition and\nshadowing of loop-finish are the same as for symbols in the COMMON-LISP\npackage which are fbound in the global environment.  The consequences of\nattempting to use loop-finish outside of loop are undefined.\n"
        },
        {
            "type": "See Also",
            "text": "*Note loop:: , *Note The LOOP Facility::\n"
        },
        {
            "type": "Notes",
            "text": ""
        }
    ],
    "_otext": "File: gcl.info,  Node: loop-finish,  Prev: loop,  Up: Iteration Dictionary\n\nloop-finish                                                   [Local Macro]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n`loop-finish'  <no arguments> =>  #<NoValue>\n\nDescription::\n.............\n\nThe loop-finish macro can be used lexically within an extended loop form\nto terminate that form \"normally.\" That is, it transfers control to the\nloop epilogue of the lexically innermost extended loop form.  This permits\nexecution of any finally clause (for effect) and the return of any\naccumulated result.\n\nExamples::\n..........\n\n     ;; Terminate the loop, but return the accumulated count.\n      (loop for i in '(1 2 3 stop-here 4 5 6)\n            when (symbolp i) do (loop-finish)\n            count i)\n     =>  3\n     \n     ;; The preceding loop is equivalent to:\n      (loop for i in '(1 2 3 stop-here 4 5 6)\n            until (symbolp i)\n            count i)\n     =>  3\n     \n     ;; While LOOP-FINISH can be used can be used in a variety of\n     ;; situations it is really most needed in a situation where a need\n     ;; to exit is detected at other than the loop's `top level'\n     ;; (where UNTIL or WHEN often work just as well), or where some\n     ;; computation must occur between the point where a need to exit is\n     ;; detected and the point where the exit actually occurs.  For example:\n      (defun tokenize-sentence (string)\n        (macrolet ((add-word (wvar svar)\n                     `(when ,wvar\n                        (push (coerce (nreverse ,wvar) 'string) ,svar)\n                        (setq ,wvar nil))))\n          (loop with word = '() and sentence = '() and endpos = nil\n                for i below (length string)\n                do (let ((char (aref string i)))\n                     (case char\n                       (#\\Space (add-word word sentence))\n                       (#\\. (setq endpos (1+ i)) (loop-finish))\n                       (otherwise (push char word))))\n                finally (add-word word sentence)\n                        (return (values (nreverse sentence) endpos)))))\n     =>  TOKENIZE-SENTENCE\n     \n      (tokenize-sentence \"this is a sentence. this is another sentence.\")\n     =>  (\"this\" \"is\" \"a\" \"sentence\"), 19\n     \n      (tokenize-sentence \"this is a sentence\")\n     =>  (\"this\" \"is\" \"a\" \"sentence\"), NIL\n\nSide Effects::\n..............\n\nTransfers control.\n\nExceptional Situations::\n........................\n\nWhether or not loop-finish is fbound in the global environment is\nimplementation-dependent; however, the restrictions on redefinition and\nshadowing of loop-finish are the same as for symbols in the COMMON-LISP\npackage which are fbound in the global environment.  The consequences of\nattempting to use loop-finish outside of loop are undefined.\n\nSee Also::\n..........\n\n*Note loop:: , *Note The LOOP Facility::\n\nNotes::\n.......\n\n"
}