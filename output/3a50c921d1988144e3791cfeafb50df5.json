{
    "name": "Tilde Circumflex-> Escape Upward",
    "prev": "Tilde Semicolon-> Clause Separator",
    "next": "Tilde Newline-> Ignored Newline",
    "up": "FORMAT Miscellaneous Pseudo-Operations",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Tilde Circumflex: Escape Upward",
            "text": "~^\nThis is an escape construct.  If there are no more arguments remaining to\nbe processed, then the immediately enclosing ~{   or ~< construct is\nterminated.  If there is no such enclosing construct, then the entire\nformatting operation is terminated.  In the ~< case, the formatting is\nperformed, but no more segments are processed before doing the\njustification.  ~^  may appear anywhere in a ~{   construct.\n      (setq donestr \"Done.~^ ~D warning~:P.~^ ~D error~:P.\")\n     =>  \"Done.~^ ~D warning~:P.~^ ~D error~:P.\"\n      (format nil donestr) =>  \"Done.\"\n      (format nil donestr 3) =>  \"Done. 3 warnings.\"\n      (format nil donestr 1 5) =>  \"Done. 1 warning. 5 errors.\"\nIf a prefix parameter is given, then termination occurs if the parameter\nis zero.  (Hence ~^ is equivalent to ~#^.)  If two parameters are given,\ntermination occurs if they are equal.\n[Reviewer Note by Barmar: Which equality predicate?]  If three parameters\nare given, termination occurs if the first is less than or equal to the\nsecond and the second is less than or equal to the third.  Of course, this\nis useless if all the prefix parameters are constants; at least one of\nthem should be a # or a V parameter.\nIf ~^ is used within a ~:{   construct, then it terminates the current\niteration step because in the standard case it tests for remaining\narguments of the current step only; the next iteration step commences\nimmediately.  ~:^ is used to terminate the iteration process.\n~:^ may be used only if the command it would terminate is ~:{   or ~:@{  .\nThe entire iteration process is terminated if and only if the sublist that\nis supplying the arguments for the current iteration step is the last\nsublist in the case of ~:{ , or the last format argument in the case of\n~:@{  .  ~:^ is not equivalent to ~#:^; the latter terminates the entire\niteration if and only if no arguments remain for the current iteration\nstep.  For example:\n      (format nil \"~:{ ~@?~:^ ...~} \" '((\"a\") (\"b\"))) =>  \"a...b\"\nIf ~^ appears within a control string being processed under the control of\na ~? directive, but not within any ~{   or ~< construct within that string,\nthen the string being processed will be terminated, thereby ending\nprocessing of the ~? directive.  Processing then continues within the\nstring containing the ~? directive at the point following that directive.\nIf ~^ appears within a ~[ or ~( construct, then all the commands up to the\n~^ are properly selected or case-converted, the ~[ or ~( processing is\nterminated, and the outward search continues for a ~{   or ~< construct to\nbe terminated.  For example:\n      (setq tellstr \"~@(~@[~R~]~^ ~A!~)\")\n     =>  \"~@(~@[~R~]~^ ~A!~)\"\n      (format nil tellstr 23) =>  \"Twenty-three!\"\n      (format nil tellstr nil \"losers\") =>  \" Losers!\"\n      (format nil tellstr 23 \"losers\") =>  \"Twenty-three losers!\"\nFollowing are examples of the use of ~^ within a ~< construct.\n      (format nil \"~15<~S~;~^~S~;~^~S~>\" 'foo)\n     =>   \"            FOO\"\n      (format nil \"~15<~S~;~^~S~;~^~S~>\" 'foo 'bar)\n     =>   \"FOO         BAR\"\n      (format nil \"~15<~S~;~^~S~;~^~S~>\" 'foo 'bar 'baz)\n     =>   \"FOO   BAR   BAZ\"\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Tilde Circumflex-> Escape Upward,  Next: Tilde Newline-> Ignored Newline,  Prev: Tilde Semicolon-> Clause Separator,  Up: FORMAT Miscellaneous Pseudo-Operations\n\nTilde Circumflex: Escape Upward\n...............................\n\n~^\n\nThis is an escape construct.  If there are no more arguments remaining to\nbe processed, then the immediately enclosing ~{   or ~< construct is\nterminated.  If there is no such enclosing construct, then the entire\nformatting operation is terminated.  In the ~< case, the formatting is\nperformed, but no more segments are processed before doing the\njustification.  ~^  may appear anywhere in a ~{   construct.\n\n      (setq donestr \"Done.~^ ~D warning~:P.~^ ~D error~:P.\")\n     =>  \"Done.~^ ~D warning~:P.~^ ~D error~:P.\"\n      (format nil donestr) =>  \"Done.\"\n      (format nil donestr 3) =>  \"Done. 3 warnings.\"\n      (format nil donestr 1 5) =>  \"Done. 1 warning. 5 errors.\"\n\nIf a prefix parameter is given, then termination occurs if the parameter\nis zero.  (Hence ~^ is equivalent to ~#^.)  If two parameters are given,\ntermination occurs if they are equal.\n\n[Reviewer Note by Barmar: Which equality predicate?]  If three parameters\nare given, termination occurs if the first is less than or equal to the\nsecond and the second is less than or equal to the third.  Of course, this\nis useless if all the prefix parameters are constants; at least one of\nthem should be a # or a V parameter.\n\nIf ~^ is used within a ~:{   construct, then it terminates the current\niteration step because in the standard case it tests for remaining\narguments of the current step only; the next iteration step commences\nimmediately.  ~:^ is used to terminate the iteration process.\n\n~:^ may be used only if the command it would terminate is ~:{   or ~:@{  .\nThe entire iteration process is terminated if and only if the sublist that\nis supplying the arguments for the current iteration step is the last\nsublist in the case of ~:{ , or the last format argument in the case of\n~:@{  .  ~:^ is not equivalent to ~#:^; the latter terminates the entire\niteration if and only if no arguments remain for the current iteration\nstep.  For example:\n\n      (format nil \"~:{ ~@?~:^ ...~} \" '((\"a\") (\"b\"))) =>  \"a...b\"\n\nIf ~^ appears within a control string being processed under the control of\na ~? directive, but not within any ~{   or ~< construct within that string,\nthen the string being processed will be terminated, thereby ending\nprocessing of the ~? directive.  Processing then continues within the\nstring containing the ~? directive at the point following that directive.\n\nIf ~^ appears within a ~[ or ~( construct, then all the commands up to the\n~^ are properly selected or case-converted, the ~[ or ~( processing is\nterminated, and the outward search continues for a ~{   or ~< construct to\nbe terminated.  For example:\n\n      (setq tellstr \"~@(~@[~R~]~^ ~A!~)\")\n     =>  \"~@(~@[~R~]~^ ~A!~)\"\n      (format nil tellstr 23) =>  \"Twenty-three!\"\n      (format nil tellstr nil \"losers\") =>  \" Losers!\"\n      (format nil tellstr 23 \"losers\") =>  \"Twenty-three losers!\"\n\nFollowing are examples of the use of ~^ within a ~< construct.\n\n      (format nil \"~15<~S~;~^~S~;~^~S~>\" 'foo)\n     =>   \"            FOO\"\n      (format nil \"~15<~S~;~^~S~;~^~S~>\" 'foo 'bar)\n     =>   \"FOO         BAR\"\n      (format nil \"~15<~S~;~^~S~;~^~S~>\" 'foo 'bar 'baz)\n     =>   \"FOO   BAR   BAZ\"\n\n"
}