{
    "name": "define-compiler-macro",
    "prev": "compiler-macro-function",
    "next": "defmacro",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Macro",
        "text": "define-compiler-macro"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "define-compiler-macro",
                    "text": " name lambda-list [[{declaration}* |documentation]] {form}*\n=>  name\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a function name."
                },
                {
                    "name": "lambda-list",
                    "desc": "a macro lambda list."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "documentation",
                    "desc": "a string; not evaluated."
                },
                {
                    "name": "form",
                    "desc": "a form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "[Editorial Note by KMP: This definition probably needs to be fully\nexpanded to not refer through the definition of defmacro, but should\nsuffice for now.]\nThis is the normal mechanism for defining a compiler macro function.  Its\nmanner of definition is the same as for defmacro; the only differences are:\n*\n     The name can be a function name naming any function or macro.\n*\n     The expander function is installed as a compiler macro function for\n     the name, rather than as a macro function.\n*\n     The &whole argument is bound to the form argument that is passed to\n     the compiler macro function.  The remaining lambda-list parameters\n     are specified as if this form contained the function name in the car\n     and the actual arguments in the cdr, but if the car of the actual\n     form is the symbol funcall, then the destructuring of the arguments\n     is actually performed using its cddr instead.\n*\n     Documentation is attached as a documentation string to name (as kind\n     compiler-macro) and to the compiler macro function.\n*\n     Unlike an ordinary macro, a compiler macro can decline to provide an\n     expansion merely by returning a form that is the same as the original\n     (which can be obtained by using &whole).\n"
        },
        {
            "type": "Examples",
            "text": "      (defun square (x) (expt x 2)) =>  SQUARE\n      (define-compiler-macro square (&whole form arg)\n        (if (atom arg)\n            `(expt ,arg 2)\n            (case (car arg)\n              (square (if (= (length arg) 2)\n                          `(expt ,(nth 1 arg) 4)\n                          form))\n              (expt   (if (= (length arg) 3)\n                          (if (numberp (nth 2 arg))\n                              `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))\n                              `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))\n                          form))\n              (otherwise `(expt ,arg 2))))) =>  SQUARE\n      (square (square 3)) =>  81\n      (macroexpand '(square x)) =>  (SQUARE X), false\n      (funcall (compiler-macro-function 'square) '(square x) nil)\n     =>  (EXPT X 2)\n      (funcall (compiler-macro-function 'square) '(square (square x)) nil)\n     =>  (EXPT X 4)\n      (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)\n     =>  (EXPT X 2)\n      (defun distance-positional (x1 y1 x2 y2)\n        (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))\n     =>  DISTANCE-POSITIONAL\n      (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))\n        (distance-positional x1 y1 x2 y2))\n     =>  DISTANCE\n      (define-compiler-macro distance (&whole form\n                                       &rest key-value-pairs\n                                       &key (x1 0  x1-p)\n                                            (y1 0  y1-p)\n                                            (x2 x1 x2-p)\n                                            (y2 y1 y2-p)\n                                       &allow-other-keys\n                                       &environment env)\n        (flet ((key (n) (nth (* n 2) key-value-pairs))\n               (arg (n) (nth (1+ (* n 2)) key-value-pairs))\n               (simplep (x)\n                 (let ((expanded-x (macroexpand x env)))\n                   (or (constantp expanded-x env)\n                       (symbolp expanded-x)))))\n          (let ((n (/ (length key-value-pairs) 2)))\n            (multiple-value-bind (x1s y1s x2s y2s others)\n                (loop for (key) on key-value-pairs by #'cddr\n                      count (eq key ':x1) into x1s\n                      count (eq key ':y1) into y1s\n                      count (eq key ':x2) into x2s\n                      count (eq key ':y1) into y2s\n                      count (not (member key '(:x1 :x2 :y1 :y2)))\n                        into others\n                      finally (return (values x1s y1s x2s y2s others)))\n              (cond ((and (= n 4)\n                          (eq (key 0) :x1)\n                          (eq (key 1) :y1)\n                          (eq (key 2) :x2)\n                          (eq (key 3) :y2))\n                     `(distance-positional ,x1 ,y1 ,x2 ,y2))\n                    ((and (if x1-p (and (= x1s 1) (simplep x1)) t)\n                          (if y1-p (and (= y1s 1) (simplep y1)) t)\n                          (if x2-p (and (= x2s 1) (simplep x2)) t)\n                          (if y2-p (and (= y2s 1) (simplep y2)) t)\n                          (zerop others))\n                     `(distance-positional ,x1 ,y1 ,x2 ,y2))\n                    ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)\n                          (zerop others))\n                     (let ((temps (loop repeat n collect (gensym))))\n                       `(let ,(loop for i below n\n                                    collect (list (nth i temps) (arg i)))\n                          (distance\n                            ,@(loop for i below n\n                                    append (list (key i) (nth i temps)))))))\n                    (t form))))))\n     =>  DISTANCE\n      (dolist (form\n                '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))\n                  (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))\n                  (distance :x1 (setq x 7) :y1 (incf x))\n                  (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))\n                  (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)\n                  (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)\n                  (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))\n        (print (funcall (compiler-macro-function 'distance) form nil)))\n      |>  (LET ((#:G6558 (SETQ X 7))\n      |>        (#:G6559 (DECF X))\n      |>        (#:G6560 (DECF X))\n      |>        (#:G6561 (DECF X)))\n      |>    (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561))\n      |>  (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))\n      |>  (LET ((#:G6567 (SETQ X 7))\n      |>        (#:G6568 (INCF X)))\n      |>    (DISTANCE :X1 #:G6567 :Y1 #:G6568))\n      |>  (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X))\n      |>  (DISTANCE-POSITIONAL A1 B1 A2 B2)\n      |>  (DISTANCE-POSITIONAL A1 B1 A2 B2)\n      |>  (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2)\n     =>  NIL\n"
        },
        {
            "type": "See Also",
            "text": "*Note compiler-macro-function:: , *Note defmacro:: , *Note documentation;\n(setf documentation):: , *Note Syntactic Interaction of Documentation\nStrings and Declarations::\n"
        },
        {
            "type": "Notes",
            "text": "The consequences of writing a compiler macro definition for a function in\nthe COMMON-LISP package are undefined; it is quite possible that in some\nimplementations such an attempt would override an equivalent or equally\nimportant definition.  In general, it is recommended that a programmer only\nwrite compiler macro definitions for functions he or she personally\nmaintains-writing a compiler macro definition for a function maintained\nelsewhere is normally considered a violation of traditional rules of\nmodularity and data abstraction.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: define-compiler-macro,  Next: defmacro,  Prev: compiler-macro-function,  Up: Evaluation and Compilation Dictionary\n\ndefine-compiler-macro                                               [Macro]\n---------------------------------------------------------------------------\n\n`define-compiler-macro'  name lambda-list [[{declaration}* |\ndocumentation]] {form}*\n=>  name\n\nArguments and Values::\n......................\n\nname--a function name.\n\nlambda-list--a macro lambda list.\n\ndeclaration--a declare expression; not evaluated.\n\ndocumentation--a string; not evaluated.\n\nform--a form.\n\nDescription::\n.............\n\n[Editorial Note by KMP: This definition probably needs to be fully\nexpanded to not refer through the definition of defmacro, but should\nsuffice for now.]\n\nThis is the normal mechanism for defining a compiler macro function.  Its\nmanner of definition is the same as for defmacro; the only differences are:\n\n*\n     The name can be a function name naming any function or macro.\n\n*\n     The expander function is installed as a compiler macro function for\n     the name, rather than as a macro function.\n\n*\n     The &whole argument is bound to the form argument that is passed to\n     the compiler macro function.  The remaining lambda-list parameters\n     are specified as if this form contained the function name in the car\n     and the actual arguments in the cdr, but if the car of the actual\n     form is the symbol funcall, then the destructuring of the arguments\n     is actually performed using its cddr instead.\n\n*\n     Documentation is attached as a documentation string to name (as kind\n     compiler-macro) and to the compiler macro function.\n\n*\n     Unlike an ordinary macro, a compiler macro can decline to provide an\n     expansion merely by returning a form that is the same as the original\n     (which can be obtained by using &whole).\n\nExamples::\n..........\n\n      (defun square (x) (expt x 2)) =>  SQUARE\n      (define-compiler-macro square (&whole form arg)\n        (if (atom arg)\n            `(expt ,arg 2)\n            (case (car arg)\n              (square (if (= (length arg) 2)\n                          `(expt ,(nth 1 arg) 4)\n                          form))\n              (expt   (if (= (length arg) 3)\n                          (if (numberp (nth 2 arg))\n                              `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))\n                              `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))\n                          form))\n              (otherwise `(expt ,arg 2))))) =>  SQUARE\n      (square (square 3)) =>  81\n      (macroexpand '(square x)) =>  (SQUARE X), false\n      (funcall (compiler-macro-function 'square) '(square x) nil)\n     =>  (EXPT X 2)\n      (funcall (compiler-macro-function 'square) '(square (square x)) nil)\n     =>  (EXPT X 4)\n      (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)\n     =>  (EXPT X 2)\n     \n      (defun distance-positional (x1 y1 x2 y2)\n        (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))\n     =>  DISTANCE-POSITIONAL\n      (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))\n        (distance-positional x1 y1 x2 y2))\n     =>  DISTANCE\n      (define-compiler-macro distance (&whole form\n                                       &rest key-value-pairs\n                                       &key (x1 0  x1-p)\n                                            (y1 0  y1-p)\n                                            (x2 x1 x2-p)\n                                            (y2 y1 y2-p)\n                                       &allow-other-keys\n                                       &environment env)\n        (flet ((key (n) (nth (* n 2) key-value-pairs))\n               (arg (n) (nth (1+ (* n 2)) key-value-pairs))\n               (simplep (x)\n                 (let ((expanded-x (macroexpand x env)))\n                   (or (constantp expanded-x env)\n                       (symbolp expanded-x)))))\n          (let ((n (/ (length key-value-pairs) 2)))\n            (multiple-value-bind (x1s y1s x2s y2s others)\n                (loop for (key) on key-value-pairs by #'cddr\n                      count (eq key ':x1) into x1s\n                      count (eq key ':y1) into y1s\n                      count (eq key ':x2) into x2s\n                      count (eq key ':y1) into y2s\n                      count (not (member key '(:x1 :x2 :y1 :y2)))\n                        into others\n                      finally (return (values x1s y1s x2s y2s others)))\n              (cond ((and (= n 4)\n                          (eq (key 0) :x1)\n                          (eq (key 1) :y1)\n                          (eq (key 2) :x2)\n                          (eq (key 3) :y2))\n                     `(distance-positional ,x1 ,y1 ,x2 ,y2))\n                    ((and (if x1-p (and (= x1s 1) (simplep x1)) t)\n                          (if y1-p (and (= y1s 1) (simplep y1)) t)\n                          (if x2-p (and (= x2s 1) (simplep x2)) t)\n                          (if y2-p (and (= y2s 1) (simplep y2)) t)\n                          (zerop others))\n                     `(distance-positional ,x1 ,y1 ,x2 ,y2))\n                    ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)\n                          (zerop others))\n                     (let ((temps (loop repeat n collect (gensym))))\n                       `(let ,(loop for i below n\n                                    collect (list (nth i temps) (arg i)))\n                          (distance\n                            ,@(loop for i below n\n                                    append (list (key i) (nth i temps)))))))\n                    (t form))))))\n     =>  DISTANCE\n      (dolist (form\n                '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))\n                  (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))\n                  (distance :x1 (setq x 7) :y1 (incf x))\n                  (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))\n                  (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)\n                  (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)\n                  (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))\n        (print (funcall (compiler-macro-function 'distance) form nil)))\n      |>  (LET ((#:G6558 (SETQ X 7))\n      |>        (#:G6559 (DECF X))\n      |>        (#:G6560 (DECF X))\n      |>        (#:G6561 (DECF X)))\n      |>    (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561))\n      |>  (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))\n      |>  (LET ((#:G6567 (SETQ X 7))\n      |>        (#:G6568 (INCF X)))\n      |>    (DISTANCE :X1 #:G6567 :Y1 #:G6568))\n      |>  (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X))\n      |>  (DISTANCE-POSITIONAL A1 B1 A2 B2)\n      |>  (DISTANCE-POSITIONAL A1 B1 A2 B2)\n      |>  (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2)\n     =>  NIL\n\nSee Also::\n..........\n\n*Note compiler-macro-function:: , *Note defmacro:: , *Note documentation;\n(setf documentation):: , *Note Syntactic Interaction of Documentation\nStrings and Declarations::\n\nNotes::\n.......\n\nThe consequences of writing a compiler macro definition for a function in\nthe COMMON-LISP package are undefined; it is quite possible that in some\nimplementations such an attempt would override an equivalent or equally\nimportant definition.  In general, it is recommended that a programmer only\nwrite compiler macro definitions for functions he or she personally\nmaintains-writing a compiler macro definition for a function maintained\nelsewhere is normally considered a violation of traditional rules of\nmodularity and data abstraction.\n\n"
}