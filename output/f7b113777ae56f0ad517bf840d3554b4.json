{
    "name": "boole",
    "prev": "parse-integer",
    "next": "boole-1",
    "up": "Numbers Dictionary",
    "header": {
        "type": "Function",
        "text": "boole"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "boole",
                    "text": " op integer-1 integer-2 =>  result-integer\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "Op",
                    "desc": "a bit-wise logical operation specifier."
                },
                {
                    "name": "integer-1",
                    "desc": "an integer."
                },
                {
                    "name": "integer-2",
                    "desc": "an integer."
                },
                {
                    "name": "result-integer",
                    "desc": "an integer."
                }
            ]
        },
        {
            "type": "Description",
            "text": "boole performs bit-wise logical operations on integer-1 and integer-2,\nwhich are treated as if they were binary and in two's complement\nrepresentation.\nThe operation to be performed and the return value are determined by op.\nboole returns the values specified for any op in Figure 12-16.\n  Op           Result                                      \n  boole-1      integer-1                                   \n  boole-2      integer-2                                   \n  boole-andc1  and complement of integer-1 with integer-2  \n  boole-andc2  and integer-1 with complement of integer-2  \n  boole-and    and                                         \n  boole-c1     complement of integer-1                     \n  boole-c2     complement of integer-2                     \n  boole-clr    always 0 (all zero bits)                    \n  boole-eqv    equivalence (exclusive nor)                 \n  boole-ior    inclusive or                                \n  boole-nand   not-and                                     \n  boole-nor    not-or                                      \n  boole-orc1   or complement of integer-1 with integer-2   \n  boole-orc2   or integer-1 with complement of integer-2   \n  boole-set    always -1 (all one bits)                    \n  boole-xor    exclusive or                                \n         Figure 12-16: Bit-Wise Logical Operations        \n"
        },
        {
            "type": "Examples",
            "text": "      (boole boole-ior 1 16) =>  17\n      (boole boole-and -2 5) =>  4\n      (boole boole-eqv 17 15) =>  -31\n     ;;; These examples illustrate the result of applying BOOLE and each\n     ;;; of the possible values of OP to each possible combination of bits.\n      (progn\n        (format t \"~&Results of (BOOLE <op> #b0011 #b0101) ...~\n                ~\n        (dolist (symbol '(boole-1     boole-2    boole-and  boole-andc1\n                          boole-andc2 boole-c1   boole-c2   boole-clr\n                          boole-eqv   boole-ior  boole-nand boole-nor\n                          boole-orc1  boole-orc2 boole-set  boole-xor))\n          (let ((result (boole (symbol-value symbol) #b0011 #b0101)))\n            (format t \"~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~\n                    symbol result (logand result #b1111)))))\n      |>  Results of (BOOLE <op> #b0011 #b0101) ...\n      |>  ---Op-------Decimal-----Binary----Bits---\n      |>   BOOLE-1       3          11    ...0011\n      |>   BOOLE-2       5         101    ...0101\n      |>   BOOLE-AND     1           1    ...0001\n      |>   BOOLE-ANDC1   4         100    ...0100\n      |>   BOOLE-ANDC2   2          10    ...0010\n      |>   BOOLE-C1     -4        -100    ...1100\n      |>   BOOLE-C2     -6        -110    ...1010\n      |>   BOOLE-CLR     0           0    ...0000\n      |>   BOOLE-EQV    -7        -111    ...1001\n      |>   BOOLE-IOR     7         111    ...0111\n      |>   BOOLE-NAND   -2         -10    ...1110\n      |>   BOOLE-NOR    -8       -1000    ...1000\n      |>   BOOLE-ORC1   -3         -11    ...1101\n      |>   BOOLE-ORC2   -5        -101    ...1011\n      |>   BOOLE-SET    -1          -1    ...1111\n      |>   BOOLE-XOR     6         110    ...0110\n     =>  NIL\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal type-error if its first argument is not a bit-wise logical\noperation specifier or if any subsequent argument is not an integer.\n"
        },
        {
            "type": "See Also",
            "text": "*Note logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot;\nlogorc1; logorc2; logxor::\n"
        },
        {
            "type": "Notes",
            "text": "In general,\n      (boole boole-and x y) == (logand x y)\nProgrammers who would prefer to use numeric indices rather than bit-wise\nlogical operation specifiers can get an equivalent effect by a technique\nsuch as the following:\n     ;; The order of the values in this `table' are such that\n     ;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n\n      (defconstant boole-n-vector\n         (vector boole-clr   boole-and  boole-andc1 boole-2\n                 boole-andc2 boole-1    boole-xor   boole-ior\n                 boole-nor   boole-eqv  boole-c1    boole-orc1\n                 boole-c2    boole-orc2 boole-nand  boole-set))\n     =>  BOOLE-N-VECTOR\n      (proclaim '(inline boole-n))\n     =>  implementation-dependent\n      (defun boole-n (n integer &rest more-integers)\n        (apply #'boole (elt boole-n-vector n) integer more-integers))\n     =>  BOOLE-N\n      (boole-n #b0111 5 3) =>  7\n      (boole-n #b0001 5 3) =>  1\n      (boole-n #b1101 5 3) =>  -3\n      (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))\n     =>  (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: boole,  Next: boole-1,  Prev: parse-integer,  Up: Numbers Dictionary\n\nboole                                                            [Function]\n---------------------------------------------------------------------------\n\n`boole'  op integer-1 integer-2 =>  result-integer\n\nArguments and Values::\n......................\n\nOp--a bit-wise logical operation specifier.\n\ninteger-1--an integer.\n\ninteger-2--an integer.\n\nresult-integer--an integer.\n\nDescription::\n.............\n\nboole performs bit-wise logical operations on integer-1 and integer-2,\nwhich are treated as if they were binary and in two's complement\nrepresentation.\n\nThe operation to be performed and the return value are determined by op.\n\nboole returns the values specified for any op in Figure 12-16.\n\n  Op           Result                                      \n  boole-1      integer-1                                   \n  boole-2      integer-2                                   \n  boole-andc1  and complement of integer-1 with integer-2  \n  boole-andc2  and integer-1 with complement of integer-2  \n  boole-and    and                                         \n  boole-c1     complement of integer-1                     \n  boole-c2     complement of integer-2                     \n  boole-clr    always 0 (all zero bits)                    \n  boole-eqv    equivalence (exclusive nor)                 \n  boole-ior    inclusive or                                \n  boole-nand   not-and                                     \n  boole-nor    not-or                                      \n  boole-orc1   or complement of integer-1 with integer-2   \n  boole-orc2   or integer-1 with complement of integer-2   \n  boole-set    always -1 (all one bits)                    \n  boole-xor    exclusive or                                \n\n         Figure 12-16: Bit-Wise Logical Operations        \n\n\nExamples::\n..........\n\n      (boole boole-ior 1 16) =>  17\n      (boole boole-and -2 5) =>  4\n      (boole boole-eqv 17 15) =>  -31\n     \n     ;;; These examples illustrate the result of applying BOOLE and each\n     ;;; of the possible values of OP to each possible combination of bits.\n      (progn\n        (format t \"~&Results of (BOOLE <op> #b0011 #b0101) ...~\n                ~\n        (dolist (symbol '(boole-1     boole-2    boole-and  boole-andc1\n                          boole-andc2 boole-c1   boole-c2   boole-clr\n                          boole-eqv   boole-ior  boole-nand boole-nor\n                          boole-orc1  boole-orc2 boole-set  boole-xor))\n          (let ((result (boole (symbol-value symbol) #b0011 #b0101)))\n            (format t \"~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~\n                    symbol result (logand result #b1111)))))\n      |>  Results of (BOOLE <op> #b0011 #b0101) ...\n      |>  ---Op-------Decimal-----Binary----Bits---\n      |>   BOOLE-1       3          11    ...0011\n      |>   BOOLE-2       5         101    ...0101\n      |>   BOOLE-AND     1           1    ...0001\n      |>   BOOLE-ANDC1   4         100    ...0100\n      |>   BOOLE-ANDC2   2          10    ...0010\n      |>   BOOLE-C1     -4        -100    ...1100\n      |>   BOOLE-C2     -6        -110    ...1010\n      |>   BOOLE-CLR     0           0    ...0000\n      |>   BOOLE-EQV    -7        -111    ...1001\n      |>   BOOLE-IOR     7         111    ...0111\n      |>   BOOLE-NAND   -2         -10    ...1110\n      |>   BOOLE-NOR    -8       -1000    ...1000\n      |>   BOOLE-ORC1   -3         -11    ...1101\n      |>   BOOLE-ORC2   -5        -101    ...1011\n      |>   BOOLE-SET    -1          -1    ...1111\n      |>   BOOLE-XOR     6         110    ...0110\n     =>  NIL\n\nExceptional Situations::\n........................\n\nShould signal type-error if its first argument is not a bit-wise logical\noperation specifier or if any subsequent argument is not an integer.\n\nSee Also::\n..........\n\n*Note logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot;\nlogorc1; logorc2; logxor::\n\nNotes::\n.......\n\nIn general,\n\n      (boole boole-and x y) == (logand x y)\n\nProgrammers who would prefer to use numeric indices rather than bit-wise\nlogical operation specifiers can get an equivalent effect by a technique\nsuch as the following:\n\n     ;; The order of the values in this `table' are such that\n     ;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n\n      (defconstant boole-n-vector\n         (vector boole-clr   boole-and  boole-andc1 boole-2\n                 boole-andc2 boole-1    boole-xor   boole-ior\n                 boole-nor   boole-eqv  boole-c1    boole-orc1\n                 boole-c2    boole-orc2 boole-nand  boole-set))\n     =>  BOOLE-N-VECTOR\n      (proclaim '(inline boole-n))\n     =>  implementation-dependent\n      (defun boole-n (n integer &rest more-integers)\n        (apply #'boole (elt boole-n-vector n) integer more-integers))\n     =>  BOOLE-N\n      (boole-n #b0111 5 3) =>  7\n      (boole-n #b0001 5 3) =>  1\n      (boole-n #b1101 5 3) =>  -3\n      (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))\n     =>  (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)\n\n"
}