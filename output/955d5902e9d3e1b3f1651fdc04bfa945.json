{
    "name": "destructuring-bind",
    "prev": "defparameter",
    "next": "let",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "destructuring-bind"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "destructuring-bind",
                    "text": " lambda-list expression {declaration}* {form}*=>  {result}*\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "lambda-list",
                    "desc": "a destructuring lambda list."
                },
                {
                    "name": "expression",
                    "desc": "a form."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "destructuring-bind binds the variables specified in lambda-list to the\ncorresponding values in the tree structure resulting from the evaluation\nof expression; then destructuring-bind evaluates forms.\nThe lambda-list supports destructuring as described in *Note Destructuring\nLambda Lists::.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun iota (n) (loop for i from 1 to n collect i))       ;helper\n      (destructuring-bind ((a &optional (b 'bee)) one two three)\n          `((alpha) ,@(iota 3))\n        (list a b three two one)) =>  (ALPHA BEE 3 2 1)\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If the result of evaluating the expression does not match the\ndestructuring pattern, an error of type error should be signaled.\n"
        },
        {
            "type": "See Also",
            "text": "macrolet, *Note defmacro::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: destructuring-bind,  Next: let,  Prev: defparameter,  Up: Data and Control Flow Dictionary\n\ndestructuring-bind                                                  [Macro]\n---------------------------------------------------------------------------\n\n`destructuring-bind'  lambda-list expression {declaration}* {form}*\n=>  {result}*\n\nArguments and Values::\n......................\n\nlambda-list--a destructuring lambda list.\n\nexpression--a form.\n\ndeclaration--a declare expression; not evaluated.\n\nforms--an implicit progn.\n\nresults--the values returned by the forms.\n\nDescription::\n.............\n\ndestructuring-bind binds the variables specified in lambda-list to the\ncorresponding values in the tree structure resulting from the evaluation\nof expression; then destructuring-bind evaluates forms.\n\nThe lambda-list supports destructuring as described in *Note Destructuring\nLambda Lists::.\n\nExamples::\n..........\n\n      (defun iota (n) (loop for i from 1 to n collect i))       ;helper\n      (destructuring-bind ((a &optional (b 'bee)) one two three)\n          `((alpha) ,@(iota 3))\n        (list a b three two one)) =>  (ALPHA BEE 3 2 1)\n\nExceptional Situations::\n........................\n\nIf the result of evaluating the expression does not match the\ndestructuring pattern, an error of type error should be signaled.\n\nSee Also::\n..........\n\nmacrolet, *Note defmacro::\n\n"
}