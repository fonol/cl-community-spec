{
    "name": "handler-case",
    "prev": "handler-bind",
    "next": "ignore-errors",
    "up": "Conditions Dictionary",
    "header": {
        "type": "Macro",
        "text": "handler-case"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "handler-case",
                    "text": " expression [[{!error-clause}* | !no-error-clause]] =>{result}*\n\nclause ::=!error-clause | !no-error-clause\n\nerror-clause ::=(typespec ([var]) {declaration}* {form}*)\n\nno-error-clause ::=(:no-error lambda-list {declaration}* {form}*)\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "expression",
                    "desc": "a form."
                },
                {
                    "name": "typespec",
                    "desc": "a type specifier."
                },
                {
                    "name": "var",
                    "desc": "a variable name."
                },
                {
                    "name": "lambda-list",
                    "desc": "an ordinary lambda list."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "form",
                    "desc": "a form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "handler-case executes expression in a dynamic environment where various\nhandlers are active.  Each error-clause specifies how to handle a\ncondition matching the indicated typespec.  A no-error-clause allows the\nspecification of a particular action if control returns normally.\nIf a condition is signaled for which there is an appropriate error-clause\nduring the execution of expression (i.e., one for which (typep condition\n'typespec) returns true) and if there is no intervening handler for a\ncondition of that type, then control is transferred to the body of the\nrelevant error-clause.  In this case, the dynamic state is unwound\nappropriately (so that the handlers established around the expression are\nno longer active), and var is bound to the condition that had been\nsignaled.  If more than one case is provided, those cases are made\naccessible in parallel.  That is, in\n       (handler-case form\n         (typespec1 (var1) form1)\n         (typespec2 (var2) form2))\nif the first clause (containing form1) has been selected, the handler for\nthe second is no longer visible (or vice versa).\nThe clauses are searched sequentially from top to bottom. If there is type\noverlap between typespecs, the earlier of the clauses is selected.\nIf var is not needed, it can be omitted. That is, a clause such as:\n       (typespec (var) (declare (ignore var)) form)\ncan be written (typespec () form).\nIf there are no forms in a selected clause, the case, and therefore\nhandler-case, returns nil.  If execution of expression returns normally\nand no no-error-clause exists, the values returned by expression are\nreturned by handler-case.  If execution of expression returns normally and\na no-error-clause does exist, the values returned are used as arguments to\nthe function described by constructing (lambda lambda-list {form}*) from\nthe no-error-clause, and the values of that function call are returned by\nhandler-case.  The handlers which were established around the expression\nare no longer active at the time of this call.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun assess-condition (condition)\n        (handler-case (signal condition)\n          (warning () \"Lots of smoke, but no fire.\")\n          ((or arithmetic-error control-error cell-error stream-error)\n             (condition)\n            (format nil \"~S looks especially bad.\" condition))\n          (serious-condition (condition)\n            (format nil \"~S looks serious.\" condition))\n          (condition () \"Hardly worth mentioning.\")))\n     =>  ASSESS-CONDITION\n      (assess-condition (make-condition 'stream-error :stream *terminal-io*))\n     =>  \"#<STREAM-ERROR 12352256> looks especially bad.\"\n      (define-condition random-condition (condition) ()\n        (:report (lambda (condition stream)\n                   (declare (ignore condition))\n                   (princ \"Yow\" stream))))\n     =>  RANDOM-CONDITION\n      (assess-condition (make-condition 'random-condition))\n     =>  \"Hardly worth mentioning.\"\n"
        },
        {
            "type": "See Also",
            "text": "*Note handler-bind:: , *Note ignore-errors:: , *Note Condition System\nConcepts::\n"
        },
        {
            "type": "Notes",
            "text": "      (handler-case form\n        (type1 (var1) . body1)\n        (type2 (var2) . body2) ...)\nis approximately equivalent to:\n      (block #1=#:g0001\n        (let ((#2=#:g0002 nil))\n          (tagbody\n            (handler-bind ((type1 #'(lambda (temp)\n                                            (setq #1# temp)\n                                            (go #3=#:g0003)))\n                           (type2 #'(lambda (temp)\n                                            (setq #2# temp)\n                                            (go #4=#:g0004))) ...)\n            (return-from #1# form))\n              #3# (return-from #1# (let ((var1 #2#)) . body1))\n              #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))\n      (handler-case form\n        (type1 (var1) . body1)\n        ...\n        (:no-error (varN-1 varN-2 ...) . bodyN))\nis approximately equivalent to:\n      (block #1=#:error-return\n       (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)\n          (block #2=#:normal-return\n            (return-from #1#\n              (handler-case (return-from #2# form)\n                (type1 (var1) . body1) ...)))))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: handler-case,  Next: ignore-errors,  Prev: handler-bind,  Up: Conditions Dictionary\n\nhandler-case                                                        [Macro]\n---------------------------------------------------------------------------\n\n`handler-case'  expression [[{!error-clause}* | !no-error-clause]] =>\n{result}*\n\nclause ::=!error-clause | !no-error-clause\n\nerror-clause ::=(typespec ([var]) {declaration}* {form}*)\n\nno-error-clause ::=(:no-error lambda-list {declaration}* {form}*)\n\nArguments and Values::\n......................\n\nexpression--a form.\n\ntypespec--a type specifier.\n\nvar--a variable name.\n\nlambda-list--an ordinary lambda list.\n\ndeclaration--a declare expression; not evaluated.\n\nform--a form.\n\nresults--In the normal situation, the values returned are those that\nresult from the evaluation of expression; in the exceptional situation\nwhen control is transferred to a clause, the value of the last form in\nthat clause is returned.\n\nDescription::\n.............\n\nhandler-case executes expression in a dynamic environment where various\nhandlers are active.  Each error-clause specifies how to handle a\ncondition matching the indicated typespec.  A no-error-clause allows the\nspecification of a particular action if control returns normally.\n\nIf a condition is signaled for which there is an appropriate error-clause\nduring the execution of expression (i.e., one for which (typep condition\n'typespec) returns true) and if there is no intervening handler for a\ncondition of that type, then control is transferred to the body of the\nrelevant error-clause.  In this case, the dynamic state is unwound\nappropriately (so that the handlers established around the expression are\nno longer active), and var is bound to the condition that had been\nsignaled.  If more than one case is provided, those cases are made\naccessible in parallel.  That is, in\n\n       (handler-case form\n         (typespec1 (var1) form1)\n         (typespec2 (var2) form2))\n\nif the first clause (containing form1) has been selected, the handler for\nthe second is no longer visible (or vice versa).\n\nThe clauses are searched sequentially from top to bottom. If there is type\noverlap between typespecs, the earlier of the clauses is selected.\n\nIf var is not needed, it can be omitted. That is, a clause such as:\n\n       (typespec (var) (declare (ignore var)) form)\n\ncan be written (typespec () form).\n\nIf there are no forms in a selected clause, the case, and therefore\nhandler-case, returns nil.  If execution of expression returns normally\nand no no-error-clause exists, the values returned by expression are\nreturned by handler-case.  If execution of expression returns normally and\na no-error-clause does exist, the values returned are used as arguments to\nthe function described by constructing (lambda lambda-list {form}*) from\nthe no-error-clause, and the values of that function call are returned by\nhandler-case.  The handlers which were established around the expression\nare no longer active at the time of this call.\n\nExamples::\n..........\n\n      (defun assess-condition (condition)\n        (handler-case (signal condition)\n          (warning () \"Lots of smoke, but no fire.\")\n          ((or arithmetic-error control-error cell-error stream-error)\n             (condition)\n            (format nil \"~S looks especially bad.\" condition))\n          (serious-condition (condition)\n            (format nil \"~S looks serious.\" condition))\n          (condition () \"Hardly worth mentioning.\")))\n     =>  ASSESS-CONDITION\n      (assess-condition (make-condition 'stream-error :stream *terminal-io*))\n     =>  \"#<STREAM-ERROR 12352256> looks especially bad.\"\n      (define-condition random-condition (condition) ()\n        (:report (lambda (condition stream)\n                   (declare (ignore condition))\n                   (princ \"Yow\" stream))))\n     =>  RANDOM-CONDITION\n      (assess-condition (make-condition 'random-condition))\n     =>  \"Hardly worth mentioning.\"\n\nSee Also::\n..........\n\n*Note handler-bind:: , *Note ignore-errors:: , *Note Condition System\nConcepts::\n\nNotes::\n.......\n\n      (handler-case form\n        (type1 (var1) . body1)\n        (type2 (var2) . body2) ...)\n\nis approximately equivalent to:\n\n      (block #1=#:g0001\n        (let ((#2=#:g0002 nil))\n          (tagbody\n            (handler-bind ((type1 #'(lambda (temp)\n                                            (setq #1# temp)\n                                            (go #3=#:g0003)))\n                           (type2 #'(lambda (temp)\n                                            (setq #2# temp)\n                                            (go #4=#:g0004))) ...)\n            (return-from #1# form))\n              #3# (return-from #1# (let ((var1 #2#)) . body1))\n              #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))\n\n      (handler-case form\n        (type1 (var1) . body1)\n        ...\n        (:no-error (varN-1 varN-2 ...) . bodyN))\n\nis approximately equivalent to:\n\n\n      (block #1=#:error-return\n       (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)\n          (block #2=#:normal-return\n            (return-from #1#\n              (handler-case (return-from #2# form)\n                (type1 (var1) . body1) ...)))))\n\n"
}