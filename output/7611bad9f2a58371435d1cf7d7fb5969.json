{
    "name": "Examples of Class Precedence List Determination",
    "prev": "Topological Sorting",
    "next": null,
    "up": "Determining the Class Precedence List",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Examples of Class Precedence List Determination",
            "text": "This example determines a class precedence list for the class pie.  The\nfollowing classes are defined:\n      (defclass pie (apple cinnamon) ())\n      (defclass apple (fruit) ())\n      (defclass cinnamon (spice) ())\n      (defclass fruit (food) ())\n      (defclass spice (food) ())\n      (defclass food () ())\nThe set S_{pie}~= {pie, apple, cinnamon, fruit, spice, food,\nstandard-object, t}. The set R~= {(pie, apple), (apple, cinnamon), (apple,\nfruit), (cinnamon, spice), \\break (fruit, food), (spice, food), (food,\nstandard-object), (standard-object, t)}.\nThe class pie is not preceded by anything, so it comes first; the result\nso far is (pie).  Remove pie from S and pairs mentioning pie from R to get\nS~= {apple, cinnamon, fruit, spice, food, standard-object, t} and\nR~=~{(apple, cinnamon), (apple, fruit), (cinnamon, spice),\\break (fruit,\nfood), (spice, food), (food, standard-object), (standard-object, t)}.\nThe class apple is not preceded by anything, so it is next; the result is\n(pie apple). Removing apple and the relevant pairs results in S~=\n{cinnamon, fruit, spice, food, standard-object, t} and R~= {(cinnamon,\nspice), (fruit, food), (spice, food), (food, standard-object),\\break\n(standard-object, t)}.\nThe classes cinnamon and fruit are not preceded by anything, so the one\nwith a direct subclass rightmost in the class precedence list computed so\nfar goes next.  The class apple is a direct subclass of fruit, and the\nclass pie is a direct subclass of cinnamon.  Because apple appears to the\nright of pie in the class precedence list, fruit goes next, and the result\nso far is (pie apple fruit).  S~= {cinnamon, spice, food, standard-object,\nt}; R~= {(cinnamon, spice), (spice, food),\\break (food, standard-object),\n(standard-object, t)}.\nThe class cinnamon is next, giving the result so far as (pie apple fruit\ncinnamon).  At this point S~= {spice, food, standard-object, t}; R~=\n{(spice, food), (food, standard-object), (standard-object, t)}.\nThe classes spice, food, standard-object, and t are added in that order,\nand the class precedence list is (pie apple fruit cinnamon spice food\nstandard-object t).\nIt is possible to write a set of class definitions that cannot be ordered.\n For example:\n      (defclass new-class (fruit apple) ())\n      (defclass apple (fruit) ())\nThe class fruit must precede apple because the local ordering of\nsuperclasses must be preserved.  The class apple must precede fruit\nbecause a class always precedes its own superclasses.  When this situation\noccurs, an error is signaled, as happens here when the system tries to\ncompute the class precedence list of new-class.\nThe following might appear to be a conflicting set of definitions:\n      (defclass pie (apple cinnamon) ())\n      (defclass pastry (cinnamon apple) ())\n      (defclass apple () ())\n      (defclass cinnamon () ())\nThe class precedence list for pie is (pie apple cinnamon standard-object\nt).\nThe class precedence list for pastry is (pastry cinnamon apple\nstandard-object t).\nIt is not a problem for apple to precede cinnamon in the ordering of the\nsuperclasses of pie but not in the ordering for pastry.  However, it is\nnot possible to build a new class that has both pie and pastry as\nsuperclasses.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Examples of Class Precedence List Determination,  Prev: Topological Sorting,  Up: Determining the Class Precedence List\n\nExamples of Class Precedence List Determination\n...............................................\n\nThis example determines a class precedence list for the class pie.  The\nfollowing classes are defined:\n\n      (defclass pie (apple cinnamon) ())\n     \n      (defclass apple (fruit) ())\n     \n      (defclass cinnamon (spice) ())\n     \n      (defclass fruit (food) ())\n     \n      (defclass spice (food) ())\n     \n      (defclass food () ())\n\nThe set S_{pie}~= {pie, apple, cinnamon, fruit, spice, food,\nstandard-object, t}. The set R~= {(pie, apple), (apple, cinnamon), (apple,\nfruit), (cinnamon, spice), \\break (fruit, food), (spice, food), (food,\nstandard-object), (standard-object, t)}.\n\nThe class pie is not preceded by anything, so it comes first; the result\nso far is (pie).  Remove pie from S and pairs mentioning pie from R to get\nS~= {apple, cinnamon, fruit, spice, food, standard-object, t} and\nR~=~{(apple, cinnamon), (apple, fruit), (cinnamon, spice),\\break (fruit,\nfood), (spice, food), (food, standard-object), (standard-object, t)}.\n\nThe class apple is not preceded by anything, so it is next; the result is\n(pie apple). Removing apple and the relevant pairs results in S~=\n{cinnamon, fruit, spice, food, standard-object, t} and R~= {(cinnamon,\nspice), (fruit, food), (spice, food), (food, standard-object),\\break\n(standard-object, t)}.\n\nThe classes cinnamon and fruit are not preceded by anything, so the one\nwith a direct subclass rightmost in the class precedence list computed so\nfar goes next.  The class apple is a direct subclass of fruit, and the\nclass pie is a direct subclass of cinnamon.  Because apple appears to the\nright of pie in the class precedence list, fruit goes next, and the result\nso far is (pie apple fruit).  S~= {cinnamon, spice, food, standard-object,\nt}; R~= {(cinnamon, spice), (spice, food),\\break (food, standard-object),\n(standard-object, t)}.\n\nThe class cinnamon is next, giving the result so far as (pie apple fruit\ncinnamon).  At this point S~= {spice, food, standard-object, t}; R~=\n{(spice, food), (food, standard-object), (standard-object, t)}.\n\nThe classes spice, food, standard-object, and t are added in that order,\nand the class precedence list is (pie apple fruit cinnamon spice food\nstandard-object t).\n\nIt is possible to write a set of class definitions that cannot be ordered.\n For example:\n\n      (defclass new-class (fruit apple) ())\n     \n      (defclass apple (fruit) ())\n\nThe class fruit must precede apple because the local ordering of\nsuperclasses must be preserved.  The class apple must precede fruit\nbecause a class always precedes its own superclasses.  When this situation\noccurs, an error is signaled, as happens here when the system tries to\ncompute the class precedence list of new-class.\n\nThe following might appear to be a conflicting set of definitions:\n\n      (defclass pie (apple cinnamon) ())\n     \n      (defclass pastry (cinnamon apple) ())\n     \n      (defclass apple () ())\n     \n      (defclass cinnamon () ())\n\nThe class precedence list for pie is (pie apple cinnamon standard-object\nt).\n\nThe class precedence list for pastry is (pastry cinnamon apple\nstandard-object t).\n\nIt is not a problem for apple to precede cinnamon in the ordering of the\nsuperclasses of pie but not in the ordering for pastry.  However, it is\nnot possible to build a new class that has both pie and pastry as\nsuperclasses.\n\n"
}