{
    "name": "Language Extensions",
    "prev": "Conformance",
    "next": "Language Subsets",
    "up": "Introduction (Introduction)",
    "header": {
        "type": null,
        "text": "Language Extensions"
    },
    "sections": [
        {
            "type": "",
            "text": "A language extension is any documented implementation-defined behavior of\na defined name in this standard that varies from the behavior described in\nthis standard, or a documented consequence of a situation that the\nstandard specifies as undefined, unspecified, or extendable by the\nimplementation.  For example, if this standard says that \"the results are\nunspecified,\" an extension would be to specify the results.\n[Reviewer Note by Barmar: This contradicts previous definitions of\nconforming code.] If the correct behavior of a program depends on the\nresults provided by an extension, only implementations with the same\nextension will execute the program correctly.  Note that such a program\nmight be non-conforming.  Also, if this standard says that \"an\nimplementation may be extended,\" a conforming, but possibly non-portable,\nprogram can be written using an extension.\nAn implementation can have extensions, provided they do not alter the\nbehavior of conforming code and provided they are not explicitly\nprohibited by this standard.\nThe term \"extension\" refers only to extensions available upon startup.  An\nimplementation is free to allow or prohibit redefinition of an extension.\nThe following list contains specific guidance to implementations\nconcerning certain types of extensions.\nExtra return values\n     An implementation must return exactly the number of return values\n     specified by this standard unless the standard specifically indicates\n     otherwise.\nUnsolicited messages\n     No output can be produced by a function other than that specified in\n     the standard or due to the signaling of conditions detected by the\n     function.\n     Unsolicited output, such as garbage collection notifications and\n     autoload heralds, should not go directly to the stream that is the\n     value of a stream variable defined in this standard, but can go\n     indirectly to terminal I/O by using a synonym stream to *terminal-io*.\n     Progress reports from such functions as load and compile are\n     considered solicited, and are not covered by this prohibition.\nImplementation of macros and special forms\n     Macros and special operators defined in this standard must not be\n     functions.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Language Extensions,  Next: Language Subsets,  Prev: Conformance,  Up: Introduction (Introduction)\n\nLanguage Extensions\n===================\n\nA language extension is any documented implementation-defined behavior of\na defined name in this standard that varies from the behavior described in\nthis standard, or a documented consequence of a situation that the\nstandard specifies as undefined, unspecified, or extendable by the\nimplementation.  For example, if this standard says that \"the results are\nunspecified,\" an extension would be to specify the results.\n\n[Reviewer Note by Barmar: This contradicts previous definitions of\nconforming code.] If the correct behavior of a program depends on the\nresults provided by an extension, only implementations with the same\nextension will execute the program correctly.  Note that such a program\nmight be non-conforming.  Also, if this standard says that \"an\nimplementation may be extended,\" a conforming, but possibly non-portable,\nprogram can be written using an extension.\n\nAn implementation can have extensions, provided they do not alter the\nbehavior of conforming code and provided they are not explicitly\nprohibited by this standard.\n\nThe term \"extension\" refers only to extensions available upon startup.  An\nimplementation is free to allow or prohibit redefinition of an extension.\n\nThe following list contains specific guidance to implementations\nconcerning certain types of extensions.\nExtra return values\n     An implementation must return exactly the number of return values\n     specified by this standard unless the standard specifically indicates\n     otherwise.\n\nUnsolicited messages\n     No output can be produced by a function other than that specified in\n     the standard or due to the signaling of conditions detected by the\n     function.\n\n     Unsolicited output, such as garbage collection notifications and\n     autoload heralds, should not go directly to the stream that is the\n     value of a stream variable defined in this standard, but can go\n     indirectly to terminal I/O by using a synonym stream to *terminal-io*.\n\n     Progress reports from such functions as load and compile are\n     considered solicited, and are not covered by this prohibition.\n\nImplementation of macros and special forms\n     Macros and special operators defined in this standard must not be\n     functions.\n\n"
}