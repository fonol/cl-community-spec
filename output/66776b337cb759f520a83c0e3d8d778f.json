{
    "name": "logical-pathname-translations",
    "prev": "load-logical-pathname-translations",
    "next": "logical-pathname",
    "up": "Filenames Dictionary",
    "header": {
        "type": "Accessor",
        "text": "logical-pathname-translations"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "logical-pathname-translations",
                    "text": " host =>  translations\n(setf (`         logical-pathname-translations' host) new-translations)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "translations, new-translations",
                    "desc": "a list."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Returns the host's list of translations.  Each translation is a list of at\nleast two elements: from-wildcard and to-wildcard.  Any additional\nelements are implementation-defined.  From-wildcard is a logical pathname\nwhose host is host.  To-wildcard is a pathname.\n[Reviewer Note by Laddaga: Can this be a logical pathname?]\n(setf (logical-pathname-translations host) translations) sets a logical\npathname host's list of translations.  If host is a string that has not\nbeen previously used as a logical pathname host, a new logical pathname\nhost is defined; otherwise an existing host's translations are replaced.\nlogical pathname host names are compared with string-equal.\nWhen setting the translations list, each from-wildcard can be a logical\npathname whose host is host or a logical pathname namestring parseable by\n(parse-namestring string host), where host represents the appropriate\nobject as defined by parse-namestring. Each to-wildcard can be anything\ncoercible to a pathname by (pathname to-wildcard).  If to-wildcard coerces\nto a logical pathname, translate-logical-pathname will perform repeated\ntranslation steps when it uses it.\nhost is either the host component of a logical pathname or a string that\nhas been defined as a logical pathname host name by setf of\nlogical-pathname-translations.\n"
        },
        {
            "type": "Examples",
            "text": "[Reviewer Note by Laddaga: Shouldn't there be some *.*'s in the list of\ntranslations for PROG below?]\n      ;;;A very simple example of setting up a logical pathname host.  No\n      ;;;translations are necessary to get around file system restrictions, so\n      ;;;all that is necessary is to specify the root of the physical directory\n      ;;;tree that contains the logical file system.\n      ;;;The namestring syntax on the right-hand side is implementation-dependent.\n      (setf (logical-pathname-translations \"foo\")\n            '((\"**;*.*.*\"              \"MY-LISPM:>library>foo>**>\")))\n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"foo:bar;baz;mum.quux.3\")\n     =>  #P\"MY-LISPM:>library>foo>bar>baz>mum.quux.3\"\n      ;;;A more complex example, dividing the files among two file servers\n      ;;;and several different directories.  This Unix doesn't support\n      ;;;:WILD-INFERIORS in the directory, so each directory level must\n      ;;;be translated individually.  No file name or type translations\n      ;;;are required except for .MAIL to .MBX.\n      ;;;The namestring syntax on the right-hand side is implementation-dependent.\n      (setf (logical-pathname-translations \"prog\")\n            '((\"RELEASED;*.*.*\"        \"MY-UNIX:/sys/bin/my-prog/\")\n              (\"RELEASED;*;*.*.*\"      \"MY-UNIX:/sys/bin/my-prog/*/\")\n              (\"EXPERIMENTAL;*.*.*\"    \"MY-UNIX:/usr/Joe/development/prog/\")\n              (\"EXPERIMENTAL;DOCUMENTATION;*.*.*\"\n                                       \"MY-VAX:SYS$DISK:[JOE.DOC]\")\n              (\"EXPERIMENTAL;*;*.*.*\"  \"MY-UNIX:/usr/Joe/development/prog/*/\")\n              (\"MAIL;**;*.MAIL\"        \"MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX\")))\n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:mail;save;ideas.mail.3\")\n     =>  #P\"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3\"\n      ;;;Example translations for a program that uses three files main.lisp,\n      ;;;auxiliary.lisp, and documentation.lisp.  These translations might be\n      ;;;supplied by a software supplier as examples.\n      ;;;For Unix with long file names\n      (setf (logical-pathname-translations \"prog\")\n            '((\"CODE;*.*.*\"             \"/lib/prog/\")))\n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"/lib/prog/documentation.lisp\"\n      ;;;For Unix with 14-character file names, using .lisp as the type\n      (setf (logical-pathname-translations \"prog\")\n            '((\"CODE;DOCUMENTATION.*.*\" \"/lib/prog/docum.*\")\n              (\"CODE;*.*.*\"             \"/lib/prog/\")))\n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"/lib/prog/docum.lisp\"\n      ;;;For Unix with 14-character file names, using .l as the type\n      ;;;The second translation shortens the compiled file type to .b\n      (setf (logical-pathname-translations \"prog\")\n            `((\"**;*.LISP.*\"            ,(logical-pathname \"PROG:**;*.L.*\"))\n              (,(compile-file-pathname (logical-pathname \"PROG:**;*.LISP.*\"))\n                                        ,(logical-pathname \"PROG:**;*.B.*\"))\n              (\"CODE;DOCUMENTATION.*.*\" \"/lib/prog/documentatio.*\")\n              (\"CODE;*.*.*\"             \"/lib/prog/\")))\n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"/lib/prog/documentatio.l\"\n      ;;;For a Cray with 6 character names and no directories, types, or versions.\n      (setf (logical-pathname-translations \"prog\")\n            (let ((l '((\"MAIN\" \"PGMN\")\n                       (\"AUXILIARY\" \"PGAUX\")\n                       (\"DOCUMENTATION\" \"PGDOC\")))\n                  (logpath (logical-pathname \"prog:code;\"))\n                  (phypath (pathname \"XXX\")))\n              (append\n                ;; Translations for source files\n                (mapcar #'(lambda (x)\n                            (let ((log (first x))\n                                  (phy (second x)))\n                              (list (make-pathname :name log\n                                                   :type \"LISP\"\n                                                   :version :wild\n                                                   :defaults logpath)\n                                    (make-pathname :name phy\n                                                   :defaults phypath))))\n                        l)\n                ;; Translations for compiled files\n                (mapcar #'(lambda (x)\n                            (let* ((log (first x))\n                                   (phy (second x))\n                                   (com (compile-file-pathname\n                                          (make-pathname :name log\n                                                         :type \"LISP\"\n                                                         :version :wild\n                                                         :defaults logpath))))\n                              (setq phy (concatenate 'string phy \"B\"))\n                              (list com\n                                    (make-pathname :name phy\n                                                   :defaults phypath))))\n                        l))))\n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"PGDOC\"\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If host is incorrectly supplied, an error of type type-error is signaled.\n"
        },
        {
            "type": "See Also",
            "text": "logical-pathname,\n*Note Pathnames as Filenames::\n"
        },
        {
            "type": "Notes",
            "text": "Implementations can define additional functions that operate on logical\npathname hosts, for example to specify additional translation rules or\noptions.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: logical-pathname-translations,  Next: logical-pathname,  Prev: load-logical-pathname-translations,  Up: Filenames Dictionary\n\nlogical-pathname-translations                                    [Accessor]\n---------------------------------------------------------------------------\n\n`logical-pathname-translations'  host =>  translations\n\n(setf (`         logical-pathname-translations' host) new-translations)\nArguments and Values::\n......................\n\nhost-a logical host designator.\n\ntranslations, new-translations--a list.\n\nDescription::\n.............\n\nReturns the host's list of translations.  Each translation is a list of at\nleast two elements: from-wildcard and to-wildcard.  Any additional\nelements are implementation-defined.  From-wildcard is a logical pathname\nwhose host is host.  To-wildcard is a pathname.\n\n[Reviewer Note by Laddaga: Can this be a logical pathname?]\n\n(setf (logical-pathname-translations host) translations) sets a logical\npathname host's list of translations.  If host is a string that has not\nbeen previously used as a logical pathname host, a new logical pathname\nhost is defined; otherwise an existing host's translations are replaced.\nlogical pathname host names are compared with string-equal.\n\nWhen setting the translations list, each from-wildcard can be a logical\npathname whose host is host or a logical pathname namestring parseable by\n(parse-namestring string host), where host represents the appropriate\nobject as defined by parse-namestring. Each to-wildcard can be anything\ncoercible to a pathname by (pathname to-wildcard).  If to-wildcard coerces\nto a logical pathname, translate-logical-pathname will perform repeated\ntranslation steps when it uses it.\n\nhost is either the host component of a logical pathname or a string that\nhas been defined as a logical pathname host name by setf of\nlogical-pathname-translations.\n\nExamples::\n..........\n\n[Reviewer Note by Laddaga: Shouldn't there be some *.*'s in the list of\ntranslations for PROG below?]\n\n      ;;;A very simple example of setting up a logical pathname host.  No\n      ;;;translations are necessary to get around file system restrictions, so\n      ;;;all that is necessary is to specify the root of the physical directory\n      ;;;tree that contains the logical file system.\n      ;;;The namestring syntax on the right-hand side is implementation-dependent.\n      (setf (logical-pathname-translations \"foo\")\n            '((\"**;*.*.*\"              \"MY-LISPM:>library>foo>**>\")))\n     \n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"foo:bar;baz;mum.quux.3\")\n     =>  #P\"MY-LISPM:>library>foo>bar>baz>mum.quux.3\"\n     \n      ;;;A more complex example, dividing the files among two file servers\n      ;;;and several different directories.  This Unix doesn't support\n      ;;;:WILD-INFERIORS in the directory, so each directory level must\n      ;;;be translated individually.  No file name or type translations\n      ;;;are required except for .MAIL to .MBX.\n      ;;;The namestring syntax on the right-hand side is implementation-dependent.\n      (setf (logical-pathname-translations \"prog\")\n            '((\"RELEASED;*.*.*\"        \"MY-UNIX:/sys/bin/my-prog/\")\n              (\"RELEASED;*;*.*.*\"      \"MY-UNIX:/sys/bin/my-prog/*/\")\n              (\"EXPERIMENTAL;*.*.*\"    \"MY-UNIX:/usr/Joe/development/prog/\")\n              (\"EXPERIMENTAL;DOCUMENTATION;*.*.*\"\n                                       \"MY-VAX:SYS$DISK:[JOE.DOC]\")\n              (\"EXPERIMENTAL;*;*.*.*\"  \"MY-UNIX:/usr/Joe/development/prog/*/\")\n              (\"MAIL;**;*.MAIL\"        \"MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX\")))\n     \n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:mail;save;ideas.mail.3\")\n     =>  #P\"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3\"\n     \n      ;;;Example translations for a program that uses three files main.lisp,\n      ;;;auxiliary.lisp, and documentation.lisp.  These translations might be\n      ;;;supplied by a software supplier as examples.\n     \n      ;;;For Unix with long file names\n      (setf (logical-pathname-translations \"prog\")\n            '((\"CODE;*.*.*\"             \"/lib/prog/\")))\n     \n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"/lib/prog/documentation.lisp\"\n     \n      ;;;For Unix with 14-character file names, using .lisp as the type\n      (setf (logical-pathname-translations \"prog\")\n            '((\"CODE;DOCUMENTATION.*.*\" \"/lib/prog/docum.*\")\n              (\"CODE;*.*.*\"             \"/lib/prog/\")))\n     \n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"/lib/prog/docum.lisp\"\n     \n      ;;;For Unix with 14-character file names, using .l as the type\n      ;;;The second translation shortens the compiled file type to .b\n      (setf (logical-pathname-translations \"prog\")\n            `((\"**;*.LISP.*\"            ,(logical-pathname \"PROG:**;*.L.*\"))\n              (,(compile-file-pathname (logical-pathname \"PROG:**;*.LISP.*\"))\n                                        ,(logical-pathname \"PROG:**;*.B.*\"))\n              (\"CODE;DOCUMENTATION.*.*\" \"/lib/prog/documentatio.*\")\n              (\"CODE;*.*.*\"             \"/lib/prog/\")))\n     \n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"/lib/prog/documentatio.l\"\n     \n      ;;;For a Cray with 6 character names and no directories, types, or versions.\n      (setf (logical-pathname-translations \"prog\")\n            (let ((l '((\"MAIN\" \"PGMN\")\n                       (\"AUXILIARY\" \"PGAUX\")\n                       (\"DOCUMENTATION\" \"PGDOC\")))\n                  (logpath (logical-pathname \"prog:code;\"))\n                  (phypath (pathname \"XXX\")))\n              (append\n                ;; Translations for source files\n                (mapcar #'(lambda (x)\n                            (let ((log (first x))\n                                  (phy (second x)))\n                              (list (make-pathname :name log\n                                                   :type \"LISP\"\n                                                   :version :wild\n                                                   :defaults logpath)\n                                    (make-pathname :name phy\n                                                   :defaults phypath))))\n                        l)\n                ;; Translations for compiled files\n                (mapcar #'(lambda (x)\n                            (let* ((log (first x))\n                                   (phy (second x))\n                                   (com (compile-file-pathname\n                                          (make-pathname :name log\n                                                         :type \"LISP\"\n                                                         :version :wild\n                                                         :defaults logpath))))\n                              (setq phy (concatenate 'string phy \"B\"))\n                              (list com\n                                    (make-pathname :name phy\n                                                   :defaults phypath))))\n                        l))))\n     \n      ;;;Sample use of that logical pathname.  The return value\n      ;;;is implementation-dependent.\n      (translate-logical-pathname \"prog:code;documentation.lisp\")\n     =>  #P\"PGDOC\"\n\nExceptional Situations::\n........................\n\nIf host is incorrectly supplied, an error of type type-error is signaled.\n\nSee Also::\n..........\n\nlogical-pathname,\n\n*Note Pathnames as Filenames::\n\nNotes::\n.......\n\nImplementations can define additional functions that operate on logical\npathname hosts, for example to specify additional translation rules or\noptions.\n\n"
}