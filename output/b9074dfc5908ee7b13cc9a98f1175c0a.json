{
    "name": "with-package-iterator",
    "prev": "make-package",
    "next": "unexport",
    "up": "Packages Dictionary",
    "header": {
        "type": "Macro",
        "text": "with-package-iterator"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "with-package-iterator",
                    "text": " (name package-list-form &rest symbol-types){declaration}* {form}*\n=>  {result}*\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a symbol."
                },
                {
                    "name": "package-list-form",
                    "desc": "a form; evaluated once to produce a package-list."
                },
                {
                    "name": "package-list",
                    "desc": "a designator for a list of package designators."
                },
                {
                    "name": "symbol-type",
                    "desc": "one of the symbols :internal, :external, or :inherited."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values of the forms."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Within the lexical scope of the body forms, the name is defined via\nmacrolet such that successive invocations of (name) will return the\nsymbols, one by one, from the packages in package-list.\nIt is unspecified whether symbols inherited from multiple packages are\nreturned more than once.  The order of symbols returned does not\nnecessarily reflect the order of packages in package-list.  When\npackage-list has more than one element, it is unspecified whether\nduplicate symbols are returned once or more than once.\nSymbol-types controls which symbols that are accessible in a package are\nreturned as follows:\n:internal\n     The symbols that are present in the package, but that are not\n     exported.\n:external\n     The symbols that are present in the package and are exported.\n:inherited\n     The symbols that are exported by used packages and that are not\n     shadowed.\nWhen more than one argument is supplied for symbol-types, a symbol is\nreturned if its accessibility matches any one of the symbol-types supplied.\nImplementations may extend this syntax by recognizing additional symbol\naccessibility types.\nAn invocation of (name) returns four values as follows:\n1.\n     A flag that indicates whether a symbol is returned (true means that a\n     symbol is returned).\n2.\n     A symbol that is accessible in one the indicated packages.\n3.\n     The accessibility type for that symbol; i.e., one of the symbols\n     :internal, :external, or :inherited.\n4.\n     The package from which the symbol was obtained.  The package is one\n     of the packages present or named in package-list.\nAfter all symbols have been returned by successive invocations of (name),\nthen only one value is returned, namely nil.\nThe meaning of the second, third, and fourth values is that the returned\nsymbol is accessible in the returned package in the way indicated by the\nsecond return value as follows:\n:internal\n     Means present and not exported.\n:external\n     Means present and exported.\n:inherited\n     Means not present (thus not shadowed) but inherited from some used\n     package.\nIt is unspecified what happens if any of the implicit interior state of an\niteration is returned outside the dynamic extent of the\nwith-package-iterator form such as by returning some closure over the\ninvocation form.\nAny number of invocations of with-package-iterator can be nested, and the\nbody of the innermost one can invoke all of the locally established\nmacros, provided all those macros have distinct names.\n"
        },
        {
            "type": "Examples",
            "text": "The following function should return t on any package, and signal an error\nif the usage of with-package-iterator does not agree with the\ncorresponding usage of do-symbols.\n      (defun test-package-iterator (package)\n        (unless (packagep package)\n          (setq package (find-package package)))\n        (let ((all-entries '())\n              (generated-entries '()))\n          (do-symbols (x package)\n            (multiple-value-bind (symbol accessibility)\n                (find-symbol (symbol-name x) package)\n              (push (list symbol accessibility) all-entries)))\n          (with-package-iterator (generator-fn package\n                                  :internal :external :inherited)\n            (loop\n              (multiple-value-bind (more? symbol accessibility pkg)\n                  (generator-fn)\n                (unless more? (return))\n                (let ((l (multiple-value-list (find-symbol (symbol-name symbol)\n                                                           package))))\n                  (unless (equal l (list symbol accessibility))\n                    (error \"Symbol ~S not found as ~S in package ~A [~S]\"\n                           symbol accessibility (package-name package) l))\n                  (push l generated-entries)))))\n          (unless (and (subsetp all-entries generated-entries :test #'equal)\n                       (subsetp generated-entries all-entries :test #'equal))\n           (error \"Generated entries and Do-Symbols entries don't correspond\"))\n          t))\nThe following function prints out every present symbol (possibly more than\nonce):\n      (defun print-all-symbols ()\n        (with-package-iterator (next-symbol (list-all-packages)\n                                :internal :external)\n          (loop\n            (multiple-value-bind (more? symbol) (next-symbol)\n              (if more?\n                 (print symbol)\n                 (return))))))\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "with-package-iterator signals an error of type program-error if no\nsymbol-types are supplied or if a symbol-type is not recognized  by the\nimplementation is supplied.\nThe consequences are undefined if the local function named name\nestablished by with-package-iterator is called after it has returned false\nas its primary value.\n"
        },
        {
            "type": "See Also",
            "text": "*Note Traversal Rules and Side Effects::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: with-package-iterator,  Next: unexport,  Prev: make-package,  Up: Packages Dictionary\n\nwith-package-iterator                                               [Macro]\n---------------------------------------------------------------------------\n\n`with-package-iterator'  (name package-list-form &rest symbol-types)\n{declaration}* {form}*\n=>  {result}*\n\nArguments and Values::\n......................\n\nname--a symbol.\n\npackage-list-form--a form; evaluated once to produce a package-list.\n\npackage-list--a designator for a list of package designators.\n\nsymbol-type--one of the symbols :internal, :external, or :inherited.\n\ndeclaration--a declare expression; not evaluated.\n\nforms--an implicit progn.\n\nresults--the values of the forms.\n\nDescription::\n.............\n\nWithin the lexical scope of the body forms, the name is defined via\nmacrolet such that successive invocations of (name) will return the\nsymbols, one by one, from the packages in package-list.\n\nIt is unspecified whether symbols inherited from multiple packages are\nreturned more than once.  The order of symbols returned does not\nnecessarily reflect the order of packages in package-list.  When\npackage-list has more than one element, it is unspecified whether\nduplicate symbols are returned once or more than once.\n\nSymbol-types controls which symbols that are accessible in a package are\nreturned as follows:\n\n:internal\n     The symbols that are present in the package, but that are not\n     exported.\n\n:external\n     The symbols that are present in the package and are exported.\n\n:inherited\n     The symbols that are exported by used packages and that are not\n     shadowed.\n\nWhen more than one argument is supplied for symbol-types, a symbol is\nreturned if its accessibility matches any one of the symbol-types supplied.\nImplementations may extend this syntax by recognizing additional symbol\naccessibility types.\n\nAn invocation of (name) returns four values as follows:\n\n1.\n     A flag that indicates whether a symbol is returned (true means that a\n     symbol is returned).\n\n2.\n     A symbol that is accessible in one the indicated packages.\n\n3.\n     The accessibility type for that symbol; i.e., one of the symbols\n     :internal, :external, or :inherited.\n\n4.\n     The package from which the symbol was obtained.  The package is one\n     of the packages present or named in package-list.\n\nAfter all symbols have been returned by successive invocations of (name),\nthen only one value is returned, namely nil.\n\nThe meaning of the second, third, and fourth values is that the returned\nsymbol is accessible in the returned package in the way indicated by the\nsecond return value as follows:\n\n:internal\n     Means present and not exported.\n\n:external\n     Means present and exported.\n\n:inherited\n     Means not present (thus not shadowed) but inherited from some used\n     package.\n\nIt is unspecified what happens if any of the implicit interior state of an\niteration is returned outside the dynamic extent of the\nwith-package-iterator form such as by returning some closure over the\ninvocation form.\n\nAny number of invocations of with-package-iterator can be nested, and the\nbody of the innermost one can invoke all of the locally established\nmacros, provided all those macros have distinct names.\n\nExamples::\n..........\n\nThe following function should return t on any package, and signal an error\nif the usage of with-package-iterator does not agree with the\ncorresponding usage of do-symbols.\n\n      (defun test-package-iterator (package)\n        (unless (packagep package)\n          (setq package (find-package package)))\n        (let ((all-entries '())\n              (generated-entries '()))\n          (do-symbols (x package)\n            (multiple-value-bind (symbol accessibility)\n                (find-symbol (symbol-name x) package)\n              (push (list symbol accessibility) all-entries)))\n          (with-package-iterator (generator-fn package\n                                  :internal :external :inherited)\n            (loop\n              (multiple-value-bind (more? symbol accessibility pkg)\n                  (generator-fn)\n                (unless more? (return))\n                (let ((l (multiple-value-list (find-symbol (symbol-name symbol)\n                                                           package))))\n                  (unless (equal l (list symbol accessibility))\n                    (error \"Symbol ~S not found as ~S in package ~A [~S]\"\n                           symbol accessibility (package-name package) l))\n                  (push l generated-entries)))))\n          (unless (and (subsetp all-entries generated-entries :test #'equal)\n                       (subsetp generated-entries all-entries :test #'equal))\n           (error \"Generated entries and Do-Symbols entries don't correspond\"))\n          t))\n\nThe following function prints out every present symbol (possibly more than\nonce):\n\n      (defun print-all-symbols ()\n        (with-package-iterator (next-symbol (list-all-packages)\n                                :internal :external)\n          (loop\n            (multiple-value-bind (more? symbol) (next-symbol)\n              (if more?\n                 (print symbol)\n                 (return))))))\n\nExceptional Situations::\n........................\n\nwith-package-iterator signals an error of type program-error if no\nsymbol-types are supplied or if a symbol-type is not recognized  by the\nimplementation is supplied.\n\nThe consequences are undefined if the local function named name\nestablished by with-package-iterator is called after it has returned false\nas its primary value.\n\nSee Also::\n..........\n\n*Note Traversal Rules and Side Effects::\n\n"
}