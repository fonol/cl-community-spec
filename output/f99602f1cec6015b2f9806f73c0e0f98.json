{
    "name": "*read-suppress*",
    "prev": "*read-eval*",
    "next": "*readtable*",
    "up": "Reader Dictionary",
    "header": {
        "type": "Variable",
        "text": "*read-suppress*"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Value Type",
            "text": "a generalized boolean.\n"
        },
        {
            "type": "Initial Value",
            "text": "false.\n"
        },
        {
            "type": "Description",
            "text": "This variable is intended primarily to support the operation of the\nread-time conditional notations #+ and #-. It is important for the reader\nmacros which implement these notations to be able to skip over the printed\nrepresentation of an expression despite the possibility that the syntax of\nthe skipped expression may not be entirely valid for the current\nimplementation, since #+ and #- exist in order to allow the same program\nto be shared among several Lisp implementations (including dialects other\nthan Common Lisp) despite small incompatibilities of syntax.\nIf it is false, the Lisp reader operates normally.\nIf the value of *read-suppress* is true, read, read-preserving-whitespace,\nread-delimited-list, and read-from-string all return a primary value of\nnil when they complete successfully; however, they continue to parse the\nrepresentation of an object in the normal way, in order to skip over the\nobject, and continue to indicate end of file in the normal way.  Except as\nnoted below, any standardized reader macro_2 that is defined to read_2 a\nfollowing object or token will do so, but not signal an error if the object\nread is not of an appropriate type or syntax.  The standard syntax and its\nassociated reader macros will not construct any new objects (e.g., when\nreading the representation of a symbol, no symbol will be constructed or\ninterned).\nExtended tokens\n     All extended tokens are completely uninterpreted.  Errors such as\n     those that might otherwise be signaled due to detection of invalid\n     potential numbers, invalid patterns of package markers, and invalid\n     uses of the dot character are suppressed.\nDispatching macro characters (including sharpsign)\n     Dispatching macro characters continue to parse an infix numerical\n     argument, and invoke the dispatch function.  The standardized\n     sharpsign reader macros do not enforce any constraints on either the\n     presence of or the value of the numerical argument.\n#=\n     The #= notation is totally ignored.  It does not read a following\n     object. It produces no object, but is treated as whitespace_2.\n##\n     The ## notation always produces nil.\nNo matter what the value of *read-suppress*, parentheses still continue to\ndelimit and construct lists; the #( notation continues to delimit vectors;\nand comments, strings, and the single-quote and backquote notations\ncontinue to be interpreted properly.  Such situations as '),\t#<,\n#), and #<Space> continue to signal errors.\n"
        },
        {
            "type": "Examples",
            "text": "      (let ((*read-suppress* t))\n        (mapcar #'read-from-string\n                '(\"#(foo bar baz)\" \"#P(:type :lisp)\" \"#c1.2\"\n                  \"#.(PRINT 'FOO)\" \"#3AHELLO\" \"#S(INTEGER)\"\n                  \"#*ABC\" \"#\\GARBAGE\" \"#RALPHA\" \"#3R444\")))\n     =>  (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)\n"
        },
        {
            "type": "See Also",
            "text": "*Note read; read-preserving-whitespace:: , *Note Syntax::\n"
        },
        {
            "type": "Notes",
            "text": "Programmers and implementations that define additional macro characters\nare strongly encouraged to make them respect *read-suppress* just as\nstandardized macro characters do.  That is, when the value of\n*read-suppress* is true, they should ignore type errors when reading a\nfollowing object and the functions that implement dispatching macro\ncharacters should tolerate nil as their infix parameter value even if a\nnumeric value would ordinarily be required.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: *read-suppress*,  Next: *readtable*,  Prev: *read-eval*,  Up: Reader Dictionary\n\n*read-suppress*                                                  [Variable]\n---------------------------------------------------------------------------\n\nValue Type::\n............\n\na generalized boolean.\n\nInitial Value::\n...............\n\nfalse.\n\nDescription::\n.............\n\nThis variable is intended primarily to support the operation of the\nread-time conditional notations #+ and #-. It is important for the reader\nmacros which implement these notations to be able to skip over the printed\nrepresentation of an expression despite the possibility that the syntax of\nthe skipped expression may not be entirely valid for the current\nimplementation, since #+ and #- exist in order to allow the same program\nto be shared among several Lisp implementations (including dialects other\nthan Common Lisp) despite small incompatibilities of syntax.\n\nIf it is false, the Lisp reader operates normally.\n\nIf the value of *read-suppress* is true, read, read-preserving-whitespace,\nread-delimited-list, and read-from-string all return a primary value of\nnil when they complete successfully; however, they continue to parse the\nrepresentation of an object in the normal way, in order to skip over the\nobject, and continue to indicate end of file in the normal way.  Except as\nnoted below, any standardized reader macro_2 that is defined to read_2 a\nfollowing object or token will do so, but not signal an error if the object\nread is not of an appropriate type or syntax.  The standard syntax and its\nassociated reader macros will not construct any new objects (e.g., when\nreading the representation of a symbol, no symbol will be constructed or\ninterned).\n\nExtended tokens\n     All extended tokens are completely uninterpreted.  Errors such as\n     those that might otherwise be signaled due to detection of invalid\n     potential numbers, invalid patterns of package markers, and invalid\n     uses of the dot character are suppressed.\n\nDispatching macro characters (including sharpsign)\n     Dispatching macro characters continue to parse an infix numerical\n     argument, and invoke the dispatch function.  The standardized\n     sharpsign reader macros do not enforce any constraints on either the\n     presence of or the value of the numerical argument.\n\n#=\n     The #= notation is totally ignored.  It does not read a following\n     object. It produces no object, but is treated as whitespace_2.\n\n##\n     The ## notation always produces nil.\n\nNo matter what the value of *read-suppress*, parentheses still continue to\ndelimit and construct lists; the #( notation continues to delimit vectors;\nand comments, strings, and the single-quote and backquote notations\ncontinue to be interpreted properly.  Such situations as '),\t#<,\n#), and #<Space> continue to signal errors.\n\nExamples::\n..........\n\n      (let ((*read-suppress* t))\n        (mapcar #'read-from-string\n                '(\"#(foo bar baz)\" \"#P(:type :lisp)\" \"#c1.2\"\n                  \"#.(PRINT 'FOO)\" \"#3AHELLO\" \"#S(INTEGER)\"\n                  \"#*ABC\" \"#\\GARBAGE\" \"#RALPHA\" \"#3R444\")))\n     =>  (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)\n\nSee Also::\n..........\n\n*Note read; read-preserving-whitespace:: , *Note Syntax::\n\nNotes::\n.......\n\nProgrammers and implementations that define additional macro characters\nare strongly encouraged to make them respect *read-suppress* just as\nstandardized macro characters do.  That is, when the value of\n*read-suppress* is true, they should ignore type errors when reading a\nfollowing object and the functions that implement dispatching macro\ncharacters should tolerate nil as their infix parameter value even if a\nnumeric value would ordinarily be required.\n\n"
}