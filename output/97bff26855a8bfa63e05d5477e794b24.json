{
    "name": "symbol",
    "prev": "Symbols Dictionary",
    "next": "keyword",
    "up": "Symbols Dictionary",
    "header": {
        "type": "System Class",
        "text": "symbol"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Class Precedence List",
            "text": "",
            "items": [
                {
                    "name": "symbol",
                    "link": "97bff26855a8bfa63e05d5477e794b24"
                },
                {
                    "name": " t",
                    "link": null
                }
            ]
        },
        {
            "type": "Description",
            "text": "Symbols are used for their object identity to name various entities in\nCommon Lisp, including (but not limited to) linguistic entities such as\nvariables and functions.\nSymbols can be collected together into packages.  A symbol is said to be\ninterned in a package if it is accessible in that package; the same symbol\ncan be interned in more than one package.  If a symbol is not interned in\nany package, it is called uninterned.\nAn interned symbol is uniquely identifiable by its name from any package\nin which it is accessible.\nSymbols have the following attributes. For historically reasons, these are\nsometimes referred to as cells, although the actual internal\nrepresentation of symbols and their attributes is implementation-dependent.\nName\n     The name of a symbol is a string used to identify the symbol.  Every\n     symbol has a name,\n     and the consequences are undefined if that name is altered.\n     The name is used as part of the external, printed representation of\n     the symbol; see *Note Character Syntax::.  The function symbol-name\n     returns the name of a given symbol.\n     A symbol may have any character in its name.\nPackage\n     The object in this cell is called the home package of the symbol.  If\n     the home package is nil, the symbol is sometimes said to have no home\n     package.\n     When a symbol is first created, it has no home package.  When it is\n     first interned, the package in which it is initially interned becomes\n     its home package.  The home package of a symbol can be accessed by\n     using the function symbol-package.\n     If a symbol is uninterned from the package which is its home package,\n     its home package is set to nil.  Depending on whether there is\n     another package in which the symbol is interned, the symbol might or\n     might not really be an uninterned symbol.  A symbol with no home\n     package is therefore called apparently uninterned.\n     The consequences are undefined if an attempt is made to alter the\n     home package of a symbol external in the COMMON-LISP package or the\n     KEYWORD package.\nProperty list\n     The property list of a symbol provides a mechanism for associating\n     named attributes with that symbol.  The operations for adding and\n     removing entries are destructive to the property list.  Common Lisp\n     provides operators both for direct manipulation of property list\n     objects (e.g., see getf, remf, and symbol-plist) and for implicit\n     manipulation of a symbol's property list by reference to the symbol\n     (e.g., see get and remprop).  The property list associated with a\n     fresh symbol is initially null.\nValue\n     If a symbol has a value attribute, it is said to be bound, and that\n     fact can be detected by the function boundp.  The object contained in\n     the value cell of a bound symbol is the value of the global variable\n     named by that symbol, and can be accessed by the function\n     symbol-value.  A symbol can be made to be unbound by the function\n     makunbound.\n     The consequences are undefined if an attempt is made to change the\n     value of a symbol that names a constant variable, or to make such a\n     symbol be unbound.\nFunction\n     If a symbol has a function attribute, it is said to be fbound, and\n     that fact can be detected by the function fboundp.  If the symbol is\n     the name of a function in the global environment, the function cell\n     contains the function, and can be accessed by the function\n     symbol-function.  If the symbol is the name of either a macro in the\n     global environment (see macro-function) or a special operator (see\n     special-operator-p), the symbol is fbound, and can be accessed by the\n     function symbol-function, but the object which the function cell\n     contains is of implementation-dependent type and purpose.  A symbol\n     can be made to be funbound by the function fmakunbound.\n     The consequences are undefined if an attempt is made to change the\n     functional value of a symbol that names a special form.\nOperations on a symbol's value cell and function cell are sometimes\ndescribed in terms of their effect on the symbol itself, but the user\nshould keep in mind that there is an intimate relationship between the\ncontents of those cells and the global variable or global function\ndefinition, respectively.\nSymbols are used as identifiers for lexical variables and lexical function\ndefinitions, but in that role, only their object identity is significant.\nCommon Lisp provides no operation on a symbol that can have any effect on\na lexical variable or on a lexical function definition.\n"
        },
        {
            "type": "See Also",
            "text": "*Note Symbols as Tokens::, *Note Potential Numbers as Tokens::, *Note\nPrinting Symbols::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: symbol,  Next: keyword,  Prev: Symbols Dictionary,  Up: Symbols Dictionary\n\nsymbol                                                       [System Class]\n---------------------------------------------------------------------------\n\nClass Precedence List::\n.......................\n\nsymbol, t\n\nDescription::\n.............\n\nSymbols are used for their object identity to name various entities in\nCommon Lisp, including (but not limited to) linguistic entities such as\nvariables and functions.\n\nSymbols can be collected together into packages.  A symbol is said to be\ninterned in a package if it is accessible in that package; the same symbol\ncan be interned in more than one package.  If a symbol is not interned in\nany package, it is called uninterned.\n\nAn interned symbol is uniquely identifiable by its name from any package\nin which it is accessible.\n\nSymbols have the following attributes. For historically reasons, these are\nsometimes referred to as cells, although the actual internal\nrepresentation of symbols and their attributes is implementation-dependent.\n\nName\n     The name of a symbol is a string used to identify the symbol.  Every\n     symbol has a name,\n\n     and the consequences are undefined if that name is altered.\n\n     The name is used as part of the external, printed representation of\n     the symbol; see *Note Character Syntax::.  The function symbol-name\n     returns the name of a given symbol.\n\n     A symbol may have any character in its name.\n\nPackage\n     The object in this cell is called the home package of the symbol.  If\n     the home package is nil, the symbol is sometimes said to have no home\n     package.\n\n     When a symbol is first created, it has no home package.  When it is\n     first interned, the package in which it is initially interned becomes\n     its home package.  The home package of a symbol can be accessed by\n     using the function symbol-package.\n\n     If a symbol is uninterned from the package which is its home package,\n     its home package is set to nil.  Depending on whether there is\n     another package in which the symbol is interned, the symbol might or\n     might not really be an uninterned symbol.  A symbol with no home\n     package is therefore called apparently uninterned.\n\n     The consequences are undefined if an attempt is made to alter the\n     home package of a symbol external in the COMMON-LISP package or the\n     KEYWORD package.\n\nProperty list\n     The property list of a symbol provides a mechanism for associating\n     named attributes with that symbol.  The operations for adding and\n     removing entries are destructive to the property list.  Common Lisp\n     provides operators both for direct manipulation of property list\n     objects (e.g., see getf, remf, and symbol-plist) and for implicit\n     manipulation of a symbol's property list by reference to the symbol\n     (e.g., see get and remprop).  The property list associated with a\n     fresh symbol is initially null.\n\nValue\n     If a symbol has a value attribute, it is said to be bound, and that\n     fact can be detected by the function boundp.  The object contained in\n     the value cell of a bound symbol is the value of the global variable\n     named by that symbol, and can be accessed by the function\n     symbol-value.  A symbol can be made to be unbound by the function\n     makunbound.\n\n     The consequences are undefined if an attempt is made to change the\n     value of a symbol that names a constant variable, or to make such a\n     symbol be unbound.\n\nFunction\n     If a symbol has a function attribute, it is said to be fbound, and\n     that fact can be detected by the function fboundp.  If the symbol is\n     the name of a function in the global environment, the function cell\n     contains the function, and can be accessed by the function\n     symbol-function.  If the symbol is the name of either a macro in the\n     global environment (see macro-function) or a special operator (see\n     special-operator-p), the symbol is fbound, and can be accessed by the\n     function symbol-function, but the object which the function cell\n     contains is of implementation-dependent type and purpose.  A symbol\n     can be made to be funbound by the function fmakunbound.\n\n     The consequences are undefined if an attempt is made to change the\n     functional value of a symbol that names a special form.\n\nOperations on a symbol's value cell and function cell are sometimes\ndescribed in terms of their effect on the symbol itself, but the user\nshould keep in mind that there is an intimate relationship between the\ncontents of those cells and the global variable or global function\ndefinition, respectively.\n\nSymbols are used as identifiers for lexical variables and lexical function\ndefinitions, but in that role, only their object identity is significant.\nCommon Lisp provides no operation on a symbol that can have any effect on\na lexical variable or on a lexical function definition.\n\nSee Also::\n..........\n\n*Note Symbols as Tokens::, *Note Potential Numbers as Tokens::, *Note\nPrinting Symbols::\n\n"
}