{
    "name": "defclass",
    "prev": "with-slots",
    "next": "defgeneric",
    "up": "Objects Dictionary",
    "header": {
        "type": "Macro",
        "text": "defclass"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "defclass",
                    "text": " class-name ({superclass-name}*) ({slot-specifier}*)[[!class-option]]\n=>  new-class\n\n slot-specifier::=slot-name | (slot-name [[!slot-option]])\n slot-name::= symbol\n slot-option::={:reader reader-function-name}* |\n                         {:writer writer-function-name}* |\n                         {:accessor reader-function-name}* |\n                         {:allocation allocation-type} |\n                         {:initarg initarg-name}* |\n                         {:initform form} |\n                         {:type type-specifier} |\n                         {:documentation string}\n function-name::= {symbol | (setf symbol)}\n class-option::=(:default-initargs . initarg-list) |\n                          (:documentation string) |\n                          (:metaclass class-name)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "Class-name",
                    "desc": "a non-nil symbol.Superclass-name-a non-nil symbol.\nSlot-name-a symbol.  The slot-name argument is a symbol that is\nsyntactically valid for use as a variable name.\n"
                },
                {
                    "name": "Reader-function-name",
                    "desc": "a non-nil symbol.  :reader can be supplied more than"
                },
                {
                    "name": "Reader-function-name",
                    "desc": "a non-nil symbol.  :reader can be supplied more thanonce for a given slot.\n"
                },
                {
                    "name": "Writer-function-name",
                    "desc": "a generic function name.  :writer can be supplied"
                },
                {
                    "name": "Writer-function-name",
                    "desc": "a generic function name.  :writer can be suppliedmore than once for a given slot.\n"
                },
                {
                    "name": "Reader-function-name",
                    "desc": "a non-nil symbol.  :accessor can be supplied more"
                },
                {
                    "name": "Reader-function-name",
                    "desc": "a non-nil symbol.  :accessor can be supplied morethan once for a given slot.\n"
                },
                {
                    "name": "Allocation-type",
                    "desc": "(member :instance :class).  :allocation can be supplied"
                },
                {
                    "name": "Allocation-type",
                    "desc": "(member :instance :class).  :allocation can be suppliedonce at most for a given slot.\n"
                },
                {
                    "name": "Initarg-name",
                    "desc": "a symbol.  :initarg can be supplied more than once for a"
                },
                {
                    "name": "Initarg-name",
                    "desc": "a symbol.  :initarg can be supplied more than once for agiven slot.\n"
                },
                {
                    "name": "Form",
                    "desc": "a form.  :init-form can be supplied once at most for a given slot."
                },
                {
                    "name": "Type-specifier",
                    "desc": "a type specifier.  :type can be supplied once at most for"
                },
                {
                    "name": "Type-specifier",
                    "desc": "a type specifier.  :type can be supplied once at most fora given slot.\n"
                },
                {
                    "name": "Class-option",
                    "desc": " refers to the class as a whole or to all class slots."
                },
                {
                    "name": "Initarg-list",
                    "desc": "a list of alternating initialization argument names anddefault initial value forms.  :default-initargs can be supplied at most\nonce.\n"
                },
                {
                    "name": "Class-name",
                    "desc": "a non-nil symbol.  :metaclass can be supplied once at most."
                },
                {
                    "name": "new-class",
                    "desc": "the new class object."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The macro defclass defines a new named class.  It returns the new class\nobject as its result.\nThe syntax of defclass provides options for specifying initialization\narguments for slots, for specifying default initialization values for\nslots, and for requesting that methods on specified generic functions be\nautomatically generated for reading and writing the values of slots.  No\nreader or writer functions are defined by default; their generation must\nbe explicitly requested.  However, slots can always be accessed using\nslot-value.\nDefining a new class also causes a type of the same name to be defined.\nThe predicate (typep object class-name) returns true if the class of the\ngiven object is the class named by class-name itself or a subclass of the\nclass class-name.  A class object can be used as a type specifier.  Thus\n(typep object class) returns true if the class of the object is class\nitself or a subclass of class.\nThe class-name argument specifies the proper name of the new class.  If a\nclass with the same proper name already exists and that class is an\ninstance of standard-class, and if the defclass form for the definition of\nthe new class specifies a class of class standard-class, the existing\nclass is redefined, and instances of it (and its subclasses) are updated\nto the new definition at the time that they are next accessed.  For\ndetails, see *Note Redefining Classes::.\nEach superclass-name argument specifies a direct superclass of the new\nclass.  If the superclass list is empty, then the superclass defaults\ndepending on the metaclass, with standard-object being the default for\nstandard-class.\nThe new class will inherit slots and methods from each of its direct\nsuperclasses, from their direct superclasses, and so on.  For a discussion\nof how slots and methods are inherited, see *Note Inheritance::.\nThe following slot options are available:\n*\n     The :reader slot option specifies that an unqualified method is to be\n     defined on the generic function named reader-function-name to read\n     the value of the given slot.\n*\n     The :writer slot option specifies that an unqualified method is to be\n     defined on the generic function named writer-function-name to write\n     the value of the slot.\n*\n     The :accessor slot option specifies that an unqualified method is to\n     be defined on the generic function named reader-function-name to read\n     the value of the given slot and that an unqualified method is to be\n     defined on the generic function named (setf reader-function-name) to\n     be used with setf to modify the value of the slot.\n*\n     The :allocation slot option is used to specify where storage is to be\n     allocated for the given slot.  Storage for a slot can be located in\n     each instance or in the class object itself.  The value of the\n     allocation-type argument can be either the keyword :instance or the\n     keyword :class.    If the :allocation slot option is not specified,\n     the effect is the same as specifying :allocation :instance.\n    -\n          If allocation-type is :instance, a local slot of the name\n          slot-name is allocated in each instance of the class.\n    -\n          If allocation-type is :class, a shared slot of the given name is\n          allocated in the class object created by this defclass form.\n          The value of the slot is shared by all instances of the class.\n          If a class C_1 defines such a shared slot, any subclass C_2 of\n          C_1 will share this single slot unless the defclass form for C_2\n          specifies a slot of the same name or there is a superclass of\n          C_2 that precedes C_1 in the class precedence list of C_2 and\n          that defines a slot of the same name.\n*\n     The :initform slot option is used to provide a default initial value\n     form to be used in the initialization of the slot.  This form is\n     evaluated every time it is used to initialize the slot.  The lexical\n     environment in which this form is evaluated is the lexical\n     environment in which the defclass form was evaluated.  Note that the\n     lexical environment refers both to variables and to functions.  For\n     local slots, the dynamic environment is the dynamic environment in\n     which make-instance is called; for shared slots, the dynamic\n     environment is the dynamic environment in which the defclass form was\n     evaluated.  See *Note Object Creation and Initialization::.\n     No implementation is permitted to extend the syntax of defclass to\n     allow (slot-name form) as an abbreviation for (slot-name :initform\n     form).\n     [Reviewer Note by Barmar: Can you extend this to mean something else?]\n*\n     The :initarg slot option declares an initialization argument named\n     initarg-name and specifies that this initialization argument\n     initializes the given slot.  If the initialization argument has a\n     value in the call to initialize-instance, the value will be stored\n     into the given slot, and the slot's :initform slot option, if any, is\n     not evaluated.  If none of the initialization arguments specified for\n     a given slot has a value, the slot is initialized according to the\n     :initform slot option, if specified.\n*\n     The :type slot option specifies that the contents of the slot will\n     always be of the specified data type.  It effectively declares the\n     result type of the reader generic function when applied to an object\n     of this class.  The consequences of attempting to store in a slot a\n     value that does not satisfy the type of the slot are undefined.  The\n     :type slot option is further discussed in *Note Inheritance of Slots\n     and Slot Options::.\n*\n     The :documentation slot option provides a documentation string for\n     the slot.  :documentation can be supplied once at most for a given\n     slot.  [Reviewer Note by Barmar: How is this retrieved?]\nEach class option is an option that refers to the class as a whole.  The\nfollowing class options are available:\n*\n     The :default-initargs class option is followed by a list of\n     alternating initialization argument names and default initial value\n     forms.  If any of these initialization arguments does not appear in\n     the initialization argument list supplied to make-instance, the\n     corresponding default initial value form is evaluated, and the\n     initialization argument name and the form's value are added to the end\n     of the initialization argument list before the instance is created;\n     see *Note Object Creation and Initialization::.  The default initial\n     value form is evaluated each time it is used.  The lexical\n     environment in which this form is evaluated is the lexical environment\n     in which the defclass form was evaluated.  The dynamic environment is\n     the dynamic environment in which make-instance was called.  If an\n     initialization argument name appears more than once in a\n     :default-initargs class option, an error is signaled.\n*\n     The :documentation class option causes a documentation string to be\n     attached with the class object, and attached with kind type to the\n     class-name.  :documentation can be supplied once at most.\n*\n     The :metaclass class option is used to specify that instances of the\n     class being defined are to have a different metaclass than the\n     default provided by the system (the class standard-class).\nNote the following rules of defclass for standard classes:\n*\n     It is not required that the superclasses of a class be defined before\n     the defclass form for that class is evaluated.\n*\n     All the superclasses of a class must be defined before an instance of\n     the class can be made.\n*\n     A class must be defined before it can be used as a parameter\n     specializer in a defmethod form.\nThe object system can be extended to cover situations where these rules\nare not obeyed.\nSome slot options are inherited by a class from its superclasses, and some\ncan be shadowed or altered by providing a local slot description.  No\nclass options except :default-initargs are inherited.  For a detailed\ndescription of how slots and slot options are inherited, see *Note\nInheritance of Slots and Slot Options::.\nThe options to defclass can be extended.  It is required that all\nimplementations signal an error if they observe a class option or a slot\noption that is not implemented locally.\nIt is valid to specify more than one reader, writer, accessor, or\ninitialization argument for a slot.  No other slot option can appear more\nthan once in a single slot description, or an error is signaled.\nIf no reader, writer, or accessor is specified for a slot, the slot can\nonly be accessed by the function slot-value.\nIf a defclass form appears as a top level form, the compiler must make the\nclass name be recognized as a valid type name in subsequent declarations\n(as for deftype) and be recognized as a valid class name for defmethod\nparameter specializers and for use as the :metaclass option of a\nsubsequent defclass.  The compiler must make the class definition\navailable to be returned by find-class when its environment argument is a\nvalue received as the environment parameter of a macro.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If there are any duplicate slot names, an error of type program-error is\nsignaled.\nIf an initialization argument name appears more than once in\n:default-initargs class option, an error of type program-error is signaled.\nIf any of the following slot options appears more than once in a single\nslot description, an error of type program-error is signaled: :allocation,\n:initform, :type, :documentation.\nIt is required that all implementations signal an error of type\nprogram-error if they observe a class option or a slot option that is not\nimplemented locally.\n"
        },
        {
            "type": "See Also",
            "text": "*Note documentation; (setf documentation):: , *Note Initialize-Instance:: ,\n*Note make-instance:: , *Note slot-value:: , *Note Classes::, *Note\nInheritance::, *Note Redefining Classes::, *Note Determining the Class\nPrecedence List::, *Note Object Creation and Initialization::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: defclass,  Next: defgeneric,  Prev: with-slots,  Up: Objects Dictionary\n\ndefclass                                                            [Macro]\n---------------------------------------------------------------------------\n\n`defclass'  class-name ({superclass-name}*) ({slot-specifier}*)\n[[!class-option]]\n=>  new-class\n\n slot-specifier::=slot-name | (slot-name [[!slot-option]])\n slot-name::= symbol\n slot-option::={:reader reader-function-name}* |\n                         {:writer writer-function-name}* |\n                         {:accessor reader-function-name}* |\n                         {:allocation allocation-type} |\n                         {:initarg initarg-name}* |\n                         {:initform form} |\n                         {:type type-specifier} |\n                         {:documentation string}\n function-name::= {symbol | (setf symbol)}\n class-option::=(:default-initargs . initarg-list) |\n                          (:documentation string) |\n                          (:metaclass class-name)\nArguments and Values::\n......................\n\nClass-name--a non-nil symbol.\n\nSuperclass-name-a non-nil symbol.\n\nSlot-name-a symbol.  The slot-name argument is a symbol that is\nsyntactically valid for use as a variable name.\n\nReader-function-name--a non-nil symbol.  :reader can be supplied more than\nonce for a given slot.\n\nWriter-function-name--a generic function name.  :writer can be supplied\nmore than once for a given slot.\n\nReader-function-name--a non-nil symbol.  :accessor can be supplied more\nthan once for a given slot.\n\nAllocation-type--(member :instance :class).  :allocation can be supplied\nonce at most for a given slot.\n\nInitarg-name--a symbol.  :initarg can be supplied more than once for a\ngiven slot.\n\nForm--a form.  :init-form can be supplied once at most for a given slot.\n\nType-specifier--a type specifier.  :type can be supplied once at most for\na given slot.\n\nClass-option-- refers to the class as a whole or to all class slots.\n\nInitarg-list--a list of alternating initialization argument names and\ndefault initial value forms.  :default-initargs can be supplied at most\nonce.\n\nClass-name--a non-nil symbol.  :metaclass can be supplied once at most.\n\nnew-class--the new class object.\n\nDescription::\n.............\n\nThe macro defclass defines a new named class.  It returns the new class\nobject as its result.\n\nThe syntax of defclass provides options for specifying initialization\narguments for slots, for specifying default initialization values for\nslots, and for requesting that methods on specified generic functions be\nautomatically generated for reading and writing the values of slots.  No\nreader or writer functions are defined by default; their generation must\nbe explicitly requested.  However, slots can always be accessed using\nslot-value.\n\nDefining a new class also causes a type of the same name to be defined.\nThe predicate (typep object class-name) returns true if the class of the\ngiven object is the class named by class-name itself or a subclass of the\nclass class-name.  A class object can be used as a type specifier.  Thus\n(typep object class) returns true if the class of the object is class\nitself or a subclass of class.\n\nThe class-name argument specifies the proper name of the new class.  If a\nclass with the same proper name already exists and that class is an\ninstance of standard-class, and if the defclass form for the definition of\nthe new class specifies a class of class standard-class, the existing\nclass is redefined, and instances of it (and its subclasses) are updated\nto the new definition at the time that they are next accessed.  For\ndetails, see *Note Redefining Classes::.\n\nEach superclass-name argument specifies a direct superclass of the new\nclass.  If the superclass list is empty, then the superclass defaults\ndepending on the metaclass, with standard-object being the default for\nstandard-class.\n\nThe new class will inherit slots and methods from each of its direct\nsuperclasses, from their direct superclasses, and so on.  For a discussion\nof how slots and methods are inherited, see *Note Inheritance::.\n\nThe following slot options are available:\n\n*\n     The :reader slot option specifies that an unqualified method is to be\n     defined on the generic function named reader-function-name to read\n     the value of the given slot.\n\n*\n     The :writer slot option specifies that an unqualified method is to be\n     defined on the generic function named writer-function-name to write\n     the value of the slot.\n\n*\n     The :accessor slot option specifies that an unqualified method is to\n     be defined on the generic function named reader-function-name to read\n     the value of the given slot and that an unqualified method is to be\n     defined on the generic function named (setf reader-function-name) to\n     be used with setf to modify the value of the slot.\n\n*\n     The :allocation slot option is used to specify where storage is to be\n     allocated for the given slot.  Storage for a slot can be located in\n     each instance or in the class object itself.  The value of the\n     allocation-type argument can be either the keyword :instance or the\n     keyword :class.    If the :allocation slot option is not specified,\n     the effect is the same as specifying :allocation :instance.\n    -\n          If allocation-type is :instance, a local slot of the name\n          slot-name is allocated in each instance of the class.\n\n    -\n          If allocation-type is :class, a shared slot of the given name is\n          allocated in the class object created by this defclass form.\n          The value of the slot is shared by all instances of the class.\n          If a class C_1 defines such a shared slot, any subclass C_2 of\n          C_1 will share this single slot unless the defclass form for C_2\n          specifies a slot of the same name or there is a superclass of\n          C_2 that precedes C_1 in the class precedence list of C_2 and\n          that defines a slot of the same name.\n\n*\n     The :initform slot option is used to provide a default initial value\n     form to be used in the initialization of the slot.  This form is\n     evaluated every time it is used to initialize the slot.  The lexical\n     environment in which this form is evaluated is the lexical\n     environment in which the defclass form was evaluated.  Note that the\n     lexical environment refers both to variables and to functions.  For\n     local slots, the dynamic environment is the dynamic environment in\n     which make-instance is called; for shared slots, the dynamic\n     environment is the dynamic environment in which the defclass form was\n     evaluated.  See *Note Object Creation and Initialization::.\n\n     No implementation is permitted to extend the syntax of defclass to\n     allow (slot-name form) as an abbreviation for (slot-name :initform\n     form).\n\n     [Reviewer Note by Barmar: Can you extend this to mean something else?]\n\n*\n     The :initarg slot option declares an initialization argument named\n     initarg-name and specifies that this initialization argument\n     initializes the given slot.  If the initialization argument has a\n     value in the call to initialize-instance, the value will be stored\n     into the given slot, and the slot's :initform slot option, if any, is\n     not evaluated.  If none of the initialization arguments specified for\n     a given slot has a value, the slot is initialized according to the\n     :initform slot option, if specified.\n\n*\n     The :type slot option specifies that the contents of the slot will\n     always be of the specified data type.  It effectively declares the\n     result type of the reader generic function when applied to an object\n     of this class.  The consequences of attempting to store in a slot a\n     value that does not satisfy the type of the slot are undefined.  The\n     :type slot option is further discussed in *Note Inheritance of Slots\n     and Slot Options::.\n\n*\n     The :documentation slot option provides a documentation string for\n     the slot.  :documentation can be supplied once at most for a given\n     slot.  [Reviewer Note by Barmar: How is this retrieved?]\n\nEach class option is an option that refers to the class as a whole.  The\nfollowing class options are available:\n\n*\n     The :default-initargs class option is followed by a list of\n     alternating initialization argument names and default initial value\n     forms.  If any of these initialization arguments does not appear in\n     the initialization argument list supplied to make-instance, the\n     corresponding default initial value form is evaluated, and the\n     initialization argument name and the form's value are added to the end\n     of the initialization argument list before the instance is created;\n     see *Note Object Creation and Initialization::.  The default initial\n     value form is evaluated each time it is used.  The lexical\n     environment in which this form is evaluated is the lexical environment\n     in which the defclass form was evaluated.  The dynamic environment is\n     the dynamic environment in which make-instance was called.  If an\n     initialization argument name appears more than once in a\n     :default-initargs class option, an error is signaled.\n\n*\n     The :documentation class option causes a documentation string to be\n     attached with the class object, and attached with kind type to the\n     class-name.  :documentation can be supplied once at most.\n\n*\n     The :metaclass class option is used to specify that instances of the\n     class being defined are to have a different metaclass than the\n     default provided by the system (the class standard-class).\n\nNote the following rules of defclass for standard classes:\n\n*\n     It is not required that the superclasses of a class be defined before\n     the defclass form for that class is evaluated.\n\n*\n     All the superclasses of a class must be defined before an instance of\n     the class can be made.\n\n*\n     A class must be defined before it can be used as a parameter\n     specializer in a defmethod form.\n\nThe object system can be extended to cover situations where these rules\nare not obeyed.\n\nSome slot options are inherited by a class from its superclasses, and some\ncan be shadowed or altered by providing a local slot description.  No\nclass options except :default-initargs are inherited.  For a detailed\ndescription of how slots and slot options are inherited, see *Note\nInheritance of Slots and Slot Options::.\n\nThe options to defclass can be extended.  It is required that all\nimplementations signal an error if they observe a class option or a slot\noption that is not implemented locally.\n\nIt is valid to specify more than one reader, writer, accessor, or\ninitialization argument for a slot.  No other slot option can appear more\nthan once in a single slot description, or an error is signaled.\n\nIf no reader, writer, or accessor is specified for a slot, the slot can\nonly be accessed by the function slot-value.\n\nIf a defclass form appears as a top level form, the compiler must make the\nclass name be recognized as a valid type name in subsequent declarations\n(as for deftype) and be recognized as a valid class name for defmethod\nparameter specializers and for use as the :metaclass option of a\nsubsequent defclass.  The compiler must make the class definition\navailable to be returned by find-class when its environment argument is a\nvalue received as the environment parameter of a macro.\n\nExceptional Situations::\n........................\n\nIf there are any duplicate slot names, an error of type program-error is\nsignaled.\n\nIf an initialization argument name appears more than once in\n:default-initargs class option, an error of type program-error is signaled.\n\nIf any of the following slot options appears more than once in a single\nslot description, an error of type program-error is signaled: :allocation,\n:initform, :type, :documentation.\n\nIt is required that all implementations signal an error of type\nprogram-error if they observe a class option or a slot option that is not\nimplemented locally.\n\nSee Also::\n..........\n\n*Note documentation; (setf documentation):: , *Note Initialize-Instance:: ,\n*Note make-instance:: , *Note slot-value:: , *Note Classes::, *Note\nInheritance::, *Note Redefining Classes::, *Note Determining the Class\nPrecedence List::, *Note Object Creation and Initialization::\n\n"
}