{
    "name": "eval",
    "prev": "compile",
    "next": "eval-when",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Function",
        "text": "eval"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "eval",
                    "text": " form =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "form",
                    "desc": "a form."
                },
                {
                    "name": "results",
                    "desc": "the values yielded by the evaluation of form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Evaluates form in the current dynamic environment and the null lexical\nenvironment.\neval is a user interface to the evaluator.\nThe evaluator expands macro calls as if through the use of macroexpand-1.\nConstants appearing in code processed by eval are not copied nor\ncoalesced. The code resulting from the execution of eval references objects\nthat are eql to the corresponding objects in the source code.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq form '(1+ a) a 999) =>  999\n      (eval form) =>  1000\n      (eval 'form) =>  (1+ A)\n      (let ((a '(this would break if eval used local value))) (eval form))\n     =>  1000\n"
        },
        {
            "type": "See Also",
            "text": "macroexpand-1, *Note The Evaluation Model::\n"
        },
        {
            "type": "Notes",
            "text": "To obtain the current dynamic value of a symbol, use of symbol-value is\nequivalent (and usually preferable) to use of eval.\nNote that an eval form involves two levels of evaluation for its argument.\nFirst, form is evaluated by the normal argument evaluation mechanism as\nwould occur with any call.  The object that results from this normal\nargument evaluation becomes the value of the form parameter, and is then\nevaluated as part of the eval form.  For example:\n      (eval (list 'cdr (car '((quote (a . b)) c)))) =>  b\nThe argument form (list 'cdr (car '((quote (a . b)) c))) is evaluated in\nthe usual way to produce the argument (cdr (quote (a . b))); eval then\nevaluates its argument, (cdr (quote (a . b))), to produce b.  Since a\nsingle evaluation already occurs for any argument form in any function\nform, eval is sometimes said to perform \"an extra level of evaluation.\"\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: eval,  Next: eval-when,  Prev: compile,  Up: Evaluation and Compilation Dictionary\n\neval                                                             [Function]\n---------------------------------------------------------------------------\n\n`eval'  form =>  {result}*\n\nArguments and Values::\n......................\n\nform--a form.\n\nresults--the values yielded by the evaluation of form.\n\nDescription::\n.............\n\nEvaluates form in the current dynamic environment and the null lexical\nenvironment.\n\neval is a user interface to the evaluator.\n\nThe evaluator expands macro calls as if through the use of macroexpand-1.\n\nConstants appearing in code processed by eval are not copied nor\ncoalesced. The code resulting from the execution of eval references objects\nthat are eql to the corresponding objects in the source code.\n\nExamples::\n..........\n\n      (setq form '(1+ a) a 999) =>  999\n      (eval form) =>  1000\n      (eval 'form) =>  (1+ A)\n      (let ((a '(this would break if eval used local value))) (eval form))\n     =>  1000\n\nSee Also::\n..........\n\nmacroexpand-1, *Note The Evaluation Model::\n\nNotes::\n.......\n\nTo obtain the current dynamic value of a symbol, use of symbol-value is\nequivalent (and usually preferable) to use of eval.\n\nNote that an eval form involves two levels of evaluation for its argument.\nFirst, form is evaluated by the normal argument evaluation mechanism as\nwould occur with any call.  The object that results from this normal\nargument evaluation becomes the value of the form parameter, and is then\nevaluated as part of the eval form.  For example:\n\n      (eval (list 'cdr (car '((quote (a . b)) c)))) =>  b\n\nThe argument form (list 'cdr (car '((quote (a . b)) c))) is evaluated in\nthe usual way to produce the argument (cdr (quote (a . b))); eval then\nevaluates its argument, (cdr (quote (a . b))), to produce b.  Since a\nsingle evaluation already occurs for any argument form in any function\nform, eval is sometimes said to perform \"an extra level of evaluation.\"\n\n"
}