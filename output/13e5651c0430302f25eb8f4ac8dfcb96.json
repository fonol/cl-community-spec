{
    "name": "Condition System Concepts",
    "prev": "Conditions",
    "next": "Conditions Dictionary",
    "up": "Conditions",
    "header": {
        "type": null,
        "text": "Condition System Concepts"
    },
    "sections": [
        {
            "type": "",
            "text": "Common Lisp constructs are described not only in terms of their behavior\nin situations during which they are intended to be used (see the\n\"Description\" part of each operator specification), but in all other\nsituations (see the \"Exceptional Situations\" part of each operator\nspecification).\nA situation is the evaluation of an expression in a specific context.  A\ncondition is an object that represents a specific situation that has been\ndetected.  Conditions are generalized instances of the class condition.  A\nhierarchy of condition classes is defined in Common Lisp.  A condition has\nslots that contain data relevant to the situation that the condition\nrepresents.\nAn error is a situation in which normal program execution cannot continue\ncorrectly without some form of intervention (either interactively by the\nuser or under program control).  Not all errors are detected.  When an\nerror goes undetected, the effects can be implementation-dependent,\nimplementation-defined, unspecified, or undefined. See *Note\nDefinitions::.  All detected errors can be represented by conditions, but\nnot all conditions represent errors.\nSignaling is the process by which a condition can alter the flow of\ncontrol in a program by raising the condition which can then be handled.\nThe functions error, cerror, signal, and warn are used to signal\nconditions.\nThe process of signaling involves the selection and invocation of a\nhandler from a set of active handlers.  A handler is a function of one\nargument (the condition) that is invoked to handle a condition.  Each\nhandler is associated with a condition type, and a handler will be invoked\nonly on a condition of the handler's associated type.\nActive handlers are established dynamically (see handler-bind or\nhandler-case).  Handlers are invoked in a dynamic environment equivalent\nto that of the signaler, except that the set of active handlers is bound\nin such a way as to include only those that were active at the time the\nhandler being invoked was established.  Signaling a condition has no\nside-effect on the condition, and there is no dynamic state contained in a\ncondition.\nIf a handler is invoked, it can address the situation in one of three ways:\nDecline\n     It can decline to handle the condition.  It does this by simply\n     returning rather than transferring control.  When this happens, any\n     values returned by the handler are ignored and the next most recently\n     established handler is invoked.  If there is no such handler and the\n     signaling function is error or cerror, the debugger is entered in the\n     dynamic environment of the signaler. If there is no such handler and\n     the signaling function is either signal or warn, the signaling\n     function simply returns~nil.\nHandle\n     It can handle the condition by performing a non-local transfer of\n     control.  This can be done either primitively by using go, return,\n     throw or more abstractly by using a function such as abort or\n     invoke-restart.\nDefer\n     It can put off a decision about whether to handle or decline, by any\n     of a number of actions, but most commonly by signaling another\n     condition, resignaling the same condition, or forcing entry into the\n     debugger.\n* Menu:\n* Condition Types::\n* Creating Conditions::\n* Printing Conditions::\n* Signaling and Handling Conditions::\n* Assertions::\n* Notes about the Condition System's Background::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Condition System Concepts,  Next: Conditions Dictionary,  Prev: Conditions,  Up: Conditions\n\nCondition System Concepts\n=========================\n\nCommon Lisp constructs are described not only in terms of their behavior\nin situations during which they are intended to be used (see the\n\"Description\" part of each operator specification), but in all other\nsituations (see the \"Exceptional Situations\" part of each operator\nspecification).\n\nA situation is the evaluation of an expression in a specific context.  A\ncondition is an object that represents a specific situation that has been\ndetected.  Conditions are generalized instances of the class condition.  A\nhierarchy of condition classes is defined in Common Lisp.  A condition has\nslots that contain data relevant to the situation that the condition\nrepresents.\n\nAn error is a situation in which normal program execution cannot continue\ncorrectly without some form of intervention (either interactively by the\nuser or under program control).  Not all errors are detected.  When an\nerror goes undetected, the effects can be implementation-dependent,\nimplementation-defined, unspecified, or undefined. See *Note\nDefinitions::.  All detected errors can be represented by conditions, but\nnot all conditions represent errors.\n\nSignaling is the process by which a condition can alter the flow of\ncontrol in a program by raising the condition which can then be handled.\nThe functions error, cerror, signal, and warn are used to signal\nconditions.\n\nThe process of signaling involves the selection and invocation of a\nhandler from a set of active handlers.  A handler is a function of one\nargument (the condition) that is invoked to handle a condition.  Each\nhandler is associated with a condition type, and a handler will be invoked\nonly on a condition of the handler's associated type.\n\nActive handlers are established dynamically (see handler-bind or\nhandler-case).  Handlers are invoked in a dynamic environment equivalent\nto that of the signaler, except that the set of active handlers is bound\nin such a way as to include only those that were active at the time the\nhandler being invoked was established.  Signaling a condition has no\nside-effect on the condition, and there is no dynamic state contained in a\ncondition.\n\nIf a handler is invoked, it can address the situation in one of three ways:\n\nDecline\n     It can decline to handle the condition.  It does this by simply\n     returning rather than transferring control.  When this happens, any\n     values returned by the handler are ignored and the next most recently\n     established handler is invoked.  If there is no such handler and the\n     signaling function is error or cerror, the debugger is entered in the\n     dynamic environment of the signaler. If there is no such handler and\n     the signaling function is either signal or warn, the signaling\n     function simply returns~nil.\n\nHandle\n     It can handle the condition by performing a non-local transfer of\n     control.  This can be done either primitively by using go, return,\n     throw or more abstractly by using a function such as abort or\n     invoke-restart.\n\nDefer\n     It can put off a decision about whether to handle or decline, by any\n     of a number of actions, but most commonly by signaling another\n     condition, resignaling the same condition, or forcing entry into the\n     debugger.\n\n* Menu:\n\n* Condition Types::\n* Creating Conditions::\n* Printing Conditions::\n* Signaling and Handling Conditions::\n* Assertions::\n* Notes about the Condition System's Background::\n\n"
}