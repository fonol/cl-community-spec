{
    "name": "Integrating Types and Classes",
    "prev": "Redefining Classes",
    "next": null,
    "up": "Classes",
    "header": {
        "type": null,
        "text": "Integrating Types and Classes"
    },
    "sections": [
        {
            "type": "",
            "text": "The object system maps the space of classes into the space of types.\nEvery class that has a proper name has a corresponding type with the same\nname.\nThe proper name of every class is a valid type specifier.  In addition,\nevery class object is a valid type specifier.  Thus the expression (typep\nobject class) evaluates to true if the class of object is class itself or\na subclass of class.  The evaluation of the expression (subtypep class1\nclass2) returns the values true and true if class1 is a subclass of class2\nor if they are the same class; otherwise it returns the values false and\ntrue.  If  I is an instance of some class C named S and C is an instance\nof standard-class, the evaluation of the expression (type-of I\\/) returns S\nif S is the proper name of C; otherwise, it returns C.\nBecause the names of classes and class objects are type specifiers, they\nmay be used in the special form the and in type declarations.\nMany but not all of the predefined type specifiers have a corresponding\nclass with the same proper name as the type.  These type specifiers are\nlisted in Figure~4-8.  For example, the type array has a corresponding\nclass named array.  No type specifier that is a list, such as (vector\ndouble-float 100), has a corresponding class.  The operator deftype does\nnot create any classes.\nEach class that corresponds to a predefined type specifier can be\nimplemented in one of three ways, at the discretion of each implementation.\nIt can be a standard class, a structure class,\nor a system class.\nA built-in class is one whose generalized instances have restricted\ncapabilities or special representations.  Attempting to use defclass to\ndefine subclasses of a built-in-class signals an error.  Calling\nmake-instance to create a generalized instance of a built-in class signals\nan error.  Calling slot-value on a generalized instance of a built-in\nclass signals an error.  Redefining a built-in class or using change-class\nto change the class of an object to or from a built-in class signals an\nerror.  However, built-in classes can be used as parameter specializers in\nmethods.\nIt is possible to determine whether a class is a built-in class by\nchecking the metaclass.  A standard class  is an instance of the class\nstandard-class, a built-in class  is an instance of the class\nbuilt-in-class, and a structure class is an instance of the class\nstructure-class.\nEach structure type created by defstruct without using the :type option\nhas a corresponding class.  This class is a generalized instance of the\nclass structure-class.  The :include option of defstruct creates a direct\nsubclass of the class that corresponds to the included structure type.\nIt is implementation-dependent whether slots are involved in the operation\nof functions defined in this specification on instances of classes defined\nin this specification, except when slots are explicitly defined by this\nspecification.\nIf in a particular implementation a class defined in this specification\nhas slots that are not defined by this specfication, the names of these\nslots must not be external symbols of packages defined in this\nspecification nor otherwise accessible in the CL-USER package.\nThe purpose of specifying that many of the standard type specifiers have a\ncorresponding class is to enable users to write methods that discriminate\non these types.  Method selection requires that a class precedence list\ncan be determined for each class.\nThe hierarchical relationships among the type specifiers are mirrored by\nrelationships among the classes corresponding to those types.\nFigure~4-8 lists the set of classes that correspond to predefined type\nspecifiers.\n arithmetic-error                 generic-function   simple-error              \n array                            hash-table         simple-type-error         \n bit-vector                       integer            simple-warning            \n broadcast-stream                 list               standard-class            \n built-in-class                   logical-pathname   standard-generic-function \n cell-error                       method             standard-method           \n character                        method-combination standard-object           \n class                            null               storage-condition         \n complex                          number             stream                    \n concatenated-stream              package            stream-error              \n condition                        package-error      string                    \n cons                             parse-error        string-stream             \n control-error                    pathname           structure-class           \n division-by-zero                 print-not-readable structure-object          \n echo-stream                      program-error      style-warning             \n end-of-file                      random-state       symbol                    \n error                            ratio              synonym-stream            \n file-error                       rational           t                         \n file-stream                      reader-error       two-way-stream            \n float                            readtable          type-error                \n floating-point-inexact           real               unbound-slot              \n floating-point-invalid-operation restart            unbound-variable          \n floating-point-overflow          sequence           undefined-function        \n floating-point-underflow         serious-condition  vector                    \n function                         simple-condition   warning                   \n       Figure 4-8: Classes that correspond to pre-defined type specifiers      \nThe class precedence list information specified in the entries for each of\nthese classes are those that are required by the object system.\nIndividual implementations may be extended to define other type specifiers\nto have a corresponding class.  Individual implementations may be extended\nto add other subclass relationships and to add other elements to the class\nprecedence lists as long as they do not violate the type relationships and\ndisjointness requirements specified by this standard.  A standard class\ndefined with no direct superclasses is guaranteed to be disjoint from all\nof the classes in the table, except for the class named t.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Integrating Types and Classes,  Prev: Redefining Classes,  Up: Classes\n\nIntegrating Types and Classes\n-----------------------------\n\nThe object system maps the space of classes into the space of types.\nEvery class that has a proper name has a corresponding type with the same\nname.\n\nThe proper name of every class is a valid type specifier.  In addition,\nevery class object is a valid type specifier.  Thus the expression (typep\nobject class) evaluates to true if the class of object is class itself or\na subclass of class.  The evaluation of the expression (subtypep class1\nclass2) returns the values true and true if class1 is a subclass of class2\nor if they are the same class; otherwise it returns the values false and\ntrue.  If  I is an instance of some class C named S and C is an instance\nof standard-class, the evaluation of the expression (type-of I\\/) returns S\nif S is the proper name of C; otherwise, it returns C.\n\nBecause the names of classes and class objects are type specifiers, they\nmay be used in the special form the and in type declarations.\n\nMany but not all of the predefined type specifiers have a corresponding\nclass with the same proper name as the type.  These type specifiers are\nlisted in Figure~4-8.  For example, the type array has a corresponding\nclass named array.  No type specifier that is a list, such as (vector\ndouble-float 100), has a corresponding class.  The operator deftype does\nnot create any classes.\n\nEach class that corresponds to a predefined type specifier can be\nimplemented in one of three ways, at the discretion of each implementation.\nIt can be a standard class, a structure class,\n\nor a system class.\n\nA built-in class is one whose generalized instances have restricted\ncapabilities or special representations.  Attempting to use defclass to\ndefine subclasses of a built-in-class signals an error.  Calling\nmake-instance to create a generalized instance of a built-in class signals\nan error.  Calling slot-value on a generalized instance of a built-in\nclass signals an error.  Redefining a built-in class or using change-class\nto change the class of an object to or from a built-in class signals an\nerror.  However, built-in classes can be used as parameter specializers in\nmethods.\n\nIt is possible to determine whether a class is a built-in class by\nchecking the metaclass.  A standard class  is an instance of the class\nstandard-class, a built-in class  is an instance of the class\nbuilt-in-class, and a structure class is an instance of the class\nstructure-class.\n\nEach structure type created by defstruct without using the :type option\nhas a corresponding class.  This class is a generalized instance of the\nclass structure-class.  The :include option of defstruct creates a direct\nsubclass of the class that corresponds to the included structure type.\n\nIt is implementation-dependent whether slots are involved in the operation\nof functions defined in this specification on instances of classes defined\nin this specification, except when slots are explicitly defined by this\nspecification.\n\nIf in a particular implementation a class defined in this specification\nhas slots that are not defined by this specfication, the names of these\nslots must not be external symbols of packages defined in this\nspecification nor otherwise accessible in the CL-USER package.\n\nThe purpose of specifying that many of the standard type specifiers have a\ncorresponding class is to enable users to write methods that discriminate\non these types.  Method selection requires that a class precedence list\ncan be determined for each class.\n\nThe hierarchical relationships among the type specifiers are mirrored by\nrelationships among the classes corresponding to those types.\n\nFigure~4-8 lists the set of classes that correspond to predefined type\nspecifiers.\n\n arithmetic-error                 generic-function   simple-error              \n array                            hash-table         simple-type-error         \n bit-vector                       integer            simple-warning            \n broadcast-stream                 list               standard-class            \n built-in-class                   logical-pathname   standard-generic-function \n cell-error                       method             standard-method           \n character                        method-combination standard-object           \n class                            null               storage-condition         \n complex                          number             stream                    \n concatenated-stream              package            stream-error              \n condition                        package-error      string                    \n cons                             parse-error        string-stream             \n control-error                    pathname           structure-class           \n division-by-zero                 print-not-readable structure-object          \n echo-stream                      program-error      style-warning             \n end-of-file                      random-state       symbol                    \n error                            ratio              synonym-stream            \n file-error                       rational           t                         \n file-stream                      reader-error       two-way-stream            \n float                            readtable          type-error                \n floating-point-inexact           real               unbound-slot              \n floating-point-invalid-operation restart            unbound-variable          \n floating-point-overflow          sequence           undefined-function        \n floating-point-underflow         serious-condition  vector                    \n function                         simple-condition   warning                   \n\n       Figure 4-8: Classes that correspond to pre-defined type specifiers      \n\n\nThe class precedence list information specified in the entries for each of\nthese classes are those that are required by the object system.\n\nIndividual implementations may be extended to define other type specifiers\nto have a corresponding class.  Individual implementations may be extended\nto add other subclass relationships and to add other elements to the class\nprecedence lists as long as they do not violate the type relationships and\ndisjointness requirements specified by this standard.  A standard class\ndefined with no direct superclasses is guaranteed to be disjoint from all\nof the classes in the table, except for the class named t.\n\n"
}