{
    "name": "Declaring the Validity of Initialization Arguments",
    "prev": "Initialization Arguments",
    "next": "Defaulting of Initialization Arguments",
    "up": "Object Creation and Initialization",
    "header": {
        "type": null,
        "text": "Declaring the Validity of Initialization Arguments"
    },
    "sections": [
        {
            "type": "",
            "text": "Initialization arguments are checked for validity in each of the four\nsituations that use them.  An initialization argument may be valid in one\nsituation and not another. For example, the system-supplied primary method\nfor make-instance defined for the class standard-class checks the validity\nof its initialization arguments and signals an error if an initialization\nargument is supplied that is not declared as valid in that situation.\nThere are two means for declaring initialization arguments valid.\n*\n     Initialization arguments that fill slots are declared as valid by the\n     :initarg slot option to defclass.  The :initarg slot option is\n     inherited from superclasses.  Thus the set of valid initialization\n     arguments that fill slots for a class is the union of the\n     initialization arguments that fill slots declared as valid by that\n     class and its superclasses.  Initialization arguments that fill slots\n     are valid in all four contexts.\n*\n     Initialization arguments that supply arguments to methods are\n     declared as valid by defining those methods.  The keyword name of\n     each keyword parameter specified in the method's lambda list becomes\n     an initialization argument for all classes for which the method is\n     applicable.\n     The presence of &allow-other-keys in the lambda list of an applicable\n     method disables validity checking of initialization arguments.\n     Thus method inheritance controls the set of valid initialization\n     arguments that supply arguments to methods.  The generic functions\n     for which method definitions serve to declare initialization\n     arguments valid are as follows:\n    -\n          Making an instance of a class: allocate-instance,\n          initialize-instance, and shared-initialize.  Initialization\n          arguments declared as valid by these methods are valid when\n          making an instance of a class.\n    -\n          Re-initializing an instance: reinitialize-instance and\n          shared-initialize.  Initialization arguments declared as valid\n          by these methods are valid when re-initializing an instance.\n    -\n          Updating an instance to conform to a redefined class:\n          update-instance-for-redefined-class and shared-initialize.\n          Initialization arguments declared as valid by these methods are\n          valid when updating an instance to conform to a redefined class.\n    -\n          Updating an instance to conform to the definition of a different\n          class: update-instance-for-different-class and shared-initialize.\n          Initialization arguments declared as valid by these methods are\n          valid when updating an instance to conform to the definition of\n          a different class.\nThe set of valid initialization arguments for a class is the set of valid\ninitialization arguments that either fill slots or supply arguments to\nmethods, along with the predefined initialization argument\n:allow-other-keys.  The default value for :allow-other-keys is nil.\nValidity checking of initialization arguments is disabled if the value of\nthe initialization argument :allow-other-keys is true.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Declaring the Validity of Initialization Arguments,  Next: Defaulting of Initialization Arguments,  Prev: Initialization Arguments,  Up: Object Creation and Initialization\n\nDeclaring the Validity of Initialization Arguments\n--------------------------------------------------\n\nInitialization arguments are checked for validity in each of the four\nsituations that use them.  An initialization argument may be valid in one\nsituation and not another. For example, the system-supplied primary method\nfor make-instance defined for the class standard-class checks the validity\nof its initialization arguments and signals an error if an initialization\nargument is supplied that is not declared as valid in that situation.\n\nThere are two means for declaring initialization arguments valid.\n\n*\n     Initialization arguments that fill slots are declared as valid by the\n     :initarg slot option to defclass.  The :initarg slot option is\n     inherited from superclasses.  Thus the set of valid initialization\n     arguments that fill slots for a class is the union of the\n     initialization arguments that fill slots declared as valid by that\n     class and its superclasses.  Initialization arguments that fill slots\n     are valid in all four contexts.\n\n*\n     Initialization arguments that supply arguments to methods are\n     declared as valid by defining those methods.  The keyword name of\n     each keyword parameter specified in the method's lambda list becomes\n     an initialization argument for all classes for which the method is\n     applicable.\n\n     The presence of &allow-other-keys in the lambda list of an applicable\n     method disables validity checking of initialization arguments.\n\n     Thus method inheritance controls the set of valid initialization\n     arguments that supply arguments to methods.  The generic functions\n     for which method definitions serve to declare initialization\n     arguments valid are as follows:\n    -\n          Making an instance of a class: allocate-instance,\n          initialize-instance, and shared-initialize.  Initialization\n          arguments declared as valid by these methods are valid when\n          making an instance of a class.\n\n    -\n          Re-initializing an instance: reinitialize-instance and\n          shared-initialize.  Initialization arguments declared as valid\n          by these methods are valid when re-initializing an instance.\n\n    -\n          Updating an instance to conform to a redefined class:\n          update-instance-for-redefined-class and shared-initialize.\n          Initialization arguments declared as valid by these methods are\n          valid when updating an instance to conform to a redefined class.\n\n    -\n          Updating an instance to conform to the definition of a different\n          class: update-instance-for-different-class and shared-initialize.\n          Initialization arguments declared as valid by these methods are\n          valid when updating an instance to conform to the definition of\n          a different class.\n\nThe set of valid initialization arguments for a class is the set of valid\ninitialization arguments that either fill slots or supply arguments to\nmethods, along with the predefined initialization argument\n:allow-other-keys.  The default value for :allow-other-keys is nil.\n\nValidity checking of initialization arguments is disabled if the value of\nthe initialization argument :allow-other-keys is true.\n\n"
}