{
    "name": "Special Symbols",
    "prev": "Additional Uses for Indirect Definitions in Modified BNF Syntax",
    "next": "Objects with Multiple Notations",
    "up": "Notational Conventions",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Special Symbols",
            "text": "The special symbols described here are used as a notational convenience\nwithin this document, and are part of neither the Common Lisp language nor\nits environment.\n=>\n     This indicates evaluation.  For example:\n           (+ 4 5) =>  9\n     This means that the result of evaluating the form (+ 4 5) is 9.\n     If a form returns multiple values, those values might be shown\n     separated by spaces, line breaks, or commas.  For example:\n           (truncate 7 5)\n          =>  1 2\n           (truncate 7 5)\n          =>  1\n             2\n           (truncate 7 5)\n          =>  1, 2\n     Each of the above three examples is equivalent, and specifies that\n     (truncate 7 5) returns two values, which are 1 and 2.\n     Some conforming implementations actually type an arrow (or some other\n     indicator) before showing return values, while others do not.\nOR=>\n     The notation \"OR=>\" is used to denote one of several possible\n     alternate results.  The example\n           (char-name #\\a)\n          =>  NIL\n          OR=> \"LOWERCASE-a\"\n          OR=> \"Small-A\"\n          OR=> \"LA01\"\n     indicates that nil, \"LOWERCASE-a\", \"Small-A\", \"LA01\" are among the\n     possible results of (char-name #\\a)--each with equal preference.\n     Unless explicitly specified otherwise, it should not be assumed that\n     the set of possible results shown is exhaustive.  Formally, the above\n     example is equivalent to\n           (char-name #\\a) =>  implementation-dependent\n     but it is intended to provide additional information to illustrate\n     some of the ways in which it is permitted for implementations to\n     diverge.\nNOT=>\n     The notation \"NOT=>\" is used to denote a result which is not possible.\n     This might be used, for example, in order to emphasize a situation\n     where some anticipated misconception might lead the reader to falsely\n     believe that the result might be possible.  For example,\n           (function-lambda-expression\n              (funcall #'(lambda (x) #'(lambda () x)) nil))\n          =>  NIL, true, NIL\n          OR=> (LAMBDA () X), true, NIL\n          NOT=> NIL, false, NIL\n          NOT=> (LAMBDA () X), false, NIL\n==\n     This indicates code equivalence. For example:\n           (gcd x (gcd y z)) == (gcd (gcd x y) z)\n     This means that the results and observable side-effects of evaluating\n     the form (gcd x (gcd y z))  are always the same as the results and\n     observable side-effects of (gcd (gcd x y) z)  for any x, y, and z.\n |>\n     Common Lisp specifies input and output with respect to a\n     non-interactive stream model.  The specific details of how\n     interactive input and output are mapped onto that non-interactive\n     model are implementation-defined.\n     For example, conforming implementations are permitted to differ in\n     issues of how interactive input is terminated.  For example, the\n     function read terminates when the final delimiter is typed on a\n     non-interactive stream.  In some implementations, an interactive call\n     to read returns as soon as the final delimiter is typed, even if that\n     delimiter is not a newline.  In other implementations, a final\n     newline is always required.  In still other implementations, there\n     might be a command which \"activates\" a buffer full of input without\n     the command itself being visible on the program's input stream.\n     In the examples in this document, the notation \" |> \" precedes lines\n     where interactive input and output occurs.  Within such a scenario,\n     \"|>>this notation<<|\" notates user input.\n     For example, the notation\n           (+ 1 (print (+ (sqrt (read)) (sqrt (read)))))\n           |>  |>>9 16 <<|\n           |>  7\n          =>  8\n     shows an interaction in which ``(+ 1 (print (+ (sqrt (read)) (sqrt\n     (read)))))\" is a form to be evaluated, ``9 16 \" is interactive input,\n     ``7\" is interactive output, and ``8\" is the value yielded from the\n     evaluation.\n     The use of this notation is intended to disguise small differences in\n     interactive input and output behavior between implementations.\n     Sometimes, the non-interactive stream model calls for a newline.  How\n     that newline character is interactively entered is an\n     implementation-defined detail of the user interface, but in that\n     case, either the notation \"<Newline>\" or \"[<-~]\" might be used.\n           (progn (format t \"~&Who? \") (read-line))\n           |>  Who? |>>Fred, Mary, and Sally[<--~]<<|\n          =>  \"Fred, Mary, and Sally\", false\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Special Symbols,  Next: Objects with Multiple Notations,  Prev: Additional Uses for Indirect Definitions in Modified BNF Syntax,  Up: Notational Conventions\n\nSpecial Symbols\n...............\n\nThe special symbols described here are used as a notational convenience\nwithin this document, and are part of neither the Common Lisp language nor\nits environment.\n\n=>\n     This indicates evaluation.  For example:\n\n           (+ 4 5) =>  9\n\n     This means that the result of evaluating the form (+ 4 5) is 9.\n\n     If a form returns multiple values, those values might be shown\n     separated by spaces, line breaks, or commas.  For example:\n\n           (truncate 7 5)\n          =>  1 2\n           (truncate 7 5)\n          =>  1\n             2\n           (truncate 7 5)\n          =>  1, 2\n\n     Each of the above three examples is equivalent, and specifies that\n     (truncate 7 5) returns two values, which are 1 and 2.\n\n     Some conforming implementations actually type an arrow (or some other\n     indicator) before showing return values, while others do not.\n\nOR=>\n     The notation \"OR=>\" is used to denote one of several possible\n     alternate results.  The example\n\n           (char-name #\\a)\n          =>  NIL\n          OR=> \"LOWERCASE-a\"\n          OR=> \"Small-A\"\n          OR=> \"LA01\"\n\n     indicates that nil, \"LOWERCASE-a\", \"Small-A\", \"LA01\" are among the\n     possible results of (char-name #\\a)--each with equal preference.\n     Unless explicitly specified otherwise, it should not be assumed that\n     the set of possible results shown is exhaustive.  Formally, the above\n     example is equivalent to\n\n           (char-name #\\a) =>  implementation-dependent\n\n     but it is intended to provide additional information to illustrate\n     some of the ways in which it is permitted for implementations to\n     diverge.\n\nNOT=>\n     The notation \"NOT=>\" is used to denote a result which is not possible.\n     This might be used, for example, in order to emphasize a situation\n     where some anticipated misconception might lead the reader to falsely\n     believe that the result might be possible.  For example,\n\n           (function-lambda-expression\n              (funcall #'(lambda (x) #'(lambda () x)) nil))\n          =>  NIL, true, NIL\n          OR=> (LAMBDA () X), true, NIL\n          NOT=> NIL, false, NIL\n          NOT=> (LAMBDA () X), false, NIL\n\n==\n     This indicates code equivalence. For example:\n\n           (gcd x (gcd y z)) == (gcd (gcd x y) z)\n\n     This means that the results and observable side-effects of evaluating\n     the form (gcd x (gcd y z))  are always the same as the results and\n     observable side-effects of (gcd (gcd x y) z)  for any x, y, and z.\n\n |>\n     Common Lisp specifies input and output with respect to a\n     non-interactive stream model.  The specific details of how\n     interactive input and output are mapped onto that non-interactive\n     model are implementation-defined.\n\n     For example, conforming implementations are permitted to differ in\n     issues of how interactive input is terminated.  For example, the\n     function read terminates when the final delimiter is typed on a\n     non-interactive stream.  In some implementations, an interactive call\n     to read returns as soon as the final delimiter is typed, even if that\n     delimiter is not a newline.  In other implementations, a final\n     newline is always required.  In still other implementations, there\n     might be a command which \"activates\" a buffer full of input without\n     the command itself being visible on the program's input stream.\n\n     In the examples in this document, the notation \" |> \" precedes lines\n     where interactive input and output occurs.  Within such a scenario,\n     \"|>>this notation<<|\" notates user input.\n\n     For example, the notation\n\n           (+ 1 (print (+ (sqrt (read)) (sqrt (read)))))\n           |>  |>>9 16 <<|\n           |>  7\n          =>  8\n\n     shows an interaction in which ``(+ 1 (print (+ (sqrt (read)) (sqrt\n     (read)))))\" is a form to be evaluated, ``9 16 \" is interactive input,\n     ``7\" is interactive output, and ``8\" is the value yielded from the\n     evaluation.\n\n     The use of this notation is intended to disguise small differences in\n     interactive input and output behavior between implementations.\n\n     Sometimes, the non-interactive stream model calls for a newline.  How\n     that newline character is interactively entered is an\n     implementation-defined detail of the user interface, but in that\n     case, either the notation \"<Newline>\" or \"[<-~]\" might be used.\n\n           (progn (format t \"~&Who? \") (read-line))\n           |>  Who? |>>Fred, Mary, and Sally[<--~]<<|\n          =>  \"Fred, Mary, and Sally\", false\n\n"
}