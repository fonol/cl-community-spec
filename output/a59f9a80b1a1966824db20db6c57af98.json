{
    "name": "define-setf-expander",
    "prev": "defsetf",
    "next": "get-setf-expansion",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "define-setf-expander"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "define-setf-expander",
                    "text": " access-fn lambda-list [[{declaration}* |documentation]] {form}*\n=>  access-fn\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "access-fn",
                    "desc": "a symbol that names a function or macro.lambda-list - macro lambda list.\n"
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "documentation",
                    "desc": "a string; not evaluated."
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                }
            ]
        },
        {
            "type": "Description",
            "text": "define-setf-expander specifies the means by which setf updates a place\nthat is referenced by access-fn.\nWhen setf is given a place that is specified in terms of access-fn and a\nnew value for the place, it is expanded into a form that performs the\nappropriate update.\nThe lambda-list supports destructuring.  See *Note Macro Lambda Lists::.\nDocumentation is attached to access-fn as a documentation string of kind\nsetf.\nForms constitute the body of the\nsetf expander\ndefinition and must compute the setf expansion for a call on setf that\nreferences the place by means of the given access-fn.\nThe setf expander function is defined in the same lexical environment in\nwhich the define-setf-expander form appears.\nWhile forms are being executed, the variables in lambda-list are bound to\nparts of the place form.\nThe body forms (but not the lambda-list)\nin a define-setf-expander form are implicitly enclosed in a block whose\nname is access-fn.\nThe evaluation of forms must result in the five values described in *Note\nSetf Expansions::.\nIf a define-setf-expander form appears as a top level form, the compiler\nmust make the setf expander available so that it may be used to expand\ncalls to setf later on in the file.  Programmers must ensure that the\nforms can be evaluated at compile time if the access-fn is used in a place\nlater in the same file.  The compiler must make these setf expanders\navailable to compile-time calls to get-setf-expansion when its environment\nargument is a value received as the environment parameter of a macro.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun lastguy (x) (car (last x))) =>  LASTGUY\n      (define-setf-expander lastguy (x &environment env)\n        \"Set the last element in a list to the given value.\"\n        (multiple-value-bind (dummies vals newval setter getter)\n            (get-setf-expansion x env)\n          (let ((store (gensym)))\n            (values dummies\n                    vals\n                    `(,store)\n                    `(progn (rplaca (last ,getter) ,store) ,store)\n                    `(lastguy ,getter))))) =>  LASTGUY\n      (setq a (list 'a 'b 'c 'd)\n            b (list 'x)\n            c (list 1 2 3 (list 4 5 6))) =>  (1 2 3 (4 5 6))\n      (setf (lastguy a) 3) =>  3\n      (setf (lastguy b) 7) =>  7\n      (setf (lastguy (lastguy c)) 'lastguy-symbol) =>  LASTGUY-SYMBOL\n      a =>  (A B C 3)\n      b =>  (7)\n      c =>  (1 2 3 (4 5 LASTGUY-SYMBOL))\n     ;;; Setf expander for the form (LDB bytespec int).\n     ;;; Recall that the int form must itself be suitable for SETF.\n      (define-setf-expander ldb (bytespec int &environment env)\n        (multiple-value-bind (temps vals stores\n                               store-form access-form)\n            (get-setf-expansion int env);Get setf expansion for int.\n          (let ((btemp (gensym))     ;Temp var for byte specifier.\n                (store (gensym))     ;Temp var for byte to store.\n                (stemp (first stores))) ;Temp var for int to store.\n            (if (cdr stores) (error \"Can't expand this.\"))\n     ;;; Return the setf expansion for LDB as five values.\n            (values (cons btemp temps)       ;Temporary variables.\n                    (cons bytespec vals)     ;Value forms.\n                    (list store)             ;Store variables.\n                    `(let ((,stemp (dpb ,store ,btemp ,access-form)))\n                       ,store-form\n                       ,store)               ;Storing form.\n                    `(ldb ,btemp ,access-form) ;Accessing form.\n                   ))))\n"
        },
        {
            "type": "See Also",
            "text": "*Note setf; psetf:: , *Note defsetf:: , *Note documentation; (setf\ndocumentation):: , *Note get-setf-expansion:: , *Note Syntactic\nInteraction of Documentation Strings and Declarations::\n"
        },
        {
            "type": "Notes",
            "text": "define-setf-expander differs from the long form of defsetf in that while\nthe body is being executed the variables in lambda-list are bound to parts\nof the place form, not to temporary variables that will be bound to the\nvalues of such parts.  In addition, define-setf-expander does not have\ndefsetf's restriction that access-fn must be a function or a function-like\nmacro; an arbitrary defmacro destructuring pattern is permitted in\nlambda-list.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: define-setf-expander,  Next: get-setf-expansion,  Prev: defsetf,  Up: Data and Control Flow Dictionary\n\ndefine-setf-expander                                                [Macro]\n---------------------------------------------------------------------------\n\n`define-setf-expander'  access-fn lambda-list [[{declaration}* |\ndocumentation]] {form}*\n=>  access-fn\n\nArguments and Values::\n......................\n\naccess-fn--a symbol that names a function or macro.\n\nlambda-list - macro lambda list.\n\ndeclaration--a declare expression; not evaluated.\n\ndocumentation--a string; not evaluated.\n\nforms--an implicit progn.\n\nDescription::\n.............\n\ndefine-setf-expander specifies the means by which setf updates a place\nthat is referenced by access-fn.\n\nWhen setf is given a place that is specified in terms of access-fn and a\nnew value for the place, it is expanded into a form that performs the\nappropriate update.\n\nThe lambda-list supports destructuring.  See *Note Macro Lambda Lists::.\n\nDocumentation is attached to access-fn as a documentation string of kind\nsetf.\n\nForms constitute the body of the\n\nsetf expander\n\ndefinition and must compute the setf expansion for a call on setf that\nreferences the place by means of the given access-fn.\n\nThe setf expander function is defined in the same lexical environment in\nwhich the define-setf-expander form appears.\n\nWhile forms are being executed, the variables in lambda-list are bound to\nparts of the place form.\n\nThe body forms (but not the lambda-list)\n\nin a define-setf-expander form are implicitly enclosed in a block whose\nname is access-fn.\n\nThe evaluation of forms must result in the five values described in *Note\nSetf Expansions::.\n\nIf a define-setf-expander form appears as a top level form, the compiler\nmust make the setf expander available so that it may be used to expand\ncalls to setf later on in the file.  Programmers must ensure that the\nforms can be evaluated at compile time if the access-fn is used in a place\nlater in the same file.  The compiler must make these setf expanders\navailable to compile-time calls to get-setf-expansion when its environment\nargument is a value received as the environment parameter of a macro.\n\nExamples::\n..........\n\n      (defun lastguy (x) (car (last x))) =>  LASTGUY\n      (define-setf-expander lastguy (x &environment env)\n        \"Set the last element in a list to the given value.\"\n        (multiple-value-bind (dummies vals newval setter getter)\n            (get-setf-expansion x env)\n          (let ((store (gensym)))\n            (values dummies\n                    vals\n                    `(,store)\n                    `(progn (rplaca (last ,getter) ,store) ,store)\n                    `(lastguy ,getter))))) =>  LASTGUY\n      (setq a (list 'a 'b 'c 'd)\n            b (list 'x)\n            c (list 1 2 3 (list 4 5 6))) =>  (1 2 3 (4 5 6))\n      (setf (lastguy a) 3) =>  3\n      (setf (lastguy b) 7) =>  7\n      (setf (lastguy (lastguy c)) 'lastguy-symbol) =>  LASTGUY-SYMBOL\n      a =>  (A B C 3)\n      b =>  (7)\n      c =>  (1 2 3 (4 5 LASTGUY-SYMBOL))\n\n     ;;; Setf expander for the form (LDB bytespec int).\n     ;;; Recall that the int form must itself be suitable for SETF.\n      (define-setf-expander ldb (bytespec int &environment env)\n        (multiple-value-bind (temps vals stores\n                               store-form access-form)\n            (get-setf-expansion int env);Get setf expansion for int.\n          (let ((btemp (gensym))     ;Temp var for byte specifier.\n                (store (gensym))     ;Temp var for byte to store.\n                (stemp (first stores))) ;Temp var for int to store.\n            (if (cdr stores) (error \"Can't expand this.\"))\n     ;;; Return the setf expansion for LDB as five values.\n            (values (cons btemp temps)       ;Temporary variables.\n                    (cons bytespec vals)     ;Value forms.\n                    (list store)             ;Store variables.\n                    `(let ((,stemp (dpb ,store ,btemp ,access-form)))\n                       ,store-form\n                       ,store)               ;Storing form.\n                    `(ldb ,btemp ,access-form) ;Accessing form.\n                   ))))\n\nSee Also::\n..........\n\n*Note setf; psetf:: , *Note defsetf:: , *Note documentation; (setf\ndocumentation):: , *Note get-setf-expansion:: , *Note Syntactic\nInteraction of Documentation Strings and Declarations::\n\nNotes::\n.......\n\ndefine-setf-expander differs from the long form of defsetf in that while\nthe body is being executed the variables in lambda-list are bound to parts\nof the place form, not to temporary variables that will be bound to the\nvalues of such parts.  In addition, define-setf-expander does not have\ndefsetf's restriction that access-fn must be a function or a function-like\nmacro; an arbitrary defmacro destructuring pattern is permitted in\nlambda-list.\n\n"
}