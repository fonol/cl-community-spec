{
    "name": "mapc",
    "prev": "member",
    "next": "acons",
    "up": "Conses Dictionary",
    "header": {
        "type": "Function",
        "text": "mapc, mapcar, mapcan, mapl, maplist, mapcon"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "mapc",
                    "text": " function &rest lists^+ =>  list-1\n"
                },
                {
                    "name": "mapcar",
                    "text": " function &rest lists^+ =>  result-list\n\n"
                },
                {
                    "name": "mapcan",
                    "text": " function &rest lists^+ =>  concatenated-results\n\n"
                },
                {
                    "name": "mapl",
                    "text": " function &rest lists^+ =>  list-1\n\n"
                },
                {
                    "name": "maplist",
                    "text": " function &rest lists^+ =>  result-list\n\n"
                },
                {
                    "name": "mapcon",
                    "text": " function &rest lists^+ =>  concatenated-results\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "function",
                    "desc": "a designator for a function that must take as many arguments as"
                },
                {
                    "name": "function",
                    "desc": "a designator for a function that must take as many arguments asthere are lists.\n"
                },
                {
                    "name": "list",
                    "desc": "a proper list."
                },
                {
                    "name": "list-1",
                    "desc": "the first list (which must be a proper list)."
                },
                {
                    "name": "result-list",
                    "desc": "a list."
                },
                {
                    "name": "concatenated-results",
                    "desc": "a list."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The mapping operation involves applying function to successive sets of\narguments in which one argument is obtained from each sequence.  Except\nfor mapc and mapl, the result contains the results returned by function.\nIn the cases of mapc and mapl, the resulting sequence is list.\nfunction is called first on all the elements with index 0, then on all\nthose with index 1, and so on.  result-type specifies the type of the\nresulting sequence.\nIf function is a symbol, it is coerced to a function as if by\nsymbol-function.\nmapcar operates on successive elements of the lists.  function is applied\nto the first element of each list, then to the second element of each\nlist, and so on.  The iteration terminates when the shortest list runs out,\nand excess elements in other lists are ignored.  The value returned by\nmapcar is a list of the results of successive calls to function.\nmapc is like mapcar except that the results of applying function are not\naccumulated.  The list argument is returned.\nmaplist is like mapcar except that function is applied to successive\nsublists of the lists.  function is first applied to the lists themselves,\nand then to the cdr of each list, and then to the cdr of the cdr of each\nlist, and so on.\nmapl is like maplist except that the results of applying function are not\naccumulated; list-1 is returned.\nmapcan and mapcon are like mapcar and maplist respectively, except that\nthe results of applying function are combined into a list by the use of\nnconc rather than list.  That is,\n      (mapcon f x1 ... xn)\n        == (apply #'nconc (maplist f x1 ... xn))\nand similarly for the relationship between mapcan and mapcar.\n"
        },
        {
            "type": "Examples",
            "text": "      (mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3)\n      (mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)\n      (mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))\n      (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3))\n     =>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3))\n      (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))\n     =>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))\n      (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))\n     =>  (0 0 1 0 1 1 1)\n     ;An entry is 1 if the corresponding element of the input\n     ;  list was the last instance of that element in the input list.\n      (setq dummy nil) =>  NIL\n      (mapc #'(lambda (&rest x) (setq dummy (append dummy x)))\n             '(1 2 3 4)\n             '(a b c d e)\n             '(x y z)) =>  (1 2 3 4)\n      dummy =>  (1 A X 2 B Y 3 C Z)\n      (setq dummy nil) =>  NIL\n      (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4)\n      dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4))\n      (mapcan #'(lambda (x y) (if (null x) nil (list x y)))\n               '(nil nil nil d e)\n               '(1 2 3 4 5 6)) =>  (D 4 E 5)\n      (mapcan #'(lambda (x) (and (numberp x) (list x)))\n               '(a 1 b c 3 4 d 5))\n     =>  (1 3 4 5)\nIn this case the function serves as a filter; this is a standard Lisp\nidiom using mapcan.\n      (mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4))\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should be prepared to signal an error of type type-error if any list is\nnot a proper list.\n"
        },
        {
            "type": "See Also",
            "text": "*Note dolist:: , *Note map:: ,\n*Note Traversal Rules and Side Effects::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: mapc,  Next: acons,  Prev: member,  Up: Conses Dictionary\n\nmapc, mapcar, mapcan, mapl, maplist, mapcon                      [Function]\n---------------------------------------------------------------------------\n\n`mapc'  function &rest lists^+ =>  list-1\n\n`mapcar'  function &rest lists^+ =>  result-list\n\n`mapcan'  function &rest lists^+ =>  concatenated-results\n\n`mapl'  function &rest lists^+ =>  list-1\n\n`maplist'  function &rest lists^+ =>  result-list\n\n`mapcon'  function &rest lists^+ =>  concatenated-results\n\nArguments and Values::\n......................\n\nfunction--a designator for a function that must take as many arguments as\nthere are lists.\n\nlist--a proper list.\n\nlist-1--the first list (which must be a proper list).\n\nresult-list--a list.\n\nconcatenated-results--a list.\n\nDescription::\n.............\n\nThe mapping operation involves applying function to successive sets of\narguments in which one argument is obtained from each sequence.  Except\nfor mapc and mapl, the result contains the results returned by function.\nIn the cases of mapc and mapl, the resulting sequence is list.\n\nfunction is called first on all the elements with index 0, then on all\nthose with index 1, and so on.  result-type specifies the type of the\nresulting sequence.\n\nIf function is a symbol, it is coerced to a function as if by\nsymbol-function.\n\nmapcar operates on successive elements of the lists.  function is applied\nto the first element of each list, then to the second element of each\nlist, and so on.  The iteration terminates when the shortest list runs out,\nand excess elements in other lists are ignored.  The value returned by\nmapcar is a list of the results of successive calls to function.\n\nmapc is like mapcar except that the results of applying function are not\naccumulated.  The list argument is returned.\n\nmaplist is like mapcar except that function is applied to successive\nsublists of the lists.  function is first applied to the lists themselves,\nand then to the cdr of each list, and then to the cdr of the cdr of each\nlist, and so on.\n\nmapl is like maplist except that the results of applying function are not\naccumulated; list-1 is returned.\n\nmapcan and mapcon are like mapcar and maplist respectively, except that\nthe results of applying function are combined into a list by the use of\nnconc rather than list.  That is,\n\n      (mapcon f x1 ... xn)\n        == (apply #'nconc (maplist f x1 ... xn))\n\nand similarly for the relationship between mapcan and mapcar.\n\nExamples::\n..........\n\n      (mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3)\n      (mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)\n      (mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))\n     \n      (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3))\n     =>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3))\n      (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))\n     =>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))\n      (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))\n     =>  (0 0 1 0 1 1 1)\n     ;An entry is 1 if the corresponding element of the input\n     ;  list was the last instance of that element in the input list.\n     \n      (setq dummy nil) =>  NIL\n      (mapc #'(lambda (&rest x) (setq dummy (append dummy x)))\n             '(1 2 3 4)\n             '(a b c d e)\n             '(x y z)) =>  (1 2 3 4)\n      dummy =>  (1 A X 2 B Y 3 C Z)\n     \n      (setq dummy nil) =>  NIL\n      (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4)\n      dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4))\n     \n      (mapcan #'(lambda (x y) (if (null x) nil (list x y)))\n               '(nil nil nil d e)\n               '(1 2 3 4 5 6)) =>  (D 4 E 5)\n      (mapcan #'(lambda (x) (and (numberp x) (list x)))\n               '(a 1 b c 3 4 d 5))\n     =>  (1 3 4 5)\n\nIn this case the function serves as a filter; this is a standard Lisp\nidiom using mapcan.\n\n      (mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4))\n\nExceptional Situations::\n........................\n\nShould be prepared to signal an error of type type-error if any list is\nnot a proper list.\n\nSee Also::\n..........\n\n*Note dolist:: , *Note map:: ,\n\n*Note Traversal Rules and Side Effects::\n\n"
}