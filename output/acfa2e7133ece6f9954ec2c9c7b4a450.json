{
    "name": "*debug-io*",
    "prev": "with-output-to-string",
    "next": "*terminal-io*",
    "up": "Streams Dictionary",
    "header": {
        "type": null,
        "text": "*trace-output*"
    },
    "sections": [
        {
            "type": "",
            "text": "                                                                [Variable]\n"
        },
        {
            "type": "Value Type",
            "text": "For *standard-input*: an input stream\nFor *error-output*, *standard-output*, and *trace-output*: an output\nstream.\nFor *debug-io*, *query-io*: a bidirectional stream.\n"
        },
        {
            "type": "Initial Value",
            "text": "implementation-dependent, but it must be an open stream that is not a\ngeneralized synonym stream to an I/O customization variables but that\nmight be a generalized synonym stream to the value of some I/O\ncustomization variable.  The initial value might also be a generalized\nsynonym stream to either the symbol *terminal-io* or to the stream that is\nits value.\n"
        },
        {
            "type": "Description",
            "text": "These variables are collectively called the standardized I/O customization\nvariables.  They can be bound or assigned in order to change the default\ndestinations for input and/or output used by various standardized\noperators and facilities.\nThe value of *debug-io*, called debug I/O, is a stream to be used for\ninteractive debugging purposes.\nThe value of *error-output*, called error output, is a stream to which\nwarnings and non-interactive error messages should be sent.\nThe value of *query-io*, called query I/O, is a bidirectional stream to be\nused when asking questions of the user.  The question should be output to\nthis stream, and the answer read from it.\nThe value of *standard-input*, called standard input, is a stream that is\nused by many operators as a default source of input when no specific input\nstream is explicitly supplied.\nThe value of *standard-output*, called standard output, is a stream that\nis used by many operators as a default destination for output when no\nspecific output stream is explicitly supplied.\nThe value of *trace-output*, called trace output, is the stream on which\ntraced functions (see trace) and the time macro print their output.\n"
        },
        {
            "type": "Examples",
            "text": "      (with-output-to-string (*error-output*)\n        (warn \"this string is sent to *error-output*\"))\n      =>  \"Warning: this string is sent to *error-output*\n     \" ;The exact format of this string is implementation-dependent.\n      (with-input-from-string (*standard-input* \"1001\")\n         (+ 990 (read))) =>  1991\n      (progn (setq out (with-output-to-string (*standard-output*)\n                          (print \"print and format t send things to\")\n                          (format t \"*standard-output* now going to a string\")))\n             :done)\n     =>  :DONE\n      out\n     =>  \"\n     \\\"print and format t send things to\\\" *standard-output* now going to a string\"\n      (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))\n     =>  FACT\n      (trace fact)\n     =>  (FACT)\n     ;; Of course, the format of traced output is implementation-dependent.\n      (with-output-to-string (*trace-output*)\n        (fact 3))\n     =>  \"\n     1 Enter FACT 3\n     | 2 Enter FACT 2\n     |   3 Enter FACT 1\n     |   3 Exit FACT 1\n     | 2 Exit FACT 2\n     1 Exit FACT 6\"\n"
        },
        {
            "type": "See Also",
            "text": "*terminal-io*, synonym-stream, *Note Time:: , *Note trace; untrace:: ,\n*Note Conditions::, *Note Reader::, *Note Printer::\n"
        },
        {
            "type": "Notes",
            "text": "The intent of the constraints on the initial value of the I/O\ncustomization variables is to ensure that it is always safe to bind or\nassign such a variable to the value of another I/O customization variable,\nwithout unduly restricting implementation flexibility.\nIt is common for an implementation to make the initial values of\n*debug-io* and *query-io* be the same stream, and to make the initial\nvalues of *error-output* and *standard-output* be the same stream.\nThe functions y-or-n-p and yes-or-no-p use query I/O for their input and\noutput.\nIn the normal Lisp read-eval-print loop, input is read from standard input.\nMany input functions, including read and read-char, take a stream argument\nthat defaults to standard input.\nIn the normal Lisp read-eval-print loop, output is sent to standard output.\nMany output functions, including print and write-char, take a stream\nargument that defaults to standard output.\nA program that wants, for example, to divert output to a file should do so\nby binding *standard-output*; that way error messages sent to\n*error-output* can still get to the user by going through *terminal-io*\n(if *error-output* is bound to *terminal-io*), which is usually what is\ndesired.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: *debug-io*,  Next: *terminal-io*,  Prev: with-output-to-string,  Up: Streams Dictionary\n\n*debug-io*, *error-output*, *query-io*,\n---------------------------------------\n\n*standard-input*, *standard-output*,\n------------------------------------\n\n*trace-output*\n--------------\n\n                                                                [Variable]\n\nValue Type::\n............\n\nFor *standard-input*: an input stream\n\nFor *error-output*, *standard-output*, and *trace-output*: an output\nstream.\n\nFor *debug-io*, *query-io*: a bidirectional stream.\n\nInitial Value::\n...............\n\nimplementation-dependent, but it must be an open stream that is not a\ngeneralized synonym stream to an I/O customization variables but that\nmight be a generalized synonym stream to the value of some I/O\ncustomization variable.  The initial value might also be a generalized\nsynonym stream to either the symbol *terminal-io* or to the stream that is\nits value.\n\nDescription::\n.............\n\nThese variables are collectively called the standardized I/O customization\nvariables.  They can be bound or assigned in order to change the default\ndestinations for input and/or output used by various standardized\noperators and facilities.\n\nThe value of *debug-io*, called debug I/O, is a stream to be used for\ninteractive debugging purposes.\n\nThe value of *error-output*, called error output, is a stream to which\nwarnings and non-interactive error messages should be sent.\n\nThe value of *query-io*, called query I/O, is a bidirectional stream to be\nused when asking questions of the user.  The question should be output to\nthis stream, and the answer read from it.\n\nThe value of *standard-input*, called standard input, is a stream that is\nused by many operators as a default source of input when no specific input\nstream is explicitly supplied.\n\nThe value of *standard-output*, called standard output, is a stream that\nis used by many operators as a default destination for output when no\nspecific output stream is explicitly supplied.\n\nThe value of *trace-output*, called trace output, is the stream on which\ntraced functions (see trace) and the time macro print their output.\n\nExamples::\n..........\n\n      (with-output-to-string (*error-output*)\n        (warn \"this string is sent to *error-output*\"))\n      =>  \"Warning: this string is sent to *error-output*\n     \" ;The exact format of this string is implementation-dependent.\n     \n      (with-input-from-string (*standard-input* \"1001\")\n         (+ 990 (read))) =>  1991\n     \n      (progn (setq out (with-output-to-string (*standard-output*)\n                          (print \"print and format t send things to\")\n                          (format t \"*standard-output* now going to a string\")))\n             :done)\n     =>  :DONE\n      out\n     =>  \"\n     \\\"print and format t send things to\\\" *standard-output* now going to a string\"\n     \n      (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))\n     =>  FACT\n      (trace fact)\n     =>  (FACT)\n     ;; Of course, the format of traced output is implementation-dependent.\n      (with-output-to-string (*trace-output*)\n        (fact 3))\n     =>  \"\n     1 Enter FACT 3\n     | 2 Enter FACT 2\n     |   3 Enter FACT 1\n     |   3 Exit FACT 1\n     | 2 Exit FACT 2\n     1 Exit FACT 6\"\n\nSee Also::\n..........\n\n*terminal-io*, synonym-stream, *Note Time:: , *Note trace; untrace:: ,\n*Note Conditions::, *Note Reader::, *Note Printer::\n\nNotes::\n.......\n\nThe intent of the constraints on the initial value of the I/O\ncustomization variables is to ensure that it is always safe to bind or\nassign such a variable to the value of another I/O customization variable,\nwithout unduly restricting implementation flexibility.\n\nIt is common for an implementation to make the initial values of\n*debug-io* and *query-io* be the same stream, and to make the initial\nvalues of *error-output* and *standard-output* be the same stream.\n\nThe functions y-or-n-p and yes-or-no-p use query I/O for their input and\noutput.\n\nIn the normal Lisp read-eval-print loop, input is read from standard input.\nMany input functions, including read and read-char, take a stream argument\nthat defaults to standard input.\n\nIn the normal Lisp read-eval-print loop, output is sent to standard output.\nMany output functions, including print and write-char, take a stream\nargument that defaults to standard output.\n\nA program that wants, for example, to divert output to a file should do so\nby binding *standard-output*; that way error messages sent to\n*error-output* can still get to the user by going through *terminal-io*\n(if *error-output* is bound to *terminal-io*), which is usually what is\ndesired.\n\n"
}