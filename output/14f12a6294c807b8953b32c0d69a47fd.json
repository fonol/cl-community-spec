{
    "name": "Type Specifiers",
    "prev": "Type Relationships",
    "next": null,
    "up": "Types",
    "header": {
        "type": null,
        "text": "Type Specifiers"
    },
    "sections": [
        {
            "type": "",
            "text": "Type specifiers can be symbols, classes, or lists.  Figure~4-2 lists\nsymbols that are standardized atomic type specifiers, and Figure~4-3 lists\nstandardized compound type specifier names.  For syntax information, see\nthe dictionary entry for the corresponding type specifier.  It is possible\nto define new type specifiers using defclass, define-condition, defstruct,\nor deftype.\n arithmetic-error                 function           simple-condition          \n array                            generic-function   simple-error              \n atom                             hash-table         simple-string             \n base-char                        integer            simple-type-error         \n base-string                      keyword            simple-vector             \n bignum                           list               simple-warning            \n bit                              logical-pathname   single-float              \n bit-vector                       long-float         standard-char             \n broadcast-stream                 method             standard-class            \n built-in-class                   method-combination standard-generic-function \n cell-error                       nil                standard-method           \n character                        null               standard-object           \n class                            number             storage-condition         \n compiled-function                package            stream                    \n complex                          package-error      stream-error              \n concatenated-stream              parse-error        string                    \n condition                        pathname           string-stream             \n cons                             print-not-readable structure-class           \n control-error                    program-error      structure-object          \n division-by-zero                 random-state       style-warning             \n double-float                     ratio              symbol                    \n echo-stream                      rational           synonym-stream            \n end-of-file                      reader-error       t                         \n error                            readtable          two-way-stream            \n extended-char                    real               type-error                \n file-error                       restart            unbound-slot              \n file-stream                      sequence           unbound-variable          \n fixnum                           serious-condition  undefined-function        \n float                            short-float        unsigned-byte             \n floating-point-inexact           signed-byte        vector                    \n floating-point-invalid-operation simple-array       warning                   \n floating-point-overflow          simple-base-string                           \n floating-point-underflow         simple-bit-vector                            \n                 Figure 4-2: Standardized Atomic Type Specifiers               \n\\indent If a type specifier is a list, the car of the list is a symbol,\nand the rest of the list is subsidiary type information.  Such a type\nspecifier is called a compound type specifier .  Except as explicitly\nstated otherwise, the subsidiary items can be unspecified.  The\nunspecified subsidiary items are indicated by writing *.  For example, to\ncompletely specify a vector, the type of the elements and the length of\nthe vector must be present.\n      (vector double-float 100)\nThe following leaves the length unspecified:\n      (vector double-float *)\nThe following leaves the element type unspecified:\n      (vector * 100)\nSuppose that two type specifiers are the same except that the first has a\n* where the second has a more explicit specification.  Then the second\ndenotes a subtype of the type denoted by the first.\nIf a list has one or more unspecified items at the end, those items can be\ndropped.  If dropping all occurrences of * results in a singleton list,\nthen the parentheses can be dropped as well (the list can be replaced by\nthe symbol in its car).  For example, (vector double-float *) can be\nabbreviated to (vector double-float), and (vector * *) can be abbreviated\nto (vector) and then to vector.\n  and           long-float    simple-base-string  \n  array         member        simple-bit-vector   \n  base-string   mod           simple-string       \n  bit-vector    not           simple-vector       \n  complex       or            single-float        \n  cons          rational      string              \n  double-float  real          unsigned-byte       \n  eql           satisfies     values              \n  float         short-float   vector              \n  function      signed-byte                       \n  integer       simple-array                      \n  Figure 4-3: Standardized Compound Type Specifier Names\nFigure 4-4 show the defined names that can be used as compound type\nspecifier names but that cannot be used as atomic type specifiers.\n  and     mod  satisfies     eql     not  values     \n  member  or              \n  Figure 4-4: Standardized Compound-Only Type Specifier Names\nNew type specifiers can come into existence in two ways.\n*\n     Defining a structure by using defstruct without using the :type\n     specifier or defining a class by using defclass or define-condition\n     automatically causes the name of the structure or class to be a new\n     type specifier symbol.\n*\n     deftype can be used to define derived type specifiers , which act as\n     `abbreviations' for other type specifiers.\nA class object can be used as a type specifier.  When used this way, it\ndenotes the set of all members of that class.\nFigure 4-5 shows some defined names relating to types and declarations.\n  coerce            defstruct  subtypep  \n  declaim           deftype    the       \n  declare           ftype      type      \n  defclass          locally    type-of   \n  define-condition  proclaim   typep     \n  Figure 4-5: Defined names relating to types and declarations.\nFigure 4-6 shows all defined names that are type specifier names, whether\nfor atomic type specifiers or compound type specifiers; this list is the\nunion of the lists in Figure~4-2 and Figure~4-3.\n and                              function           simple-array              \n arithmetic-error                 generic-function   simple-base-string        \n array                            hash-table         simple-bit-vector         \n atom                             integer            simple-condition          \n base-char                        keyword            simple-error              \n base-string                      list               simple-string             \n bignum                           logical-pathname   simple-type-error         \n bit                              long-float         simple-vector             \n bit-vector                       member             simple-warning            \n broadcast-stream                 method             single-float              \n built-in-class                   method-combination standard-char             \n cell-error                       mod                standard-class            \n character                        nil                standard-generic-function \n class                            not                standard-method           \n compiled-function                null               standard-object           \n complex                          number             storage-condition         \n concatenated-stream              or                 stream                    \n condition                        package            stream-error              \n cons                             package-error      string                    \n control-error                    parse-error        string-stream             \n division-by-zero                 pathname           structure-class           \n double-float                     print-not-readable structure-object          \n echo-stream                      program-error      style-warning             \n end-of-file                      random-state       symbol                    \n eql                              ratio              synonym-stream            \n error                            rational           t                         \n extended-char                    reader-error       two-way-stream            \n file-error                       readtable          type-error                \n file-stream                      real               unbound-slot              \n fixnum                           restart            unbound-variable          \n float                            satisfies          undefined-function        \n floating-point-inexact           sequence           unsigned-byte             \n floating-point-invalid-operation serious-condition  values                    \n floating-point-overflow          short-float        vector                    \n floating-point-underflow         signed-byte        warning                   \n                  Figure 4-6: Standardized Type Specifier Names                \n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Type Specifiers,  Prev: Type Relationships,  Up: Types\n\nType Specifiers\n---------------\n\nType specifiers can be symbols, classes, or lists.  Figure~4-2 lists\nsymbols that are standardized atomic type specifiers, and Figure~4-3 lists\nstandardized compound type specifier names.  For syntax information, see\nthe dictionary entry for the corresponding type specifier.  It is possible\nto define new type specifiers using defclass, define-condition, defstruct,\nor deftype.\n\n arithmetic-error                 function           simple-condition          \n array                            generic-function   simple-error              \n atom                             hash-table         simple-string             \n base-char                        integer            simple-type-error         \n base-string                      keyword            simple-vector             \n bignum                           list               simple-warning            \n bit                              logical-pathname   single-float              \n bit-vector                       long-float         standard-char             \n broadcast-stream                 method             standard-class            \n built-in-class                   method-combination standard-generic-function \n cell-error                       nil                standard-method           \n character                        null               standard-object           \n class                            number             storage-condition         \n compiled-function                package            stream                    \n complex                          package-error      stream-error              \n concatenated-stream              parse-error        string                    \n condition                        pathname           string-stream             \n cons                             print-not-readable structure-class           \n control-error                    program-error      structure-object          \n division-by-zero                 random-state       style-warning             \n double-float                     ratio              symbol                    \n echo-stream                      rational           synonym-stream            \n end-of-file                      reader-error       t                         \n error                            readtable          two-way-stream            \n extended-char                    real               type-error                \n file-error                       restart            unbound-slot              \n file-stream                      sequence           unbound-variable          \n fixnum                           serious-condition  undefined-function        \n float                            short-float        unsigned-byte             \n floating-point-inexact           signed-byte        vector                    \n floating-point-invalid-operation simple-array       warning                   \n floating-point-overflow          simple-base-string                           \n floating-point-underflow         simple-bit-vector                            \n\n                 Figure 4-2: Standardized Atomic Type Specifiers               \n\n\n\\indent If a type specifier is a list, the car of the list is a symbol,\nand the rest of the list is subsidiary type information.  Such a type\nspecifier is called a compound type specifier .  Except as explicitly\nstated otherwise, the subsidiary items can be unspecified.  The\nunspecified subsidiary items are indicated by writing *.  For example, to\ncompletely specify a vector, the type of the elements and the length of\nthe vector must be present.\n\n      (vector double-float 100)\n\nThe following leaves the length unspecified:\n\n      (vector double-float *)\n\nThe following leaves the element type unspecified:\n\n      (vector * 100)\n\nSuppose that two type specifiers are the same except that the first has a\n* where the second has a more explicit specification.  Then the second\ndenotes a subtype of the type denoted by the first.\n\nIf a list has one or more unspecified items at the end, those items can be\ndropped.  If dropping all occurrences of * results in a singleton list,\nthen the parentheses can be dropped as well (the list can be replaced by\nthe symbol in its car).  For example, (vector double-float *) can be\nabbreviated to (vector double-float), and (vector * *) can be abbreviated\nto (vector) and then to vector.\n\n  and           long-float    simple-base-string  \n  array         member        simple-bit-vector   \n  base-string   mod           simple-string       \n  bit-vector    not           simple-vector       \n  complex       or            single-float        \n  cons          rational      string              \n  double-float  real          unsigned-byte       \n  eql           satisfies     values              \n  float         short-float   vector              \n  function      signed-byte                       \n  integer       simple-array                      \n\n  Figure 4-3: Standardized Compound Type Specifier Names\n\n\nFigure 4-4 show the defined names that can be used as compound type\nspecifier names but that cannot be used as atomic type specifiers.\n\n  and     mod  satisfies     eql     not  values     \n  member  or              \n\n  Figure 4-4: Standardized Compound-Only Type Specifier Names\n\n\nNew type specifiers can come into existence in two ways.\n*\n     Defining a structure by using defstruct without using the :type\n     specifier or defining a class by using defclass or define-condition\n     automatically causes the name of the structure or class to be a new\n     type specifier symbol.\n\n*\n     deftype can be used to define derived type specifiers , which act as\n     `abbreviations' for other type specifiers.\n\nA class object can be used as a type specifier.  When used this way, it\ndenotes the set of all members of that class.\n\nFigure 4-5 shows some defined names relating to types and declarations.\n\n  coerce            defstruct  subtypep  \n  declaim           deftype    the       \n  declare           ftype      type      \n  defclass          locally    type-of   \n  define-condition  proclaim   typep     \n\n  Figure 4-5: Defined names relating to types and declarations.\n\n\nFigure 4-6 shows all defined names that are type specifier names, whether\nfor atomic type specifiers or compound type specifiers; this list is the\nunion of the lists in Figure~4-2 and Figure~4-3.\n\n and                              function           simple-array              \n arithmetic-error                 generic-function   simple-base-string        \n array                            hash-table         simple-bit-vector         \n atom                             integer            simple-condition          \n base-char                        keyword            simple-error              \n base-string                      list               simple-string             \n bignum                           logical-pathname   simple-type-error         \n bit                              long-float         simple-vector             \n bit-vector                       member             simple-warning            \n broadcast-stream                 method             single-float              \n built-in-class                   method-combination standard-char             \n cell-error                       mod                standard-class            \n character                        nil                standard-generic-function \n class                            not                standard-method           \n compiled-function                null               standard-object           \n complex                          number             storage-condition         \n concatenated-stream              or                 stream                    \n condition                        package            stream-error              \n cons                             package-error      string                    \n control-error                    parse-error        string-stream             \n division-by-zero                 pathname           structure-class           \n double-float                     print-not-readable structure-object          \n echo-stream                      program-error      style-warning             \n end-of-file                      random-state       symbol                    \n eql                              ratio              synonym-stream            \n error                            rational           t                         \n extended-char                    reader-error       two-way-stream            \n file-error                       readtable          type-error                \n file-stream                      real               unbound-slot              \n fixnum                           restart            unbound-variable          \n float                            satisfies          undefined-function        \n floating-point-inexact           sequence           unsigned-byte             \n floating-point-invalid-operation serious-condition  values                    \n floating-point-overflow          short-float        vector                    \n floating-point-underflow         signed-byte        warning                   \n\n                  Figure 4-6: Standardized Type Specifier Names                \n\n\n"
}