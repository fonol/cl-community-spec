{
    "name": "do",
    "prev": "Iteration Dictionary",
    "next": "dotimes",
    "up": "Iteration Dictionary",
    "header": {
        "type": "Macro",
        "text": "do, do*"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "do",
                    "text": " ({var | (var [init-form [step-form]])}*) (end-test-form{result-form}*) {declaration}* {tag | statement}*\n=>  {result}*\n\n"
                },
                {
                    "name": "do*",
                    "text": " ({var | (var [init-form [step-form]])}*) (end-test-form\n{result-form}*) {declaration}* {tag | statement}*\n=>  {result}*\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "var",
                    "desc": "a symbol."
                },
                {
                    "name": "init-form",
                    "desc": "a form."
                },
                {
                    "name": "step-form",
                    "desc": "a form."
                },
                {
                    "name": "end-test-form",
                    "desc": "a form."
                },
                {
                    "name": "result-forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "tag",
                    "desc": "a go tag; not evaluated."
                },
                {
                    "name": "statement",
                    "desc": "a compound form; evaluated as described below."
                },
                {
                    "name": "results",
                    "desc": "if a return or return-from form is executed, the values passed"
                }
            ]
        },
        {
            "type": "Description",
            "text": "do iterates over a group of statements while a test condition holds.  do\naccepts an arbitrary number of iteration vars which are bound within the\niteration and stepped in parallel.  An initial value may be supplied for\neach iteration variable by use of an init-form.  Step-forms may be used to\nspecify how the vars should be updated on succeeding iterations through\nthe loop.  Step-forms may be used both to generate successive values or to\naccumulate results.  If the end-test-form condition is met prior to an\nexecution of the body, the iteration terminates.  Tags label statements.\ndo* is exactly like do except that the bindings and steppings of the vars\nare performed sequentially rather than in parallel.\nBefore the first iteration, all the init-forms are evaluated, and each var\nis bound to the value of its respective init-form, if supplied.  This is a\nbinding, not an assignment; when the loop terminates, the old values of\nthose variables will be restored.  For do, all of the init-forms are\nevaluated before any var is bound. The init-forms can refer to the\nbindings of the vars visible before beginning execution of do.  For do*,\nthe first init-form is evaluated, then the first var is bound to that\nvalue, then the second init-form is evaluated, then the second var is\nbound, and so on; in general, the kth init-form can refer to the new\nbinding of the jth var if j < k, and otherwise to the old binding of the\njth var.\nAt the beginning of each iteration, after processing the variables, the\nend-test-form is evaluated.  If the result is false, execution proceeds\nwith the body of the do (or do*) form.  If the result is true, the\nresult-forms are evaluated in order as an implicit progn, and then do or\ndo* returns.\nAt the beginning of each iteration other than the first, vars are updated\nas follows.  All the step-forms, if supplied, are evaluated, from left to\nright, and the resulting values are assigned to the respective vars.  Any\nvar that has no associated step-form is not assigned to.  For do, all the\nstep-forms are evaluated before any var is updated; the assignment of\nvalues to vars is done in parallel, as if by psetq.  Because all of the\nstep-forms are evaluated before any of the vars are altered, a step-form\nwhen evaluated always has access to the old values of all the vars, even\nif other step-forms precede it.  For do*, the first step-form is\nevaluated, then the value is assigned to the first var, then the second\nstep-form is evaluated, then the value is assigned to the second var, and\nso on; the assignment of values to variables is done sequentially, as if\nby setq.  For either do or do*, after the vars have been updated, the\nend-test-form is evaluated as described above, and the iteration continues.\nThe remainder of the do (or do*) form constitutes an implicit tagbody.\nTags may appear within the body of a do loop for use by go statements\nappearing in the body (but such go statements may not appear in the\nvariable specifiers, the end-test-form, or the result-forms).  When the\nend of a do body is reached, the next iteration cycle (beginning with the\nevaluation of step-forms) occurs.\nAn implicit block named nil surrounds the entire do (or do*) form.  A\nreturn statement may be used at any point to exit the loop immediately.\nInit-form  is an initial value for the var with which it is associated.\nIf init-form is omitted, the initial value of var is nil.  If a\ndeclaration is supplied for a var, init-form must be consistent with the\ndeclaration.\nDeclarations can appear at the beginning of a do (or do*) body.  They\napply to code in the do (or do*) body, to the bindings of the do (or do*)\nvars, to the step-forms, to the end-test-form, and to the result-forms.\n"
        },
        {
            "type": "Examples",
            "text": "      (do ((temp-one 1 (1+ temp-one))\n            (temp-two 0 (1- temp-two)))\n           ((> (- temp-one temp-two) 5) temp-one)) =>  4\n      (do ((temp-one 1 (1+ temp-one))\n            (temp-two 0 (1+ temp-one)))\n           ((= 3 temp-two) temp-one)) =>  3\n      (do* ((temp-one 1 (1+ temp-one))\n             (temp-two 0 (1+ temp-one)))\n            ((= 3 temp-two) temp-one)) =>  2\n      (do ((j 0 (+ j 1)))\n          (nil)                       ;Do forever.\n        (format t \"~\n        (let ((item (read)))\n          (if (null item) (return)   ;Process items until NIL seen.\n              (format t \"~&Output ~D: ~S\" j item))))\n      |>  Input 0: |>>banana<<|\n      |>  Output 0: BANANA\n      |>  Input 1: |>>(57 boxes)<<|\n      |>  Output 1: (57 BOXES)\n      |>  Input 2: |>>NIL<<|\n     =>  NIL\n      (setq a-vector (vector 1 nil 3 nil))\n      (do ((i 0 (+ i 1))     ;Sets every null element of a-vector to zero.\n           (n (array-dimension a-vector 0)))\n          ((= i n))\n        (when (null (aref a-vector i))\n          (setf (aref a-vector i) 0))) =>  NIL\n     a-vector =>  #(1 0 3 0)\n      (do ((x e (cdr x))\n           (oldx x x))\n          ((null x))\n        body)\nis an example of parallel assignment to index variables.  On the first\niteration, the value of oldx is whatever value x had before the do was\nentered.  On succeeding iterations, oldx contains the value that x had on\nthe previous iteration.\n      (do ((x foo (cdr x))\n           (y bar (cdr y))\n           (z '() (cons (f (car x) (car y)) z)))\n          ((or (null x) (null y))\n           (nreverse z)))\ndoes the same thing as (mapcar #'f foo bar).  The step computation for z\nis an example of the fact that variables are stepped in parallel.  Also,\nthe body of the loop is empty.\n      (defun list-reverse (list)\n             (do ((x list (cdr x))\n                  (y '() (cons (car x) y)))\n                 ((endp x) y)))\nAs an example of nested iterations, consider a data structure that is a\nlist of conses. The car of each cons is a list of symbols, and the cdr of\neach cons is a list of equal length containing corresponding values.  Such\na data structure is similar to an association list, but is divided into\n\"frames\"; the overall structure resembles a rib-cage.  A lookup function\non such a data structure might be:\n      (defun ribcage-lookup (sym ribcage)\n             (do ((r ribcage (cdr r)))\n                 ((null r) nil)\n               (do ((s (caar r) (cdr s))\n                    (v (cdar r) (cdr v)))\n                   ((null s))\n                 (when (eq (car s) sym)\n                   (return-from ribcage-lookup (car v)))))) =>  RIBCAGE-LOOKUP\n"
        },
        {
            "type": "See Also",
            "text": "other iteration functions ( *Note dolist:: , *Note dotimes:: , and *Note\nloop:: ) and more primitive functionality ( *Note tagbody:: , *Note go:: ,\n*Note block:: , *Note return:: ,\n*Note let; let*:: , and *Note setq:: )\n"
        },
        {
            "type": "Notes",
            "text": "If end-test-form is nil, the test will never succeed.  This provides an\nidiom for \"do forever\": the body of the do or do* is executed repeatedly.\nThe infinite loop can be terminated by the use of return, return-from, go\nto an outer level, or throw.\nA do form may be explained in terms of the more primitive forms block,\nreturn, let, loop, tagbody, and psetq as follows:\n      (block nil\n        (let ((var1 init1)\n              (var2 init2)\n              ...\n              (varn initn))\n          declarations\n          (loop (when end-test (return (progn . result)))\n                (tagbody . tagbody)\n                (psetq var1 step1\n                       var2 step2\n                       ...\n                       varn stepn))))\ndo* is similar, except that let* and setq replace the let and psetq,\nrespectively.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: do,  Next: dotimes,  Prev: Iteration Dictionary,  Up: Iteration Dictionary\n\ndo, do*                                                             [Macro]\n---------------------------------------------------------------------------\n\n`do'  ({var | (var [init-form [step-form]])}*) (end-test-form\n{result-form}*) {declaration}* {tag | statement}*\n=>  {result}*\n\n`do*'  ({var | (var [init-form [step-form]])}*) (end-test-form\n{result-form}*) {declaration}* {tag | statement}*\n=>  {result}*\n\nArguments and Values::\n......................\n\nvar--a symbol.\n\ninit-form--a form.\n\nstep-form--a form.\n\nend-test-form--a form.\n\nresult-forms--an implicit progn.\n\ndeclaration--a declare expression; not evaluated.\n\ntag--a go tag; not evaluated.\n\nstatement--a compound form; evaluated as described below.\n\nresults--if a return or return-from form is executed, the values passed\nfrom that form; otherwise, the values returned by the result-forms.\n\nDescription::\n.............\n\ndo iterates over a group of statements while a test condition holds.  do\naccepts an arbitrary number of iteration vars which are bound within the\niteration and stepped in parallel.  An initial value may be supplied for\neach iteration variable by use of an init-form.  Step-forms may be used to\nspecify how the vars should be updated on succeeding iterations through\nthe loop.  Step-forms may be used both to generate successive values or to\naccumulate results.  If the end-test-form condition is met prior to an\nexecution of the body, the iteration terminates.  Tags label statements.\n\ndo* is exactly like do except that the bindings and steppings of the vars\nare performed sequentially rather than in parallel.\n\nBefore the first iteration, all the init-forms are evaluated, and each var\nis bound to the value of its respective init-form, if supplied.  This is a\nbinding, not an assignment; when the loop terminates, the old values of\nthose variables will be restored.  For do, all of the init-forms are\nevaluated before any var is bound. The init-forms can refer to the\nbindings of the vars visible before beginning execution of do.  For do*,\nthe first init-form is evaluated, then the first var is bound to that\nvalue, then the second init-form is evaluated, then the second var is\nbound, and so on; in general, the kth init-form can refer to the new\nbinding of the jth var if j < k, and otherwise to the old binding of the\njth var.\n\nAt the beginning of each iteration, after processing the variables, the\nend-test-form is evaluated.  If the result is false, execution proceeds\nwith the body of the do (or do*) form.  If the result is true, the\nresult-forms are evaluated in order as an implicit progn, and then do or\ndo* returns.\n\nAt the beginning of each iteration other than the first, vars are updated\nas follows.  All the step-forms, if supplied, are evaluated, from left to\nright, and the resulting values are assigned to the respective vars.  Any\nvar that has no associated step-form is not assigned to.  For do, all the\nstep-forms are evaluated before any var is updated; the assignment of\nvalues to vars is done in parallel, as if by psetq.  Because all of the\nstep-forms are evaluated before any of the vars are altered, a step-form\nwhen evaluated always has access to the old values of all the vars, even\nif other step-forms precede it.  For do*, the first step-form is\nevaluated, then the value is assigned to the first var, then the second\nstep-form is evaluated, then the value is assigned to the second var, and\nso on; the assignment of values to variables is done sequentially, as if\nby setq.  For either do or do*, after the vars have been updated, the\nend-test-form is evaluated as described above, and the iteration continues.\n\nThe remainder of the do (or do*) form constitutes an implicit tagbody.\nTags may appear within the body of a do loop for use by go statements\nappearing in the body (but such go statements may not appear in the\nvariable specifiers, the end-test-form, or the result-forms).  When the\nend of a do body is reached, the next iteration cycle (beginning with the\nevaluation of step-forms) occurs.\n\nAn implicit block named nil surrounds the entire do (or do*) form.  A\nreturn statement may be used at any point to exit the loop immediately.\n\nInit-form  is an initial value for the var with which it is associated.\nIf init-form is omitted, the initial value of var is nil.  If a\ndeclaration is supplied for a var, init-form must be consistent with the\ndeclaration.\n\nDeclarations can appear at the beginning of a do (or do*) body.  They\napply to code in the do (or do*) body, to the bindings of the do (or do*)\nvars, to the step-forms, to the end-test-form, and to the result-forms.\n\nExamples::\n..........\n\n      (do ((temp-one 1 (1+ temp-one))\n            (temp-two 0 (1- temp-two)))\n           ((> (- temp-one temp-two) 5) temp-one)) =>  4\n     \n      (do ((temp-one 1 (1+ temp-one))\n            (temp-two 0 (1+ temp-one)))\n           ((= 3 temp-two) temp-one)) =>  3\n     \n      (do* ((temp-one 1 (1+ temp-one))\n             (temp-two 0 (1+ temp-one)))\n            ((= 3 temp-two) temp-one)) =>  2\n     \n      (do ((j 0 (+ j 1)))\n          (nil)                       ;Do forever.\n        (format t \"~\n        (let ((item (read)))\n          (if (null item) (return)   ;Process items until NIL seen.\n              (format t \"~&Output ~D: ~S\" j item))))\n      |>  Input 0: |>>banana<<|\n      |>  Output 0: BANANA\n      |>  Input 1: |>>(57 boxes)<<|\n      |>  Output 1: (57 BOXES)\n      |>  Input 2: |>>NIL<<|\n     =>  NIL\n     \n      (setq a-vector (vector 1 nil 3 nil))\n      (do ((i 0 (+ i 1))     ;Sets every null element of a-vector to zero.\n           (n (array-dimension a-vector 0)))\n          ((= i n))\n        (when (null (aref a-vector i))\n          (setf (aref a-vector i) 0))) =>  NIL\n     a-vector =>  #(1 0 3 0)\n\n      (do ((x e (cdr x))\n           (oldx x x))\n          ((null x))\n        body)\n\nis an example of parallel assignment to index variables.  On the first\niteration, the value of oldx is whatever value x had before the do was\nentered.  On succeeding iterations, oldx contains the value that x had on\nthe previous iteration.\n\n      (do ((x foo (cdr x))\n           (y bar (cdr y))\n           (z '() (cons (f (car x) (car y)) z)))\n          ((or (null x) (null y))\n           (nreverse z)))\n\ndoes the same thing as (mapcar #'f foo bar).  The step computation for z\nis an example of the fact that variables are stepped in parallel.  Also,\nthe body of the loop is empty.\n\n      (defun list-reverse (list)\n             (do ((x list (cdr x))\n                  (y '() (cons (car x) y)))\n                 ((endp x) y)))\n\nAs an example of nested iterations, consider a data structure that is a\nlist of conses. The car of each cons is a list of symbols, and the cdr of\neach cons is a list of equal length containing corresponding values.  Such\na data structure is similar to an association list, but is divided into\n\"frames\"; the overall structure resembles a rib-cage.  A lookup function\non such a data structure might be:\n\n      (defun ribcage-lookup (sym ribcage)\n             (do ((r ribcage (cdr r)))\n                 ((null r) nil)\n               (do ((s (caar r) (cdr s))\n                    (v (cdar r) (cdr v)))\n                   ((null s))\n                 (when (eq (car s) sym)\n                   (return-from ribcage-lookup (car v)))))) =>  RIBCAGE-LOOKUP\n\nSee Also::\n..........\n\nother iteration functions ( *Note dolist:: , *Note dotimes:: , and *Note\nloop:: ) and more primitive functionality ( *Note tagbody:: , *Note go:: ,\n*Note block:: , *Note return:: ,\n\n*Note let; let*:: , and *Note setq:: )\n\nNotes::\n.......\n\nIf end-test-form is nil, the test will never succeed.  This provides an\nidiom for \"do forever\": the body of the do or do* is executed repeatedly.\nThe infinite loop can be terminated by the use of return, return-from, go\nto an outer level, or throw.\n\nA do form may be explained in terms of the more primitive forms block,\nreturn, let, loop, tagbody, and psetq as follows:\n\n      (block nil\n        (let ((var1 init1)\n              (var2 init2)\n              ...\n              (varn initn))\n          declarations\n          (loop (when end-test (return (progn . result)))\n                (tagbody . tagbody)\n                (psetq var1 step1\n                       var2 step2\n                       ...\n                       varn stepn))))\n\ndo* is similar, except that let* and setq replace the let and psetq,\nrespectively.\n\n"
}