{
    "name": "char=",
    "prev": "extended-char",
    "next": "character",
    "up": "Characters Dictionary",
    "header": {
        "type": null,
        "text": "char-not-lessp"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "char=",
                    "text": " &rest characters^+ =>  generalized-boolean\n"
                },
                {
                    "name": "char/=",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char<",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char>",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char<=",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char>=",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char-equal",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char-not-equal",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char-lessp",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char-greaterp",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char-not-greaterp",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                },
                {
                    "name": "char-not-lessp",
                    "text": " &rest characters^+ =>  generalized-boolean\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "character",
                    "desc": "a character."
                },
                {
                    "name": "generalized-boolean",
                    "desc": "a generalized boolean."
                }
            ]
        },
        {
            "type": "Description",
            "text": "These predicates compare characters.\nchar= returns true if all characters are the same; otherwise, it returns\nfalse.\nIf two characters differ in any implementation-defined attributes, then\nthey are not char=.\nchar/= returns true if all characters are different; otherwise, it returns\nfalse.\nchar< returns true if the characters are monotonically increasing;\notherwise, it returns false.\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char< is consistent with the numerical ordering by the\npredicate < on their codes.\nchar> returns true if the characters are monotonically decreasing;\notherwise, it returns false.\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char> is consistent with the numerical ordering by the\npredicate > on their codes.\nchar<= returns true if the characters are monotonically nondecreasing;\notherwise, it returns false.\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char<= is consistent with the numerical ordering by the\npredicate <= on their codes.\nchar>= returns true if the characters are monotonically nonincreasing;\notherwise, it returns false.\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char>= is consistent with the numerical ordering by the\npredicate >= on their codes.\nchar-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp,\nand char-not-lessp are similar to char=, char/=, char<, char>, char<=,\nchar>=, respectively, except that they ignore differences in case and\nmight have an implementation-defined behavior for non-simple characters.\nFor example, an implementation might define that char-equal, etc. ignore\ncertain implementation-defined attributes.  The effect, if any, of each\nimplementation-defined attribute upon these functions must be specified as\npart of the definition of that attribute.\n"
        },
        {
            "type": "Examples",
            "text": "      (char= #\\d #\\d) =>  true\n      (char= #\\A #\\a) =>  false\n      (char= #\\d #\\x) =>  false\n      (char= #\\d #\\D) =>  false\n      (char/= #\\d #\\d) =>  false\n      (char/= #\\d #\\x) =>  true\n      (char/= #\\d #\\D) =>  true\n      (char= #\\d #\\d #\\d #\\d) =>  true\n      (char/= #\\d #\\d #\\d #\\d) =>  false\n      (char= #\\d #\\d #\\x #\\d) =>  false\n      (char/= #\\d #\\d #\\x #\\d) =>  false\n      (char= #\\d #\\y #\\x #\\c) =>  false\n      (char/= #\\d #\\y #\\x #\\c) =>  true\n      (char= #\\d #\\c #\\d) =>  false\n      (char/= #\\d #\\c #\\d) =>  false\n      (char< #\\d #\\x) =>  true\n      (char<= #\\d #\\x) =>  true\n      (char< #\\d #\\d) =>  false\n      (char<= #\\d #\\d) =>  true\n      (char< #\\a #\\e #\\y #\\z) =>  true\n      (char<= #\\a #\\e #\\y #\\z) =>  true\n      (char< #\\a #\\e #\\e #\\y) =>  false\n      (char<= #\\a #\\e #\\e #\\y) =>  true\n      (char> #\\e #\\d) =>  true\n      (char>= #\\e #\\d) =>  true\n      (char> #\\d #\\c #\\b #\\a) =>  true\n      (char>= #\\d #\\c #\\b #\\a) =>  true\n      (char> #\\d #\\d #\\c #\\a) =>  false\n      (char>= #\\d #\\d #\\c #\\a) =>  true\n      (char> #\\e #\\d #\\b #\\c #\\a) =>  false\n      (char>= #\\e #\\d #\\b #\\c #\\a) =>  false\n      (char> #\\z #\\A) =>  implementation-dependent\n      (char> #\\Z #\\a) =>  implementation-dependent\n      (char-equal #\\A #\\a) =>  true\n      (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)\n     =>  (#\\A #\\a #\\b #\\B #\\c #\\C)\n      (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)\n     =>  (#\\A #\\B #\\C #\\a #\\b #\\c) ;Implementation A\n     =>  (#\\a #\\b #\\c #\\A #\\B #\\C) ;Implementation B\n     =>  (#\\a #\\A #\\b #\\B #\\c #\\C) ;Implementation C\n     =>  (#\\A #\\a #\\B #\\b #\\C #\\c) ;Implementation D\n     =>  (#\\A #\\B #\\a #\\b #\\C #\\c) ;Implementation E\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should signal an error of type program-error if at least one character is\nnot supplied.\n"
        },
        {
            "type": "See Also",
            "text": "*Note Character Syntax::, *Note Documentation of Implementation-Defined\nScripts::\n"
        },
        {
            "type": "Notes",
            "text": "If characters differ in their code attribute or any implementation-defined\nattribute, they are considered to be different by char=.\nThere is no requirement that (eq c1 c2) be true merely because (char= c1\nc2) is true.  While eq can distinguish two characters that char= does not,\nit is distinguishing them not as characters, but in some sense on the\nbasis of a lower level implementation characteristic.  If (eq c1 c2) is\ntrue, then (char= c1 c2) is also true.  eql and equal compare characters\nin the same way that char= does.\nThe manner in which case is used by char-equal, char-not-equal, char-lessp,\nchar-greaterp, char-not-greaterp, and char-not-lessp implies an ordering\nfor standard characters such that A=a, B=b, and so on, up to Z=z, and\nfurthermore either 9<A or Z<0.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: char=,  Next: character,  Prev: extended-char,  Up: Characters Dictionary\n\nchar=, char/=, char<, char>, char<=, char>=,\n--------------------------------------------\n\nchar-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp,\n-------------------------------------------------------------------------\n\nchar-not-lessp\n--------------\n\n                                                                [Function]\n\n`char='  &rest characters^+ =>  generalized-boolean\n\n`char/='  &rest characters^+ =>  generalized-boolean\n\n`char<'  &rest characters^+ =>  generalized-boolean\n\n`char>'  &rest characters^+ =>  generalized-boolean\n\n`char<='  &rest characters^+ =>  generalized-boolean\n\n`char>='  &rest characters^+ =>  generalized-boolean\n\n`char-equal'  &rest characters^+ =>  generalized-boolean\n\n`char-not-equal'  &rest characters^+ =>  generalized-boolean\n\n`char-lessp'  &rest characters^+ =>  generalized-boolean\n\n`char-greaterp'  &rest characters^+ =>  generalized-boolean\n\n`char-not-greaterp'  &rest characters^+ =>  generalized-boolean\n\n`char-not-lessp'  &rest characters^+ =>  generalized-boolean\n\nArguments and Values::\n......................\n\ncharacter--a character.\n\ngeneralized-boolean--a generalized boolean.\n\nDescription::\n.............\n\nThese predicates compare characters.\n\nchar= returns true if all characters are the same; otherwise, it returns\nfalse.\n\nIf two characters differ in any implementation-defined attributes, then\nthey are not char=.\n\nchar/= returns true if all characters are different; otherwise, it returns\nfalse.\n\nchar< returns true if the characters are monotonically increasing;\notherwise, it returns false.\n\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char< is consistent with the numerical ordering by the\npredicate < on their codes.\n\nchar> returns true if the characters are monotonically decreasing;\notherwise, it returns false.\n\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char> is consistent with the numerical ordering by the\npredicate > on their codes.\n\nchar<= returns true if the characters are monotonically nondecreasing;\notherwise, it returns false.\n\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char<= is consistent with the numerical ordering by the\npredicate <= on their codes.\n\nchar>= returns true if the characters are monotonically nonincreasing;\notherwise, it returns false.\n\nIf two characters have identical implementation-defined attributes, then\ntheir ordering by char>= is consistent with the numerical ordering by the\npredicate >= on their codes.\n\nchar-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp,\nand char-not-lessp are similar to char=, char/=, char<, char>, char<=,\nchar>=, respectively, except that they ignore differences in case and\n\nmight have an implementation-defined behavior for non-simple characters.\nFor example, an implementation might define that char-equal, etc. ignore\ncertain implementation-defined attributes.  The effect, if any, of each\nimplementation-defined attribute upon these functions must be specified as\npart of the definition of that attribute.\n\nExamples::\n..........\n\n      (char= #\\d #\\d) =>  true\n      (char= #\\A #\\a) =>  false\n      (char= #\\d #\\x) =>  false\n      (char= #\\d #\\D) =>  false\n      (char/= #\\d #\\d) =>  false\n      (char/= #\\d #\\x) =>  true\n      (char/= #\\d #\\D) =>  true\n      (char= #\\d #\\d #\\d #\\d) =>  true\n      (char/= #\\d #\\d #\\d #\\d) =>  false\n      (char= #\\d #\\d #\\x #\\d) =>  false\n      (char/= #\\d #\\d #\\x #\\d) =>  false\n      (char= #\\d #\\y #\\x #\\c) =>  false\n      (char/= #\\d #\\y #\\x #\\c) =>  true\n      (char= #\\d #\\c #\\d) =>  false\n      (char/= #\\d #\\c #\\d) =>  false\n      (char< #\\d #\\x) =>  true\n      (char<= #\\d #\\x) =>  true\n      (char< #\\d #\\d) =>  false\n      (char<= #\\d #\\d) =>  true\n      (char< #\\a #\\e #\\y #\\z) =>  true\n      (char<= #\\a #\\e #\\y #\\z) =>  true\n      (char< #\\a #\\e #\\e #\\y) =>  false\n      (char<= #\\a #\\e #\\e #\\y) =>  true\n      (char> #\\e #\\d) =>  true\n      (char>= #\\e #\\d) =>  true\n      (char> #\\d #\\c #\\b #\\a) =>  true\n      (char>= #\\d #\\c #\\b #\\a) =>  true\n      (char> #\\d #\\d #\\c #\\a) =>  false\n      (char>= #\\d #\\d #\\c #\\a) =>  true\n      (char> #\\e #\\d #\\b #\\c #\\a) =>  false\n      (char>= #\\e #\\d #\\b #\\c #\\a) =>  false\n      (char> #\\z #\\A) =>  implementation-dependent\n      (char> #\\Z #\\a) =>  implementation-dependent\n      (char-equal #\\A #\\a) =>  true\n      (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)\n     =>  (#\\A #\\a #\\b #\\B #\\c #\\C)\n      (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)\n     =>  (#\\A #\\B #\\C #\\a #\\b #\\c) ;Implementation A\n     =>  (#\\a #\\b #\\c #\\A #\\B #\\C) ;Implementation B\n     =>  (#\\a #\\A #\\b #\\B #\\c #\\C) ;Implementation C\n     =>  (#\\A #\\a #\\B #\\b #\\C #\\c) ;Implementation D\n     =>  (#\\A #\\B #\\a #\\b #\\C #\\c) ;Implementation E\n\nExceptional Situations::\n........................\n\nShould signal an error of type program-error if at least one character is\nnot supplied.\n\nSee Also::\n..........\n\n*Note Character Syntax::, *Note Documentation of Implementation-Defined\nScripts::\n\nNotes::\n.......\n\nIf characters differ in their code attribute or any implementation-defined\nattribute, they are considered to be different by char=.\n\nThere is no requirement that (eq c1 c2) be true merely because (char= c1\nc2) is true.  While eq can distinguish two characters that char= does not,\nit is distinguishing them not as characters, but in some sense on the\nbasis of a lower level implementation characteristic.  If (eq c1 c2) is\ntrue, then (char= c1 c2) is also true.  eql and equal compare characters\nin the same way that char= does.\n\nThe manner in which case is used by char-equal, char-not-equal, char-lessp,\nchar-greaterp, char-not-greaterp, and char-not-lessp implies an ordering\nfor standard characters such that A=a, B=b, and so on, up to Z=z, and\nfurthermore either 9<A or Z<0.\n\n"
}