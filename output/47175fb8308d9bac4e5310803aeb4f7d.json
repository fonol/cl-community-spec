{
    "name": "Built-in Method Combination Types",
    "prev": "Declarative Method Combination",
    "next": null,
    "up": "Method Selection and Combination",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Built-in Method Combination Types",
            "text": "The object system provides a set of built-in method combination types.  To\nspecify that a generic function is to use one of these method combination\ntypes, the name of the method combination type is given as the argument to\nthe :method-combination option to defgeneric or to the :method-combination\noption to any of the other operators that specify generic function options.\nThe names of the built-in  method combination types are listed in Figure\n7-3.\n  +    append  max  nconc  progn        and  list    min  or     standard  \n  Figure 7-3: Built-in Method Combination Types\nThe semantics of the standard built-in method combination type is\ndescribed in *Note Standard Method Combination::.  The other built-in\nmethod combination types are called simple built-in method combination\ntypes.\nThe simple built-in method combination types act as though they were\ndefined by the short form of define-method-combination.  They recognize\ntwo roles for methods:\n*\n     An around method has the keyword symbol :around as its sole\n     qualifier.  The meaning of :around methods is the same as in standard\n     method combination.  Use of the functions call-next-method and\n     next-method-p is supported in around methods.\n*\n     A primary method has the name of the method combination type as its\n     sole qualifier.  For example, the built-in method combination type\n     and recognizes methods whose sole qualifier is and; these are primary\n     methods. Use of the functions call-next-method and next-method-p is\n     not supported in primary methods.\nThe semantics of the simple built-in method combination types is as\nfollows:\n*\n     If there are any around methods, the most specific around method is\n     called.   It supplies the value or values of the generic function.\n*\n     Inside the body of an around method, the function call-next-method\n     can be used to call the next method.  The generic function\n     no-next-method is invoked if call-next-method is used and there is no\n     applicable method to call.  The function next-method-p may be used to\n     determine whether a next method exists. When the next method returns,\n     the around method can execute more code, perhaps based on the\n     returned value or values.\n*\n     If an around method invokes call-next-method, the next most specific\n     around method is called, if one is applicable.  If there are no\n     around methods or if call-next-method is called by the least specific\n     around method, a Lisp form derived from the name of the built-in\n     method combination type and from the list of applicable primary\n     methods is evaluated to produce the value of the generic function.\n     Suppose the name of the method combination type is operator and the\n     call to the generic function is of the form\n                         (generic-function a_1... a_n)\n     Let M_1,...,M_k be the applicable primary methods in order; then the\n     derived Lisp form is\n                                (operator < M_1\n     a_1... a_n>...< M_k a_1... a_n>)\n     If the expression < M_i  a_1... a_n> is evaluated, the method M_i\n     will be applied to the arguments a_1... a_n.  For example, if\n     operator is or, the expression < M_i  a_1... a_n> is evaluated only\n     if < M_j  a_1... a_n>, 1<= j<i, returned nil.\n     The default order for the primary methods is :most-specific-first.\n     However, the order can be reversed by supplying :most-specific-last\n     as the second argument to the :method-combination option.\nThe simple built-in method combination types require exactly one qualifier\nper method.  An error is signaled if there are applicable methods with no\nqualifiers or with qualifiers that are not supported by the method\ncombination type. An error is signaled if there are applicable around\nmethods and no applicable primary methods.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Built-in Method Combination Types,  Prev: Declarative Method Combination,  Up: Method Selection and Combination\n\nBuilt-in Method Combination Types\n.................................\n\nThe object system provides a set of built-in method combination types.  To\nspecify that a generic function is to use one of these method combination\ntypes, the name of the method combination type is given as the argument to\nthe :method-combination option to defgeneric or to the :method-combination\noption to any of the other operators that specify generic function options.\n\nThe names of the built-in  method combination types are listed in Figure\n7-3.\n\n  +    append  max  nconc  progn        and  list    min  or     standard  \n\n  Figure 7-3: Built-in Method Combination Types\n\n\nThe semantics of the standard built-in method combination type is\ndescribed in *Note Standard Method Combination::.  The other built-in\nmethod combination types are called simple built-in method combination\ntypes.\n\nThe simple built-in method combination types act as though they were\ndefined by the short form of define-method-combination.  They recognize\ntwo roles for methods:\n\n*\n     An around method has the keyword symbol :around as its sole\n     qualifier.  The meaning of :around methods is the same as in standard\n     method combination.  Use of the functions call-next-method and\n     next-method-p is supported in around methods.\n\n*\n     A primary method has the name of the method combination type as its\n     sole qualifier.  For example, the built-in method combination type\n     and recognizes methods whose sole qualifier is and; these are primary\n     methods. Use of the functions call-next-method and next-method-p is\n     not supported in primary methods.\n\nThe semantics of the simple built-in method combination types is as\nfollows:\n\n*\n     If there are any around methods, the most specific around method is\n     called.   It supplies the value or values of the generic function.\n\n*\n     Inside the body of an around method, the function call-next-method\n     can be used to call the next method.  The generic function\n     no-next-method is invoked if call-next-method is used and there is no\n     applicable method to call.  The function next-method-p may be used to\n     determine whether a next method exists. When the next method returns,\n     the around method can execute more code, perhaps based on the\n     returned value or values.\n\n*\n     If an around method invokes call-next-method, the next most specific\n     around method is called, if one is applicable.  If there are no\n     around methods or if call-next-method is called by the least specific\n     around method, a Lisp form derived from the name of the built-in\n     method combination type and from the list of applicable primary\n     methods is evaluated to produce the value of the generic function.\n     Suppose the name of the method combination type is operator and the\n     call to the generic function is of the form\n\n                         (generic-function a_1... a_n)\n\n\n     Let M_1,...,M_k be the applicable primary methods in order; then the\n     derived Lisp form is\n\n                                (operator < M_1\n\n     a_1... a_n>...< M_k a_1... a_n>)\n\n\n     If the expression < M_i  a_1... a_n> is evaluated, the method M_i\n     will be applied to the arguments a_1... a_n.  For example, if\n     operator is or, the expression < M_i  a_1... a_n> is evaluated only\n     if < M_j  a_1... a_n>, 1<= j<i, returned nil.\n\n\n     The default order for the primary methods is :most-specific-first.\n     However, the order can be reversed by supplying :most-specific-last\n     as the second argument to the :method-combination option.\n\nThe simple built-in method combination types require exactly one qualifier\nper method.  An error is signaled if there are applicable methods with no\nqualifiers or with qualifiers that are not supported by the method\ncombination type. An error is signaled if there are applicable around\nmethods and no applicable primary methods.\n\n"
}