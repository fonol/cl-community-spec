{
    "name": "eval-when",
    "prev": "eval",
    "next": "load-time-value",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Special Operator",
        "text": "eval-when"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "eval-when",
                    "text": " ({situation}*) {form}* =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "situation",
                    "desc": "One of the symbols :compile-toplevel , :load-toplevel , :execute"
                },
                {
                    "name": "situation",
                    "desc": "One of the symbols :compile-toplevel , :load-toplevel , :execute, compile , load , or eval .\nThe use of eval, compile, and load is deprecated.\n"
                },
                {
                    "name": "forms",
                    "desc": "an implicit progn."
                },
                {
                    "name": "results",
                    "desc": "the values of the forms if they are executed, or nil if they are"
                }
            ]
        },
        {
            "type": "Description",
            "text": "The body of an eval-when form is processed as an implicit progn, but only\nin the situations listed.\nThe use of the situations :compile-toplevel (or compile) and\n:load-toplevel (or load) controls whether and when evaluation occurs when\neval-when appears as a top level form in code processed by compile-file.\nSee *Note File Compilation::.\nThe use of the situation :execute (or eval) controls whether evaluation\noccurs for other eval-when forms; that is, those that are not top level\nforms, or those in code processed by eval or compile.  If the :execute\nsituation is specified in such a form, then the body forms are processed as\nan implicit progn; otherwise, the eval-when form returns nil.\neval-when normally appears as a top level form, but it is meaningful for\nit to appear as a non-top-level form.  However, the compile-time side\neffects described in *Note Compilation:: only take place when eval-when\nappears as a top level form.\n"
        },
        {
            "type": "Examples",
            "text": "One example of the use of eval-when is that for the compiler to be able to\nread a file properly when it uses user-defined reader macros, it is\nnecessary to write\n      (eval-when (:compile-toplevel :load-toplevel :execute)\n        (set-macro-character #\\$ #'(lambda (stream char)\n                                     (declare (ignore char))\n                                     (list 'dollar (read stream))))) =>  T\nThis causes the call to set-macro-character to be executed in the\ncompiler's execution environment, thereby modifying its reader syntax\ntable.\n     ;;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE\n     ;;;     keyword is considered. At compile time, this has no effect.\n     ;;;     At load time (if the LET is at toplevel), or at execution time\n     ;;;     (if the LET is embedded in some other form which does not execute\n     ;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which\n     ;;;     returns 1.\n      (let ((x 1))\n        (eval-when (:execute :load-toplevel :compile-toplevel)\n          (setf (symbol-function 'foo1) #'(lambda () x))))\n     ;;;     If this expression occurs at the toplevel of a file to be compiled,\n     ;;;     it has BOTH a compile time AND a load-time effect of setting\n     ;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.\n      (eval-when (:execute :load-toplevel :compile-toplevel)\n        (let ((x 2))\n          (eval-when (:execute :load-toplevel :compile-toplevel)\n            (setf (symbol-function 'foo2) #'(lambda () x)))))\n     ;;;     If this expression occurs at the toplevel of a file to be compiled,\n     ;;;     it has BOTH a compile time AND a load-time effect of setting the\n     ;;;     function cell of FOO3 to a function which returns 3.\n      (eval-when (:execute :load-toplevel :compile-toplevel)\n        (setf (symbol-function 'foo3) #'(lambda () 3)))\n     ;;; #4: This always does nothing. It simply returns NIL.\n      (eval-when (:compile-toplevel)\n        (eval-when (:compile-toplevel)\n          (print 'foo4)))\n     ;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is\n     ;;;     printed at compile time. If this form occurs in a non-top-level\n     ;;;     position, nothing is printed at compile time. Regardless of context,\n     ;;;     nothing is ever printed at load time or execution time.\n      (eval-when (:compile-toplevel)\n        (eval-when (:execute)\n          (print 'foo5)))\n     ;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is\n     ;;;     printed at compile time.  If this form occurs in a non-top-level\n     ;;;     position, nothing is printed at compile time. Regardless of context,\n     ;;;     nothing is ever printed at load time or execution time.\n      (eval-when (:execute :load-toplevel)\n        (eval-when (:compile-toplevel)\n          (print 'foo6)))\n"
        },
        {
            "type": "See Also",
            "text": "*Note compile-file:: , *Note Compilation::\n"
        },
        {
            "type": "Notes",
            "text": "The following effects are logical consequences of the definition of\neval-when:\n*\n     Execution of a single eval-when expression executes the body code at\n     most once.\n*\n     Macros intended for use in top level forms should be written so that\n     side-effects are done by the forms in the macro expansion.  The\n     macro-expander itself should not do the side-effects.\n     For example:\n     Wrong:\n           (defmacro foo ()\n             (really-foo)\n             `(really-foo))\n     Right:\n           (defmacro foo ()\n             `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))\n     Adherence to this convention means that such macros behave\n     intuitively when appearing as non-top-level forms.\n*\n     Placing a variable binding around an eval-when reliably captures the\n     binding because the compile-time-too mode cannot occur (i.e.,\n     introducing a variable binding means that the eval-when is not a top\n     level form).  For example,\n           (let ((x 3))\n             (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))\n     prints 3 at execution (i.e., load) time, and does not print anything\n     at compile time.  This is important so that expansions of defun and\n     defmacro can be done in terms of eval-when and can correctly capture\n     the lexical environment.\n           (defun bar (x) (defun foo () (+ x 3)))\n     might expand into\n           (defun bar (x)\n             (progn (eval-when (:compile-toplevel)\n                      (compiler::notice-function-definition 'foo '(x)))\n                    (eval-when (:execute :load-toplevel)\n                      (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))\n     which would be treated by the above rules the same as\n           (defun bar (x)\n             (setf (symbol-function 'foo) #'(lambda () (+ x 3))))\n     when the definition of bar is not a top level form.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: eval-when,  Next: load-time-value,  Prev: eval,  Up: Evaluation and Compilation Dictionary\n\neval-when                                                [Special Operator]\n---------------------------------------------------------------------------\n\n`eval-when'  ({situation}*) {form}* =>  {result}*\n\nArguments and Values::\n......................\n\nsituation--One of the symbols :compile-toplevel , :load-toplevel , :execute\n, compile , load , or eval .\n\nThe use of eval, compile, and load is deprecated.\n\nforms--an implicit progn.\n\nresults--the values of the forms if they are executed, or nil if they are\nnot.\n\nDescription::\n.............\n\nThe body of an eval-when form is processed as an implicit progn, but only\nin the situations listed.\n\nThe use of the situations :compile-toplevel (or compile) and\n:load-toplevel (or load) controls whether and when evaluation occurs when\neval-when appears as a top level form in code processed by compile-file.\nSee *Note File Compilation::.\n\nThe use of the situation :execute (or eval) controls whether evaluation\noccurs for other eval-when forms; that is, those that are not top level\nforms, or those in code processed by eval or compile.  If the :execute\nsituation is specified in such a form, then the body forms are processed as\nan implicit progn; otherwise, the eval-when form returns nil.\n\neval-when normally appears as a top level form, but it is meaningful for\nit to appear as a non-top-level form.  However, the compile-time side\neffects described in *Note Compilation:: only take place when eval-when\nappears as a top level form.\n\nExamples::\n..........\n\nOne example of the use of eval-when is that for the compiler to be able to\nread a file properly when it uses user-defined reader macros, it is\nnecessary to write\n\n      (eval-when (:compile-toplevel :load-toplevel :execute)\n        (set-macro-character #\\$ #'(lambda (stream char)\n                                     (declare (ignore char))\n                                     (list 'dollar (read stream))))) =>  T\n\nThis causes the call to set-macro-character to be executed in the\ncompiler's execution environment, thereby modifying its reader syntax\ntable.\n\n     ;;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE\n     ;;;     keyword is considered. At compile time, this has no effect.\n     ;;;     At load time (if the LET is at toplevel), or at execution time\n     ;;;     (if the LET is embedded in some other form which does not execute\n     ;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which\n     ;;;     returns 1.\n      (let ((x 1))\n        (eval-when (:execute :load-toplevel :compile-toplevel)\n          (setf (symbol-function 'foo1) #'(lambda () x))))\n     \n     ;;;     If this expression occurs at the toplevel of a file to be compiled,\n     ;;;     it has BOTH a compile time AND a load-time effect of setting\n     ;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.\n      (eval-when (:execute :load-toplevel :compile-toplevel)\n        (let ((x 2))\n          (eval-when (:execute :load-toplevel :compile-toplevel)\n            (setf (symbol-function 'foo2) #'(lambda () x)))))\n     \n     ;;;     If this expression occurs at the toplevel of a file to be compiled,\n     ;;;     it has BOTH a compile time AND a load-time effect of setting the\n     ;;;     function cell of FOO3 to a function which returns 3.\n      (eval-when (:execute :load-toplevel :compile-toplevel)\n        (setf (symbol-function 'foo3) #'(lambda () 3)))\n     \n     ;;; #4: This always does nothing. It simply returns NIL.\n      (eval-when (:compile-toplevel)\n        (eval-when (:compile-toplevel)\n          (print 'foo4)))\n     \n     ;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is\n     ;;;     printed at compile time. If this form occurs in a non-top-level\n     ;;;     position, nothing is printed at compile time. Regardless of context,\n     ;;;     nothing is ever printed at load time or execution time.\n      (eval-when (:compile-toplevel)\n        (eval-when (:execute)\n          (print 'foo5)))\n     \n     ;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is\n     ;;;     printed at compile time.  If this form occurs in a non-top-level\n     ;;;     position, nothing is printed at compile time. Regardless of context,\n     ;;;     nothing is ever printed at load time or execution time.\n      (eval-when (:execute :load-toplevel)\n        (eval-when (:compile-toplevel)\n          (print 'foo6)))\n\nSee Also::\n..........\n\n*Note compile-file:: , *Note Compilation::\n\nNotes::\n.......\n\nThe following effects are logical consequences of the definition of\neval-when:\n\n*\n     Execution of a single eval-when expression executes the body code at\n     most once.\n\n*\n     Macros intended for use in top level forms should be written so that\n     side-effects are done by the forms in the macro expansion.  The\n     macro-expander itself should not do the side-effects.\n\n     For example:\n\n     Wrong:\n\n           (defmacro foo ()\n             (really-foo)\n             `(really-foo))\n\n     Right:\n\n           (defmacro foo ()\n             `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))\n\n     Adherence to this convention means that such macros behave\n     intuitively when appearing as non-top-level forms.\n\n*\n     Placing a variable binding around an eval-when reliably captures the\n     binding because the compile-time-too mode cannot occur (i.e.,\n     introducing a variable binding means that the eval-when is not a top\n     level form).  For example,\n\n           (let ((x 3))\n             (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))\n\n     prints 3 at execution (i.e., load) time, and does not print anything\n     at compile time.  This is important so that expansions of defun and\n     defmacro can be done in terms of eval-when and can correctly capture\n     the lexical environment.\n\n           (defun bar (x) (defun foo () (+ x 3)))\n\n     might expand into\n\n           (defun bar (x)\n             (progn (eval-when (:compile-toplevel)\n                      (compiler::notice-function-definition 'foo '(x)))\n                    (eval-when (:execute :load-toplevel)\n                      (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))\n\n     which would be treated by the above rules the same as\n\n           (defun bar (x)\n             (setf (symbol-function 'foo) #'(lambda () (+ x 3))))\n\n     when the definition of bar is not a top level form.\n\n"
}