{
    "name": "Function Forms",
    "prev": "Macro Forms",
    "next": "Lambda Forms",
    "up": "The Evaluation Model",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Function Forms",
            "text": "If the operator is a symbol naming a function, the form represents a\nfunction form, and the cdr of the list contains the forms which when\nevaluated will supply the arguments passed to the function.\nWhen a function name is not defined, an error of type undefined-function\nshould be signaled at run time; see *Note Semantic Constraints::.\nA function form is evaluated as follows:\nThe subforms in the cdr of the original form are evaluated in\nleft-to-right order in the current lexical and dynamic environments.  The\nprimary value of each such evaluation becomes an argument to the named\nfunction; any additional values returned by the subforms are discarded.\nThe functional value of the operator is retrieved from the lexical\nenvironment, and that function is invoked with the indicated arguments.\nAlthough the order of evaluation of the argument subforms themselves is\nstrictly left-to-right, it is not specified whether the definition of the\noperator in a function form is looked up before the evaluation of the\nargument subforms, after the evaluation of the argument subforms, or\nbetween the evaluation of any two argument subforms if there is more than\none such argument subform.  For example, the following might return 23\nor~24.\n      (defun foo (x) (+ x 3))\n      (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))\n      (foo (progn (bar) 20))\nA binding for a function name can be established in one of several ways.\nA binding for a function name in the global environment can be established\nby defun, setf of fdefinition, setf of symbol-function,\nensure-generic-function, defmethod (implicitly, due to\nensure-generic-function), or defgeneric.  A binding for a function name in\nthe lexical environment can be established by flet or labels.\nFigure 3-4 lists some defined names that are applicable to functions.\n  apply                 fdefinition  mapcan               \n  call-arguments-limit  flet         mapcar               \n  complement            fmakunbound  mapcon               \n  constantly            funcall      mapl                 \n  defgeneric            function     maplist              \n  defmethod             functionp    multiple-value-call  \n  defun                 labels       reduce               \n  fboundp               map          symbol-function      \n      Figure 3-4: Some function-related defined names    \n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Function Forms,  Next: Lambda Forms,  Prev: Macro Forms,  Up: The Evaluation Model\n\nFunction Forms\n..............\n\nIf the operator is a symbol naming a function, the form represents a\nfunction form, and the cdr of the list contains the forms which when\nevaluated will supply the arguments passed to the function.\n\nWhen a function name is not defined, an error of type undefined-function\nshould be signaled at run time; see *Note Semantic Constraints::.\n\nA function form is evaluated as follows:\n\nThe subforms in the cdr of the original form are evaluated in\nleft-to-right order in the current lexical and dynamic environments.  The\nprimary value of each such evaluation becomes an argument to the named\nfunction; any additional values returned by the subforms are discarded.\n\nThe functional value of the operator is retrieved from the lexical\nenvironment, and that function is invoked with the indicated arguments.\n\nAlthough the order of evaluation of the argument subforms themselves is\nstrictly left-to-right, it is not specified whether the definition of the\noperator in a function form is looked up before the evaluation of the\nargument subforms, after the evaluation of the argument subforms, or\nbetween the evaluation of any two argument subforms if there is more than\none such argument subform.  For example, the following might return 23\nor~24.\n\n      (defun foo (x) (+ x 3))\n      (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))\n      (foo (progn (bar) 20))\n\nA binding for a function name can be established in one of several ways.\nA binding for a function name in the global environment can be established\nby defun, setf of fdefinition, setf of symbol-function,\nensure-generic-function, defmethod (implicitly, due to\nensure-generic-function), or defgeneric.  A binding for a function name in\nthe lexical environment can be established by flet or labels.\n\nFigure 3-4 lists some defined names that are applicable to functions.\n\n  apply                 fdefinition  mapcan               \n  call-arguments-limit  flet         mapcar               \n  complement            fmakunbound  mapcon               \n  constantly            funcall      mapl                 \n  defgeneric            function     maplist              \n  defmethod             functionp    multiple-value-call  \n  defun                 labels       reduce               \n  fboundp               map          symbol-function      \n\n      Figure 3-4: Some function-related defined names    \n\n\n"
}