{
    "name": "subseq",
    "prev": "make-sequence",
    "next": "map",
    "up": "Sequences Dictionary",
    "header": {
        "type": "Accessor",
        "text": "subseq"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "subseq",
                    "text": " sequence start &optional end =>  subsequence\n(setf (`         subseq' sequence start &optional end) new-subsequence)\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "sequence",
                    "desc": "a proper sequence."
                },
                {
                    "name": "start, end",
                    "desc": "bounding index designators of sequence.  The default for end"
                },
                {
                    "name": "start, end",
                    "desc": "bounding index designators of sequence.  The default for endis nil.\n"
                },
                {
                    "name": "subsequence",
                    "desc": "a proper sequence."
                },
                {
                    "name": "new-subsequence",
                    "desc": "a proper sequence."
                }
            ]
        },
        {
            "type": "Description",
            "text": "subseq creates a sequence that is a copy of the subsequence of sequence\nbounded by start and end.\nStart specifies an offset into the original sequence and marks the\nbeginning position of the subsequence.  end marks the position following\nthe last element of the subsequence.\nsubseq always allocates a new sequence for a result; it never shares\nstorage with an old sequence.  The result subsequence is always of the\nsame type as sequence.\nIf sequence is a vector, the result is a fresh simple array of rank one\nthat has the same actual array element type as sequence.  If sequence is a\nlist, the result is a fresh list.\nsetf may be used with subseq to destructively replace elements of a\nsubsequence with elements taken from a sequence of new values.  If the\nsubsequence and the new sequence are not of equal length, the shorter\nlength determines the number of elements that are replaced.  The remaining\nelements at the end of the longer sequence are not modified in the\noperation.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq str \"012345\") =>  \"012345\"\n      (subseq str 2) =>  \"2345\"\n      (subseq str 3 5) =>  \"34\"\n      (setf (subseq str 4) \"abc\") =>  \"abc\"\n      str =>  \"0123ab\"\n      (setf (subseq str 0 2) \"A\") =>  \"A\"\n      str =>  \"A123ab\"\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "Should be prepared to signal an error of type type-error if sequence is\nnot a proper sequence.  Should be prepared to signal an error of type\ntype-error if new-subsequence is not a proper sequence.\n"
        },
        {
            "type": "See Also",
            "text": "*Note replace::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: subseq,  Next: map,  Prev: make-sequence,  Up: Sequences Dictionary\n\nsubseq                                                           [Accessor]\n---------------------------------------------------------------------------\n\n`subseq'  sequence start &optional end =>  subsequence\n\n(setf (`         subseq' sequence start &optional end) new-subsequence)\nArguments and Values::\n......................\n\nsequence--a proper sequence.\n\nstart, end--bounding index designators of sequence.  The default for end\nis nil.\n\nsubsequence--a proper sequence.\n\nnew-subsequence--a proper sequence.\n\nDescription::\n.............\n\nsubseq creates a sequence that is a copy of the subsequence of sequence\nbounded by start and end.\n\nStart specifies an offset into the original sequence and marks the\nbeginning position of the subsequence.  end marks the position following\nthe last element of the subsequence.\n\nsubseq always allocates a new sequence for a result; it never shares\nstorage with an old sequence.  The result subsequence is always of the\nsame type as sequence.\n\nIf sequence is a vector, the result is a fresh simple array of rank one\nthat has the same actual array element type as sequence.  If sequence is a\nlist, the result is a fresh list.\n\nsetf may be used with subseq to destructively replace elements of a\nsubsequence with elements taken from a sequence of new values.  If the\nsubsequence and the new sequence are not of equal length, the shorter\nlength determines the number of elements that are replaced.  The remaining\nelements at the end of the longer sequence are not modified in the\noperation.\n\nExamples::\n..........\n\n      (setq str \"012345\") =>  \"012345\"\n      (subseq str 2) =>  \"2345\"\n      (subseq str 3 5) =>  \"34\"\n      (setf (subseq str 4) \"abc\") =>  \"abc\"\n      str =>  \"0123ab\"\n      (setf (subseq str 0 2) \"A\") =>  \"A\"\n      str =>  \"A123ab\"\n\nExceptional Situations::\n........................\n\nShould be prepared to signal an error of type type-error if sequence is\nnot a proper sequence.  Should be prepared to signal an error of type\ntype-error if new-subsequence is not a proper sequence.\n\nSee Also::\n..........\n\n*Note replace::\n\n"
}