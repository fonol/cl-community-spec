{
    "name": "print-object",
    "prev": "pprint-tab",
    "next": "print-unreadable-object",
    "up": "Printer Dictionary",
    "header": {
        "type": "Standard Generic Function",
        "text": "print-object"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "print-object",
                    "text": " object stream =>  object\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "print-object",
                    "text": " (object standard-object) stream\n"
                },
                {
                    "name": "print-object",
                    "text": " (object structure-object) stream\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "object",
                    "desc": "an object."
                },
                {
                    "name": "stream",
                    "desc": "a stream."
                }
            ]
        },
        {
            "type": "Description",
            "text": "The generic function print-object writes the printed representation of\nobject to stream.  The function print-object is called by the Lisp printer;\nit should not be called by the user.\nEach implementation is required to provide a method on the class\nstandard-object and on the class structure-object.  In addition, each\nimplementation must provide methods on enough other classes so as to\nensure that there is always an applicable method.  Implementations are\nfree to add methods for other classes.  Users may write methods for\nprint-object for their own classes if they do not wish to inherit an\nimplementation-dependent method.\nThe method on the class structure-object prints the object in the default\n#S notation; see *Note Printing Structures::.\nMethods on print-object are responsible for implementing their part of the\nsemantics of the printer control variables, as follows:\n*print-readably*\n     All methods for print-object must obey *print-readably*.  This\n     includes both user-defined methods and implementation-defined methods.\n     Readable printing of structures and standard objects is controlled by\n     their print-object method, not by their make-load-form method.\n     Similarity for these objects is application dependent and hence is\n     defined to be whatever these methods do; see *Note Similarity of\n     Literal Objects::.\n*print-escape*\n     Each method must implement *print-escape*.\n*print-pretty*\n     The method may wish to perform specialized line breaking or other\n     output conditional on the value of *print-pretty*.  For further\n     information, see (for example) the macro pprint-fill.  See also *Note\n     Pretty Print Dispatch Tables:: and *Note Examples of using the Pretty\n     Printer::.\n*print-length*\n     Methods that produce output of indefinite length must obey\n     *print-length*.\n     For further information, see (for example) the macros\n     pprint-logical-block and pprint-pop.  See also *Note Pretty Print\n     Dispatch Tables:: and *Note Examples of using the Pretty Printer::.\n*print-level*\n     The printer takes care of *print-level* automatically, provided that\n     each method handles exactly one level of structure and calls write\n     (or an equivalent function) recursively if there are more structural\n     levels.  The printer's decision of whether an object has components\n     (and therefore should not be printed when the printing depth is not\n     less than *print-level*) is implementation-dependent.  In some\n     implementations its print-object method is not called; in others the\n     method is called, and the determination that the object has\n     components is based on what it tries to write to the stream.\n*print-circle*\n     When the value of *print-circle* is true, a user-defined\n     print-object method\n     can print objects to the supplied stream using write, prin1, princ,\n     or format and expect circularities to be detected and printed using\n     the #n# syntax.  If a user-defined\n     print-object method\n     prints to a stream other than the one that was supplied, then\n     circularity detection starts over for that stream.  See\n     *print-circle*.\n*print-base*,\n     *print-radix*, *print-case*, *print-gensym*, and *print-array* These\n     printer control variables apply to specific types of objects and are\n     handled by the methods for those objects.\nIf these rules are not obeyed, the results are undefined.\nIn general, the printer and the print-object methods should not rebind the\nprint control variables as they operate recursively through the structure,\nbut this is implementation-dependent.\nIn some implementations the stream argument passed to a print-object\nmethod is not the original stream, but is an intermediate stream that\nimplements part of the printer.  methods should therefore not depend on\nthe identity of this stream.\n"
        },
        {
            "type": "See Also",
            "text": "*Note pprint-fill; pprint-linear; pprint-tabular:: , *Note\npprint-logical-block:: , *Note pprint-pop:: , *Note write; prin1; print;\npprint; princ:: , *print-readably*, *print-escape*, *print-pretty*,\n*print-length*, *Note Default Print-Object Methods::,\n*Note Printing Structures::,\n*Note Pretty Print Dispatch Tables::, *Note Examples of using the Pretty\nPrinter::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: print-object,  Next: print-unreadable-object,  Prev: pprint-tab,  Up: Printer Dictionary\n\nprint-object                                    [Standard Generic Function]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n`print-object'  object stream =>  object\n\nMethod Signatures::\n...................\n\n`print-object'  (object standard-object) stream\n\n`print-object'  (object structure-object) stream\n\nArguments and Values::\n......................\n\nobject--an object.\n\nstream--a stream.\n\nDescription::\n.............\n\nThe generic function print-object writes the printed representation of\nobject to stream.  The function print-object is called by the Lisp printer;\nit should not be called by the user.\n\nEach implementation is required to provide a method on the class\nstandard-object and on the class structure-object.  In addition, each\nimplementation must provide methods on enough other classes so as to\nensure that there is always an applicable method.  Implementations are\nfree to add methods for other classes.  Users may write methods for\nprint-object for their own classes if they do not wish to inherit an\nimplementation-dependent method.\n\nThe method on the class structure-object prints the object in the default\n#S notation; see *Note Printing Structures::.\n\nMethods on print-object are responsible for implementing their part of the\nsemantics of the printer control variables, as follows:\n\n*print-readably*\n     All methods for print-object must obey *print-readably*.  This\n     includes both user-defined methods and implementation-defined methods.\n     Readable printing of structures and standard objects is controlled by\n     their print-object method, not by their make-load-form method.\n     Similarity for these objects is application dependent and hence is\n     defined to be whatever these methods do; see *Note Similarity of\n     Literal Objects::.\n\n*print-escape*\n     Each method must implement *print-escape*.\n\n*print-pretty*\n     The method may wish to perform specialized line breaking or other\n     output conditional on the value of *print-pretty*.  For further\n     information, see (for example) the macro pprint-fill.  See also *Note\n     Pretty Print Dispatch Tables:: and *Note Examples of using the Pretty\n     Printer::.\n\n*print-length*\n     Methods that produce output of indefinite length must obey\n     *print-length*.\n\n     For further information, see (for example) the macros\n     pprint-logical-block and pprint-pop.  See also *Note Pretty Print\n     Dispatch Tables:: and *Note Examples of using the Pretty Printer::.\n\n*print-level*\n     The printer takes care of *print-level* automatically, provided that\n     each method handles exactly one level of structure and calls write\n     (or an equivalent function) recursively if there are more structural\n     levels.  The printer's decision of whether an object has components\n     (and therefore should not be printed when the printing depth is not\n     less than *print-level*) is implementation-dependent.  In some\n     implementations its print-object method is not called; in others the\n     method is called, and the determination that the object has\n     components is based on what it tries to write to the stream.\n\n*print-circle*\n     When the value of *print-circle* is true, a user-defined\n\n     print-object method\n\n     can print objects to the supplied stream using write, prin1, princ,\n     or format and expect circularities to be detected and printed using\n     the #n# syntax.  If a user-defined\n\n     print-object method\n\n     prints to a stream other than the one that was supplied, then\n     circularity detection starts over for that stream.  See\n     *print-circle*.\n\n*print-base*,\n     *print-radix*, *print-case*, *print-gensym*, and *print-array* These\n     printer control variables apply to specific types of objects and are\n     handled by the methods for those objects.\n\nIf these rules are not obeyed, the results are undefined.\n\nIn general, the printer and the print-object methods should not rebind the\nprint control variables as they operate recursively through the structure,\nbut this is implementation-dependent.\n\nIn some implementations the stream argument passed to a print-object\nmethod is not the original stream, but is an intermediate stream that\nimplements part of the printer.  methods should therefore not depend on\nthe identity of this stream.\n\nSee Also::\n..........\n\n*Note pprint-fill; pprint-linear; pprint-tabular:: , *Note\npprint-logical-block:: , *Note pprint-pop:: , *Note write; prin1; print;\npprint; princ:: , *print-readably*, *print-escape*, *print-pretty*,\n*print-length*, *Note Default Print-Object Methods::,\n\n*Note Printing Structures::,\n\n*Note Pretty Print Dispatch Tables::, *Note Examples of using the Pretty\nPrinter::\n\n"
}