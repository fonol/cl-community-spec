{
    "name": "dynamic-extent",
    "prev": "ignore",
    "next": "type",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Declaration",
        "text": "dynamic-extent"
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "text": "(dynamic-extent [[{var}* | (function fn)*]])\n"
        },
        {
            "type": "Arguments",
            "text": "var--a variable name.\nfn--a function name.\n"
        },
        {
            "type": "Valid Context",
            "text": "declaration\n"
        },
        {
            "type": "Binding Types Affected",
            "text": "variable, function\n"
        },
        {
            "type": "Description",
            "text": "In some containing form, F, this declaration asserts for each var_i (which\nneed not be bound by F), and for each value v_{ij} that var_i takes on,\nand for each object x_{ijk} that is an otherwise inaccessible part of\nv_{ij} at any time when v_{ij} becomes the value of var_i, that just after\nthe execution of F terminates, x_{ijk} is either inaccessible (if F\nestablished a binding for var_i) or still an otherwise inaccessible part\nof the current value of var_i (if F did not establish a binding for var_i).\nThe same relation holds for each fn_i, except that the bindings are in the\nfunction namespace.\nThe compiler is permitted to use this information in any way that is\nappropriate to the implementation and that does not conflict with the\nsemantics of Common Lisp.\ndynamic-extent declarations can be free declarations or bound declarations.\nThe vars and fns named in a dynamic-extent declaration must not refer to\nsymbol macro or macro bindings.\n"
        },
        {
            "type": "Examples",
            "text": "Since stack allocation of the initial value entails knowing at the\nobject's creation time that the object can be stack-allocated,  it is not\ngenerally useful to make a dynamic-extent declaration for variables which\nhave no lexically apparent initial value.  For example, it is probably\nuseful to write:\n      (defun f ()\n        (let ((x (list 1 2 3)))\n          (declare (dynamic-extent x))\n              ...))\nThis would permit those compilers that wish to do so to stack allocate the\nlist held by the local variable x.  It is permissible, but in practice\nprobably not as useful, to write:\n      (defun g (x) (declare (dynamic-extent x)) ...)\n      (defun f () (g (list 1 2 3)))\nMost compilers would probably not stack allocate the argument to g in f\nbecause it would be a modularity violation for the compiler to assume\nfacts about g from within f.   Only an implementation that was willing to\nbe responsible for recompiling f if the definition of g changed\nincompatibly could legitimately stack allocate the list argument to g in f.\nHere is another example:\n      (declaim (inline g))\n      (defun g (x) (declare (dynamic-extent x)) ...)\n      (defun f () (g (list 1 2 3)))\n      (defun f ()\n        (flet ((g (x) (declare (dynamic-extent x)) ...))\n          (g (list 1 2 3))))\nIn the previous example, some compilers might determine that optimization\nwas possible and others might not.\nA variant of this is the so-called \"stack allocated rest list\" that can be\nachieved (in implementations supporting the optimization) by:\n      (defun f (&rest x)\n        (declare (dynamic-extent x))\n        ...)\nNote that although the initial value of x is not explicit, the f function\nis responsible for assembling the list x from the passed arguments, so the\nf function can be optimized by the compiler to construct a stack-allocated\nlist instead of a heap-allocated list in implementations that support such.\nIn the following example,\n      (let ((x (list 'a1 'b1 'c1))\n            (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))\n        (declare (dynamic-extent x y))\n        ...)\nThe otherwise inaccessible parts of x are three conses,  and the otherwise\ninaccessible parts of y are three other conses.  None of the symbols a1,\nb1,  c1,  a2, b2,  c2,  or nil is an otherwise inaccessible part of x or y\nbecause each is interned and hence accessible by the package (or packages)\nin which it is interned.  However, if a freshly allocated uninterned\nsymbol had been used, it would have been an otherwise inaccessible part of\nthe list which contained it.\n     ;; In this example, the implementation is permitted to stack allocate\n     ;; the list that is bound to X.\n      (let ((x (list 1 2 3)))\n        (declare (dynamic-extent x))\n        (print x)\n        :done)\n      |>  (1 2 3)\n     =>  :DONE\n     ;; In this example, the list to be bound to L can be stack-allocated.\n      (defun zap (x y z)\n        (do ((l (list x y z) (cdr l)))\n            ((null l))\n          (declare (dynamic-extent l))\n          (prin1 (car l)))) =>  ZAP\n      (zap 1 2 3)\n      |>  123\n     =>  NIL\n     ;; Some implementations might open-code LIST-ALL-PACKAGES in a way\n     ;; that permits using stack allocation of the list to be bound to L.\n      (do ((l (list-all-packages) (cdr l)))\n          ((null l))\n        (declare (dynamic-extent l))\n        (let ((name (package-name (car l))))\n          (when (string-search \"COMMON-LISP\" name) (print name))))\n      |>  \"COMMON-LISP\"\n      |>  \"COMMON-LISP-USER\"\n     =>  NIL\n     ;; Some implementations might have the ability to stack allocate\n     ;; rest lists.  A declaration such as the following should be a cue\n     ;; to such implementations that stack-allocation of the rest list\n     ;; would be desirable.\n      (defun add (&rest x)\n        (declare (dynamic-extent x))\n        (apply #'+ x)) =>  ADD\n      (add 1 2 3) =>  6\n      (defun zap (n m)\n        ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).\n        ;; It may be slow, but with a good compiler at least it\n        ;; doesn't waste much heap storage.  :-}\n        (let ((a (make-array n)))\n          (declare (dynamic-extent a))\n          (dotimes (i n)\n            (declare (dynamic-extent i))\n            (setf (aref a i) (random (+ i 1))))\n          (aref a m))) =>  ZAP\n      (< (zap 5 3) 3) =>  true\nThe following are in error, since the value of x is used outside of its\nextent:\n      (length (list (let ((x (list 1 2 3)))  ; Invalid\n                     (declare (dynamic-extent x))\n                     x)))\n      (progn (let ((x (list 1 2 3)))  ; Invalid\n               (declare (dynamic-extent x))\n               x)\n             nil)\n"
        },
        {
            "type": "See Also",
            "text": "declare\n"
        },
        {
            "type": "Notes",
            "text": "The most common optimization is to stack allocate the initial value of the\nobjects named by the vars.\nIt is permissible for an implementation to simply ignore this declaration.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: dynamic-extent,  Next: type,  Prev: ignore,  Up: Evaluation and Compilation Dictionary\n\ndynamic-extent                                                [Declaration]\n---------------------------------------------------------------------------\n\nSyntax::\n........\n\n(dynamic-extent [[{var}* | (function fn)*]])\n\nArguments::\n...........\n\nvar--a variable name.\n\nfn--a function name.\n\nValid Context::\n...............\n\ndeclaration\n\nBinding Types Affected::\n........................\n\nvariable, function\n\nDescription::\n.............\n\nIn some containing form, F, this declaration asserts for each var_i (which\nneed not be bound by F), and for each value v_{ij} that var_i takes on,\nand for each object x_{ijk} that is an otherwise inaccessible part of\nv_{ij} at any time when v_{ij} becomes the value of var_i, that just after\nthe execution of F terminates, x_{ijk} is either inaccessible (if F\nestablished a binding for var_i) or still an otherwise inaccessible part\nof the current value of var_i (if F did not establish a binding for var_i).\n\nThe same relation holds for each fn_i, except that the bindings are in the\nfunction namespace.\n\nThe compiler is permitted to use this information in any way that is\nappropriate to the implementation and that does not conflict with the\nsemantics of Common Lisp.\n\ndynamic-extent declarations can be free declarations or bound declarations.\n\nThe vars and fns named in a dynamic-extent declaration must not refer to\nsymbol macro or macro bindings.\n\nExamples::\n..........\n\nSince stack allocation of the initial value entails knowing at the\nobject's creation time that the object can be stack-allocated,  it is not\ngenerally useful to make a dynamic-extent declaration for variables which\nhave no lexically apparent initial value.  For example, it is probably\nuseful to write:\n\n      (defun f ()\n        (let ((x (list 1 2 3)))\n          (declare (dynamic-extent x))\n              ...))\n\nThis would permit those compilers that wish to do so to stack allocate the\nlist held by the local variable x.  It is permissible, but in practice\nprobably not as useful, to write:\n\n      (defun g (x) (declare (dynamic-extent x)) ...)\n      (defun f () (g (list 1 2 3)))\n\nMost compilers would probably not stack allocate the argument to g in f\nbecause it would be a modularity violation for the compiler to assume\nfacts about g from within f.   Only an implementation that was willing to\nbe responsible for recompiling f if the definition of g changed\nincompatibly could legitimately stack allocate the list argument to g in f.\n\nHere is another example:\n\n      (declaim (inline g))\n      (defun g (x) (declare (dynamic-extent x)) ...)\n      (defun f () (g (list 1 2 3)))\n     \n      (defun f ()\n        (flet ((g (x) (declare (dynamic-extent x)) ...))\n          (g (list 1 2 3))))\n\nIn the previous example, some compilers might determine that optimization\nwas possible and others might not.\n\nA variant of this is the so-called \"stack allocated rest list\" that can be\nachieved (in implementations supporting the optimization) by:\n\n      (defun f (&rest x)\n        (declare (dynamic-extent x))\n        ...)\n\nNote that although the initial value of x is not explicit, the f function\nis responsible for assembling the list x from the passed arguments, so the\nf function can be optimized by the compiler to construct a stack-allocated\nlist instead of a heap-allocated list in implementations that support such.\n\nIn the following example,\n\n      (let ((x (list 'a1 'b1 'c1))\n            (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))\n        (declare (dynamic-extent x y))\n        ...)\n\nThe otherwise inaccessible parts of x are three conses,  and the otherwise\ninaccessible parts of y are three other conses.  None of the symbols a1,\nb1,  c1,  a2, b2,  c2,  or nil is an otherwise inaccessible part of x or y\nbecause each is interned and hence accessible by the package (or packages)\nin which it is interned.  However, if a freshly allocated uninterned\nsymbol had been used, it would have been an otherwise inaccessible part of\nthe list which contained it.\n\n     ;; In this example, the implementation is permitted to stack allocate\n     ;; the list that is bound to X.\n      (let ((x (list 1 2 3)))\n        (declare (dynamic-extent x))\n        (print x)\n        :done)\n      |>  (1 2 3)\n     =>  :DONE\n     \n     ;; In this example, the list to be bound to L can be stack-allocated.\n      (defun zap (x y z)\n        (do ((l (list x y z) (cdr l)))\n            ((null l))\n          (declare (dynamic-extent l))\n          (prin1 (car l)))) =>  ZAP\n      (zap 1 2 3)\n      |>  123\n     =>  NIL\n     \n     ;; Some implementations might open-code LIST-ALL-PACKAGES in a way\n     ;; that permits using stack allocation of the list to be bound to L.\n      (do ((l (list-all-packages) (cdr l)))\n          ((null l))\n        (declare (dynamic-extent l))\n        (let ((name (package-name (car l))))\n          (when (string-search \"COMMON-LISP\" name) (print name))))\n      |>  \"COMMON-LISP\"\n      |>  \"COMMON-LISP-USER\"\n     =>  NIL\n     \n     ;; Some implementations might have the ability to stack allocate\n     ;; rest lists.  A declaration such as the following should be a cue\n     ;; to such implementations that stack-allocation of the rest list\n     ;; would be desirable.\n      (defun add (&rest x)\n        (declare (dynamic-extent x))\n        (apply #'+ x)) =>  ADD\n      (add 1 2 3) =>  6\n     \n      (defun zap (n m)\n        ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).\n        ;; It may be slow, but with a good compiler at least it\n        ;; doesn't waste much heap storage.  :-}\n        (let ((a (make-array n)))\n          (declare (dynamic-extent a))\n          (dotimes (i n)\n            (declare (dynamic-extent i))\n            (setf (aref a i) (random (+ i 1))))\n          (aref a m))) =>  ZAP\n      (< (zap 5 3) 3) =>  true\n\nThe following are in error, since the value of x is used outside of its\nextent:\n\n      (length (list (let ((x (list 1 2 3)))  ; Invalid\n                     (declare (dynamic-extent x))\n                     x)))\n     \n      (progn (let ((x (list 1 2 3)))  ; Invalid\n               (declare (dynamic-extent x))\n               x)\n             nil)\n\nSee Also::\n..........\n\ndeclare\n\nNotes::\n.......\n\nThe most common optimization is to stack allocate the initial value of the\nobjects named by the vars.\n\nIt is permissible for an implementation to simply ignore this declaration.\n\n"
}