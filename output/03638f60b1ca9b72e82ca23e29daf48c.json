{
    "name": "compile",
    "prev": "lambda",
    "next": "eval",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Function",
        "text": "compile"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "compile",
                    "text": " name &optional definition =>  function, warnings-p, failure-p\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a function name, or nil."
                },
                {
                    "name": "definition",
                    "desc": "a lambda expression or a function.  The default is thefunction definition of name if it names a function, or the macro function\nof name if it names a macro.  The consequences are undefined if no\ndefinition is supplied when the name is nil.\n"
                },
                {
                    "name": "function",
                    "desc": "the function-name,or a compiled function.\n"
                },
                {
                    "name": "warnings-p",
                    "desc": "a generalized boolean."
                },
                {
                    "name": "failure-p",
                    "desc": "a generalized boolean."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Compiles an interpreted function.\ncompile produces a compiled function from definition.  If the definition\nis a lambda expression, it is coerced to a function.\nIf the definition is already a compiled function, compile either produces\nthat function itself (i.e., is an identity operation) or an equivalent\nfunction.\n[Editorial Note by KMP: There are a number of ambiguities here that still\nneed resolution.] If the name is nil, the resulting compiled function is\nreturned directly as the primary value.  If a non-nil name is given, then\nthe resulting compiled function replaces the existing function definition\nof name and the name is returned as the primary value; if name is a symbol\nthat names a macro, its macro function is updated and the name is returned\nas the primary value.\nLiteral objects appearing in code processed by the compile function are\nneither copied nor coalesced.  The code resulting from the execution of\ncompile references objects that are eql to the corresponding objects in\nthe source code.\ncompile is permitted, but not required, to establish a handler for\nconditions of type error.  For example, the handler might issue a warning\nand restart compilation from some implementation-dependent point in order\nto let the compilation proceed without manual intervention.\nThe secondary value, warnings-p, is false if no conditions of type error\nor warning were detected by the compiler, and true otherwise.\nThe tertiary value, failure-p, is false if no conditions of type error or\nwarning (other than style-warning) were detected by the compiler, and true\notherwise.\n"
        },
        {
            "type": "Examples",
            "text": "      (defun foo () \"bar\") =>  FOO\n      (compiled-function-p #'foo) =>  implementation-dependent\n      (compile 'foo) =>  FOO\n      (compiled-function-p #'foo) =>  true\n      (setf (symbol-function 'foo)\n            (compile nil '(lambda () \"replaced\"))) =>  #<Compiled-Function>\n      (foo) =>  \"replaced\"\n"
        },
        {
            "type": "Affected By",
            "text": "*error-output*,\n*macroexpand-hook*.\nThe presence of macro definitions and proclamations.\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "The consequences are undefined if the lexical environment surrounding the\nfunction to be compiled contains any bindings other than those for macros,\nsymbol macros, or declarations.\nFor information about errors detected during the compilation process, see\n*Note Exceptional Situations in the Compiler::.\n"
        },
        {
            "type": "See Also",
            "text": "*Note compile-file::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: compile,  Next: eval,  Prev: lambda,  Up: Evaluation and Compilation Dictionary\n\ncompile                                                          [Function]\n---------------------------------------------------------------------------\n\n`compile'  name &optional definition =>  function, warnings-p, failure-p\n\nArguments and Values::\n......................\n\nname--a function name, or nil.\n\ndefinition--a lambda expression or a function.  The default is the\nfunction definition of name if it names a function, or the macro function\nof name if it names a macro.  The consequences are undefined if no\ndefinition is supplied when the name is nil.\n\nfunction--the function-name,\n\nor a compiled function.\n\nwarnings-p--a generalized boolean.\n\nfailure-p--a generalized boolean.\n\nDescription::\n.............\n\nCompiles an interpreted function.\n\ncompile produces a compiled function from definition.  If the definition\nis a lambda expression, it is coerced to a function.\n\nIf the definition is already a compiled function, compile either produces\nthat function itself (i.e., is an identity operation) or an equivalent\nfunction.\n\n[Editorial Note by KMP: There are a number of ambiguities here that still\nneed resolution.] If the name is nil, the resulting compiled function is\nreturned directly as the primary value.  If a non-nil name is given, then\nthe resulting compiled function replaces the existing function definition\nof name and the name is returned as the primary value; if name is a symbol\nthat names a macro, its macro function is updated and the name is returned\nas the primary value.\n\nLiteral objects appearing in code processed by the compile function are\nneither copied nor coalesced.  The code resulting from the execution of\ncompile references objects that are eql to the corresponding objects in\nthe source code.\n\ncompile is permitted, but not required, to establish a handler for\nconditions of type error.  For example, the handler might issue a warning\nand restart compilation from some implementation-dependent point in order\nto let the compilation proceed without manual intervention.\n\nThe secondary value, warnings-p, is false if no conditions of type error\nor warning were detected by the compiler, and true otherwise.\n\nThe tertiary value, failure-p, is false if no conditions of type error or\nwarning (other than style-warning) were detected by the compiler, and true\notherwise.\n\nExamples::\n..........\n\n      (defun foo () \"bar\") =>  FOO\n      (compiled-function-p #'foo) =>  implementation-dependent\n      (compile 'foo) =>  FOO\n      (compiled-function-p #'foo) =>  true\n      (setf (symbol-function 'foo)\n            (compile nil '(lambda () \"replaced\"))) =>  #<Compiled-Function>\n      (foo) =>  \"replaced\"\n\nAffected By::\n.............\n\n*error-output*,\n\n*macroexpand-hook*.\n\nThe presence of macro definitions and proclamations.\n\nExceptional Situations::\n........................\n\nThe consequences are undefined if the lexical environment surrounding the\nfunction to be compiled contains any bindings other than those for macros,\nsymbol macros, or declarations.\n\nFor information about errors detected during the compilation process, see\n*Note Exceptional Situations in the Compiler::.\n\nSee Also::\n..........\n\n*Note compile-file::\n\n"
}