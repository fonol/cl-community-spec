{
    "name": "parse-namestring",
    "prev": "namestring",
    "next": "wild-pathname-p",
    "up": "Filenames Dictionary",
    "header": {
        "type": "Function",
        "text": "parse-namestring"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "parse-namestring",
                    "text": " thing &optional host default-pathname &key start endjunk-allowed\n=>  pathname, position\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "thing",
                    "desc": "a string, a pathname, or a stream associated with a file."
                },
                {
                    "name": "host",
                    "desc": "a valid pathname host, a logical host, or nil."
                },
                {
                    "name": "default-pathname",
                    "desc": "a pathname designator.  The default is the value of"
                },
                {
                    "name": "default-pathname",
                    "desc": "a pathname designator.  The default is the value of*default-pathname-defaults*.\n"
                },
                {
                    "name": "start, end",
                    "desc": "bounding index designators of thing.  The defaults for start"
                },
                {
                    "name": "start, end",
                    "desc": "bounding index designators of thing.  The defaults for startand end are 0 and nil, respectively.\n"
                },
                {
                    "name": "junk-allowed",
                    "desc": "a generalized boolean.  The default is false."
                },
                {
                    "name": "pathname",
                    "desc": "a pathname, or nil."
                },
                {
                    "name": "position",
                    "desc": "a bounding index designator for thing."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Converts thing into a pathname.\nThe host supplies a host name with respect to which the parsing occurs.\nIf thing is a stream associated with a file, processing proceeds as if the\npathname used to open that file had been supplied instead.\nIf thing is a pathname, the host and the host component of thing are\ncompared.  If they match, two values are immediately returned: thing and\nstart; otherwise (if they do not match), an error is signaled.\nOtherwise (if thing is a string), parse-namestring parses the name of a\nfile within the substring of thing bounded by start and end.\nIf thing is a string then the substring of thing bounded by start and end\nis parsed into a pathname as follows:\n*\n     If host is a logical host then thing is parsed as a logical pathname\n     namestring on the host.\n*\n     If host is nil and thing is a syntactically valid logical pathname\n     namestring containing an explicit host, then it is parsed as a\n     logical pathname namestring.\n*\n     If  host is nil, default-pathname is a logical pathname, and thing is\n     a syntactically valid logical pathname namestring without an explicit\n     host, then it is parsed as a logical pathname namestring on the host\n     that is the host component of default-pathname.\n*\n     Otherwise, the parsing of thing is implementation-defined.\nIn the first of these cases, the host portion of the logical pathname\nnamestring and its following colon are optional.\nIf the host portion of the namestring and host are both present and do not\nmatch, an error is signaled.\nIf junk-allowed is true, then the primary value is the pathname parsed or,\nif no syntactically correct pathname was seen, nil.  If junk-allowed is\nfalse, then the entire substring is scanned, and the primary value is the\npathname parsed.\nIn either case, the secondary value is the index into thing of the\ndelimiter that terminated the parse, or the index beyond the substring if\nthe parse terminated at the end of the substring (as will always be the\ncase if junk-allowed is false).\nParsing a null string always succeeds, producing a pathname with all\ncomponents (except the host) equal to nil.\nIf thing contains an explicit host name and no explicit device name, then\nit is implementation-defined whether parse-namestring will supply the\nstandard default device for that host as the device component of the\nresulting pathname.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq q (parse-namestring \"test\"))\n     =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \"test\"\n            :TYPE NIL :VERSION NIL)\n      (pathnamep q) =>  true\n      (parse-namestring \"test\")\n     =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \"test\"\n            :TYPE NIL :VERSION NIL), 4\n      (setq s (open xxx)) =>  #<Input File Stream...>\n      (parse-namestring s)\n     =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx\n            :TYPE NIL :VERSION NIL), 0\n      (parse-namestring \"test\" nil nil :start 2 :end 4 )\n      =>  #S(PATHNAME ...), 15\n      (parse-namestring \"foo.lisp\")\n     =>  #P\"foo.lisp\"\n"
        },
        {
            "type": "Exceptional Situations",
            "text": "If junk-allowed is false, an error of type parse-error is signaled if thing\ndoes not consist entirely of the representation of a pathname, possibly\nsurrounded on either side by whitespace_1 characters if that is\nappropriate to the cultural conventions of the implementation.\nIf host is supplied and not nil, and thing contains a manifest host name,\nan error of type error is signaled if the hosts do not match.\nIf thing is a logical pathname namestring and if the host portion of the\nnamestring and host are both present and do not match, an error of type\nerror is signaled.\n"
        },
        {
            "type": "See Also",
            "text": "pathname, logical-pathname, *Note File System Concepts::,\n*Note ->UNSPECIFIC as a Component Value::,\n*Note Pathnames as Filenames::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: parse-namestring,  Next: wild-pathname-p,  Prev: namestring,  Up: Filenames Dictionary\n\nparse-namestring                                                 [Function]\n---------------------------------------------------------------------------\n\n`parse-namestring'  thing &optional host default-pathname &key start end\njunk-allowed\n=>  pathname, position\n\nArguments and Values::\n......................\n\nthing--a string, a pathname, or a stream associated with a file.\n\nhost--a valid pathname host, a logical host, or nil.\n\ndefault-pathname--a pathname designator.  The default is the value of\n*default-pathname-defaults*.\n\nstart, end--bounding index designators of thing.  The defaults for start\nand end are 0 and nil, respectively.\n\njunk-allowed--a generalized boolean.  The default is false.\n\npathname--a pathname, or nil.\n\nposition--a bounding index designator for thing.\n\nDescription::\n.............\n\nConverts thing into a pathname.\n\nThe host supplies a host name with respect to which the parsing occurs.\n\nIf thing is a stream associated with a file, processing proceeds as if the\npathname used to open that file had been supplied instead.\n\nIf thing is a pathname, the host and the host component of thing are\ncompared.  If they match, two values are immediately returned: thing and\nstart; otherwise (if they do not match), an error is signaled.\n\nOtherwise (if thing is a string), parse-namestring parses the name of a\nfile within the substring of thing bounded by start and end.\n\nIf thing is a string then the substring of thing bounded by start and end\nis parsed into a pathname as follows:\n\n*\n     If host is a logical host then thing is parsed as a logical pathname\n     namestring on the host.\n\n*\n     If host is nil and thing is a syntactically valid logical pathname\n     namestring containing an explicit host, then it is parsed as a\n     logical pathname namestring.\n\n*\n     If  host is nil, default-pathname is a logical pathname, and thing is\n     a syntactically valid logical pathname namestring without an explicit\n     host, then it is parsed as a logical pathname namestring on the host\n     that is the host component of default-pathname.\n\n*\n     Otherwise, the parsing of thing is implementation-defined.\n\nIn the first of these cases, the host portion of the logical pathname\nnamestring and its following colon are optional.\n\nIf the host portion of the namestring and host are both present and do not\nmatch, an error is signaled.\n\nIf junk-allowed is true, then the primary value is the pathname parsed or,\nif no syntactically correct pathname was seen, nil.  If junk-allowed is\nfalse, then the entire substring is scanned, and the primary value is the\npathname parsed.\n\nIn either case, the secondary value is the index into thing of the\ndelimiter that terminated the parse, or the index beyond the substring if\nthe parse terminated at the end of the substring (as will always be the\ncase if junk-allowed is false).\n\nParsing a null string always succeeds, producing a pathname with all\ncomponents (except the host) equal to nil.\n\nIf thing contains an explicit host name and no explicit device name, then\nit is implementation-defined whether parse-namestring will supply the\nstandard default device for that host as the device component of the\nresulting pathname.\n\nExamples::\n..........\n\n      (setq q (parse-namestring \"test\"))\n     =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \"test\"\n            :TYPE NIL :VERSION NIL)\n      (pathnamep q) =>  true\n      (parse-namestring \"test\")\n     =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \"test\"\n            :TYPE NIL :VERSION NIL), 4\n      (setq s (open xxx)) =>  #<Input File Stream...>\n      (parse-namestring s)\n     =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx\n            :TYPE NIL :VERSION NIL), 0\n      (parse-namestring \"test\" nil nil :start 2 :end 4 )\n      =>  #S(PATHNAME ...), 15\n      (parse-namestring \"foo.lisp\")\n     =>  #P\"foo.lisp\"\n\nExceptional Situations::\n........................\n\nIf junk-allowed is false, an error of type parse-error is signaled if thing\ndoes not consist entirely of the representation of a pathname, possibly\nsurrounded on either side by whitespace_1 characters if that is\nappropriate to the cultural conventions of the implementation.\n\nIf host is supplied and not nil, and thing contains a manifest host name,\nan error of type error is signaled if the hosts do not match.\n\nIf thing is a logical pathname namestring and if the host portion of the\nnamestring and host are both present and do not match, an error of type\nerror is signaled.\n\nSee Also::\n..........\n\npathname, logical-pathname, *Note File System Concepts::,\n\n*Note ->UNSPECIFIC as a Component Value::,\n\n*Note Pathnames as Filenames::\n\n"
}