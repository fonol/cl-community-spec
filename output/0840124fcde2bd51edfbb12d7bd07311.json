{
    "name": "Parsing Loop Clauses",
    "prev": "Loop Keywords",
    "next": "Expanding Loop Forms",
    "up": "Overview of the Loop Facility",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Parsing Loop Clauses",
            "text": "The syntactic parts of an extended loop form are called clauses; the rules\nfor parsing are determined by that clause's keyword.  The following\nexample shows a loop form with six clauses:\n      (loop for i from 1 to (compute-top-value)       ; first clause\n            while (not (unacceptable i))              ; second clause\n            collect (square i)                        ; third clause\n            do (format t \"Working on ~D now\" i)       ; fourth clause\n            when (evenp i)                            ; fifth clause\n              do (format t \"~D is a non-odd number\" i)\n            finally (format t \"About to exit!\"))      ; sixth clause\nEach loop keyword introduces either a compound loop clause or a simple\nloop clause that can consist of a loop keyword followed by a single form.\nThe number of forms in a clause is determined by the loop keyword that\nbegins the clause and by the auxiliary keywords in the clause.  The\nkeywords do,\ndoing,\ninitially, and finally are the only loop keywords that can take any number\nof forms and group them as an implicit progn.\nLoop clauses can contain auxiliary keywords, which are sometimes called\nprepositions.  For example, the first clause in the code above includes\nthe prepositions from and to, which mark the value from which stepping\nbegins and the value at which stepping ends.\nFor detailed information about loop syntax, see the macro loop.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Parsing Loop Clauses,  Next: Expanding Loop Forms,  Prev: Loop Keywords,  Up: Overview of the Loop Facility\n\nParsing Loop Clauses\n....................\n\nThe syntactic parts of an extended loop form are called clauses; the rules\nfor parsing are determined by that clause's keyword.  The following\nexample shows a loop form with six clauses:\n\n      (loop for i from 1 to (compute-top-value)       ; first clause\n            while (not (unacceptable i))              ; second clause\n            collect (square i)                        ; third clause\n            do (format t \"Working on ~D now\" i)       ; fourth clause\n            when (evenp i)                            ; fifth clause\n              do (format t \"~D is a non-odd number\" i)\n            finally (format t \"About to exit!\"))      ; sixth clause\n\nEach loop keyword introduces either a compound loop clause or a simple\nloop clause that can consist of a loop keyword followed by a single form.\nThe number of forms in a clause is determined by the loop keyword that\nbegins the clause and by the auxiliary keywords in the clause.  The\nkeywords do,\n\ndoing,\n\ninitially, and finally are the only loop keywords that can take any number\nof forms and group them as an implicit progn.\n\nLoop clauses can contain auxiliary keywords, which are sometimes called\nprepositions.  For example, the first clause in the code above includes\nthe prepositions from and to, which mark the value from which stepping\nbegins and the value at which stepping ends.\n\nFor detailed information about loop syntax, see the macro loop.\n\n"
}