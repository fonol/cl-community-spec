{
    "name": "Inheritance of Slots and Slot Options",
    "prev": "Accessing Slots",
    "next": null,
    "up": "Slots",
    "header": {
        "type": null,
        "text": "Inheritance of Slots and Slot Options"
    },
    "sections": [
        {
            "type": "",
            "text": "The set of the names of all slots accessible in an instance of a class C\nis the union of the sets of names of slots defined by C and its\nsuperclasses. The structure of an instance is the set of names of local\nslots in that instance.\nIn the simplest case, only one class among C and its superclasses defines\na slot with a given slot name.  If a slot is defined by a superclass of C,\nthe slot is said to be inherited.  The characteristics of the slot are\ndetermined by the slot specifier of the defining class.  Consider the\ndefining class for a slot S.  If the value of the :allocation slot option\nis :instance, then S is a local slot and each instance of C has its own\nslot named S that stores its own value.  If the value of the :allocation\nslot option is :class, then S is a shared slot, the class that defined S\nstores the value, and all instances of C can access that single slot.  If\nthe :allocation slot option is omitted, :instance is used.\nIn general, more than one class among C and its superclasses can define a\nslot with a given name.  In such cases, only one slot with the given name\nis accessible in an instance of C, and the characteristics of that slot are\na combination of the several slot specifiers, computed as follows:\n*\n     All the slot specifiers for a given slot name are ordered from most\n     specific to least specific, according to the order in C's class\n     precedence list of the classes that define them. All references to\n     the specificity of slot specifiers immediately below refers to this\n     ordering.\n*\n     The allocation of a slot is controlled by the most specific slot\n     specifier.  If the most specific slot specifier does not contain an\n     :allocation slot option, :instance is used.  Less specific slot\n     specifiers do not affect the allocation.\n*\n     The default initial value form for a slot is the value of the\n     :initform slot option in the most specific slot specifier that\n     contains one.  If no slot specifier contains an :initform slot\n     option, the slot has no default initial value form.\n*\n     The contents of a slot will always be of type (and T_1 ... T_n) where\n     T_1 ... T_n are the values of the :type slot options contained in all\n     of the slot specifiers.  If no slot specifier contains the :type slot\n     option, the contents of the slot will always be of type t. The\n     consequences of attempting to store in a slot a value that does not\n     satisfy the type of the slot are undefined.\n*\n     The set of initialization arguments that initialize a given slot is\n     the union of the initialization arguments declared in the :initarg\n     slot options in all the slot specifiers.\n*\n     The documentation string for a slot is the value of the\n     :documentation slot option in the most specific slot specifier that\n     contains one.  If no slot specifier contains a :documentation slot\n     option, the slot has no documentation string.\nA consequence of the allocation rule is that a shared slot can be\nshadowed.  For example, if a class C_1 defines a slot named S whose value\nfor the :allocation slot option is :class, that slot is accessible in\ninstances of C_1 and all of its subclasses.  However, if C_2 is a subclass\nof C_1 and also defines a slot named S, C_1's slot is not shared by\ninstances of C_2 and its subclasses. When a class C_1 defines a shared\nslot, any subclass C_2 of C_1 will share this single slot unless the\ndefclass form for C_2 specifies a slot of the same name or there is a\nsuperclass of C_2 that precedes C_1 in the class precedence list of C_2\nthat defines a slot of the same name.\nA consequence of the type rule is that the value of a slot satisfies the\ntype constraint of each slot specifier that contributes to that slot.\nBecause the result of attempting to store in a slot a value that does not\nsatisfy the type constraint for the slot is undefined, the value in a slot\nmight fail to satisfy its type constraint.\nThe :reader, :writer, and :accessor slot options create methods rather\nthan define the characteristics of a slot.  Reader and writer methods are\ninherited in the sense described in *Note Inheritance of Methods::.\nMethods that access slots use only the name of the slot and the type of\nthe slot's value.  Suppose a superclass provides a method that expects to\naccess a shared slot of a given name, and a subclass defines a local slot\nwith the same name.  If the method provided by the superclass is used on\nan instance of the subclass, the method accesses the local slot.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Inheritance of Slots and Slot Options,  Prev: Accessing Slots,  Up: Slots\n\nInheritance of Slots and Slot Options\n-------------------------------------\n\nThe set of the names of all slots accessible in an instance of a class C\nis the union of the sets of names of slots defined by C and its\nsuperclasses. The structure of an instance is the set of names of local\nslots in that instance.\n\nIn the simplest case, only one class among C and its superclasses defines\na slot with a given slot name.  If a slot is defined by a superclass of C,\nthe slot is said to be inherited.  The characteristics of the slot are\ndetermined by the slot specifier of the defining class.  Consider the\ndefining class for a slot S.  If the value of the :allocation slot option\nis :instance, then S is a local slot and each instance of C has its own\nslot named S that stores its own value.  If the value of the :allocation\nslot option is :class, then S is a shared slot, the class that defined S\nstores the value, and all instances of C can access that single slot.  If\nthe :allocation slot option is omitted, :instance is used.\n\nIn general, more than one class among C and its superclasses can define a\nslot with a given name.  In such cases, only one slot with the given name\nis accessible in an instance of C, and the characteristics of that slot are\na combination of the several slot specifiers, computed as follows:\n\n*\n     All the slot specifiers for a given slot name are ordered from most\n     specific to least specific, according to the order in C's class\n     precedence list of the classes that define them. All references to\n     the specificity of slot specifiers immediately below refers to this\n     ordering.\n\n*\n     The allocation of a slot is controlled by the most specific slot\n     specifier.  If the most specific slot specifier does not contain an\n     :allocation slot option, :instance is used.  Less specific slot\n     specifiers do not affect the allocation.\n\n*\n     The default initial value form for a slot is the value of the\n     :initform slot option in the most specific slot specifier that\n     contains one.  If no slot specifier contains an :initform slot\n     option, the slot has no default initial value form.\n\n*\n     The contents of a slot will always be of type (and T_1 ... T_n) where\n     T_1 ... T_n are the values of the :type slot options contained in all\n     of the slot specifiers.  If no slot specifier contains the :type slot\n     option, the contents of the slot will always be of type t. The\n     consequences of attempting to store in a slot a value that does not\n     satisfy the type of the slot are undefined.\n\n*\n     The set of initialization arguments that initialize a given slot is\n     the union of the initialization arguments declared in the :initarg\n     slot options in all the slot specifiers.\n\n*\n     The documentation string for a slot is the value of the\n     :documentation slot option in the most specific slot specifier that\n     contains one.  If no slot specifier contains a :documentation slot\n     option, the slot has no documentation string.\n\nA consequence of the allocation rule is that a shared slot can be\nshadowed.  For example, if a class C_1 defines a slot named S whose value\nfor the :allocation slot option is :class, that slot is accessible in\ninstances of C_1 and all of its subclasses.  However, if C_2 is a subclass\nof C_1 and also defines a slot named S, C_1's slot is not shared by\ninstances of C_2 and its subclasses. When a class C_1 defines a shared\nslot, any subclass C_2 of C_1 will share this single slot unless the\ndefclass form for C_2 specifies a slot of the same name or there is a\nsuperclass of C_2 that precedes C_1 in the class precedence list of C_2\nthat defines a slot of the same name.\n\nA consequence of the type rule is that the value of a slot satisfies the\ntype constraint of each slot specifier that contributes to that slot.\nBecause the result of attempting to store in a slot a value that does not\nsatisfy the type constraint for the slot is undefined, the value in a slot\nmight fail to satisfy its type constraint.\n\nThe :reader, :writer, and :accessor slot options create methods rather\nthan define the characteristics of a slot.  Reader and writer methods are\ninherited in the sense described in *Note Inheritance of Methods::.\n\nMethods that access slots use only the name of the slot and the type of\nthe slot's value.  Suppose a superclass provides a method that expects to\naccess a shared slot of a given name, and a subclass defines a local slot\nwith the same name.  If the method provided by the superclass is used on\nan instance of the subclass, the method accesses the local slot.\n\n"
}