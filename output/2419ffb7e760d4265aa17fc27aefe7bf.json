{
    "name": "defmacro",
    "prev": "define-compiler-macro",
    "next": "macro-function",
    "up": "Evaluation and Compilation Dictionary",
    "header": {
        "type": "Macro",
        "text": "defmacro"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "defmacro",
                    "text": " name lambda-list [[{declaration}* | documentation]] {form}*=>  name\n\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "name",
                    "desc": "a symbol."
                },
                {
                    "name": "lambda-list",
                    "desc": "a macro lambda list."
                },
                {
                    "name": "declaration",
                    "desc": "a declare expression; not evaluated."
                },
                {
                    "name": "documentation",
                    "desc": "a string; not evaluated."
                },
                {
                    "name": "form",
                    "desc": "a form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "Defines name as a macro by associating a macro function with that name in\nthe global environment.\nThe macro function is defined in the same lexical environment in which the\ndefmacro form appears.\nThe parameter variables in lambda-list are bound to destructured portions\nof the macro call.\nThe expansion function accepts two arguments, a form and an environment.\nThe expansion function returns a form.  The body of the expansion function\nis specified by forms.  Forms are executed in order.  The value of the\nlast form executed is returned as the expansion of the macro.\nThe body forms of the expansion function (but not the lambda-list)\nare implicitly enclosed in a block whose name is name.\nThe lambda-list conforms to the requirements described in *Note Macro\nLambda Lists::.\nDocumentation is attached as a documentation string to name (as kind\nfunction) and to the macro function.\ndefmacro can be used to redefine a macro or to replace a function\ndefinition with a macro definition.\nRecursive expansion of the form returned must terminate, including the\nexpansion of other macros which are subforms of other forms returned.\nThe consequences are undefined if the result of fully macroexpanding a form\ncontains any circular list structure except in literal objects.\nIf a defmacro form appears as a top level form, the compiler must store\nthe macro definition at compile time, so that occurrences of the macro\nlater on in the file can be expanded correctly.  Users must ensure that\nthe body of the macro can be evaluated at compile time if it is referenced\nwithin the file being compiled.\n"
        },
        {
            "type": "Examples",
            "text": "      (defmacro mac1 (a b) \"Mac1 multiplies and adds\"\n                 `(+ ,a (* ,b 3))) =>  MAC1\n      (mac1 4 5) =>  19\n      (documentation 'mac1 'function) =>  \"Mac1 multiplies and adds\"\n      (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) =>  MAC2\n      (mac2 6) =>  (6 T 3 NIL NIL)\n      (mac2 6 3 8) =>  (6 T 3 T (8))\n      (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))\n         `'(,r ,a ,b ,c ,d ,x)) =>  MAC3\n      (mac3 1 6 :d 8 :c 9 :d 10) =>  ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10))\nThe stipulation that an embedded destructuring lambda list is permitted\nonly where ordinary lambda list syntax would permit a parameter name but\nnot a list is made to prevent ambiguity.  For example, the following is\nnot valid:\n      (defmacro loser (x &optional (a b &rest c) &rest z)\n        ...)\nbecause ordinary lambda list syntax does permit a list following &optional;\nthe list (a b &rest c) would be interpreted as describing an optional\nparameter named a whose default value is that of the form b, with a\nsupplied-p parameter named &rest (not valid), and an extraneous symbol c\nin the list (also not valid).  An almost correct way to express this is\n      (defmacro loser (x &optional ((a b &rest c)) &rest z)\n        ...)\nThe extra set of parentheses removes the ambiguity.  However, the\ndefinition is now incorrect because a macro call such as (loser (car pool))\nwould not provide any argument form for the lambda list (a b &rest c), and\nso the default value against which to match the lambda list would be nil\nbecause no explicit default value was specified.  The consequences of this\nare  unspecified since the empty list, nil, does not have forms to satisfy\nthe parameters a and b.  The fully correct definition would be either\n      (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)\n        ...)\nor\n      (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)\n        ...)\nThese differ slightly: the first requires that if the macro call specifies\na explicitly then it must also specify b explicitly, whereas the second\ndoes not have this requirement.  For example,\n      (loser (car pool) ((+ x 1)))\nwould be a valid call for the second definition but not for the first.\n      (defmacro dm1a (&whole x) `',x)\n      (macroexpand '(dm1a))  =>  (QUOTE (DM1A))\n      (macroexpand '(dm1a a)) is an error.\n      (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))\n      (macroexpand '(dm1b))  is an error.\n      (macroexpand '(dm1b q))  =>  (QUOTE ((DM1B Q) Q NIL))\n      (macroexpand '(dm1b q r)) =>  (QUOTE ((DM1B Q R) Q R))\n      (macroexpand '(dm1b q r s)) is an error.\n      (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))\n      (macroexpand '(dm2a x y)) =>  (QUOTE (FORM (DM2A X Y) A X B Y))\n      (dm2a x y) =>  (FORM (DM2A X Y) A X B Y)\n      (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5))\n                      &body f &environment env)\n        ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))\n      ;Note that because backquote is involved, implementations may differ\n      ;slightly in the nature (though not the functionality) of the expansion.\n      (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))\n      =>  (LIST* '(DM2B X1 (((INCF X2) X3 X4))\n                        X5 X6)\n                 X1\n                 '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),\n          T\n      (let ((x1 5))\n        (macrolet ((segundo (x) `(cadr ,x)))\n          (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))\n      =>  ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)\n           5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))\n"
        },
        {
            "type": "See Also",
            "text": "*Note define-compiler-macro:: ,\n*Note destructuring-bind:: , *Note documentation; (setf documentation):: ,\n*Note macroexpand; macroexpand-1:: , *macroexpand-hook*, macrolet, *Note\nmacro-function:: , *Note Evaluation::, *Note Compilation::, *Note\nSyntactic Interaction of Documentation Strings and Declarations::\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: defmacro,  Next: macro-function,  Prev: define-compiler-macro,  Up: Evaluation and Compilation Dictionary\n\ndefmacro                                                            [Macro]\n---------------------------------------------------------------------------\n\n`defmacro'  name lambda-list [[{declaration}* | documentation]] {form}*\n=>  name\n\nArguments and Values::\n......................\n\nname--a symbol.\n\nlambda-list--a macro lambda list.\n\ndeclaration--a declare expression; not evaluated.\n\ndocumentation--a string; not evaluated.\n\nform--a form.\n\nDescription::\n.............\n\nDefines name as a macro by associating a macro function with that name in\nthe global environment.\n\nThe macro function is defined in the same lexical environment in which the\ndefmacro form appears.\n\nThe parameter variables in lambda-list are bound to destructured portions\nof the macro call.\n\nThe expansion function accepts two arguments, a form and an environment.\nThe expansion function returns a form.  The body of the expansion function\nis specified by forms.  Forms are executed in order.  The value of the\nlast form executed is returned as the expansion of the macro.\n\nThe body forms of the expansion function (but not the lambda-list)\n\nare implicitly enclosed in a block whose name is name.\n\nThe lambda-list conforms to the requirements described in *Note Macro\nLambda Lists::.\n\nDocumentation is attached as a documentation string to name (as kind\nfunction) and to the macro function.\n\ndefmacro can be used to redefine a macro or to replace a function\ndefinition with a macro definition.\n\nRecursive expansion of the form returned must terminate, including the\nexpansion of other macros which are subforms of other forms returned.\n\nThe consequences are undefined if the result of fully macroexpanding a form\ncontains any circular list structure except in literal objects.\n\nIf a defmacro form appears as a top level form, the compiler must store\nthe macro definition at compile time, so that occurrences of the macro\nlater on in the file can be expanded correctly.  Users must ensure that\nthe body of the macro can be evaluated at compile time if it is referenced\nwithin the file being compiled.\n\nExamples::\n..........\n\n      (defmacro mac1 (a b) \"Mac1 multiplies and adds\"\n                 `(+ ,a (* ,b 3))) =>  MAC1\n      (mac1 4 5) =>  19\n      (documentation 'mac1 'function) =>  \"Mac1 multiplies and adds\"\n      (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) =>  MAC2\n      (mac2 6) =>  (6 T 3 NIL NIL)\n      (mac2 6 3 8) =>  (6 T 3 T (8))\n      (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))\n         `'(,r ,a ,b ,c ,d ,x)) =>  MAC3\n      (mac3 1 6 :d 8 :c 9 :d 10) =>  ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10))\n\nThe stipulation that an embedded destructuring lambda list is permitted\nonly where ordinary lambda list syntax would permit a parameter name but\nnot a list is made to prevent ambiguity.  For example, the following is\nnot valid:\n\n      (defmacro loser (x &optional (a b &rest c) &rest z)\n        ...)\n\nbecause ordinary lambda list syntax does permit a list following &optional;\nthe list (a b &rest c) would be interpreted as describing an optional\nparameter named a whose default value is that of the form b, with a\nsupplied-p parameter named &rest (not valid), and an extraneous symbol c\nin the list (also not valid).  An almost correct way to express this is\n\n      (defmacro loser (x &optional ((a b &rest c)) &rest z)\n        ...)\n\nThe extra set of parentheses removes the ambiguity.  However, the\ndefinition is now incorrect because a macro call such as (loser (car pool))\nwould not provide any argument form for the lambda list (a b &rest c), and\nso the default value against which to match the lambda list would be nil\nbecause no explicit default value was specified.  The consequences of this\nare  unspecified since the empty list, nil, does not have forms to satisfy\nthe parameters a and b.  The fully correct definition would be either\n\n      (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)\n        ...)\n\nor\n\n      (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)\n        ...)\n\nThese differ slightly: the first requires that if the macro call specifies\na explicitly then it must also specify b explicitly, whereas the second\ndoes not have this requirement.  For example,\n\n      (loser (car pool) ((+ x 1)))\n\nwould be a valid call for the second definition but not for the first.\n\n      (defmacro dm1a (&whole x) `',x)\n      (macroexpand '(dm1a))  =>  (QUOTE (DM1A))\n      (macroexpand '(dm1a a)) is an error.\n     \n      (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))\n      (macroexpand '(dm1b))  is an error.\n      (macroexpand '(dm1b q))  =>  (QUOTE ((DM1B Q) Q NIL))\n      (macroexpand '(dm1b q r)) =>  (QUOTE ((DM1B Q R) Q R))\n      (macroexpand '(dm1b q r s)) is an error.\n\n      (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))\n      (macroexpand '(dm2a x y)) =>  (QUOTE (FORM (DM2A X Y) A X B Y))\n      (dm2a x y) =>  (FORM (DM2A X Y) A X B Y)\n     \n      (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5))\n                      &body f &environment env)\n        ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))\n      ;Note that because backquote is involved, implementations may differ\n      ;slightly in the nature (though not the functionality) of the expansion.\n      (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))\n      =>  (LIST* '(DM2B X1 (((INCF X2) X3 X4))\n                        X5 X6)\n                 X1\n                 '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),\n          T\n      (let ((x1 5))\n        (macrolet ((segundo (x) `(cadr ,x)))\n          (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))\n      =>  ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)\n           5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))\n\nSee Also::\n..........\n\n*Note define-compiler-macro:: ,\n\n*Note destructuring-bind:: , *Note documentation; (setf documentation):: ,\n*Note macroexpand; macroexpand-1:: , *macroexpand-hook*, macrolet, *Note\nmacro-function:: , *Note Evaluation::, *Note Compilation::, *Note\nSyntactic Interaction of Documentation Strings and Declarations::\n\n"
}