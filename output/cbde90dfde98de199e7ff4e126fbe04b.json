{
    "name": "Definitions of Make-Instance and Initialize-Instance",
    "prev": "Initialize-Instance",
    "next": null,
    "up": "Object Creation and Initialization",
    "header": {
        "type": null,
        "text": "Definitions of Make-Instance and Initialize-Instance"
    },
    "sections": [
        {
            "type": "",
            "text": "The generic function make-instance behaves as if it were defined as\nfollows, except that certain optimizations are permitted:\n      (defmethod make-instance ((class standard-class) &rest initargs)\n        ...\n        (let ((instance (apply #'allocate-instance class initargs)))\n          (apply #'initialize-instance instance initargs)\n          instance))\n      (defmethod make-instance ((class-name symbol) &rest initargs)\n        (apply #'make-instance (find-class class-name) initargs))\nThe elided code in the definition of make-instance augments the initargs\nwith any defaulted initialization arguments and checks the resulting\ninitialization arguments to determine whether an initialization argument\nwas supplied that neither filled a slot nor supplied an argument to an\napplicable method.\nThe generic function initialize-instance behaves as if it were defined as\nfollows, except that certain optimizations are permitted:\n      (defmethod initialize-instance ((instance standard-object) &rest initargs)\n        (apply #'shared-initialize instance t initargs)))\nThese procedures can be customized.\nCustomizing at the Programmer Interface level includes using the\n:initform, :initarg, and :default-initargs options to defclass, as well as\ndefining methods for make-instance, allocate-instance, and\ninitialize-instance.  It is also possible to define methods for\nshared-initialize, which would be invoked by the generic functions\nreinitialize-instance, update-instance-for-redefined-class,\nupdate-instance-for-different-class, and initialize-instance.  The\nmeta-object level supports additional customization.\nImplementations are permitted to make certain optimizations to\ninitialize-instance and shared-initialize.  The description of\nshared-initialize in Chapter~7 mentions the possible optimizations.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Definitions of Make-Instance and Initialize-Instance,  Prev: Initialize-Instance,  Up: Object Creation and Initialization\n\nDefinitions of Make-Instance and Initialize-Instance\n----------------------------------------------------\n\nThe generic function make-instance behaves as if it were defined as\nfollows, except that certain optimizations are permitted:\n\n      (defmethod make-instance ((class standard-class) &rest initargs)\n        ...\n        (let ((instance (apply #'allocate-instance class initargs)))\n          (apply #'initialize-instance instance initargs)\n          instance))\n     \n      (defmethod make-instance ((class-name symbol) &rest initargs)\n        (apply #'make-instance (find-class class-name) initargs))\n\nThe elided code in the definition of make-instance augments the initargs\nwith any defaulted initialization arguments and checks the resulting\ninitialization arguments to determine whether an initialization argument\nwas supplied that neither filled a slot nor supplied an argument to an\napplicable method.\n\nThe generic function initialize-instance behaves as if it were defined as\nfollows, except that certain optimizations are permitted:\n\n      (defmethod initialize-instance ((instance standard-object) &rest initargs)\n        (apply #'shared-initialize instance t initargs)))\n\nThese procedures can be customized.\n\nCustomizing at the Programmer Interface level includes using the\n:initform, :initarg, and :default-initargs options to defclass, as well as\ndefining methods for make-instance, allocate-instance, and\ninitialize-instance.  It is also possible to define methods for\nshared-initialize, which would be invoked by the generic functions\nreinitialize-instance, update-instance-for-redefined-class,\nupdate-instance-for-different-class, and initialize-instance.  The\nmeta-object level supports additional customization.\n\nImplementations are permitted to make certain optimizations to\ninitialize-instance and shared-initialize.  The description of\nshared-initialize in Chapter~7 mentions the possible optimizations.\n\n"
}