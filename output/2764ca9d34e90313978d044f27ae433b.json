{
    "name": "step",
    "prev": "trace",
    "next": "time",
    "up": "Environment Dictionary",
    "header": {
        "type": "Macro",
        "text": "step"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "step",
                    "text": " form =>  {result}*\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "form",
                    "desc": "a form; evaluated as described below."
                },
                {
                    "name": "results",
                    "desc": "the values returned by the form."
                }
            ]
        },
        {
            "type": "Description",
            "text": "step implements a debugging paradigm wherein the programmer is allowed to\nstep through the evaluation of a form.  The specific nature of the\ninteraction,\nincluding which I/O streams are used and whether the stepping has lexical\nor dynamic scope,\nis implementation-defined.\nstep evaluates form in the current environment.  A call to step can be\ncompiled, but it is acceptable for an implementation to interactively step\nthrough only those parts of the computation that are interpreted.\nIt is technically permissible for a conforming implementation to take no\naction at all other than normal execution of the form.  In such a\nsituation, (step form) is equivalent to, for example, (let () form).  In\nimplementations where this is the case, the associated documentation\nshould mention that fact.\n"
        },
        {
            "type": "See Also",
            "text": "*Note trace; untrace::\n"
        },
        {
            "type": "Notes",
            "text": "Implementations are encouraged to respond to the typing of ?  or the\npressing of a \"help key\" by providing help including a list of commands.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: step,  Next: time,  Prev: trace,  Up: Environment Dictionary\n\nstep                                                                [Macro]\n---------------------------------------------------------------------------\n\n`step'  form =>  {result}*\n\nArguments and Values::\n......................\n\nform--a form; evaluated as described below.\n\nresults--the values returned by the form.\n\nDescription::\n.............\n\nstep implements a debugging paradigm wherein the programmer is allowed to\nstep through the evaluation of a form.  The specific nature of the\ninteraction,\n\nincluding which I/O streams are used and whether the stepping has lexical\nor dynamic scope,\n\nis implementation-defined.\n\nstep evaluates form in the current environment.  A call to step can be\ncompiled, but it is acceptable for an implementation to interactively step\nthrough only those parts of the computation that are interpreted.\n\nIt is technically permissible for a conforming implementation to take no\naction at all other than normal execution of the form.  In such a\nsituation, (step form) is equivalent to, for example, (let () form).  In\nimplementations where this is the case, the associated documentation\nshould mention that fact.\n\nSee Also::\n..........\n\n*Note trace; untrace::\n\nNotes::\n.......\n\nImplementations are encouraged to respond to the typing of ?  or the\npressing of a \"help key\" by providing help including a list of commands.\n\n"
}