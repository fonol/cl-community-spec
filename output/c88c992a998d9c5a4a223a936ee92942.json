{
    "name": "Function Call Forms as Places",
    "prev": "Variable Names as Places",
    "next": "VALUES Forms as Places",
    "up": "Kinds of Places",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Function Call Forms as Places",
            "text": "A function form can be used as a place if it falls into one of the\nfollowing categories:\n*\n     A function call form whose first element is the name of any one of\n     the functions in Figure 5-7.\n     [Editorial Note by KMP: Note that what are in some places still\n     called `condition accessors' are deliberately omitted from this\n     table, and are not labeled as accessors in their entries.  I have not\n     yet had time to do a full search for these items and eliminate stray\n     references to them as `accessors', which they are not, but I will do\n     that at some point.]\n       aref    cdadr                    get                            \n       bit     cdar                     gethash                        \n       caaaar  cddaar                   logical-pathname-translations  \n       caaadr  cddadr                   macro-function                 \n       caaar   cddar                    ninth                          \n       caadar  cdddar                   nth                            \n       caaddr  cddddr                   readtable-case                 \n       caadr   cdddr                    rest                           \n       caar    cddr                     row-major-aref                 \n       cadaar  cdr                      sbit                           \n       cadadr  char                     schar                          \n       cadar   class-name               second                         \n       caddar  compiler-macro-function  seventh                        \n       cadddr  documentation            sixth                          \n       caddr   eighth                   slot-value                     \n       cadr    elt                      subseq                         \n       car     fdefinition              svref                          \n       cdaaar  fifth                    symbol-function                \n       cdaadr  fill-pointer             symbol-plist                   \n       cdaar   find-class               symbol-value                   \n       cdadar  first                    tenth                          \n       cdaddr  fourth                   third                          \n            Figure 5-7: Functions that setf can be used with--1      \n     In the case of subseq, the replacement value must be a sequence whose\n     elements might be contained by the sequence argument to subseq, but\n     does not have to be a sequence of the same type as the sequence of\n     which the subsequence is specified.  If the length of the replacement\n     value does not equal the length of the subsequence to be replaced,\n     then the shorter length determines the number of elements to be\n     stored, as for replace.\n*\n     A function call form whose first element is the name of a selector\n     function constructed by defstruct.\n     The function name must refer to the global function definition,\n     rather than a locally defined function.\n*\n     A function call form whose first element is the name of any one of\n     the functions in Figure 5-8, provided that the supplied argument to\n     that function is in turn a place form; in this case the new place has\n     stored back into it the result of applying the supplied \"update\"\n     function.\n       Function name  Argument that is a place  Update function used      \n       ldb            second                    dpb                       \n       mask-field     second                    deposit-field             \n       getf           first                     implementation-dependent  \n              Figure 5-8: Functions that setf can be used with--2       \n     During the setf expansion of these forms, it is necessary to call\n     get-setf-expansion\n     in order to figure out how the inner, nested generalized variable\n     must be treated.\n     The information from\n     get-setf-expansion\n     is used as follows.\n    ldb\n          In a form such as:\n          (setf (ldb byte-spec place-form) value-form)\n          the place referred to by the place-form must always be both read\n          and written;  note that the update is to the generalized variable\n          specified by place-form, not to any object of type integer.\n          Thus this setf should generate code to do the following:\n         1.\n               Evaluate byte-spec (and bind it into a temporary variable).\n         2.\n               Bind the temporary variables for place-form.\n         3.\n               Evaluate value-form  (and bind\n               its value or values into the store variable).\n         4.\n               Do the read from place-form.\n         5.\n               Do the write into place-form with the given bits of the\n               integer fetched in step 4 replaced with the value from step\n               3.\n          If the evaluation of value-form in step 3 alters what is found\n          in place-form, such as setting different bits of integer, then\n          the change of the bits denoted by byte-spec is to that altered\n          integer, because step 4 is done after the value-form evaluation.\n          Nevertheless, the evaluations required for binding the\n          temporary variables are done in steps 1 and 2, and thus the\n          expected left-to-right evaluation order is seen.  For example:\n                (setq integer #x69) =>  #x69\n                (rotatef (ldb (byte 4 4) integer)\n                         (ldb (byte 4 0) integer))\n                integer =>  #x96\n               ;;; This example is trying to swap two independent bit fields\n               ;;; in an integer.  Note that the generalized variable of\n               ;;; interest here is just the (possibly local) program variable\n               ;;; integer.\n    mask-field\n          This case is the same as ldb in all essential aspects.\n    getf\n          In a form such as:\n          (setf (getf place-form ind-form) value-form)\n          the place referred to by place-form must always be both read and\n          written;  note that the update is to the generalized variable\n          specified by place-form, not necessarily to the particular list\n          that is the property list in question.\n          Thus this setf should generate code to do the following:\n         1.\n               Bind the temporary variables for place-form.\n         2.\n               Evaluate ind-form (and bind it into a temporary variable).\n         3.\n               Evaluate value-form (and bind\n               its value or values into the store variable).\n         4.\n               Do the read from place-form.\n         5.\n               Do the write into place-form with a possibly-new property\n               list obtained by combining the values from steps 2, 3, and\n               4.  (Note that the phrase \"possibly-new property list\" can\n               mean that the former property list is somehow destructively\n               re-used, or it can mean partial or full copying of it.\n               Since either copying or destructive re-use can occur, the\n               treatment of the resultant value for the possibly-new\n               property list must proceed as if it were a different copy\n               needing to be stored back into the generalized variable.)\n          If the evaluation of value-form in step 3 alters what is found in\n          place-form, such as setting a different named property in the\n          list, then the change of the property denoted by ind-form is to\n          that altered list, because step 4 is done after the value-form\n          evaluation.  Nevertheless, the evaluations required for binding\n          the temporary variables  are done in steps 1 and 2,  and thus\n          the expected left-to-right evaluation order is seen.\n          For example:\n                (setq s (setq r (list (list 'a 1 'b 2 'c 3)))) =>  ((a 1 b 2 c 3))\n                (setf (getf (car r) 'b)\n                      (progn (setq r nil) 6)) =>  6\n                r =>  NIL\n                s =>  ((A 1 B 6 C 3))\n               ;;; Note that the (setq r nil) does not affect the actions of\n               ;;; the SETF because the value of R had already been saved in\n               ;;; a temporary variable as part of the step 1. Only the CAR\n               ;;; of this value will be retrieved, and subsequently modified\n               ;;; after the value computation.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Function Call Forms as Places,  Next: VALUES Forms as Places,  Prev: Variable Names as Places,  Up: Kinds of Places\n\nFunction Call Forms as Places\n.............................\n\nA function form can be used as a place if it falls into one of the\nfollowing categories:\n\n*\n     A function call form whose first element is the name of any one of\n     the functions in Figure 5-7.\n\n     [Editorial Note by KMP: Note that what are in some places still\n     called `condition accessors' are deliberately omitted from this\n     table, and are not labeled as accessors in their entries.  I have not\n     yet had time to do a full search for these items and eliminate stray\n     references to them as `accessors', which they are not, but I will do\n     that at some point.]\n\n       aref    cdadr                    get                            \n       bit     cdar                     gethash                        \n       caaaar  cddaar                   logical-pathname-translations  \n       caaadr  cddadr                   macro-function                 \n       caaar   cddar                    ninth                          \n       caadar  cdddar                   nth                            \n       caaddr  cddddr                   readtable-case                 \n       caadr   cdddr                    rest                           \n       caar    cddr                     row-major-aref                 \n       cadaar  cdr                      sbit                           \n       cadadr  char                     schar                          \n       cadar   class-name               second                         \n       caddar  compiler-macro-function  seventh                        \n       cadddr  documentation            sixth                          \n       caddr   eighth                   slot-value                     \n       cadr    elt                      subseq                         \n       car     fdefinition              svref                          \n       cdaaar  fifth                    symbol-function                \n       cdaadr  fill-pointer             symbol-plist                   \n       cdaar   find-class               symbol-value                   \n       cdadar  first                    tenth                          \n       cdaddr  fourth                   third                          \n\n            Figure 5-7: Functions that setf can be used with--1      \n\n\n     In the case of subseq, the replacement value must be a sequence whose\n     elements might be contained by the sequence argument to subseq, but\n     does not have to be a sequence of the same type as the sequence of\n     which the subsequence is specified.  If the length of the replacement\n     value does not equal the length of the subsequence to be replaced,\n     then the shorter length determines the number of elements to be\n     stored, as for replace.\n\n*\n     A function call form whose first element is the name of a selector\n     function constructed by defstruct.\n\n     The function name must refer to the global function definition,\n     rather than a locally defined function.\n\n*\n     A function call form whose first element is the name of any one of\n     the functions in Figure 5-8, provided that the supplied argument to\n     that function is in turn a place form; in this case the new place has\n     stored back into it the result of applying the supplied \"update\"\n     function.\n\n       Function name  Argument that is a place  Update function used      \n       ldb            second                    dpb                       \n       mask-field     second                    deposit-field             \n       getf           first                     implementation-dependent  \n\n              Figure 5-8: Functions that setf can be used with--2       \n\n\n     During the setf expansion of these forms, it is necessary to call\n\n     get-setf-expansion\n\n     in order to figure out how the inner, nested generalized variable\n     must be treated.\n\n     The information from\n\n     get-setf-expansion\n\n     is used as follows.\n    ldb\n          In a form such as:\n\n          (setf (ldb byte-spec place-form) value-form)\n\n          the place referred to by the place-form must always be both read\n          and written;  note that the update is to the generalized variable\n          specified by place-form, not to any object of type integer.\n\n          Thus this setf should generate code to do the following:\n\n         1.\n               Evaluate byte-spec (and bind it into a temporary variable).\n\n         2.\n               Bind the temporary variables for place-form.\n\n         3.\n               Evaluate value-form  (and bind\n\n               its value or values into the store variable).\n\n         4.\n               Do the read from place-form.\n\n         5.\n               Do the write into place-form with the given bits of the\n               integer fetched in step 4 replaced with the value from step\n               3.\n\n          If the evaluation of value-form in step 3 alters what is found\n          in place-form, such as setting different bits of integer, then\n          the change of the bits denoted by byte-spec is to that altered\n          integer, because step 4 is done after the value-form evaluation.\n          Nevertheless, the evaluations required for binding the\n          temporary variables are done in steps 1 and 2, and thus the\n          expected left-to-right evaluation order is seen.  For example:\n\n                (setq integer #x69) =>  #x69\n                (rotatef (ldb (byte 4 4) integer)\n                         (ldb (byte 4 0) integer))\n                integer =>  #x96\n               ;;; This example is trying to swap two independent bit fields\n               ;;; in an integer.  Note that the generalized variable of\n               ;;; interest here is just the (possibly local) program variable\n               ;;; integer.\n\n    mask-field\n          This case is the same as ldb in all essential aspects.\n\n    getf\n          In a form such as:\n\n          (setf (getf place-form ind-form) value-form)\n\n          the place referred to by place-form must always be both read and\n          written;  note that the update is to the generalized variable\n          specified by place-form, not necessarily to the particular list\n          that is the property list in question.\n\n          Thus this setf should generate code to do the following:\n         1.\n               Bind the temporary variables for place-form.\n\n         2.\n               Evaluate ind-form (and bind it into a temporary variable).\n\n         3.\n               Evaluate value-form (and bind\n\n               its value or values into the store variable).\n\n         4.\n               Do the read from place-form.\n\n         5.\n               Do the write into place-form with a possibly-new property\n               list obtained by combining the values from steps 2, 3, and\n               4.  (Note that the phrase \"possibly-new property list\" can\n               mean that the former property list is somehow destructively\n               re-used, or it can mean partial or full copying of it.\n               Since either copying or destructive re-use can occur, the\n               treatment of the resultant value for the possibly-new\n               property list must proceed as if it were a different copy\n               needing to be stored back into the generalized variable.)\n\n          If the evaluation of value-form in step 3 alters what is found in\n          place-form, such as setting a different named property in the\n          list, then the change of the property denoted by ind-form is to\n          that altered list, because step 4 is done after the value-form\n          evaluation.  Nevertheless, the evaluations required for binding\n          the temporary variables  are done in steps 1 and 2,  and thus\n          the expected left-to-right evaluation order is seen.\n\n          For example:\n\n                (setq s (setq r (list (list 'a 1 'b 2 'c 3)))) =>  ((a 1 b 2 c 3))\n                (setf (getf (car r) 'b)\n                      (progn (setq r nil) 6)) =>  6\n                r =>  NIL\n                s =>  ((A 1 B 6 C 3))\n               ;;; Note that the (setq r nil) does not affect the actions of\n               ;;; the SETF because the value of R had already been saved in\n               ;;; a temporary variable as part of the step 1. Only the CAR\n               ;;; of this value will be retrieved, and subsequently modified\n               ;;; after the value computation.\n\n"
}