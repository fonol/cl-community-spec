{
    "name": "Standard Method Combination",
    "prev": "Applying method combination to the sorted list of applicable methods",
    "next": "Declarative Method Combination",
    "up": "Method Selection and Combination",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Standard Method Combination",
            "text": "Standard method combination is supported by the class\nstandard-generic-function.  It is used if no other type of method\ncombination is specified or if the built-in method combination type\nstandard is specified.\nPrimary methods define the main action of the effective method, while\nauxiliary methods modify that action in one of three ways.  A primary\nmethod has no method qualifiers.\nAn auxiliary method is a method whose qualifier is :before, :after, or\n:around.  Standard method combination allows no more than one qualifier\nper method; if a method definition specifies more than one qualifier per\nmethod, an error is signaled.\n*\n     A before method has the keyword :before as its only qualifier.  A\n     before method specifies code that is to be run before any primary\n     methods.\n*\n     An after method has the keyword :after as its only qualifier.  An\n     after method specifies code that is to be run after primary methods.\n*\n     An around method has the keyword :around as its only qualifier.  An\n     around method specifies code that is to be run instead of other\n     applicable methods, but which might contain explicit code which calls\n     some of those shadowed methods (via call-next-method).\nThe semantics of standard method combination is as follows:\n*\n     If there are any around methods, the most specific around method is\n     called.  It supplies the value or values of the generic function.\n*\n     Inside the body of an around method, call-next-method can be used to\n     call the next method.  When the next method returns, the around\n     method can execute more code, perhaps based on the returned value or\n     values.  The generic function no-next-method is invoked if\n     call-next-method is used and there is no applicable method to call.\n     The function next-method-p may be used to determine whether a next\n     method exists.\n*\n     If an around method invokes call-next-method, the next most specific\n     around method is called, if one is applicable.  If there are no\n     around methods or if call-next-method is called by the least specific\n     around method, the other methods are called as follows:\n    -\n          All the before methods are called, in most-specific-first order.\n          Their values are ignored.  An error is signaled if\n          call-next-method is used in a before method.\n    -\n          The most specific primary method is called.  Inside the body of\n          a primary method, call-next-method may be used to call the next\n          most specific primary method.  When that method returns, the\n          previous primary method can execute more code, perhaps based on\n          the returned value or values.  The generic function\n          no-next-method is invoked if call-next-method is used and there\n          are no more applicable primary methods.  The function\n          next-method-p may be used to determine whether a next method\n          exists.  If call-next-method is not used, only the most specific\n          primary method is called.\n    -\n          All the after methods are called in most-specific-last order.\n          Their values are ignored.  An error is signaled if\n          call-next-method is used in an after method.\n*\n     If no around methods were invoked, the most specific primary method\n     supplies the value or values returned by the generic function.  The\n     value or values returned by the invocation of call-next-method in the\n     least specific around method are those returned by the most specific\n     primary method.\nIn standard method combination, if there is an applicable method but no\napplicable primary method, an error is signaled.\nThe before methods are run in most-specific-first order while the after\nmethods are run in least-specific-first order.  The design rationale for\nthis difference can be illustrated with an example.  Suppose class C_1\nmodifies the behavior of its superclass, C_2, by adding before methods and\nafter methods.  Whether the behavior of the class C_2 is defined directly\nby methods on C_2 or is inherited from its superclasses does not affect\nthe relative order of invocation of methods on instances of the class C_1.\nClass C_1's before method runs before all of class C_2's methods.  Class\nC_1's after method runs after all of class C_2's methods.\nBy contrast, all around methods run before any other methods run.  Thus a\nless specific around method runs before a more specific primary method.\nIf only primary methods are used and if call-next-method is not used, only\nthe most specific method is invoked; that is, more specific methods shadow\nmore general ones.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Standard Method Combination,  Next: Declarative Method Combination,  Prev: Applying method combination to the sorted list of applicable methods,  Up: Method Selection and Combination\n\nStandard Method Combination\n...........................\n\nStandard method combination is supported by the class\nstandard-generic-function.  It is used if no other type of method\ncombination is specified or if the built-in method combination type\nstandard is specified.\n\nPrimary methods define the main action of the effective method, while\nauxiliary methods modify that action in one of three ways.  A primary\nmethod has no method qualifiers.\n\nAn auxiliary method is a method whose qualifier is :before, :after, or\n:around.  Standard method combination allows no more than one qualifier\nper method; if a method definition specifies more than one qualifier per\nmethod, an error is signaled.\n\n*\n     A before method has the keyword :before as its only qualifier.  A\n     before method specifies code that is to be run before any primary\n     methods.\n\n*\n     An after method has the keyword :after as its only qualifier.  An\n     after method specifies code that is to be run after primary methods.\n\n*\n     An around method has the keyword :around as its only qualifier.  An\n     around method specifies code that is to be run instead of other\n     applicable methods, but which might contain explicit code which calls\n     some of those shadowed methods (via call-next-method).\n\nThe semantics of standard method combination is as follows:\n\n*\n     If there are any around methods, the most specific around method is\n     called.  It supplies the value or values of the generic function.\n\n*\n     Inside the body of an around method, call-next-method can be used to\n     call the next method.  When the next method returns, the around\n     method can execute more code, perhaps based on the returned value or\n     values.  The generic function no-next-method is invoked if\n     call-next-method is used and there is no applicable method to call.\n     The function next-method-p may be used to determine whether a next\n     method exists.\n\n*\n     If an around method invokes call-next-method, the next most specific\n     around method is called, if one is applicable.  If there are no\n     around methods or if call-next-method is called by the least specific\n     around method, the other methods are called as follows:\n    -\n          All the before methods are called, in most-specific-first order.\n          Their values are ignored.  An error is signaled if\n          call-next-method is used in a before method.\n\n    -\n          The most specific primary method is called.  Inside the body of\n          a primary method, call-next-method may be used to call the next\n          most specific primary method.  When that method returns, the\n          previous primary method can execute more code, perhaps based on\n          the returned value or values.  The generic function\n          no-next-method is invoked if call-next-method is used and there\n          are no more applicable primary methods.  The function\n          next-method-p may be used to determine whether a next method\n          exists.  If call-next-method is not used, only the most specific\n          primary method is called.\n\n    -\n          All the after methods are called in most-specific-last order.\n          Their values are ignored.  An error is signaled if\n          call-next-method is used in an after method.\n\n*\n     If no around methods were invoked, the most specific primary method\n     supplies the value or values returned by the generic function.  The\n     value or values returned by the invocation of call-next-method in the\n     least specific around method are those returned by the most specific\n     primary method.\n\nIn standard method combination, if there is an applicable method but no\napplicable primary method, an error is signaled.\n\nThe before methods are run in most-specific-first order while the after\nmethods are run in least-specific-first order.  The design rationale for\nthis difference can be illustrated with an example.  Suppose class C_1\nmodifies the behavior of its superclass, C_2, by adding before methods and\nafter methods.  Whether the behavior of the class C_2 is defined directly\nby methods on C_2 or is inherited from its superclasses does not affect\nthe relative order of invocation of methods on instances of the class C_1.\nClass C_1's before method runs before all of class C_2's methods.  Class\nC_1's after method runs after all of class C_2's methods.\n\nBy contrast, all around methods run before any other methods run.  Thus a\nless specific around method runs before a more specific primary method.\n\nIf only primary methods are used and if call-next-method is not used, only\nthe most specific method is invoked; that is, more specific methods shadow\nmore general ones.\n\n"
}