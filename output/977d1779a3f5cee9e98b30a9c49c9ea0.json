{
    "name": "Tilde Left-Bracket-> Conditional Expression",
    "prev": "Tilde Asterisk-> Go-To",
    "next": "Tilde Right-Bracket-> End of Conditional Expression",
    "up": "FORMAT Control-Flow Operations",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Tilde Left-Bracket: Conditional Expression",
            "text": "~[str0~;str1~;...~;strn~]\nThis is a set of control strings, called clauses, one of which is chosen\nand used.  The clauses are separated by ~; and the construct is terminated\nby ~].  For example,\n\"~[Siamese~;Manx~;Persian~] Cat\"\nThe argth clause is selected, where the first clause is number 0.  If a\nprefix parameter is given (as ~n[), then the parameter is used instead of\nan argument.  If arg is out of range then no clause is selected and no\nerror is signaled.  After the selected alternative has been processed, the\ncontrol string continues after the ~].\n~[str0~;str1~;...~;strn~:;default~] has a default case.  If the last ~;\nused to separate clauses is ~:; instead, then the last clause is an else\nclause that is performed if no other clause is selected.  For example:\n\"~[Siamese~;Manx~;Persian~:;Alley~] Cat\"\n~:[alternative~;consequent~] selects the alternative control string if arg\nis false, and selects the consequent control string otherwise.\n~@[consequent~] tests the argument.  If it is true, then the argument is\nnot used up by the ~[ command but remains as the next one to be processed,\nand the one clause consequent is processed.  If the arg is false, then the\nargument is used up, and the clause is not processed.  The clause\ntherefore should normally use exactly one argument, and may expect it to\nbe non-nil.  For example:\n      (setq *print-level* nil *print-length* 5)\n      (format nil\n             \"~@[ print level = ~D~]~@[ print length = ~D~]\"\n             *print-level* *print-length*)\n     =>   \" print length = 5\"\nNote also that\n      (format stream \"...~@[str~]...\" ...)\n     == (format stream \"...~:[~;~:*str~]...\" ...)\nThe combination of ~[ and # is useful, for example, for dealing with\nEnglish conventions for printing lists:\n      (setq foo \"Items:~#[ none~; ~S~; ~S and ~S~\n                ~:;~@{~#[~; and~] ~S~^ ,~}~].\")\n      (format nil foo) =>   \"Items: none.\"\n      (format nil foo 'foo) =>   \"Items: FOO.\"\n      (format nil foo 'foo 'bar) =>   \"Items: FOO and BAR.\"\n      (format nil foo 'foo 'bar 'baz) =>   \"Items: FOO, BAR, and BAZ.\"\n      (format nil foo 'foo 'bar 'baz 'quux) =>   \"Items: FOO, BAR, BAZ, and QUUX.\"\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Tilde Left-Bracket-> Conditional Expression,  Next: Tilde Right-Bracket-> End of Conditional Expression,  Prev: Tilde Asterisk-> Go-To,  Up: FORMAT Control-Flow Operations\n\nTilde Left-Bracket: Conditional Expression\n..........................................\n\n~[str0~;str1~;...~;strn~]\n\nThis is a set of control strings, called clauses, one of which is chosen\nand used.  The clauses are separated by ~; and the construct is terminated\nby ~].  For example,\n\n\"~[Siamese~;Manx~;Persian~] Cat\"\n\nThe argth clause is selected, where the first clause is number 0.  If a\nprefix parameter is given (as ~n[), then the parameter is used instead of\nan argument.  If arg is out of range then no clause is selected and no\nerror is signaled.  After the selected alternative has been processed, the\ncontrol string continues after the ~].\n\n~[str0~;str1~;...~;strn~:;default~] has a default case.  If the last ~;\nused to separate clauses is ~:; instead, then the last clause is an else\nclause that is performed if no other clause is selected.  For example:\n\n\"~[Siamese~;Manx~;Persian~:;Alley~] Cat\"\n\n~:[alternative~;consequent~] selects the alternative control string if arg\nis false, and selects the consequent control string otherwise.\n\n~@[consequent~] tests the argument.  If it is true, then the argument is\nnot used up by the ~[ command but remains as the next one to be processed,\nand the one clause consequent is processed.  If the arg is false, then the\nargument is used up, and the clause is not processed.  The clause\ntherefore should normally use exactly one argument, and may expect it to\nbe non-nil.  For example:\n\n      (setq *print-level* nil *print-length* 5)\n      (format nil\n             \"~@[ print level = ~D~]~@[ print length = ~D~]\"\n             *print-level* *print-length*)\n     =>   \" print length = 5\"\n\nNote also that\n\n      (format stream \"...~@[str~]...\" ...)\n     == (format stream \"...~:[~;~:*str~]...\" ...)\n\nThe combination of ~[ and # is useful, for example, for dealing with\nEnglish conventions for printing lists:\n\n      (setq foo \"Items:~#[ none~; ~S~; ~S and ~S~\n                ~:;~@{~#[~; and~] ~S~^ ,~}~].\")\n      (format nil foo) =>   \"Items: none.\"\n      (format nil foo 'foo) =>   \"Items: FOO.\"\n      (format nil foo 'foo 'bar) =>   \"Items: FOO and BAR.\"\n      (format nil foo 'foo 'bar 'baz) =>   \"Items: FOO, BAR, and BAZ.\"\n      (format nil foo 'foo 'bar 'baz 'quux) =>   \"Items: FOO, BAR, BAZ, and QUUX.\"\n\n"
}