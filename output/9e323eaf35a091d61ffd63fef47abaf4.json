{
    "name": "Processing of Defining Macros",
    "prev": "Processing of Top Level Forms",
    "next": "Constraints on Macros and Compiler Macros",
    "up": "File Compilation",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "normal",
                    "text": "way (either interpretively or by loading the compiled file).\nIn particular, the information stored by the defining macros at compile\ntime might or might not be available to the interpreter (either during or\nafter compilation), or during subsequent calls to the compiler.  For\nexample, the following code is nonportable because it assumes that the\ncompiler stores the macro definition of foo where it is available to the\ninterpreter:\n\n      (defmacro foo (x) `(car ,x))\n      (eval-when (:execute :compile-toplevel :load-toplevel)\n        (print (foo '(a b c))))\n\nA portable way to do the same thing would be to include the macro\ndefinition inside the eval-when form, as in:\n\n      (eval-when (:execute :compile-toplevel :load-toplevel)\n        (defmacro foo (x) `(car ,x))\n        (print (foo '(a b c))))\n\nFigure 3-8 lists macros that make definitions available both in the\ncompilation and run-time environments.  It is not specified whether\ndefinitions made available in the compilation environment are available in\nthe evaluation environment, nor is it specified whether they are available\nin subsequent compilation units or subsequent invocations of the compiler.\nAs with eval-when, these compile-time side effects happen only when the\ndefining macros appear at top level.\n\n  declaim                define-modify-macro   defsetf    \n  defclass               define-setf-expander  defstruct  \n  defconstant            defmacro              deftype    \n  define-compiler-macro  defpackage            defvar     \n  define-condition       defparameter                     \n\n  Figure 3-8: Defining Macros That Affect the Compile-Time Environment\n\n\n"
                }
            ],
            "text": "`normal' way (either interpretively or by loading the compiled file).\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Processing of Defining Macros,  Next: Constraints on Macros and Compiler Macros,  Prev: Processing of Top Level Forms,  Up: File Compilation\n\nProcessing of Defining Macros\n.............................\n\nDefining macros (such as defmacro or defvar) appearing within a file being\nprocessed by compile-file normally have compile-time side effects which\naffect how subsequent forms in the same file are compiled.  A convenient\nmodel for explaining how these side effects happen is that the defining\nmacro expands into one or more eval-when forms, and that the calls which\ncause the compile-time side effects to happen appear in the body of an\n(eval-when (:compile-toplevel) ...) form.\n\nThe compile-time side effects may cause information about the definition to\nbe stored differently than if the defining macro had been processed in the\n`normal' way (either interpretively or by loading the compiled file).\n\nIn particular, the information stored by the defining macros at compile\ntime might or might not be available to the interpreter (either during or\nafter compilation), or during subsequent calls to the compiler.  For\nexample, the following code is nonportable because it assumes that the\ncompiler stores the macro definition of foo where it is available to the\ninterpreter:\n\n      (defmacro foo (x) `(car ,x))\n      (eval-when (:execute :compile-toplevel :load-toplevel)\n        (print (foo '(a b c))))\n\nA portable way to do the same thing would be to include the macro\ndefinition inside the eval-when form, as in:\n\n      (eval-when (:execute :compile-toplevel :load-toplevel)\n        (defmacro foo (x) `(car ,x))\n        (print (foo '(a b c))))\n\nFigure 3-8 lists macros that make definitions available both in the\ncompilation and run-time environments.  It is not specified whether\ndefinitions made available in the compilation environment are available in\nthe evaluation environment, nor is it specified whether they are available\nin subsequent compilation units or subsequent invocations of the compiler.\nAs with eval-when, these compile-time side effects happen only when the\ndefining macros appear at top level.\n\n  declaim                define-modify-macro   defsetf    \n  defclass               define-setf-expander  defstruct  \n  defconstant            defmacro              deftype    \n  define-compiler-macro  defpackage            defvar     \n  define-condition       defparameter                     \n\n  Figure 3-8: Defining Macros That Affect the Compile-Time Environment\n\n\n"
}