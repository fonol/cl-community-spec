{
    "name": "shiftf",
    "prev": "setf",
    "next": "rotatef",
    "up": "Data and Control Flow Dictionary",
    "header": {
        "type": "Macro",
        "text": "shiftf"
    },
    "sections": [
        {
            "type": "Syntax",
            "defs": [
                {
                    "name": "shiftf",
                    "text": " {place}^+ newvalue =>  old-value-1\n"
                }
            ],
            "text": ""
        },
        {
            "type": "Arguments and Values",
            "text": "",
            "values": [
                {
                    "name": "place",
                    "desc": "a place."
                },
                {
                    "name": "newvalue",
                    "desc": "a form; evaluated."
                },
                {
                    "name": "old-value-1",
                    "desc": "an object (the old value of the first place)."
                }
            ]
        },
        {
            "type": "Description",
            "text": "shiftf modifies the values of each place by storing newvalue into the last\nplace, and shifting the values of the second through the last place into\nthe remaining places.\nIf newvalue produces more values than there are store variables, the extra\nvalues are ignored. If newvalue produces fewer values than there are store\nvariables, the missing values are set to nil.\nIn the form (shiftf place1 place2 ... placen newvalue), the values in\nplace1 through placen are read and saved, and newvalue is evaluated, for a\ntotal of n+1 values in all.  Values 2 through n+1 are then stored into\nplace1 through placen, respectively.  It is as if all the places form a\nshift register; the newvalue is shifted in from the right, all values\nshift over to the left one place, and the value shifted out of place1 is\nreturned.\nFor information about the evaluation of subforms of places, see *Note\nEvaluation of Subforms to Places::.\n"
        },
        {
            "type": "Examples",
            "text": "      (setq x (list 1 2 3) y 'trash) =>  TRASH\n      (shiftf y x (cdr x) '(hi there)) =>  TRASH\n      x =>  (2 3)\n      y =>  (1 HI THERE)\n      (setq x (list 'a 'b 'c)) =>  (A B C)\n      (shiftf (cadr x) 'z) =>  B\n      x =>  (A Z C)\n      (shiftf (cadr x) (cddr x) 'q) =>  Z\n      x =>  (A (C) . Q)\n      (setq n 0) =>  0\n      (setq x (list 'a 'b 'c 'd)) =>  (A B C D)\n      (shiftf (nth (setq n (+ n 1)) x) 'z) =>  B\n      x =>  (A Z C D)\n"
        },
        {
            "type": "Affected By",
            "text": "define-setf-expander, defsetf, *macroexpand-hook*\n"
        },
        {
            "type": "See Also",
            "text": "*Note setf; psetf:: , *Note rotatef:: , *Note Generalized Reference::\n"
        },
        {
            "type": "Notes",
            "text": "The effect of (shiftf place1 place2 ... placen newvalue) is roughly\nequivalent to\n      (let ((var1 place1)\n            (var2 place2)\n            ...\n            (varn placen)\n            (var0 newvalue))\n        (setf place1 var2)\n        (setf place2 var3)\n        ...\n        (setf placen var0)\n        var1)\nexcept that the latter would evaluate any subforms of each place twice,\nwhereas shiftf evaluates them once.  For example,\n      (setq n 0) =>  0\n      (setq x (list 'a 'b 'c 'd)) =>  (A B C D)\n      (prog1 (nth (setq n (+ n 1)) x)\n             (setf (nth (setq n (+ n 1)) x) 'z)) =>  B\n      x =>  (A B Z D)\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: shiftf,  Next: rotatef,  Prev: setf,  Up: Data and Control Flow Dictionary\n\nshiftf                                                              [Macro]\n---------------------------------------------------------------------------\n\n`shiftf'  {place}^+ newvalue =>  old-value-1\n\nArguments and Values::\n......................\n\nplace--a place.\n\nnewvalue--a form; evaluated.\n\nold-value-1--an object (the old value of the first place).\n\nDescription::\n.............\n\nshiftf modifies the values of each place by storing newvalue into the last\nplace, and shifting the values of the second through the last place into\nthe remaining places.\n\nIf newvalue produces more values than there are store variables, the extra\nvalues are ignored. If newvalue produces fewer values than there are store\nvariables, the missing values are set to nil.\n\nIn the form (shiftf place1 place2 ... placen newvalue), the values in\nplace1 through placen are read and saved, and newvalue is evaluated, for a\ntotal of n+1 values in all.  Values 2 through n+1 are then stored into\nplace1 through placen, respectively.  It is as if all the places form a\nshift register; the newvalue is shifted in from the right, all values\nshift over to the left one place, and the value shifted out of place1 is\nreturned.\n\nFor information about the evaluation of subforms of places, see *Note\nEvaluation of Subforms to Places::.\n\nExamples::\n..........\n\n      (setq x (list 1 2 3) y 'trash) =>  TRASH\n      (shiftf y x (cdr x) '(hi there)) =>  TRASH\n      x =>  (2 3)\n      y =>  (1 HI THERE)\n     \n      (setq x (list 'a 'b 'c)) =>  (A B C)\n      (shiftf (cadr x) 'z) =>  B\n      x =>  (A Z C)\n      (shiftf (cadr x) (cddr x) 'q) =>  Z\n      x =>  (A (C) . Q)\n      (setq n 0) =>  0\n      (setq x (list 'a 'b 'c 'd)) =>  (A B C D)\n      (shiftf (nth (setq n (+ n 1)) x) 'z) =>  B\n      x =>  (A Z C D)\n\nAffected By::\n.............\n\ndefine-setf-expander, defsetf, *macroexpand-hook*\n\nSee Also::\n..........\n\n*Note setf; psetf:: , *Note rotatef:: , *Note Generalized Reference::\n\nNotes::\n.......\n\nThe effect of (shiftf place1 place2 ... placen newvalue) is roughly\nequivalent to\n\n      (let ((var1 place1)\n            (var2 place2)\n            ...\n            (varn placen)\n            (var0 newvalue))\n        (setf place1 var2)\n        (setf place2 var3)\n        ...\n        (setf placen var0)\n        var1)\n\nexcept that the latter would evaluate any subforms of each place twice,\nwhereas shiftf evaluates them once.  For example,\n\n      (setq n 0) =>  0\n      (setq x (list 'a 'b 'c 'd)) =>  (A B C D)\n      (prog1 (nth (setq n (+ n 1)) x)\n             (setf (nth (setq n (+ n 1)) x) 'z)) =>  B\n      x =>  (A B Z D)\n\n"
}