{
    "name": "Treatment of Other Macros Based on SETF",
    "prev": "Kinds of Places",
    "next": null,
    "up": "Generalized Reference",
    "header": {
        "type": null,
        "text": "Treatment of Other Macros Based on SETF"
    },
    "sections": [
        {
            "type": "",
            "text": "For each of the \"read-modify-write\" operators in Figure 5-9, and for any\nadditional macros defined by the programmer using define-modify-macro, an\nexception is made to the normal rule of left-to-right evaluation of\narguments.  Evaluation of argument forms occurs in left-to-right order,\nwith the exception that for the place argument, the actual read of the\n\"old value\" from that place happens after all of the argument form\nevaluations, and just before a \"new value\" is computed and written back\ninto the place.\nSpecifically, each of these operators can be viewed as involving a form\nwith the following general syntax:\n      (operator {preceding-form}* place {following-form}*)\nThe evaluation of each such form proceeds like this:\n1.\n     Evaluate each of the preceding-forms, in left-to-right order.\n2.\n     Evaluate the subforms of the place, in the order specified by the\n     second value of the setf expansion for that place.\n3.\n     Evaluate each of the following-forms, in left-to-right order.\n4.\n     Read the old value from place.\n5.\n     Compute the new value.\n6.\n     Store the new value into place.\n  decf  pop   pushnew     incf  push  remf     \n  Figure 5-9: Read-Modify-Write Macros\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Treatment of Other Macros Based on SETF,  Prev: Kinds of Places,  Up: Generalized Reference\n\nTreatment of Other Macros Based on SETF\n---------------------------------------\n\nFor each of the \"read-modify-write\" operators in Figure 5-9, and for any\nadditional macros defined by the programmer using define-modify-macro, an\nexception is made to the normal rule of left-to-right evaluation of\narguments.  Evaluation of argument forms occurs in left-to-right order,\nwith the exception that for the place argument, the actual read of the\n\"old value\" from that place happens after all of the argument form\nevaluations, and just before a \"new value\" is computed and written back\ninto the place.\n\nSpecifically, each of these operators can be viewed as involving a form\nwith the following general syntax:\n\n      (operator {preceding-form}* place {following-form}*)\n\nThe evaluation of each such form proceeds like this:\n\n1.\n     Evaluate each of the preceding-forms, in left-to-right order.\n\n2.\n     Evaluate the subforms of the place, in the order specified by the\n     second value of the setf expansion for that place.\n\n3.\n     Evaluate each of the following-forms, in left-to-right order.\n\n4.\n     Read the old value from place.\n\n5.\n     Compute the new value.\n\n6.\n     Store the new value into place.\n\n  decf  pop   pushnew     incf  push  remf     \n\n  Figure 5-9: Read-Modify-Write Macros\n\n\n"
}