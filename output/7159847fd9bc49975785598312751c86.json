{
    "name": "Specifiers for @b{&aux} variables",
    "prev": "Examples of Suppressing Keyword Argument Checking",
    "next": "Examples of Ordinary Lambda Lists",
    "up": "Ordinary Lambda Lists",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Specifiers for &aux variables",
            "text": "These are not really parameters.  If the lambda list keyword &aux is\npresent, all specifiers after it are auxiliary variable specifiers.  After\nall parameter specifiers have been processed, the auxiliary variable\nspecifiers (those following &aux) are processed from left to right.  For\neach one, init-form is evaluated and var is bound to that value (or to nil\nif no init-form was specified).  &aux variable processing is analogous to\nlet* processing.\n      (lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))\n         == (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Specifiers for @b{&aux} variables,  Next: Examples of Ordinary Lambda Lists,  Prev: Examples of Suppressing Keyword Argument Checking,  Up: Ordinary Lambda Lists\n\nSpecifiers for &aux variables\n.............................\n\nThese are not really parameters.  If the lambda list keyword &aux is\npresent, all specifiers after it are auxiliary variable specifiers.  After\nall parameter specifiers have been processed, the auxiliary variable\nspecifiers (those following &aux) are processed from left to right.  For\neach one, init-form is evaluated and var is bound to that value (or to nil\nif no init-form was specified).  &aux variable processing is analogous to\nlet* processing.\n\n      (lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))\n         == (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))\n\n"
}