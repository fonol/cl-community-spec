{
    "name": "The RECURSIVE-P argument",
    "prev": "The EOF-ERROR-P argument",
    "next": null,
    "up": "Argument Conventions of Some Reader Functions",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "The RECURSIVE-P argument",
            "text": "If recursive-p is supplied and not nil, it specifies that this function\ncall is not an outermost call to read but an embedded call, typically from\na reader macro function.  It is important to distinguish such recursive\ncalls for three reasons.\n1.\n     An outermost call establishes the context within which the #n= and\n     #n# syntax is scoped.  Consider, for example, the expression\n           (cons '#3=(p q r) '(x y . #3#))\n     If the single-quote reader macro were defined in this way:\n           (set-macro-character #\\'       ;incorrect\n              #'(lambda (stream char)\n                   (declare (ignore char))\n                   (list 'quote (read stream))))\n     then each call to the single-quote reader macro function would\n     establish independent contexts for the scope of read information,\n     including the scope of identifications between markers like \"#3=\" and\n     \"#3#\".  However, for this expression, the scope was clearly intended\n     to be determined by the outer set of parentheses, so such a\n     definition would be incorrect.  The correct way to define the\n     single-quote reader macro uses recursive-p:\n           (set-macro-character #\\'       ;correct\n              #'(lambda (stream char)\n                   (declare (ignore char))\n                   (list 'quote (read stream t nil t))))\n2.\n     A recursive call does not alter whether the reading process is to\n     preserve whitespace_2 or not (as determined by whether the outermost\n     call was to read or read-preserving-whitespace).  Suppose again that\n     single-quote were to be defined as shown above in the incorrect\n     definition.  Then a call to read-preserving-whitespace that read the\n     expression 'foo<Space> would fail to preserve the space character\n     following the symbol foo because the single-quote reader macro\n     function calls read, not read-preserving-whitespace, to read the\n     following expression (in this case foo).  The correct definition,\n     which passes the value true for recursive-p to read, allows the\n     outermost call to determine whether whitespace_2 is preserved.\n3.\n     When end-of-file is encountered and the eof-error-p argument is not\n     nil, the kind of error that is signaled may depend on the value of\n     recursive-p.  If recursive-p is true, then the end-of-file is deemed\n     to have occurred within the middle of a printed representation; if\n     recursive-p is false, then the end-of-file may be deemed to have\n     occurred between objects rather than within the middle of one.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: The RECURSIVE-P argument,  Prev: The EOF-ERROR-P argument,  Up: Argument Conventions of Some Reader Functions\n\nThe RECURSIVE-P argument\n........................\n\nIf recursive-p is supplied and not nil, it specifies that this function\ncall is not an outermost call to read but an embedded call, typically from\na reader macro function.  It is important to distinguish such recursive\ncalls for three reasons.\n\n1.\n     An outermost call establishes the context within which the #n= and\n     #n# syntax is scoped.  Consider, for example, the expression\n\n           (cons '#3=(p q r) '(x y . #3#))\n\n     If the single-quote reader macro were defined in this way:\n\n           (set-macro-character #\\'       ;incorrect\n              #'(lambda (stream char)\n                   (declare (ignore char))\n                   (list 'quote (read stream))))\n\n     then each call to the single-quote reader macro function would\n     establish independent contexts for the scope of read information,\n     including the scope of identifications between markers like \"#3=\" and\n     \"#3#\".  However, for this expression, the scope was clearly intended\n     to be determined by the outer set of parentheses, so such a\n     definition would be incorrect.  The correct way to define the\n     single-quote reader macro uses recursive-p:\n\n           (set-macro-character #\\'       ;correct\n              #'(lambda (stream char)\n                   (declare (ignore char))\n                   (list 'quote (read stream t nil t))))\n\n2.\n     A recursive call does not alter whether the reading process is to\n     preserve whitespace_2 or not (as determined by whether the outermost\n     call was to read or read-preserving-whitespace).  Suppose again that\n     single-quote were to be defined as shown above in the incorrect\n     definition.  Then a call to read-preserving-whitespace that read the\n     expression 'foo<Space> would fail to preserve the space character\n     following the symbol foo because the single-quote reader macro\n     function calls read, not read-preserving-whitespace, to read the\n     following expression (in this case foo).  The correct definition,\n     which passes the value true for recursive-p to read, allows the\n     outermost call to determine whether whitespace_2 is preserved.\n\n3.\n     When end-of-file is encountered and the eof-error-p argument is not\n     nil, the kind of error that is signaled may depend on the value of\n     recursive-p.  If recursive-p is true, then the end-of-file is deemed\n     to have occurred within the middle of a printed representation; if\n     recursive-p is false, then the end-of-file may be deemed to have\n     occurred between objects rather than within the middle of one.\n\n"
}