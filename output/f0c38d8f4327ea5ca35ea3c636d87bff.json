{
    "name": "Lambda-list-directed Destructuring by Lambda Lists",
    "prev": "Examples of Data-directed Destructuring by Lambda Lists",
    "next": null,
    "up": "Macro Lambda Lists",
    "header": {
        "type": null,
        "text": null
    },
    "sections": [
        {
            "type": "",
            "text": ""
        },
        {
            "type": "Lambda-list-directed Destructuring by Lambda Lists",
            "text": "An extension of data-directed destructuring of trees is\nlambda-list-directed destructuring.  This derives from the analogy between\nthe three-element destructuring pattern\n(first second third)\nand the three-argument lambda list\n(first second third)\nLambda-list-directed destructuring is identical to data-directed\ndestructuring if no lambda list keywords appear in the pattern.  Any list\nin the pattern (whether a sub-list or the whole pattern itself) that\ncontains a lambda list keyword is interpreted specially.  Elements of the\nlist to the left of the first lambda list keyword are treated as\ndestructuring patterns, as usual, but the remaining elements of the list\nare treated like a function's lambda list except that where a variable\nwould normally be required, an arbitrary destructuring pattern is allowed.\nNote that in case of ambiguity, lambda list syntax is preferred over\ndestructuring syntax.  Thus, after &optional a list of elements is a list\nof a destructuring pattern and a default value form.\nThe detailed behavior of each lambda list keyword in a\nlambda-list-directed destructuring pattern is as follows:\n&optional\n     Each following element is a variable or a list of a destructuring\n     pattern, a default value form, and a supplied-p variable.  The\n     default value and the supplied-p variable can be omitted.  If the\n     list being destructured ends early, so that it does not have an\n     element to match against this destructuring (sub)-pattern, the\n     default form is evaluated and destructured instead.  The supplied-p\n     variable receives the value nil if the default form is used, t\n     otherwise.\n&rest, &body\n     The next element is a destructuring pattern that matches the rest of\n     the list.  &body is identical to &rest but declares that what is\n     being matched is a list of forms that constitutes the body of form.\n     This next element must be the last unless a lambda list keyword\n     follows it.\n&aux\n     The remaining elements are not destructuring patterns at all, but are\n     auxiliary variable bindings.\n&whole\n     The next element is a destructuring pattern that matches the entire\n     form in a macro, or the entire subexpression at inner levels.\n&key\n     Each following element is one of\n          a variable,\n    or\n          a list of a variable, an optional initialization form, and an\n          optional supplied-p variable.\n    or\n          a list of a list of a keyword and a destructuring pattern, an\n          optional initialization form, and an optional supplied-p\n          variable.\n     The rest of the list being destructured is taken to be alternating\n     keywords and values and is taken apart appropriately.\n&allow-other-keys\n     Stands by itself.\n"
        }
    ],
    "_otext": "File: gcl.info,  Node: Lambda-list-directed Destructuring by Lambda Lists,  Prev: Examples of Data-directed Destructuring by Lambda Lists,  Up: Macro Lambda Lists\n\nLambda-list-directed Destructuring by Lambda Lists\n..................................................\n\nAn extension of data-directed destructuring of trees is\nlambda-list-directed destructuring.  This derives from the analogy between\nthe three-element destructuring pattern\n\n(first second third)\n\nand the three-argument lambda list\n\n(first second third)\n\nLambda-list-directed destructuring is identical to data-directed\ndestructuring if no lambda list keywords appear in the pattern.  Any list\nin the pattern (whether a sub-list or the whole pattern itself) that\ncontains a lambda list keyword is interpreted specially.  Elements of the\nlist to the left of the first lambda list keyword are treated as\ndestructuring patterns, as usual, but the remaining elements of the list\nare treated like a function's lambda list except that where a variable\nwould normally be required, an arbitrary destructuring pattern is allowed.\nNote that in case of ambiguity, lambda list syntax is preferred over\ndestructuring syntax.  Thus, after &optional a list of elements is a list\nof a destructuring pattern and a default value form.\n\nThe detailed behavior of each lambda list keyword in a\nlambda-list-directed destructuring pattern is as follows:\n\n&optional\n     Each following element is a variable or a list of a destructuring\n     pattern, a default value form, and a supplied-p variable.  The\n     default value and the supplied-p variable can be omitted.  If the\n     list being destructured ends early, so that it does not have an\n     element to match against this destructuring (sub)-pattern, the\n     default form is evaluated and destructured instead.  The supplied-p\n     variable receives the value nil if the default form is used, t\n     otherwise.\n\n&rest, &body\n     The next element is a destructuring pattern that matches the rest of\n     the list.  &body is identical to &rest but declares that what is\n     being matched is a list of forms that constitutes the body of form.\n     This next element must be the last unless a lambda list keyword\n     follows it.\n\n&aux\n     The remaining elements are not destructuring patterns at all, but are\n     auxiliary variable bindings.\n\n&whole\n     The next element is a destructuring pattern that matches the entire\n     form in a macro, or the entire subexpression at inner levels.\n\n&key\n     Each following element is one of\n\n          a variable,\n\n    or\n          a list of a variable, an optional initialization form, and an\n          optional supplied-p variable.\n\n    or\n          a list of a list of a keyword and a destructuring pattern, an\n          optional initialization form, and an optional supplied-p\n          variable.\n\n     The rest of the list being destructured is taken to be alternating\n     keywords and values and is taken apart appropriately.\n\n&allow-other-keys\n     Stands by itself.\n\n"
}